(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
  new MutationObserver((i) => {
    for (const a of i)
      if (a.type === "childList")
        for (const l of a.addedNodes)
          l.tagName === "LINK" && l.rel === "modulepreload" && n(l);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const a = {};
    return (
      i.integrity && (a.integrity = i.integrity),
      i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (a.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (a.credentials = "omit")
        : (a.credentials = "same-origin"),
      a
    );
  }
  function n(i) {
    if (i.ep) return;
    i.ep = !0;
    const a = t(i);
    fetch(i.href, a);
  }
})();
function My(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default")
    ? s.default
    : s;
}
var Y_ = { exports: {} },
  jp = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var DS;
function IC() {
  if (DS) return jp;
  DS = 1;
  var s = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.fragment");
  function t(n, i, a) {
    var l = null;
    if (
      (a !== void 0 && (l = "" + a),
      i.key !== void 0 && (l = "" + i.key),
      "key" in i)
    ) {
      a = {};
      for (var u in i) u !== "key" && (a[u] = i[u]);
    } else a = i;
    return (
      (i = a.ref),
      { $$typeof: s, type: n, key: l, ref: i !== void 0 ? i : null, props: a }
    );
  }
  return (jp.Fragment = e), (jp.jsx = t), (jp.jsxs = t), jp;
}
var US;
function FC() {
  return US || ((US = 1), (Y_.exports = IC())), Y_.exports;
}
var Tt = FC(),
  W_ = { exports: {} },
  Mn = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var OS;
function PC() {
  if (OS) return Mn;
  OS = 1;
  var s = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    n = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    a = Symbol.for("react.consumer"),
    l = Symbol.for("react.context"),
    u = Symbol.for("react.forward_ref"),
    f = Symbol.for("react.suspense"),
    d = Symbol.for("react.memo"),
    m = Symbol.for("react.lazy"),
    v = Symbol.iterator;
  function _(V) {
    return V === null || typeof V != "object"
      ? null
      : ((V = (v && V[v]) || V["@@iterator"]),
        typeof V == "function" ? V : null);
  }
  var A = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    M = Object.assign,
    T = {};
  function E(V, Y, ae) {
    (this.props = V),
      (this.context = Y),
      (this.refs = T),
      (this.updater = ae || A);
  }
  (E.prototype.isReactComponent = {}),
    (E.prototype.setState = function (V, Y) {
      if (typeof V != "object" && typeof V != "function" && V != null)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, V, Y, "setState");
    }),
    (E.prototype.forceUpdate = function (V) {
      this.updater.enqueueForceUpdate(this, V, "forceUpdate");
    });
  function b() {}
  b.prototype = E.prototype;
  function w(V, Y, ae) {
    (this.props = V),
      (this.context = Y),
      (this.refs = T),
      (this.updater = ae || A);
  }
  var D = (w.prototype = new b());
  (D.constructor = w), M(D, E.prototype), (D.isPureReactComponent = !0);
  var B = Array.isArray,
    I = { H: null, A: null, T: null, S: null },
    N = Object.prototype.hasOwnProperty;
  function P(V, Y, ae, fe, j, se) {
    return (
      (ae = se.ref),
      {
        $$typeof: s,
        type: V,
        key: Y,
        ref: ae !== void 0 ? ae : null,
        props: se,
      }
    );
  }
  function F(V, Y) {
    return P(V.type, Y, void 0, void 0, void 0, V.props);
  }
  function O(V) {
    return typeof V == "object" && V !== null && V.$$typeof === s;
  }
  function U(V) {
    var Y = { "=": "=0", ":": "=2" };
    return (
      "$" +
      V.replace(/[=:]/g, function (ae) {
        return Y[ae];
      })
    );
  }
  var W = /\/+/g;
  function J(V, Y) {
    return typeof V == "object" && V !== null && V.key != null
      ? U("" + V.key)
      : Y.toString(36);
  }
  function q() {}
  function Z(V) {
    switch (V.status) {
      case "fulfilled":
        return V.value;
      case "rejected":
        throw V.reason;
      default:
        switch (
          (typeof V.status == "string"
            ? V.then(q, q)
            : ((V.status = "pending"),
              V.then(
                function (Y) {
                  V.status === "pending" &&
                    ((V.status = "fulfilled"), (V.value = Y));
                },
                function (Y) {
                  V.status === "pending" &&
                    ((V.status = "rejected"), (V.reason = Y));
                }
              )),
          V.status)
        ) {
          case "fulfilled":
            return V.value;
          case "rejected":
            throw V.reason;
        }
    }
    throw V;
  }
  function ue(V, Y, ae, fe, j) {
    var se = typeof V;
    (se === "undefined" || se === "boolean") && (V = null);
    var ve = !1;
    if (V === null) ve = !0;
    else
      switch (se) {
        case "bigint":
        case "string":
        case "number":
          ve = !0;
          break;
        case "object":
          switch (V.$$typeof) {
            case s:
            case e:
              ve = !0;
              break;
            case m:
              return (ve = V._init), ue(ve(V._payload), Y, ae, fe, j);
          }
      }
    if (ve)
      return (
        (j = j(V)),
        (ve = fe === "" ? "." + J(V, 0) : fe),
        B(j)
          ? ((ae = ""),
            ve != null && (ae = ve.replace(W, "$&/") + "/"),
            ue(j, Y, ae, "", function (it) {
              return it;
            }))
          : j != null &&
            (O(j) &&
              (j = F(
                j,
                ae +
                  (j.key == null || (V && V.key === j.key)
                    ? ""
                    : ("" + j.key).replace(W, "$&/") + "/") +
                  ve
              )),
            Y.push(j)),
        1
      );
    ve = 0;
    var ye = fe === "" ? "." : fe + ":";
    if (B(V))
      for (var be = 0; be < V.length; be++)
        (fe = V[be]), (se = ye + J(fe, be)), (ve += ue(fe, Y, ae, se, j));
    else if (((be = _(V)), typeof be == "function"))
      for (V = be.call(V), be = 0; !(fe = V.next()).done; )
        (fe = fe.value), (se = ye + J(fe, be++)), (ve += ue(fe, Y, ae, se, j));
    else if (se === "object") {
      if (typeof V.then == "function") return ue(Z(V), Y, ae, fe, j);
      throw (
        ((Y = String(V)),
        Error(
          "Objects are not valid as a React child (found: " +
            (Y === "[object Object]"
              ? "object with keys {" + Object.keys(V).join(", ") + "}"
              : Y) +
            "). If you meant to render a collection of children, use an array instead."
        ))
      );
    }
    return ve;
  }
  function K(V, Y, ae) {
    if (V == null) return V;
    var fe = [],
      j = 0;
    return (
      ue(V, fe, "", "", function (se) {
        return Y.call(ae, se, j++);
      }),
      fe
    );
  }
  function ge(V) {
    if (V._status === -1) {
      var Y = V._result;
      (Y = Y()),
        Y.then(
          function (ae) {
            (V._status === 0 || V._status === -1) &&
              ((V._status = 1), (V._result = ae));
          },
          function (ae) {
            (V._status === 0 || V._status === -1) &&
              ((V._status = 2), (V._result = ae));
          }
        ),
        V._status === -1 && ((V._status = 0), (V._result = Y));
    }
    if (V._status === 1) return V._result.default;
    throw V._result;
  }
  var oe =
    typeof reportError == "function"
      ? reportError
      : function (V) {
          if (
            typeof window == "object" &&
            typeof window.ErrorEvent == "function"
          ) {
            var Y = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof V == "object" &&
                V !== null &&
                typeof V.message == "string"
                  ? String(V.message)
                  : String(V),
              error: V,
            });
            if (!window.dispatchEvent(Y)) return;
          } else if (
            typeof process == "object" &&
            typeof process.emit == "function"
          ) {
            process.emit("uncaughtException", V);
            return;
          }
          console.error(V);
        };
  function me() {}
  return (
    (Mn.Children = {
      map: K,
      forEach: function (V, Y, ae) {
        K(
          V,
          function () {
            Y.apply(this, arguments);
          },
          ae
        );
      },
      count: function (V) {
        var Y = 0;
        return (
          K(V, function () {
            Y++;
          }),
          Y
        );
      },
      toArray: function (V) {
        return (
          K(V, function (Y) {
            return Y;
          }) || []
        );
      },
      only: function (V) {
        if (!O(V))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return V;
      },
    }),
    (Mn.Component = E),
    (Mn.Fragment = t),
    (Mn.Profiler = i),
    (Mn.PureComponent = w),
    (Mn.StrictMode = n),
    (Mn.Suspense = f),
    (Mn.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = I),
    (Mn.act = function () {
      throw Error("act(...) is not supported in production builds of React.");
    }),
    (Mn.cache = function (V) {
      return function () {
        return V.apply(null, arguments);
      };
    }),
    (Mn.cloneElement = function (V, Y, ae) {
      if (V == null)
        throw Error(
          "The argument must be a React element, but you passed " + V + "."
        );
      var fe = M({}, V.props),
        j = V.key,
        se = void 0;
      if (Y != null)
        for (ve in (Y.ref !== void 0 && (se = void 0),
        Y.key !== void 0 && (j = "" + Y.key),
        Y))
          !N.call(Y, ve) ||
            ve === "key" ||
            ve === "__self" ||
            ve === "__source" ||
            (ve === "ref" && Y.ref === void 0) ||
            (fe[ve] = Y[ve]);
      var ve = arguments.length - 2;
      if (ve === 1) fe.children = ae;
      else if (1 < ve) {
        for (var ye = Array(ve), be = 0; be < ve; be++)
          ye[be] = arguments[be + 2];
        fe.children = ye;
      }
      return P(V.type, j, void 0, void 0, se, fe);
    }),
    (Mn.createContext = function (V) {
      return (
        (V = {
          $$typeof: l,
          _currentValue: V,
          _currentValue2: V,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
        }),
        (V.Provider = V),
        (V.Consumer = { $$typeof: a, _context: V }),
        V
      );
    }),
    (Mn.createElement = function (V, Y, ae) {
      var fe,
        j = {},
        se = null;
      if (Y != null)
        for (fe in (Y.key !== void 0 && (se = "" + Y.key), Y))
          N.call(Y, fe) &&
            fe !== "key" &&
            fe !== "__self" &&
            fe !== "__source" &&
            (j[fe] = Y[fe]);
      var ve = arguments.length - 2;
      if (ve === 1) j.children = ae;
      else if (1 < ve) {
        for (var ye = Array(ve), be = 0; be < ve; be++)
          ye[be] = arguments[be + 2];
        j.children = ye;
      }
      if (V && V.defaultProps)
        for (fe in ((ve = V.defaultProps), ve))
          j[fe] === void 0 && (j[fe] = ve[fe]);
      return P(V, se, void 0, void 0, null, j);
    }),
    (Mn.createRef = function () {
      return { current: null };
    }),
    (Mn.forwardRef = function (V) {
      return { $$typeof: u, render: V };
    }),
    (Mn.isValidElement = O),
    (Mn.lazy = function (V) {
      return { $$typeof: m, _payload: { _status: -1, _result: V }, _init: ge };
    }),
    (Mn.memo = function (V, Y) {
      return { $$typeof: d, type: V, compare: Y === void 0 ? null : Y };
    }),
    (Mn.startTransition = function (V) {
      var Y = I.T,
        ae = {};
      I.T = ae;
      try {
        var fe = V(),
          j = I.S;
        j !== null && j(ae, fe),
          typeof fe == "object" &&
            fe !== null &&
            typeof fe.then == "function" &&
            fe.then(me, oe);
      } catch (se) {
        oe(se);
      } finally {
        I.T = Y;
      }
    }),
    (Mn.unstable_useCacheRefresh = function () {
      return I.H.useCacheRefresh();
    }),
    (Mn.use = function (V) {
      return I.H.use(V);
    }),
    (Mn.useActionState = function (V, Y, ae) {
      return I.H.useActionState(V, Y, ae);
    }),
    (Mn.useCallback = function (V, Y) {
      return I.H.useCallback(V, Y);
    }),
    (Mn.useContext = function (V) {
      return I.H.useContext(V);
    }),
    (Mn.useDebugValue = function () {}),
    (Mn.useDeferredValue = function (V, Y) {
      return I.H.useDeferredValue(V, Y);
    }),
    (Mn.useEffect = function (V, Y) {
      return I.H.useEffect(V, Y);
    }),
    (Mn.useId = function () {
      return I.H.useId();
    }),
    (Mn.useImperativeHandle = function (V, Y, ae) {
      return I.H.useImperativeHandle(V, Y, ae);
    }),
    (Mn.useInsertionEffect = function (V, Y) {
      return I.H.useInsertionEffect(V, Y);
    }),
    (Mn.useLayoutEffect = function (V, Y) {
      return I.H.useLayoutEffect(V, Y);
    }),
    (Mn.useMemo = function (V, Y) {
      return I.H.useMemo(V, Y);
    }),
    (Mn.useOptimistic = function (V, Y) {
      return I.H.useOptimistic(V, Y);
    }),
    (Mn.useReducer = function (V, Y, ae) {
      return I.H.useReducer(V, Y, ae);
    }),
    (Mn.useRef = function (V) {
      return I.H.useRef(V);
    }),
    (Mn.useState = function (V) {
      return I.H.useState(V);
    }),
    (Mn.useSyncExternalStore = function (V, Y, ae) {
      return I.H.useSyncExternalStore(V, Y, ae);
    }),
    (Mn.useTransition = function () {
      return I.H.useTransition();
    }),
    (Mn.version = "19.0.0"),
    Mn
  );
}
var LS;
function Ud() {
  return LS || ((LS = 1), (W_.exports = PC())), W_.exports;
}
var je = Ud();
const oE = My(je);
var J_ = { exports: {} },
  Kp = {},
  q_ = { exports: {} },
  j_ = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var NS;
function GC() {
  return (
    NS ||
      ((NS = 1),
      (function (s) {
        function e(K, ge) {
          var oe = K.length;
          K.push(ge);
          e: for (; 0 < oe; ) {
            var me = (oe - 1) >>> 1,
              V = K[me];
            if (0 < i(V, ge)) (K[me] = ge), (K[oe] = V), (oe = me);
            else break e;
          }
        }
        function t(K) {
          return K.length === 0 ? null : K[0];
        }
        function n(K) {
          if (K.length === 0) return null;
          var ge = K[0],
            oe = K.pop();
          if (oe !== ge) {
            K[0] = oe;
            e: for (var me = 0, V = K.length, Y = V >>> 1; me < Y; ) {
              var ae = 2 * (me + 1) - 1,
                fe = K[ae],
                j = ae + 1,
                se = K[j];
              if (0 > i(fe, oe))
                j < V && 0 > i(se, fe)
                  ? ((K[me] = se), (K[j] = oe), (me = j))
                  : ((K[me] = fe), (K[ae] = oe), (me = ae));
              else if (j < V && 0 > i(se, oe))
                (K[me] = se), (K[j] = oe), (me = j);
              else break e;
            }
          }
          return ge;
        }
        function i(K, ge) {
          var oe = K.sortIndex - ge.sortIndex;
          return oe !== 0 ? oe : K.id - ge.id;
        }
        if (
          ((s.unstable_now = void 0),
          typeof performance == "object" &&
            typeof performance.now == "function")
        ) {
          var a = performance;
          s.unstable_now = function () {
            return a.now();
          };
        } else {
          var l = Date,
            u = l.now();
          s.unstable_now = function () {
            return l.now() - u;
          };
        }
        var f = [],
          d = [],
          m = 1,
          v = null,
          _ = 3,
          A = !1,
          M = !1,
          T = !1,
          E = typeof setTimeout == "function" ? setTimeout : null,
          b = typeof clearTimeout == "function" ? clearTimeout : null,
          w = typeof setImmediate < "u" ? setImmediate : null;
        function D(K) {
          for (var ge = t(d); ge !== null; ) {
            if (ge.callback === null) n(d);
            else if (ge.startTime <= K)
              n(d), (ge.sortIndex = ge.expirationTime), e(f, ge);
            else break;
            ge = t(d);
          }
        }
        function B(K) {
          if (((T = !1), D(K), !M))
            if (t(f) !== null) (M = !0), Z();
            else {
              var ge = t(d);
              ge !== null && ue(B, ge.startTime - K);
            }
        }
        var I = !1,
          N = -1,
          P = 5,
          F = -1;
        function O() {
          return !(s.unstable_now() - F < P);
        }
        function U() {
          if (I) {
            var K = s.unstable_now();
            F = K;
            var ge = !0;
            try {
              e: {
                (M = !1), T && ((T = !1), b(N), (N = -1)), (A = !0);
                var oe = _;
                try {
                  t: {
                    for (
                      D(K), v = t(f);
                      v !== null && !(v.expirationTime > K && O());

                    ) {
                      var me = v.callback;
                      if (typeof me == "function") {
                        (v.callback = null), (_ = v.priorityLevel);
                        var V = me(v.expirationTime <= K);
                        if (((K = s.unstable_now()), typeof V == "function")) {
                          (v.callback = V), D(K), (ge = !0);
                          break t;
                        }
                        v === t(f) && n(f), D(K);
                      } else n(f);
                      v = t(f);
                    }
                    if (v !== null) ge = !0;
                    else {
                      var Y = t(d);
                      Y !== null && ue(B, Y.startTime - K), (ge = !1);
                    }
                  }
                  break e;
                } finally {
                  (v = null), (_ = oe), (A = !1);
                }
                ge = void 0;
              }
            } finally {
              ge ? W() : (I = !1);
            }
          }
        }
        var W;
        if (typeof w == "function")
          W = function () {
            w(U);
          };
        else if (typeof MessageChannel < "u") {
          var J = new MessageChannel(),
            q = J.port2;
          (J.port1.onmessage = U),
            (W = function () {
              q.postMessage(null);
            });
        } else
          W = function () {
            E(U, 0);
          };
        function Z() {
          I || ((I = !0), W());
        }
        function ue(K, ge) {
          N = E(function () {
            K(s.unstable_now());
          }, ge);
        }
        (s.unstable_IdlePriority = 5),
          (s.unstable_ImmediatePriority = 1),
          (s.unstable_LowPriority = 4),
          (s.unstable_NormalPriority = 3),
          (s.unstable_Profiling = null),
          (s.unstable_UserBlockingPriority = 2),
          (s.unstable_cancelCallback = function (K) {
            K.callback = null;
          }),
          (s.unstable_continueExecution = function () {
            M || A || ((M = !0), Z());
          }),
          (s.unstable_forceFrameRate = function (K) {
            0 > K || 125 < K
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (P = 0 < K ? Math.floor(1e3 / K) : 5);
          }),
          (s.unstable_getCurrentPriorityLevel = function () {
            return _;
          }),
          (s.unstable_getFirstCallbackNode = function () {
            return t(f);
          }),
          (s.unstable_next = function (K) {
            switch (_) {
              case 1:
              case 2:
              case 3:
                var ge = 3;
                break;
              default:
                ge = _;
            }
            var oe = _;
            _ = ge;
            try {
              return K();
            } finally {
              _ = oe;
            }
          }),
          (s.unstable_pauseExecution = function () {}),
          (s.unstable_requestPaint = function () {}),
          (s.unstable_runWithPriority = function (K, ge) {
            switch (K) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                K = 3;
            }
            var oe = _;
            _ = K;
            try {
              return ge();
            } finally {
              _ = oe;
            }
          }),
          (s.unstable_scheduleCallback = function (K, ge, oe) {
            var me = s.unstable_now();
            switch (
              (typeof oe == "object" && oe !== null
                ? ((oe = oe.delay),
                  (oe = typeof oe == "number" && 0 < oe ? me + oe : me))
                : (oe = me),
              K)
            ) {
              case 1:
                var V = -1;
                break;
              case 2:
                V = 250;
                break;
              case 5:
                V = 1073741823;
                break;
              case 4:
                V = 1e4;
                break;
              default:
                V = 5e3;
            }
            return (
              (V = oe + V),
              (K = {
                id: m++,
                callback: ge,
                priorityLevel: K,
                startTime: oe,
                expirationTime: V,
                sortIndex: -1,
              }),
              oe > me
                ? ((K.sortIndex = oe),
                  e(d, K),
                  t(f) === null &&
                    K === t(d) &&
                    (T ? (b(N), (N = -1)) : (T = !0), ue(B, oe - me)))
                : ((K.sortIndex = V), e(f, K), M || A || ((M = !0), Z())),
              K
            );
          }),
          (s.unstable_shouldYield = O),
          (s.unstable_wrapCallback = function (K) {
            var ge = _;
            return function () {
              var oe = _;
              _ = ge;
              try {
                return K.apply(this, arguments);
              } finally {
                _ = oe;
              }
            };
          });
      })(j_)),
    j_
  );
}
var IS;
function HA() {
  return IS || ((IS = 1), (q_.exports = GC())), q_.exports;
}
var K_ = { exports: {} },
  or = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var FS;
function zC() {
  if (FS) return or;
  FS = 1;
  var s = Ud();
  function e(f) {
    var d = "https://react.dev/errors/" + f;
    if (1 < arguments.length) {
      d += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var m = 2; m < arguments.length; m++)
        d += "&args[]=" + encodeURIComponent(arguments[m]);
    }
    return (
      "Minified React error #" +
      f +
      "; visit " +
      d +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  function t() {}
  var n = {
      d: {
        f: t,
        r: function () {
          throw Error(e(522));
        },
        D: t,
        C: t,
        L: t,
        m: t,
        X: t,
        S: t,
        M: t,
      },
      p: 0,
      findDOMNode: null,
    },
    i = Symbol.for("react.portal");
  function a(f, d, m) {
    var v =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: i,
      key: v == null ? null : "" + v,
      children: f,
      containerInfo: d,
      implementation: m,
    };
  }
  var l = s.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function u(f, d) {
    if (f === "font") return "";
    if (typeof d == "string") return d === "use-credentials" ? d : "";
  }
  return (
    (or.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = n),
    (or.createPortal = function (f, d) {
      var m =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!d || (d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11))
        throw Error(e(299));
      return a(f, d, null, m);
    }),
    (or.flushSync = function (f) {
      var d = l.T,
        m = n.p;
      try {
        if (((l.T = null), (n.p = 2), f)) return f();
      } finally {
        (l.T = d), (n.p = m), n.d.f();
      }
    }),
    (or.preconnect = function (f, d) {
      typeof f == "string" &&
        (d
          ? ((d = d.crossOrigin),
            (d =
              typeof d == "string"
                ? d === "use-credentials"
                  ? d
                  : ""
                : void 0))
          : (d = null),
        n.d.C(f, d));
    }),
    (or.prefetchDNS = function (f) {
      typeof f == "string" && n.d.D(f);
    }),
    (or.preinit = function (f, d) {
      if (typeof f == "string" && d && typeof d.as == "string") {
        var m = d.as,
          v = u(m, d.crossOrigin),
          _ = typeof d.integrity == "string" ? d.integrity : void 0,
          A = typeof d.fetchPriority == "string" ? d.fetchPriority : void 0;
        m === "style"
          ? n.d.S(f, typeof d.precedence == "string" ? d.precedence : void 0, {
              crossOrigin: v,
              integrity: _,
              fetchPriority: A,
            })
          : m === "script" &&
            n.d.X(f, {
              crossOrigin: v,
              integrity: _,
              fetchPriority: A,
              nonce: typeof d.nonce == "string" ? d.nonce : void 0,
            });
      }
    }),
    (or.preinitModule = function (f, d) {
      if (typeof f == "string")
        if (typeof d == "object" && d !== null) {
          if (d.as == null || d.as === "script") {
            var m = u(d.as, d.crossOrigin);
            n.d.M(f, {
              crossOrigin: m,
              integrity: typeof d.integrity == "string" ? d.integrity : void 0,
              nonce: typeof d.nonce == "string" ? d.nonce : void 0,
            });
          }
        } else d == null && n.d.M(f);
    }),
    (or.preload = function (f, d) {
      if (
        typeof f == "string" &&
        typeof d == "object" &&
        d !== null &&
        typeof d.as == "string"
      ) {
        var m = d.as,
          v = u(m, d.crossOrigin);
        n.d.L(f, m, {
          crossOrigin: v,
          integrity: typeof d.integrity == "string" ? d.integrity : void 0,
          nonce: typeof d.nonce == "string" ? d.nonce : void 0,
          type: typeof d.type == "string" ? d.type : void 0,
          fetchPriority:
            typeof d.fetchPriority == "string" ? d.fetchPriority : void 0,
          referrerPolicy:
            typeof d.referrerPolicy == "string" ? d.referrerPolicy : void 0,
          imageSrcSet:
            typeof d.imageSrcSet == "string" ? d.imageSrcSet : void 0,
          imageSizes: typeof d.imageSizes == "string" ? d.imageSizes : void 0,
          media: typeof d.media == "string" ? d.media : void 0,
        });
      }
    }),
    (or.preloadModule = function (f, d) {
      if (typeof f == "string")
        if (d) {
          var m = u(d.as, d.crossOrigin);
          n.d.m(f, {
            as: typeof d.as == "string" && d.as !== "script" ? d.as : void 0,
            crossOrigin: m,
            integrity: typeof d.integrity == "string" ? d.integrity : void 0,
          });
        } else n.d.m(f);
    }),
    (or.requestFormReset = function (f) {
      n.d.r(f);
    }),
    (or.unstable_batchedUpdates = function (f, d) {
      return f(d);
    }),
    (or.useFormState = function (f, d, m) {
      return l.H.useFormState(f, d, m);
    }),
    (or.useFormStatus = function () {
      return l.H.useHostTransitionStatus();
    }),
    (or.version = "19.0.0"),
    or
  );
}
var PS;
function HC() {
  if (PS) return K_.exports;
  PS = 1;
  function s() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s);
      } catch (e) {
        console.error(e);
      }
  }
  return s(), (K_.exports = zC()), K_.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var GS;
function VC() {
  if (GS) return Kp;
  GS = 1;
  var s = HA(),
    e = Ud(),
    t = HC();
  function n(r) {
    var o = "https://react.dev/errors/" + r;
    if (1 < arguments.length) {
      o += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var p = 2; p < arguments.length; p++)
        o += "&args[]=" + encodeURIComponent(arguments[p]);
    }
    return (
      "Minified React error #" +
      r +
      "; visit " +
      o +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  function i(r) {
    return !(!r || (r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11));
  }
  var a = Symbol.for("react.element"),
    l = Symbol.for("react.transitional.element"),
    u = Symbol.for("react.portal"),
    f = Symbol.for("react.fragment"),
    d = Symbol.for("react.strict_mode"),
    m = Symbol.for("react.profiler"),
    v = Symbol.for("react.provider"),
    _ = Symbol.for("react.consumer"),
    A = Symbol.for("react.context"),
    M = Symbol.for("react.forward_ref"),
    T = Symbol.for("react.suspense"),
    E = Symbol.for("react.suspense_list"),
    b = Symbol.for("react.memo"),
    w = Symbol.for("react.lazy"),
    D = Symbol.for("react.offscreen"),
    B = Symbol.for("react.memo_cache_sentinel"),
    I = Symbol.iterator;
  function N(r) {
    return r === null || typeof r != "object"
      ? null
      : ((r = (I && r[I]) || r["@@iterator"]),
        typeof r == "function" ? r : null);
  }
  var P = Symbol.for("react.client.reference");
  function F(r) {
    if (r == null) return null;
    if (typeof r == "function")
      return r.$$typeof === P ? null : r.displayName || r.name || null;
    if (typeof r == "string") return r;
    switch (r) {
      case f:
        return "Fragment";
      case u:
        return "Portal";
      case m:
        return "Profiler";
      case d:
        return "StrictMode";
      case T:
        return "Suspense";
      case E:
        return "SuspenseList";
    }
    if (typeof r == "object")
      switch (r.$$typeof) {
        case A:
          return (r.displayName || "Context") + ".Provider";
        case _:
          return (r._context.displayName || "Context") + ".Consumer";
        case M:
          var o = r.render;
          return (
            (r = r.displayName),
            r ||
              ((r = o.displayName || o.name || ""),
              (r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef")),
            r
          );
        case b:
          return (
            (o = r.displayName || null), o !== null ? o : F(r.type) || "Memo"
          );
        case w:
          (o = r._payload), (r = r._init);
          try {
            return F(r(o));
          } catch {}
      }
    return null;
  }
  var O = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    U = Object.assign,
    W,
    J;
  function q(r) {
    if (W === void 0)
      try {
        throw Error();
      } catch (p) {
        var o = p.stack.trim().match(/\n( *(at )?)/);
        (W = (o && o[1]) || ""),
          (J =
            -1 <
            p.stack.indexOf(`
    at`)
              ? " (<anonymous>)"
              : -1 < p.stack.indexOf("@")
              ? "@unknown:0:0"
              : "");
      }
    return (
      `
` +
      W +
      r +
      J
    );
  }
  var Z = !1;
  function ue(r, o) {
    if (!r || Z) return "";
    Z = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var g = {
        DetermineComponentFrameRoot: function () {
          try {
            if (o) {
              var xt = function () {
                throw Error();
              };
              if (
                (Object.defineProperty(xt.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == "object" && Reflect.construct)
              ) {
                try {
                  Reflect.construct(xt, []);
                } catch (ot) {
                  var ke = ot;
                }
                Reflect.construct(r, [], xt);
              } else {
                try {
                  xt.call();
                } catch (ot) {
                  ke = ot;
                }
                r.call(xt.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (ot) {
                ke = ot;
              }
              (xt = r()) &&
                typeof xt.catch == "function" &&
                xt.catch(function () {});
            }
          } catch (ot) {
            if (ot && ke && typeof ot.stack == "string")
              return [ot.stack, ke.stack];
          }
          return [null, null];
        },
      };
      g.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var x = Object.getOwnPropertyDescriptor(
        g.DetermineComponentFrameRoot,
        "name"
      );
      x &&
        x.configurable &&
        Object.defineProperty(g.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot",
        });
      var C = g.DetermineComponentFrameRoot(),
        G = C[0],
        Q = C[1];
      if (G && Q) {
        var he = G.split(`
`),
          Ce = Q.split(`
`);
        for (
          x = g = 0;
          g < he.length && !he[g].includes("DetermineComponentFrameRoot");

        )
          g++;
        for (
          ;
          x < Ce.length && !Ce[x].includes("DetermineComponentFrameRoot");

        )
          x++;
        if (g === he.length || x === Ce.length)
          for (
            g = he.length - 1, x = Ce.length - 1;
            1 <= g && 0 <= x && he[g] !== Ce[x];

          )
            x--;
        for (; 1 <= g && 0 <= x; g--, x--)
          if (he[g] !== Ce[x]) {
            if (g !== 1 || x !== 1)
              do
                if ((g--, x--, 0 > x || he[g] !== Ce[x])) {
                  var ct =
                    `
` + he[g].replace(" at new ", " at ");
                  return (
                    r.displayName &&
                      ct.includes("<anonymous>") &&
                      (ct = ct.replace("<anonymous>", r.displayName)),
                    ct
                  );
                }
              while (1 <= g && 0 <= x);
            break;
          }
      }
    } finally {
      (Z = !1), (Error.prepareStackTrace = p);
    }
    return (p = r ? r.displayName || r.name : "") ? q(p) : "";
  }
  function K(r) {
    switch (r.tag) {
      case 26:
      case 27:
      case 5:
        return q(r.type);
      case 16:
        return q("Lazy");
      case 13:
        return q("Suspense");
      case 19:
        return q("SuspenseList");
      case 0:
      case 15:
        return (r = ue(r.type, !1)), r;
      case 11:
        return (r = ue(r.type.render, !1)), r;
      case 1:
        return (r = ue(r.type, !0)), r;
      default:
        return "";
    }
  }
  function ge(r) {
    try {
      var o = "";
      do (o += K(r)), (r = r.return);
      while (r);
      return o;
    } catch (p) {
      return (
        `
Error generating stack: ` +
        p.message +
        `
` +
        p.stack
      );
    }
  }
  function oe(r) {
    var o = r,
      p = r;
    if (r.alternate) for (; o.return; ) o = o.return;
    else {
      r = o;
      do (o = r), (o.flags & 4098) !== 0 && (p = o.return), (r = o.return);
      while (r);
    }
    return o.tag === 3 ? p : null;
  }
  function me(r) {
    if (r.tag === 13) {
      var o = r.memoizedState;
      if (
        (o === null && ((r = r.alternate), r !== null && (o = r.memoizedState)),
        o !== null)
      )
        return o.dehydrated;
    }
    return null;
  }
  function V(r) {
    if (oe(r) !== r) throw Error(n(188));
  }
  function Y(r) {
    var o = r.alternate;
    if (!o) {
      if (((o = oe(r)), o === null)) throw Error(n(188));
      return o !== r ? null : r;
    }
    for (var p = r, g = o; ; ) {
      var x = p.return;
      if (x === null) break;
      var C = x.alternate;
      if (C === null) {
        if (((g = x.return), g !== null)) {
          p = g;
          continue;
        }
        break;
      }
      if (x.child === C.child) {
        for (C = x.child; C; ) {
          if (C === p) return V(x), r;
          if (C === g) return V(x), o;
          C = C.sibling;
        }
        throw Error(n(188));
      }
      if (p.return !== g.return) (p = x), (g = C);
      else {
        for (var G = !1, Q = x.child; Q; ) {
          if (Q === p) {
            (G = !0), (p = x), (g = C);
            break;
          }
          if (Q === g) {
            (G = !0), (g = x), (p = C);
            break;
          }
          Q = Q.sibling;
        }
        if (!G) {
          for (Q = C.child; Q; ) {
            if (Q === p) {
              (G = !0), (p = C), (g = x);
              break;
            }
            if (Q === g) {
              (G = !0), (g = C), (p = x);
              break;
            }
            Q = Q.sibling;
          }
          if (!G) throw Error(n(189));
        }
      }
      if (p.alternate !== g) throw Error(n(190));
    }
    if (p.tag !== 3) throw Error(n(188));
    return p.stateNode.current === p ? r : o;
  }
  function ae(r) {
    var o = r.tag;
    if (o === 5 || o === 26 || o === 27 || o === 6) return r;
    for (r = r.child; r !== null; ) {
      if (((o = ae(r)), o !== null)) return o;
      r = r.sibling;
    }
    return null;
  }
  var fe = Array.isArray,
    j = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    se = { pending: !1, data: null, method: null, action: null },
    ve = [],
    ye = -1;
  function be(r) {
    return { current: r };
  }
  function it(r) {
    0 > ye || ((r.current = ve[ye]), (ve[ye] = null), ye--);
  }
  function We(r, o) {
    ye++, (ve[ye] = r.current), (r.current = o);
  }
  var $e = be(null),
    Me = be(null),
    Ie = be(null),
    $ = be(null);
  function ft(r, o) {
    switch ((We(Ie, o), We(Me, r), We($e, null), (r = o.nodeType), r)) {
      case 9:
      case 11:
        o = (o = o.documentElement) && (o = o.namespaceURI) ? sS(o) : 0;
        break;
      default:
        if (
          ((r = r === 8 ? o.parentNode : o),
          (o = r.tagName),
          (r = r.namespaceURI))
        )
          (r = sS(r)), (o = oS(r, o));
        else
          switch (o) {
            case "svg":
              o = 1;
              break;
            case "math":
              o = 2;
              break;
            default:
              o = 0;
          }
    }
    it($e), We($e, o);
  }
  function Pe() {
    it($e), it(Me), it(Ie);
  }
  function rt(r) {
    r.memoizedState !== null && We($, r);
    var o = $e.current,
      p = oS(o, r.type);
    o !== p && (We(Me, r), We($e, p));
  }
  function Ue(r) {
    Me.current === r && (it($e), it(Me)),
      $.current === r && (it($), (Xp._currentValue = se));
  }
  var ht = Object.prototype.hasOwnProperty,
    Ve = s.unstable_scheduleCallback,
    X = s.unstable_cancelCallback,
    k = s.unstable_shouldYield,
    de = s.unstable_requestPaint,
    Ee = s.unstable_now,
    we = s.unstable_getCurrentPriorityLevel,
    He = s.unstable_ImmediatePriority,
    tt = s.unstable_UserBlockingPriority,
    Ke = s.unstable_NormalPriority,
    st = s.unstable_LowPriority,
    Ut = s.unstable_IdlePriority,
    et = s.log,
    At = s.unstable_setDisableYieldValue,
    mt = null,
    nt = null;
  function Ze(r) {
    if (nt && typeof nt.onCommitFiberRoot == "function")
      try {
        nt.onCommitFiberRoot(mt, r, void 0, (r.current.flags & 128) === 128);
      } catch {}
  }
  function le(r) {
    if (
      (typeof et == "function" && At(r),
      nt && typeof nt.setStrictMode == "function")
    )
      try {
        nt.setStrictMode(mt, r);
      } catch {}
  }
  var Be = Math.clz32 ? Math.clz32 : xe,
    vt = Math.log,
    ce = Math.LN2;
  function xe(r) {
    return (r >>>= 0), r === 0 ? 32 : (31 - ((vt(r) / ce) | 0)) | 0;
  }
  var Re = 128,
    Qe = 4194304;
  function gt(r) {
    var o = r & 42;
    if (o !== 0) return o;
    switch (r & -r) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return r & 4194176;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return r & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return r;
    }
  }
  function dt(r, o) {
    var p = r.pendingLanes;
    if (p === 0) return 0;
    var g = 0,
      x = r.suspendedLanes,
      C = r.pingedLanes,
      G = r.warmLanes;
    r = r.finishedLanes !== 0;
    var Q = p & 134217727;
    return (
      Q !== 0
        ? ((p = Q & ~x),
          p !== 0
            ? (g = gt(p))
            : ((C &= Q),
              C !== 0
                ? (g = gt(C))
                : r || ((G = Q & ~G), G !== 0 && (g = gt(G)))))
        : ((Q = p & ~x),
          Q !== 0
            ? (g = gt(Q))
            : C !== 0
            ? (g = gt(C))
            : r || ((G = p & ~G), G !== 0 && (g = gt(G)))),
      g === 0
        ? 0
        : o !== 0 &&
          o !== g &&
          (o & x) === 0 &&
          ((x = g & -g),
          (G = o & -o),
          x >= G || (x === 32 && (G & 4194176) !== 0))
        ? o
        : g
    );
  }
  function Ct(r, o) {
    return (r.pendingLanes & ~(r.suspendedLanes & ~r.pingedLanes) & o) === 0;
  }
  function Ht(r, o) {
    switch (r) {
      case 1:
      case 2:
      case 4:
      case 8:
        return o + 250;
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Nt() {
    var r = Re;
    return (Re <<= 1), (Re & 4194176) === 0 && (Re = 128), r;
  }
  function Ft() {
    var r = Qe;
    return (Qe <<= 1), (Qe & 62914560) === 0 && (Qe = 4194304), r;
  }
  function gn(r) {
    for (var o = [], p = 0; 31 > p; p++) o.push(r);
    return o;
  }
  function vn(r, o) {
    (r.pendingLanes |= o),
      o !== 268435456 &&
        ((r.suspendedLanes = 0), (r.pingedLanes = 0), (r.warmLanes = 0));
  }
  function ai(r, o, p, g, x, C) {
    var G = r.pendingLanes;
    (r.pendingLanes = p),
      (r.suspendedLanes = 0),
      (r.pingedLanes = 0),
      (r.warmLanes = 0),
      (r.expiredLanes &= p),
      (r.entangledLanes &= p),
      (r.errorRecoveryDisabledLanes &= p),
      (r.shellSuspendCounter = 0);
    var Q = r.entanglements,
      he = r.expirationTimes,
      Ce = r.hiddenUpdates;
    for (p = G & ~p; 0 < p; ) {
      var ct = 31 - Be(p),
        xt = 1 << ct;
      (Q[ct] = 0), (he[ct] = -1);
      var ke = Ce[ct];
      if (ke !== null)
        for (Ce[ct] = null, ct = 0; ct < ke.length; ct++) {
          var ot = ke[ct];
          ot !== null && (ot.lane &= -536870913);
        }
      p &= ~xt;
    }
    g !== 0 && Bi(r, g, 0),
      C !== 0 && x === 0 && r.tag !== 0 && (r.suspendedLanes |= C & ~(G & ~o));
  }
  function Bi(r, o, p) {
    (r.pendingLanes |= o), (r.suspendedLanes &= ~o);
    var g = 31 - Be(o);
    (r.entangledLanes |= o),
      (r.entanglements[g] = r.entanglements[g] | 1073741824 | (p & 4194218));
  }
  function ui(r, o) {
    var p = (r.entangledLanes |= o);
    for (r = r.entanglements; p; ) {
      var g = 31 - Be(p),
        x = 1 << g;
      (x & o) | (r[g] & o) && (r[g] |= o), (p &= ~x);
    }
  }
  function di(r) {
    return (
      (r &= -r),
      2 < r ? (8 < r ? ((r & 134217727) !== 0 ? 32 : 268435456) : 8) : 2
    );
  }
  function Di() {
    var r = j.p;
    return r !== 0 ? r : ((r = window.event), r === void 0 ? 32 : ES(r.type));
  }
  function pi(r, o) {
    var p = j.p;
    try {
      return (j.p = r), o();
    } finally {
      j.p = p;
    }
  }
  var zt = Math.random().toString(36).slice(2),
    pn = "__reactFiber$" + zt,
    en = "__reactProps$" + zt,
    H = "__reactContainer$" + zt,
    te = "__reactEvents$" + zt,
    Ae = "__reactListeners$" + zt,
    Ge = "__reactHandles$" + zt,
    qe = "__reactResources$" + zt,
    Je = "__reactMarker$" + zt;
  function St(r) {
    delete r[pn], delete r[en], delete r[te], delete r[Ae], delete r[Ge];
  }
  function yt(r) {
    var o = r[pn];
    if (o) return o;
    for (var p = r.parentNode; p; ) {
      if ((o = p[H] || p[pn])) {
        if (
          ((p = o.alternate),
          o.child !== null || (p !== null && p.child !== null))
        )
          for (r = cS(r); r !== null; ) {
            if ((p = r[pn])) return p;
            r = cS(r);
          }
        return o;
      }
      (r = p), (p = r.parentNode);
    }
    return null;
  }
  function z(r) {
    if ((r = r[pn] || r[H])) {
      var o = r.tag;
      if (o === 5 || o === 6 || o === 13 || o === 26 || o === 27 || o === 3)
        return r;
    }
    return null;
  }
  function re(r) {
    var o = r.tag;
    if (o === 5 || o === 26 || o === 27 || o === 6) return r.stateNode;
    throw Error(n(33));
  }
  function pe(r) {
    var o = r[qe];
    return (
      o ||
        (o = r[qe] =
          { hoistableStyles: new Map(), hoistableScripts: new Map() }),
      o
    );
  }
  function ne(r) {
    r[Je] = !0;
  }
  var Se = new Set(),
    Ne = {};
  function Ye(r, o) {
    lt(r, o), lt(r + "Capture", o);
  }
  function lt(r, o) {
    for (Ne[r] = o, r = 0; r < o.length; r++) Se.add(o[r]);
  }
  var pt = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    wt = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ),
    Bt = {},
    Rt = {};
  function jt(r) {
    return ht.call(Rt, r)
      ? !0
      : ht.call(Bt, r)
      ? !1
      : wt.test(r)
      ? (Rt[r] = !0)
      : ((Bt[r] = !0), !1);
  }
  function Pt(r, o, p) {
    if (jt(o))
      if (p === null) r.removeAttribute(o);
      else {
        switch (typeof p) {
          case "undefined":
          case "function":
          case "symbol":
            r.removeAttribute(o);
            return;
          case "boolean":
            var g = o.toLowerCase().slice(0, 5);
            if (g !== "data-" && g !== "aria-") {
              r.removeAttribute(o);
              return;
            }
        }
        r.setAttribute(o, "" + p);
      }
  }
  function yn(r, o, p) {
    if (p === null) r.removeAttribute(o);
    else {
      switch (typeof p) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          r.removeAttribute(o);
          return;
      }
      r.setAttribute(o, "" + p);
    }
  }
  function Vt(r, o, p, g) {
    if (g === null) r.removeAttribute(p);
    else {
      switch (typeof g) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          r.removeAttribute(p);
          return;
      }
      r.setAttributeNS(o, p, "" + g);
    }
  }
  function Gt(r) {
    switch (typeof r) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return r;
      case "object":
        return r;
      default:
        return "";
    }
  }
  function It(r) {
    var o = r.type;
    return (
      (r = r.nodeName) &&
      r.toLowerCase() === "input" &&
      (o === "checkbox" || o === "radio")
    );
  }
  function Jn(r) {
    var o = It(r) ? "checked" : "value",
      p = Object.getOwnPropertyDescriptor(r.constructor.prototype, o),
      g = "" + r[o];
    if (
      !r.hasOwnProperty(o) &&
      typeof p < "u" &&
      typeof p.get == "function" &&
      typeof p.set == "function"
    ) {
      var x = p.get,
        C = p.set;
      return (
        Object.defineProperty(r, o, {
          configurable: !0,
          get: function () {
            return x.call(this);
          },
          set: function (G) {
            (g = "" + G), C.call(this, G);
          },
        }),
        Object.defineProperty(r, o, { enumerable: p.enumerable }),
        {
          getValue: function () {
            return g;
          },
          setValue: function (G) {
            g = "" + G;
          },
          stopTracking: function () {
            (r._valueTracker = null), delete r[o];
          },
        }
      );
    }
  }
  function qt(r) {
    r._valueTracker || (r._valueTracker = Jn(r));
  }
  function rn(r) {
    if (!r) return !1;
    var o = r._valueTracker;
    if (!o) return !0;
    var p = o.getValue(),
      g = "";
    return (
      r && (g = It(r) ? (r.checked ? "true" : "false") : r.value),
      (r = g),
      r !== p ? (o.setValue(r), !0) : !1
    );
  }
  function Ln(r) {
    if (
      ((r = r || (typeof document < "u" ? document : void 0)), typeof r > "u")
    )
      return null;
    try {
      return r.activeElement || r.body;
    } catch {
      return r.body;
    }
  }
  var sn = /[\n"\\]/g;
  function Xt(r) {
    return r.replace(sn, function (o) {
      return "\\" + o.charCodeAt(0).toString(16) + " ";
    });
  }
  function on(r, o, p, g, x, C, G, Q) {
    (r.name = ""),
      G != null &&
      typeof G != "function" &&
      typeof G != "symbol" &&
      typeof G != "boolean"
        ? (r.type = G)
        : r.removeAttribute("type"),
      o != null
        ? G === "number"
          ? ((o === 0 && r.value === "") || r.value != o) &&
            (r.value = "" + Gt(o))
          : r.value !== "" + Gt(o) && (r.value = "" + Gt(o))
        : (G !== "submit" && G !== "reset") || r.removeAttribute("value"),
      o != null
        ? Tn(r, G, Gt(o))
        : p != null
        ? Tn(r, G, Gt(p))
        : g != null && r.removeAttribute("value"),
      x == null && C != null && (r.defaultChecked = !!C),
      x != null &&
        (r.checked = x && typeof x != "function" && typeof x != "symbol"),
      Q != null &&
      typeof Q != "function" &&
      typeof Q != "symbol" &&
      typeof Q != "boolean"
        ? (r.name = "" + Gt(Q))
        : r.removeAttribute("name");
  }
  function Zn(r, o, p, g, x, C, G, Q) {
    if (
      (C != null &&
        typeof C != "function" &&
        typeof C != "symbol" &&
        typeof C != "boolean" &&
        (r.type = C),
      o != null || p != null)
    ) {
      if (!((C !== "submit" && C !== "reset") || o != null)) return;
      (p = p != null ? "" + Gt(p) : ""),
        (o = o != null ? "" + Gt(o) : p),
        Q || o === r.value || (r.value = o),
        (r.defaultValue = o);
    }
    (g = g ?? x),
      (g = typeof g != "function" && typeof g != "symbol" && !!g),
      (r.checked = Q ? r.checked : !!g),
      (r.defaultChecked = !!g),
      G != null &&
        typeof G != "function" &&
        typeof G != "symbol" &&
        typeof G != "boolean" &&
        (r.name = G);
  }
  function Tn(r, o, p) {
    (o === "number" && Ln(r.ownerDocument) === r) ||
      r.defaultValue === "" + p ||
      (r.defaultValue = "" + p);
  }
  function Nn(r, o, p, g) {
    if (((r = r.options), o)) {
      o = {};
      for (var x = 0; x < p.length; x++) o["$" + p[x]] = !0;
      for (p = 0; p < r.length; p++)
        (x = o.hasOwnProperty("$" + r[p].value)),
          r[p].selected !== x && (r[p].selected = x),
          x && g && (r[p].defaultSelected = !0);
    } else {
      for (p = "" + Gt(p), o = null, x = 0; x < r.length; x++) {
        if (r[x].value === p) {
          (r[x].selected = !0), g && (r[x].defaultSelected = !0);
          return;
        }
        o !== null || r[x].disabled || (o = r[x]);
      }
      o !== null && (o.selected = !0);
    }
  }
  function Mi(r, o, p) {
    if (
      o != null &&
      ((o = "" + Gt(o)), o !== r.value && (r.value = o), p == null)
    ) {
      r.defaultValue !== o && (r.defaultValue = o);
      return;
    }
    r.defaultValue = p != null ? "" + Gt(p) : "";
  }
  function Sa(r, o, p, g) {
    if (o == null) {
      if (g != null) {
        if (p != null) throw Error(n(92));
        if (fe(g)) {
          if (1 < g.length) throw Error(n(93));
          g = g[0];
        }
        p = g;
      }
      p == null && (p = ""), (o = p);
    }
    (p = Gt(o)),
      (r.defaultValue = p),
      (g = r.textContent),
      g === p && g !== "" && g !== null && (r.value = g);
  }
  function ea(r, o) {
    if (o) {
      var p = r.firstChild;
      if (p && p === r.lastChild && p.nodeType === 3) {
        p.nodeValue = o;
        return;
      }
    }
    r.textContent = o;
  }
  var Bl = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function Fo(r, o, p) {
    var g = o.indexOf("--") === 0;
    p == null || typeof p == "boolean" || p === ""
      ? g
        ? r.setProperty(o, "")
        : o === "float"
        ? (r.cssFloat = "")
        : (r[o] = "")
      : g
      ? r.setProperty(o, p)
      : typeof p != "number" || p === 0 || Bl.has(o)
      ? o === "float"
        ? (r.cssFloat = p)
        : (r[o] = ("" + p).trim())
      : (r[o] = p + "px");
  }
  function Dl(r, o, p) {
    if (o != null && typeof o != "object") throw Error(n(62));
    if (((r = r.style), p != null)) {
      for (var g in p)
        !p.hasOwnProperty(g) ||
          (o != null && o.hasOwnProperty(g)) ||
          (g.indexOf("--") === 0
            ? r.setProperty(g, "")
            : g === "float"
            ? (r.cssFloat = "")
            : (r[g] = ""));
      for (var x in o)
        (g = o[x]), o.hasOwnProperty(x) && p[x] !== g && Fo(r, x, g);
    } else for (var C in o) o.hasOwnProperty(C) && Fo(r, C, o[C]);
  }
  function Qr(r) {
    if (r.indexOf("-") === -1) return !1;
    switch (r) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Rc = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"],
    ]),
    Ul =
      /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function wr(r) {
    return Ul.test("" + r)
      ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
      : r;
  }
  var $r = null;
  function es(r) {
    return (
      (r = r.target || r.srcElement || window),
      r.correspondingUseElement && (r = r.correspondingUseElement),
      r.nodeType === 3 ? r.parentNode : r
    );
  }
  var ys = null,
    pr = null;
  function Po(r) {
    var o = z(r);
    if (o && (r = o.stateNode)) {
      var p = r[en] || null;
      e: switch (((r = o.stateNode), o.type)) {
        case "input":
          if (
            (on(
              r,
              p.value,
              p.defaultValue,
              p.defaultValue,
              p.checked,
              p.defaultChecked,
              p.type,
              p.name
            ),
            (o = p.name),
            p.type === "radio" && o != null)
          ) {
            for (p = r; p.parentNode; ) p = p.parentNode;
            for (
              p = p.querySelectorAll(
                'input[name="' + Xt("" + o) + '"][type="radio"]'
              ),
                o = 0;
              o < p.length;
              o++
            ) {
              var g = p[o];
              if (g !== r && g.form === r.form) {
                var x = g[en] || null;
                if (!x) throw Error(n(90));
                on(
                  g,
                  x.value,
                  x.defaultValue,
                  x.defaultValue,
                  x.checked,
                  x.defaultChecked,
                  x.type,
                  x.name
                );
              }
            }
            for (o = 0; o < p.length; o++)
              (g = p[o]), g.form === r.form && rn(g);
          }
          break e;
        case "textarea":
          Mi(r, p.value, p.defaultValue);
          break e;
        case "select":
          (o = p.value), o != null && Nn(r, !!p.multiple, o, !1);
      }
    }
  }
  var Go = !1;
  function Eu(r, o, p) {
    if (Go) return r(o, p);
    Go = !0;
    try {
      var g = r(o);
      return g;
    } finally {
      if (
        ((Go = !1),
        (ys !== null || pr !== null) &&
          (iu(), ys && ((o = ys), (r = pr), (pr = ys = null), Po(o), r)))
      )
        for (o = 0; o < r.length; o++) Po(r[o]);
    }
  }
  function ts(r, o) {
    var p = r.stateNode;
    if (p === null) return null;
    var g = p[en] || null;
    if (g === null) return null;
    p = g[o];
    e: switch (o) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (g = !g.disabled) ||
          ((r = r.type),
          (g = !(
            r === "button" ||
            r === "input" ||
            r === "select" ||
            r === "textarea"
          ))),
          (r = !g);
        break e;
      default:
        r = !1;
    }
    if (r) return null;
    if (p && typeof p != "function") throw Error(n(231, o, typeof p));
    return p;
  }
  var Vs = !1;
  if (pt)
    try {
      var ks = {};
      Object.defineProperty(ks, "passive", {
        get: function () {
          Vs = !0;
        },
      }),
        window.addEventListener("test", ks, ks),
        window.removeEventListener("test", ks, ks);
    } catch {
      Vs = !1;
    }
  var Ui = null,
    Ol = null,
    Ll = null;
  function Tu() {
    if (Ll) return Ll;
    var r,
      o = Ol,
      p = o.length,
      g,
      x = "value" in Ui ? Ui.value : Ui.textContent,
      C = x.length;
    for (r = 0; r < p && o[r] === x[r]; r++);
    var G = p - r;
    for (g = 1; g <= G && o[p - g] === x[C - g]; g++);
    return (Ll = x.slice(r, 1 < g ? 1 - g : void 0));
  }
  function Br(r) {
    var o = r.keyCode;
    return (
      "charCode" in r
        ? ((r = r.charCode), r === 0 && o === 13 && (r = 13))
        : (r = o),
      r === 10 && (r = 13),
      32 <= r || r === 13 ? r : 0
    );
  }
  function Xs() {
    return !0;
  }
  function zo() {
    return !1;
  }
  function Oi(r) {
    function o(p, g, x, C, G) {
      (this._reactName = p),
        (this._targetInst = x),
        (this.type = g),
        (this.nativeEvent = C),
        (this.target = G),
        (this.currentTarget = null);
      for (var Q in r)
        r.hasOwnProperty(Q) && ((p = r[Q]), (this[Q] = p ? p(C) : C[Q]));
      return (
        (this.isDefaultPrevented = (
          C.defaultPrevented != null ? C.defaultPrevented : C.returnValue === !1
        )
          ? Xs
          : zo),
        (this.isPropagationStopped = zo),
        this
      );
    }
    return (
      U(o.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var p = this.nativeEvent;
          p &&
            (p.preventDefault
              ? p.preventDefault()
              : typeof p.returnValue != "unknown" && (p.returnValue = !1),
            (this.isDefaultPrevented = Xs));
        },
        stopPropagation: function () {
          var p = this.nativeEvent;
          p &&
            (p.stopPropagation
              ? p.stopPropagation()
              : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0),
            (this.isPropagationStopped = Xs));
        },
        persist: function () {},
        isPersistent: Xs,
      }),
      o
    );
  }
  var ja = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (r) {
        return r.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    Ia = Oi(ja),
    Ys = U({}, ja, { view: 0, detail: 0 }),
    Cu = Oi(Ys),
    mr,
    Dr,
    Ws,
    Ur = U({}, Ys, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Dc,
      button: 0,
      buttons: 0,
      relatedTarget: function (r) {
        return r.relatedTarget === void 0
          ? r.fromElement === r.srcElement
            ? r.toElement
            : r.fromElement
          : r.relatedTarget;
      },
      movementX: function (r) {
        return "movementX" in r
          ? r.movementX
          : (r !== Ws &&
              (Ws && r.type === "mousemove"
                ? ((mr = r.screenX - Ws.screenX), (Dr = r.screenY - Ws.screenY))
                : (Dr = mr = 0),
              (Ws = r)),
            mr);
      },
      movementY: function (r) {
        return "movementY" in r ? r.movementY : Dr;
      },
    }),
    Nl = Oi(Ur),
    Ma = U({}, Ur, { dataTransfer: 0 }),
    Vd = Oi(Ma),
    Ti = U({}, Ys, { relatedTarget: 0 }),
    Js = Oi(Ti),
    wc = U({}, ja, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    ih = Oi(wc),
    da = U({}, ja, {
      clipboardData: function (r) {
        return "clipboardData" in r ? r.clipboardData : window.clipboardData;
      },
    }),
    Ka = Oi(da),
    ki = U({}, ja, { data: 0 }),
    gr = Oi(ki),
    Bc = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    ag = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    rg = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function kd(r) {
    var o = this.nativeEvent;
    return o.getModifierState
      ? o.getModifierState(r)
      : (r = rg[r])
      ? !!o[r]
      : !1;
  }
  function Dc() {
    return kd;
  }
  var sg = U({}, Ys, {
      key: function (r) {
        if (r.key) {
          var o = Bc[r.key] || r.key;
          if (o !== "Unidentified") return o;
        }
        return r.type === "keypress"
          ? ((r = Br(r)), r === 13 ? "Enter" : String.fromCharCode(r))
          : r.type === "keydown" || r.type === "keyup"
          ? ag[r.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Dc,
      charCode: function (r) {
        return r.type === "keypress" ? Br(r) : 0;
      },
      keyCode: function (r) {
        return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
      },
      which: function (r) {
        return r.type === "keypress"
          ? Br(r)
          : r.type === "keydown" || r.type === "keyup"
          ? r.keyCode
          : 0;
      },
    }),
    Xd = Oi(sg),
    Yd = U({}, Ur, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    ah = Oi(Yd),
    og = U({}, Ys, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Dc,
    }),
    Wd = Oi(og),
    lg = U({}, ja, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    qs = Oi(lg),
    Jd = U({}, Ur, {
      deltaX: function (r) {
        return "deltaX" in r
          ? r.deltaX
          : "wheelDeltaX" in r
          ? -r.wheelDeltaX
          : 0;
      },
      deltaY: function (r) {
        return "deltaY" in r
          ? r.deltaY
          : "wheelDeltaY" in r
          ? -r.wheelDeltaY
          : "wheelDelta" in r
          ? -r.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    f_ = Oi(Jd),
    ug = U({}, ja, { newState: 0, oldState: 0 }),
    Ho = Oi(ug),
    js = [9, 13, 27, 32],
    Uc = pt && "CompositionEvent" in window,
    Il = null;
  pt && "documentMode" in document && (Il = document.documentMode);
  var Oc = pt && "TextEvent" in window && !Il,
    Lc = pt && (!Uc || (Il && 8 < Il && 11 >= Il)),
    Vo = " ",
    pa = !1;
  function Nc(r, o) {
    switch (r) {
      case "keyup":
        return js.indexOf(o.keyCode) !== -1;
      case "keydown":
        return o.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function qd(r) {
    return (r = r.detail), typeof r == "object" && "data" in r ? r.data : null;
  }
  var ko = !1;
  function Ic(r, o) {
    switch (r) {
      case "compositionend":
        return qd(o);
      case "keypress":
        return o.which !== 32 ? null : ((pa = !0), Vo);
      case "textInput":
        return (r = o.data), r === Vo && pa ? null : r;
      default:
        return null;
    }
  }
  function jd(r, o) {
    if (ko)
      return r === "compositionend" || (!Uc && Nc(r, o))
        ? ((r = Tu()), (Ll = Ol = Ui = null), (ko = !1), r)
        : null;
    switch (r) {
      case "paste":
        return null;
      case "keypress":
        if (!(o.ctrlKey || o.altKey || o.metaKey) || (o.ctrlKey && o.altKey)) {
          if (o.char && 1 < o.char.length) return o.char;
          if (o.which) return String.fromCharCode(o.which);
        }
        return null;
      case "compositionend":
        return Lc && o.locale !== "ko" ? null : o.data;
      default:
        return null;
    }
  }
  var rh = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function Kd(r) {
    var o = r && r.nodeName && r.nodeName.toLowerCase();
    return o === "input" ? !!rh[r.type] : o === "textarea";
  }
  function Za(r, o, p, g) {
    ys ? (pr ? pr.push(g) : (pr = [g])) : (ys = g),
      (o = uv(o, "onChange")),
      0 < o.length &&
        ((p = new Ia("onChange", "change", null, p, g)),
        r.push({ event: p, listeners: o }));
  }
  var Ru = null,
    Fl = null;
  function cg(r) {
    tS(r, 0);
  }
  function Fc(r) {
    var o = re(r);
    if (rn(o)) return r;
  }
  function sh(r, o) {
    if (r === "change") return o;
  }
  var oh = !1;
  if (pt) {
    var lh;
    if (pt) {
      var wu = "oninput" in document;
      if (!wu) {
        var Bu = document.createElement("div");
        Bu.setAttribute("oninput", "return;"),
          (wu = typeof Bu.oninput == "function");
      }
      lh = wu;
    } else lh = !1;
    oh = lh && (!document.documentMode || 9 < document.documentMode);
  }
  function _i() {
    Ru && (Ru.detachEvent("onpropertychange", fg), (Fl = Ru = null));
  }
  function fg(r) {
    if (r.propertyName === "value" && Fc(Fl)) {
      var o = [];
      Za(o, Fl, r, es(r)), Eu(cg, o);
    }
  }
  function h_(r, o, p) {
    r === "focusin"
      ? (_i(), (Ru = o), (Fl = p), Ru.attachEvent("onpropertychange", fg))
      : r === "focusout" && _i();
  }
  function hg(r) {
    if (r === "selectionchange" || r === "keyup" || r === "keydown")
      return Fc(Fl);
  }
  function Pc(r, o) {
    if (r === "click") return Fc(o);
  }
  function Xo(r, o) {
    if (r === "input" || r === "change") return Fc(o);
  }
  function dg(r, o) {
    return (r === o && (r !== 0 || 1 / r === 1 / o)) || (r !== r && o !== o);
  }
  var Qa = typeof Object.is == "function" ? Object.is : dg;
  function ns(r, o) {
    if (Qa(r, o)) return !0;
    if (
      typeof r != "object" ||
      r === null ||
      typeof o != "object" ||
      o === null
    )
      return !1;
    var p = Object.keys(r),
      g = Object.keys(o);
    if (p.length !== g.length) return !1;
    for (g = 0; g < p.length; g++) {
      var x = p[g];
      if (!ht.call(o, x) || !Qa(r[x], o[x])) return !1;
    }
    return !0;
  }
  function $a(r) {
    for (; r && r.firstChild; ) r = r.firstChild;
    return r;
  }
  function Zd(r, o) {
    var p = $a(r);
    r = 0;
    for (var g; p; ) {
      if (p.nodeType === 3) {
        if (((g = r + p.textContent.length), r <= o && g >= o))
          return { node: p, offset: o - r };
        r = g;
      }
      e: {
        for (; p; ) {
          if (p.nextSibling) {
            p = p.nextSibling;
            break e;
          }
          p = p.parentNode;
        }
        p = void 0;
      }
      p = $a(p);
    }
  }
  function Qd(r, o) {
    return r && o
      ? r === o
        ? !0
        : r && r.nodeType === 3
        ? !1
        : o && o.nodeType === 3
        ? Qd(r, o.parentNode)
        : "contains" in r
        ? r.contains(o)
        : r.compareDocumentPosition
        ? !!(r.compareDocumentPosition(o) & 16)
        : !1
      : !1;
  }
  function $d(r) {
    r =
      r != null &&
      r.ownerDocument != null &&
      r.ownerDocument.defaultView != null
        ? r.ownerDocument.defaultView
        : window;
    for (var o = Ln(r.document); o instanceof r.HTMLIFrameElement; ) {
      try {
        var p = typeof o.contentWindow.location.href == "string";
      } catch {
        p = !1;
      }
      if (p) r = o.contentWindow;
      else break;
      o = Ln(r.document);
    }
    return o;
  }
  function Gc(r) {
    var o = r && r.nodeName && r.nodeName.toLowerCase();
    return (
      o &&
      ((o === "input" &&
        (r.type === "text" ||
          r.type === "search" ||
          r.type === "tel" ||
          r.type === "url" ||
          r.type === "password")) ||
        o === "textarea" ||
        r.contentEditable === "true")
    );
  }
  function ep(r, o) {
    var p = $d(o);
    o = r.focusedElem;
    var g = r.selectionRange;
    if (
      p !== o &&
      o &&
      o.ownerDocument &&
      Qd(o.ownerDocument.documentElement, o)
    ) {
      if (g !== null && Gc(o)) {
        if (
          ((r = g.start),
          (p = g.end),
          p === void 0 && (p = r),
          "selectionStart" in o)
        )
          (o.selectionStart = r),
            (o.selectionEnd = Math.min(p, o.value.length));
        else if (
          ((p = ((r = o.ownerDocument || document) && r.defaultView) || window),
          p.getSelection)
        ) {
          p = p.getSelection();
          var x = o.textContent.length,
            C = Math.min(g.start, x);
          (g = g.end === void 0 ? C : Math.min(g.end, x)),
            !p.extend && C > g && ((x = g), (g = C), (C = x)),
            (x = Zd(o, C));
          var G = Zd(o, g);
          x &&
            G &&
            (p.rangeCount !== 1 ||
              p.anchorNode !== x.node ||
              p.anchorOffset !== x.offset ||
              p.focusNode !== G.node ||
              p.focusOffset !== G.offset) &&
            ((r = r.createRange()),
            r.setStart(x.node, x.offset),
            p.removeAllRanges(),
            C > g
              ? (p.addRange(r), p.extend(G.node, G.offset))
              : (r.setEnd(G.node, G.offset), p.addRange(r)));
        }
      }
      for (r = [], p = o; (p = p.parentNode); )
        p.nodeType === 1 &&
          r.push({ element: p, left: p.scrollLeft, top: p.scrollTop });
      for (typeof o.focus == "function" && o.focus(), o = 0; o < r.length; o++)
        (p = r[o]),
          (p.element.scrollLeft = p.left),
          (p.element.scrollTop = p.top);
    }
  }
  var uh = pt && "documentMode" in document && 11 >= document.documentMode,
    Pl = null,
    tp = null,
    Du = null,
    ch = !1;
  function Or(r, o, p) {
    var g =
      p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
    ch ||
      Pl == null ||
      Pl !== Ln(g) ||
      ((g = Pl),
      "selectionStart" in g && Gc(g)
        ? (g = { start: g.selectionStart, end: g.selectionEnd })
        : ((g = (
            (g.ownerDocument && g.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (g = {
            anchorNode: g.anchorNode,
            anchorOffset: g.anchorOffset,
            focusNode: g.focusNode,
            focusOffset: g.focusOffset,
          })),
      (Du && ns(Du, g)) ||
        ((Du = g),
        (g = uv(tp, "onSelect")),
        0 < g.length &&
          ((o = new Ia("onSelect", "select", null, o, p)),
          r.push({ event: o, listeners: g }),
          (o.target = Pl))));
  }
  function Ks(r, o) {
    var p = {};
    return (
      (p[r.toLowerCase()] = o.toLowerCase()),
      (p["Webkit" + r] = "webkit" + o),
      (p["Moz" + r] = "moz" + o),
      p
    );
  }
  var Gl = {
      animationend: Ks("Animation", "AnimationEnd"),
      animationiteration: Ks("Animation", "AnimationIteration"),
      animationstart: Ks("Animation", "AnimationStart"),
      transitionrun: Ks("Transition", "TransitionRun"),
      transitionstart: Ks("Transition", "TransitionStart"),
      transitioncancel: Ks("Transition", "TransitionCancel"),
      transitionend: Ks("Transition", "TransitionEnd"),
    },
    np = {},
    fh = {};
  pt &&
    ((fh = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete Gl.animationend.animation,
      delete Gl.animationiteration.animation,
      delete Gl.animationstart.animation),
    "TransitionEvent" in window || delete Gl.transitionend.transition);
  function Xi(r) {
    if (np[r]) return np[r];
    if (!Gl[r]) return r;
    var o = Gl[r],
      p;
    for (p in o) if (o.hasOwnProperty(p) && p in fh) return (np[r] = o[p]);
    return r;
  }
  var ip = Xi("animationend"),
    er = Xi("animationiteration"),
    ap = Xi("animationstart"),
    Zs = Xi("transitionrun"),
    Uu = Xi("transitionstart"),
    Yo = Xi("transitioncancel"),
    hh = Xi("transitionend"),
    dh = new Map(),
    Qs =
      "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
        " "
      );
  function Lr(r, o) {
    dh.set(r, o), Ye(o, [r]);
  }
  var ma = [],
    _s = 0,
    $s = 0;
  function zc() {
    for (var r = _s, o = ($s = _s = 0); o < r; ) {
      var p = ma[o];
      ma[o++] = null;
      var g = ma[o];
      ma[o++] = null;
      var x = ma[o];
      ma[o++] = null;
      var C = ma[o];
      if (((ma[o++] = null), g !== null && x !== null)) {
        var G = g.pending;
        G === null ? (x.next = x) : ((x.next = G.next), (G.next = x)),
          (g.pending = x);
      }
      C !== 0 && Vc(p, x, C);
    }
  }
  function Hc(r, o, p, g) {
    (ma[_s++] = r),
      (ma[_s++] = o),
      (ma[_s++] = p),
      (ma[_s++] = g),
      ($s |= g),
      (r.lanes |= g),
      (r = r.alternate),
      r !== null && (r.lanes |= g);
  }
  function zl(r, o, p, g) {
    return Hc(r, o, p, g), kc(r);
  }
  function eo(r, o) {
    return Hc(r, null, null, o), kc(r);
  }
  function Vc(r, o, p) {
    r.lanes |= p;
    var g = r.alternate;
    g !== null && (g.lanes |= p);
    for (var x = !1, C = r.return; C !== null; )
      (C.childLanes |= p),
        (g = C.alternate),
        g !== null && (g.childLanes |= p),
        C.tag === 22 &&
          ((r = C.stateNode), r === null || r._visibility & 1 || (x = !0)),
        (r = C),
        (C = C.return);
    x &&
      o !== null &&
      r.tag === 3 &&
      ((C = r.stateNode),
      (x = 31 - Be(p)),
      (C = C.hiddenUpdates),
      (r = C[x]),
      r === null ? (C[x] = [o]) : r.push(o),
      (o.lane = p | 536870912));
  }
  function kc(r) {
    if (50 < Xr) throw ((Xr = 0), (So = null), Error(n(185)));
    for (var o = r.return; o !== null; ) (r = o), (o = r.return);
    return r.tag === 3 ? r.stateNode : null;
  }
  var Wo = {},
    ph = new WeakMap();
  function tr(r, o) {
    if (typeof r == "object" && r !== null) {
      var p = ph.get(r);
      return p !== void 0
        ? p
        : ((o = { value: r, source: o, stack: ge(o) }), ph.set(r, o), o);
    }
    return { value: r, source: o, stack: ge(o) };
  }
  var Hl = [],
    Jo = 0,
    ba = null,
    Xc = 0,
    ci = [],
    vr = 0,
    to = null,
    As = 1,
    no = "";
  function Fa(r, o) {
    (Hl[Jo++] = Xc), (Hl[Jo++] = ba), (ba = r), (Xc = o);
  }
  function rp(r, o, p) {
    (ci[vr++] = As), (ci[vr++] = no), (ci[vr++] = to), (to = r);
    var g = As;
    r = no;
    var x = 32 - Be(g) - 1;
    (g &= ~(1 << x)), (p += 1);
    var C = 32 - Be(o) + x;
    if (30 < C) {
      var G = x - (x % 5);
      (C = (g & ((1 << G) - 1)).toString(32)),
        (g >>= G),
        (x -= G),
        (As = (1 << (32 - Be(o) + x)) | (p << x) | g),
        (no = C + r);
    } else (As = (1 << C) | (p << x) | g), (no = r);
  }
  function Yc(r) {
    r.return !== null && (Fa(r, 1), rp(r, 1, 0));
  }
  function qo(r) {
    for (; r === ba; )
      (ba = Hl[--Jo]), (Hl[Jo] = null), (Xc = Hl[--Jo]), (Hl[Jo] = null);
    for (; r === to; )
      (to = ci[--vr]),
        (ci[vr] = null),
        (no = ci[--vr]),
        (ci[vr] = null),
        (As = ci[--vr]),
        (ci[vr] = null);
  }
  var Ea = null,
    la = null,
    Fn = !1,
    Nr = null,
    Ir = !1,
    Wc = Error(n(519));
  function Vl(r) {
    var o = Error(n(418, ""));
    throw (xs(tr(o, r)), Wc);
  }
  function pg(r) {
    var o = r.stateNode,
      p = r.type,
      g = r.memoizedProps;
    switch (((o[pn] = r), (o[en] = g), p)) {
      case "dialog":
        Gn("cancel", o), Gn("close", o);
        break;
      case "iframe":
      case "object":
      case "embed":
        Gn("load", o);
        break;
      case "video":
      case "audio":
        for (p = 0; p < Gp.length; p++) Gn(Gp[p], o);
        break;
      case "source":
        Gn("error", o);
        break;
      case "img":
      case "image":
      case "link":
        Gn("error", o), Gn("load", o);
        break;
      case "details":
        Gn("toggle", o);
        break;
      case "input":
        Gn("invalid", o),
          Zn(
            o,
            g.value,
            g.defaultValue,
            g.checked,
            g.defaultChecked,
            g.type,
            g.name,
            !0
          ),
          qt(o);
        break;
      case "select":
        Gn("invalid", o);
        break;
      case "textarea":
        Gn("invalid", o), Sa(o, g.value, g.defaultValue, g.children), qt(o);
    }
    (p = g.children),
      (typeof p != "string" && typeof p != "number" && typeof p != "bigint") ||
      o.textContent === "" + p ||
      g.suppressHydrationWarning === !0 ||
      rS(o.textContent, p)
        ? (g.popover != null && (Gn("beforetoggle", o), Gn("toggle", o)),
          g.onScroll != null && Gn("scroll", o),
          g.onScrollEnd != null && Gn("scrollend", o),
          g.onClick != null && (o.onclick = cv),
          (o = !0))
        : (o = !1),
      o || Vl(r);
  }
  function mg(r) {
    for (Ea = r.return; Ea; )
      switch (Ea.tag) {
        case 3:
        case 27:
          Ir = !0;
          return;
        case 5:
        case 13:
          Ir = !1;
          return;
        default:
          Ea = Ea.return;
      }
  }
  function Ou(r) {
    if (r !== Ea) return !1;
    if (!Fn) return mg(r), (Fn = !0), !1;
    var o = !1,
      p;
    if (
      ((p = r.tag !== 3 && r.tag !== 27) &&
        ((p = r.tag === 5) &&
          ((p = r.type),
          (p =
            !(p !== "form" && p !== "button") || U_(r.type, r.memoizedProps))),
        (p = !p)),
      p && (o = !0),
      o && la && Vl(r),
      mg(r),
      r.tag === 13)
    ) {
      if (((r = r.memoizedState), (r = r !== null ? r.dehydrated : null), !r))
        throw Error(n(317));
      e: {
        for (r = r.nextSibling, o = 0; r; ) {
          if (r.nodeType === 8)
            if (((p = r.data), p === "/$")) {
              if (o === 0) {
                la = bo(r.nextSibling);
                break e;
              }
              o--;
            } else (p !== "$" && p !== "$!" && p !== "$?") || o++;
          r = r.nextSibling;
        }
        la = null;
      }
    } else la = Ea ? bo(r.stateNode.nextSibling) : null;
    return !0;
  }
  function Lu() {
    (la = Ea = null), (Fn = !1);
  }
  function xs(r) {
    Nr === null ? (Nr = [r]) : Nr.push(r);
  }
  var jo = Error(n(460)),
    sp = Error(n(474)),
    mh = { then: function () {} };
  function gg(r) {
    return (r = r.status), r === "fulfilled" || r === "rejected";
  }
  function Jc() {}
  function Ko(r, o, p) {
    switch (
      ((p = r[p]),
      p === void 0 ? r.push(o) : p !== o && (o.then(Jc, Jc), (o = p)),
      o.status)
    ) {
      case "fulfilled":
        return o.value;
      case "rejected":
        throw ((r = o.reason), r === jo ? Error(n(483)) : r);
      default:
        if (typeof o.status == "string") o.then(Jc, Jc);
        else {
          if (((r = ti), r !== null && 100 < r.shellSuspendCounter))
            throw Error(n(482));
          (r = o),
            (r.status = "pending"),
            r.then(
              function (g) {
                if (o.status === "pending") {
                  var x = o;
                  (x.status = "fulfilled"), (x.value = g);
                }
              },
              function (g) {
                if (o.status === "pending") {
                  var x = o;
                  (x.status = "rejected"), (x.reason = g);
                }
              }
            );
        }
        switch (o.status) {
          case "fulfilled":
            return o.value;
          case "rejected":
            throw ((r = o.reason), r === jo ? Error(n(483)) : r);
        }
        throw ((Nu = o), jo);
    }
  }
  var Nu = null;
  function qn() {
    if (Nu === null) throw Error(n(459));
    var r = Nu;
    return (Nu = null), r;
  }
  var Zo = null,
    qc = 0;
  function jc(r) {
    var o = qc;
    return (qc += 1), Zo === null && (Zo = []), Ko(Zo, r, o);
  }
  function Kc(r, o) {
    (o = o.props.ref), (r.ref = o !== void 0 ? o : null);
  }
  function gh(r, o) {
    throw o.$$typeof === a
      ? Error(n(525))
      : ((r = Object.prototype.toString.call(o)),
        Error(
          n(
            31,
            r === "[object Object]"
              ? "object with keys {" + Object.keys(o).join(", ") + "}"
              : r
          )
        ));
  }
  function vg(r) {
    var o = r._init;
    return o(r._payload);
  }
  function yg(r) {
    function o(Oe, Te) {
      if (r) {
        var Fe = Oe.deletions;
        Fe === null ? ((Oe.deletions = [Te]), (Oe.flags |= 16)) : Fe.push(Te);
      }
    }
    function p(Oe, Te) {
      if (!r) return null;
      for (; Te !== null; ) o(Oe, Te), (Te = Te.sibling);
      return null;
    }
    function g(Oe) {
      for (var Te = new Map(); Oe !== null; )
        Oe.key !== null ? Te.set(Oe.key, Oe) : Te.set(Oe.index, Oe),
          (Oe = Oe.sibling);
      return Te;
    }
    function x(Oe, Te) {
      return (Oe = Ha(Oe, Te)), (Oe.index = 0), (Oe.sibling = null), Oe;
    }
    function C(Oe, Te, Fe) {
      return (
        (Oe.index = Fe),
        r
          ? ((Fe = Oe.alternate),
            Fe !== null
              ? ((Fe = Fe.index), Fe < Te ? ((Oe.flags |= 33554434), Te) : Fe)
              : ((Oe.flags |= 33554434), Te))
          : ((Oe.flags |= 1048576), Te)
      );
    }
    function G(Oe) {
      return r && Oe.alternate === null && (Oe.flags |= 33554434), Oe;
    }
    function Q(Oe, Te, Fe, _t) {
      return Te === null || Te.tag !== 6
        ? ((Te = qi(Fe, Oe.mode, _t)), (Te.return = Oe), Te)
        : ((Te = x(Te, Fe)), (Te.return = Oe), Te);
    }
    function he(Oe, Te, Fe, _t) {
      var kt = Fe.type;
      return kt === f
        ? ct(Oe, Te, Fe.props.children, _t, Fe.key)
        : Te !== null &&
          (Te.elementType === kt ||
            (typeof kt == "object" &&
              kt !== null &&
              kt.$$typeof === w &&
              vg(kt) === Te.type))
        ? ((Te = x(Te, Fe.props)), Kc(Te, Fe), (Te.return = Oe), Te)
        : ((Te = Ku(Fe.type, Fe.key, Fe.props, null, Oe.mode, _t)),
          Kc(Te, Fe),
          (Te.return = Oe),
          Te);
    }
    function Ce(Oe, Te, Fe, _t) {
      return Te === null ||
        Te.tag !== 4 ||
        Te.stateNode.containerInfo !== Fe.containerInfo ||
        Te.stateNode.implementation !== Fe.implementation
        ? ((Te = uf(Fe, Oe.mode, _t)), (Te.return = Oe), Te)
        : ((Te = x(Te, Fe.children || [])), (Te.return = Oe), Te);
    }
    function ct(Oe, Te, Fe, _t, kt) {
      return Te === null || Te.tag !== 7
        ? ((Te = gl(Fe, Oe.mode, _t, kt)), (Te.return = Oe), Te)
        : ((Te = x(Te, Fe)), (Te.return = Oe), Te);
    }
    function xt(Oe, Te, Fe) {
      if (
        (typeof Te == "string" && Te !== "") ||
        typeof Te == "number" ||
        typeof Te == "bigint"
      )
        return (Te = qi("" + Te, Oe.mode, Fe)), (Te.return = Oe), Te;
      if (typeof Te == "object" && Te !== null) {
        switch (Te.$$typeof) {
          case l:
            return (
              (Fe = Ku(Te.type, Te.key, Te.props, null, Oe.mode, Fe)),
              Kc(Fe, Te),
              (Fe.return = Oe),
              Fe
            );
          case u:
            return (Te = uf(Te, Oe.mode, Fe)), (Te.return = Oe), Te;
          case w:
            var _t = Te._init;
            return (Te = _t(Te._payload)), xt(Oe, Te, Fe);
        }
        if (fe(Te) || N(Te))
          return (Te = gl(Te, Oe.mode, Fe, null)), (Te.return = Oe), Te;
        if (typeof Te.then == "function") return xt(Oe, jc(Te), Fe);
        if (Te.$$typeof === A) return xt(Oe, Oh(Oe, Te), Fe);
        gh(Oe, Te);
      }
      return null;
    }
    function ke(Oe, Te, Fe, _t) {
      var kt = Te !== null ? Te.key : null;
      if (
        (typeof Fe == "string" && Fe !== "") ||
        typeof Fe == "number" ||
        typeof Fe == "bigint"
      )
        return kt !== null ? null : Q(Oe, Te, "" + Fe, _t);
      if (typeof Fe == "object" && Fe !== null) {
        switch (Fe.$$typeof) {
          case l:
            return Fe.key === kt ? he(Oe, Te, Fe, _t) : null;
          case u:
            return Fe.key === kt ? Ce(Oe, Te, Fe, _t) : null;
          case w:
            return (kt = Fe._init), (Fe = kt(Fe._payload)), ke(Oe, Te, Fe, _t);
        }
        if (fe(Fe) || N(Fe))
          return kt !== null ? null : ct(Oe, Te, Fe, _t, null);
        if (typeof Fe.then == "function") return ke(Oe, Te, jc(Fe), _t);
        if (Fe.$$typeof === A) return ke(Oe, Te, Oh(Oe, Fe), _t);
        gh(Oe, Fe);
      }
      return null;
    }
    function ot(Oe, Te, Fe, _t, kt) {
      if (
        (typeof _t == "string" && _t !== "") ||
        typeof _t == "number" ||
        typeof _t == "bigint"
      )
        return (Oe = Oe.get(Fe) || null), Q(Te, Oe, "" + _t, kt);
      if (typeof _t == "object" && _t !== null) {
        switch (_t.$$typeof) {
          case l:
            return (
              (Oe = Oe.get(_t.key === null ? Fe : _t.key) || null),
              he(Te, Oe, _t, kt)
            );
          case u:
            return (
              (Oe = Oe.get(_t.key === null ? Fe : _t.key) || null),
              Ce(Te, Oe, _t, kt)
            );
          case w:
            var Dn = _t._init;
            return (_t = Dn(_t._payload)), ot(Oe, Te, Fe, _t, kt);
        }
        if (fe(_t) || N(_t))
          return (Oe = Oe.get(Fe) || null), ct(Te, Oe, _t, kt, null);
        if (typeof _t.then == "function") return ot(Oe, Te, Fe, jc(_t), kt);
        if (_t.$$typeof === A) return ot(Oe, Te, Fe, Oh(Te, _t), kt);
        gh(Te, _t);
      }
      return null;
    }
    function Jt(Oe, Te, Fe, _t) {
      for (
        var kt = null, Dn = null, Kt = Te, an = (Te = 0), Ua = null;
        Kt !== null && an < Fe.length;
        an++
      ) {
        Kt.index > an ? ((Ua = Kt), (Kt = null)) : (Ua = Kt.sibling);
        var jn = ke(Oe, Kt, Fe[an], _t);
        if (jn === null) {
          Kt === null && (Kt = Ua);
          break;
        }
        r && Kt && jn.alternate === null && o(Oe, Kt),
          (Te = C(jn, Te, an)),
          Dn === null ? (kt = jn) : (Dn.sibling = jn),
          (Dn = jn),
          (Kt = Ua);
      }
      if (an === Fe.length) return p(Oe, Kt), Fn && Fa(Oe, an), kt;
      if (Kt === null) {
        for (; an < Fe.length; an++)
          (Kt = xt(Oe, Fe[an], _t)),
            Kt !== null &&
              ((Te = C(Kt, Te, an)),
              Dn === null ? (kt = Kt) : (Dn.sibling = Kt),
              (Dn = Kt));
        return Fn && Fa(Oe, an), kt;
      }
      for (Kt = g(Kt); an < Fe.length; an++)
        (Ua = ot(Kt, Oe, an, Fe[an], _t)),
          Ua !== null &&
            (r &&
              Ua.alternate !== null &&
              Kt.delete(Ua.key === null ? an : Ua.key),
            (Te = C(Ua, Te, an)),
            Dn === null ? (kt = Ua) : (Dn.sibling = Ua),
            (Dn = Ua));
      return (
        r &&
          Kt.forEach(function (rc) {
            return o(Oe, rc);
          }),
        Fn && Fa(Oe, an),
        kt
      );
    }
    function fn(Oe, Te, Fe, _t) {
      if (Fe == null) throw Error(n(151));
      for (
        var kt = null,
          Dn = null,
          Kt = Te,
          an = (Te = 0),
          Ua = null,
          jn = Fe.next();
        Kt !== null && !jn.done;
        an++, jn = Fe.next()
      ) {
        Kt.index > an ? ((Ua = Kt), (Kt = null)) : (Ua = Kt.sibling);
        var rc = ke(Oe, Kt, jn.value, _t);
        if (rc === null) {
          Kt === null && (Kt = Ua);
          break;
        }
        r && Kt && rc.alternate === null && o(Oe, Kt),
          (Te = C(rc, Te, an)),
          Dn === null ? (kt = rc) : (Dn.sibling = rc),
          (Dn = rc),
          (Kt = Ua);
      }
      if (jn.done) return p(Oe, Kt), Fn && Fa(Oe, an), kt;
      if (Kt === null) {
        for (; !jn.done; an++, jn = Fe.next())
          (jn = xt(Oe, jn.value, _t)),
            jn !== null &&
              ((Te = C(jn, Te, an)),
              Dn === null ? (kt = jn) : (Dn.sibling = jn),
              (Dn = jn));
        return Fn && Fa(Oe, an), kt;
      }
      for (Kt = g(Kt); !jn.done; an++, jn = Fe.next())
        (jn = ot(Kt, Oe, an, jn.value, _t)),
          jn !== null &&
            (r &&
              jn.alternate !== null &&
              Kt.delete(jn.key === null ? an : jn.key),
            (Te = C(jn, Te, an)),
            Dn === null ? (kt = jn) : (Dn.sibling = jn),
            (Dn = jn));
      return (
        r &&
          Kt.forEach(function (NC) {
            return o(Oe, NC);
          }),
        Fn && Fa(Oe, an),
        kt
      );
    }
    function Zi(Oe, Te, Fe, _t) {
      if (
        (typeof Fe == "object" &&
          Fe !== null &&
          Fe.type === f &&
          Fe.key === null &&
          (Fe = Fe.props.children),
        typeof Fe == "object" && Fe !== null)
      ) {
        switch (Fe.$$typeof) {
          case l:
            e: {
              for (var kt = Fe.key; Te !== null; ) {
                if (Te.key === kt) {
                  if (((kt = Fe.type), kt === f)) {
                    if (Te.tag === 7) {
                      p(Oe, Te.sibling),
                        (_t = x(Te, Fe.props.children)),
                        (_t.return = Oe),
                        (Oe = _t);
                      break e;
                    }
                  } else if (
                    Te.elementType === kt ||
                    (typeof kt == "object" &&
                      kt !== null &&
                      kt.$$typeof === w &&
                      vg(kt) === Te.type)
                  ) {
                    p(Oe, Te.sibling),
                      (_t = x(Te, Fe.props)),
                      Kc(_t, Fe),
                      (_t.return = Oe),
                      (Oe = _t);
                    break e;
                  }
                  p(Oe, Te);
                  break;
                } else o(Oe, Te);
                Te = Te.sibling;
              }
              Fe.type === f
                ? ((_t = gl(Fe.props.children, Oe.mode, _t, Fe.key)),
                  (_t.return = Oe),
                  (Oe = _t))
                : ((_t = Ku(Fe.type, Fe.key, Fe.props, null, Oe.mode, _t)),
                  Kc(_t, Fe),
                  (_t.return = Oe),
                  (Oe = _t));
            }
            return G(Oe);
          case u:
            e: {
              for (kt = Fe.key; Te !== null; ) {
                if (Te.key === kt)
                  if (
                    Te.tag === 4 &&
                    Te.stateNode.containerInfo === Fe.containerInfo &&
                    Te.stateNode.implementation === Fe.implementation
                  ) {
                    p(Oe, Te.sibling),
                      (_t = x(Te, Fe.children || [])),
                      (_t.return = Oe),
                      (Oe = _t);
                    break e;
                  } else {
                    p(Oe, Te);
                    break;
                  }
                else o(Oe, Te);
                Te = Te.sibling;
              }
              (_t = uf(Fe, Oe.mode, _t)), (_t.return = Oe), (Oe = _t);
            }
            return G(Oe);
          case w:
            return (kt = Fe._init), (Fe = kt(Fe._payload)), Zi(Oe, Te, Fe, _t);
        }
        if (fe(Fe)) return Jt(Oe, Te, Fe, _t);
        if (N(Fe)) {
          if (((kt = N(Fe)), typeof kt != "function")) throw Error(n(150));
          return (Fe = kt.call(Fe)), fn(Oe, Te, Fe, _t);
        }
        if (typeof Fe.then == "function") return Zi(Oe, Te, jc(Fe), _t);
        if (Fe.$$typeof === A) return Zi(Oe, Te, Oh(Oe, Fe), _t);
        gh(Oe, Fe);
      }
      return (typeof Fe == "string" && Fe !== "") ||
        typeof Fe == "number" ||
        typeof Fe == "bigint"
        ? ((Fe = "" + Fe),
          Te !== null && Te.tag === 6
            ? (p(Oe, Te.sibling), (_t = x(Te, Fe)), (_t.return = Oe), (Oe = _t))
            : (p(Oe, Te),
              (_t = qi(Fe, Oe.mode, _t)),
              (_t.return = Oe),
              (Oe = _t)),
          G(Oe))
        : p(Oe, Te);
    }
    return function (Oe, Te, Fe, _t) {
      try {
        qc = 0;
        var kt = Zi(Oe, Te, Fe, _t);
        return (Zo = null), kt;
      } catch (Kt) {
        if (Kt === jo) throw Kt;
        var Dn = zi(29, Kt, null, Oe.mode);
        return (Dn.lanes = _t), (Dn.return = Oe), Dn;
      } finally {
      }
    };
  }
  var io = yg(!0),
    ao = yg(!1),
    kl = be(null),
    Xl = be(0);
  function Qo(r, o) {
    (r = xo), We(Xl, r), We(kl, o), (xo = r | o.baseLanes);
  }
  function vh() {
    We(Xl, xo), We(kl, kl.current);
  }
  function Zc() {
    (xo = Xl.current), it(kl), it(Xl);
  }
  var nr = be(null),
    Ss = null;
  function ro(r) {
    var o = r.alternate;
    We(Yi, Yi.current & 1),
      We(nr, r),
      Ss === null &&
        (o === null || kl.current !== null || o.memoizedState !== null) &&
        (Ss = r);
  }
  function op(r) {
    if (r.tag === 22) {
      if ((We(Yi, Yi.current), We(nr, r), Ss === null)) {
        var o = r.alternate;
        o !== null && o.memoizedState !== null && (Ss = r);
      }
    } else so();
  }
  function so() {
    We(Yi, Yi.current), We(nr, nr.current);
  }
  function Ms(r) {
    it(nr), Ss === r && (Ss = null), it(Yi);
  }
  var Yi = be(0);
  function Iu(r) {
    for (var o = r; o !== null; ) {
      if (o.tag === 13) {
        var p = o.memoizedState;
        if (
          p !== null &&
          ((p = p.dehydrated), p === null || p.data === "$?" || p.data === "$!")
        )
          return o;
      } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
        if ((o.flags & 128) !== 0) return o;
      } else if (o.child !== null) {
        (o.child.return = o), (o = o.child);
        continue;
      }
      if (o === r) break;
      for (; o.sibling === null; ) {
        if (o.return === null || o.return === r) return null;
        o = o.return;
      }
      (o.sibling.return = o.return), (o = o.sibling);
    }
    return null;
  }
  var Cn =
      typeof AbortController < "u"
        ? AbortController
        : function () {
            var r = [],
              o = (this.signal = {
                aborted: !1,
                addEventListener: function (p, g) {
                  r.push(g);
                },
              });
            this.abort = function () {
              (o.aborted = !0),
                r.forEach(function (p) {
                  return p();
                });
            };
          },
    d_ = s.unstable_scheduleCallback,
    yr = s.unstable_NormalPriority,
    Li = {
      $$typeof: A,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
    };
  function lp() {
    return { controller: new Cn(), data: new Map(), refCount: 0 };
  }
  function $o(r) {
    r.refCount--,
      r.refCount === 0 &&
        d_(yr, function () {
          r.controller.abort();
        });
  }
  var bs = null,
    el = 0,
    Yl = 0,
    tl = null;
  function p_(r, o) {
    if (bs === null) {
      var p = (bs = []);
      (el = 0),
        (Yl = M_()),
        (tl = {
          status: "pending",
          value: void 0,
          then: function (g) {
            p.push(g);
          },
        });
    }
    return el++, o.then(up, up), o;
  }
  function up() {
    if (--el === 0 && bs !== null) {
      tl !== null && (tl.status = "fulfilled");
      var r = bs;
      (bs = null), (Yl = 0), (tl = null);
      for (var o = 0; o < r.length; o++) (0, r[o])();
    }
  }
  function nl(r, o) {
    var p = [],
      g = {
        status: "pending",
        value: null,
        reason: null,
        then: function (x) {
          p.push(x);
        },
      };
    return (
      r.then(
        function () {
          (g.status = "fulfilled"), (g.value = o);
          for (var x = 0; x < p.length; x++) (0, p[x])(o);
        },
        function (x) {
          for (g.status = "rejected", g.reason = x, x = 0; x < p.length; x++)
            (0, p[x])(void 0);
        }
      ),
      g
    );
  }
  var yh = O.S;
  O.S = function (r, o) {
    typeof o == "object" &&
      o !== null &&
      typeof o.then == "function" &&
      p_(r, o),
      yh !== null && yh(r, o);
  };
  var oo = be(null);
  function Qc() {
    var r = oo.current;
    return r !== null ? r : ti.pooledCache;
  }
  function Fu(r, o) {
    o === null ? We(oo, oo.current) : We(oo, o.pool);
  }
  function lo() {
    var r = Qc();
    return r === null ? null : { parent: Li._currentValue, pool: r };
  }
  var uo = 0,
    xn = null,
    Qn = null,
    Wi = null,
    nn = !1,
    il = !1,
    al = !1,
    Pu = 0,
    rl = 0,
    Gu = null,
    m_ = 0;
  function Ci() {
    throw Error(n(321));
  }
  function Wl(r, o) {
    if (o === null) return !1;
    for (var p = 0; p < o.length && p < r.length; p++)
      if (!Qa(r[p], o[p])) return !1;
    return !0;
  }
  function cp(r, o, p, g, x, C) {
    return (
      (uo = C),
      (xn = o),
      (o.memoizedState = null),
      (o.updateQueue = null),
      (o.lanes = 0),
      (O.H = r === null || r.memoizedState === null ? ol : fo),
      (al = !1),
      (C = p(g, x)),
      (al = !1),
      il && (C = Ag(o, p, g, x)),
      _g(r),
      C
    );
  }
  function _g(r) {
    O.H = Ts;
    var o = Qn !== null && Qn.next !== null;
    if (((uo = 0), (Wi = Qn = xn = null), (nn = !1), (rl = 0), (Gu = null), o))
      throw Error(n(300));
    r === null ||
      ta ||
      ((r = r.dependencies), r !== null && Xu(r) && (ta = !0));
  }
  function Ag(r, o, p, g) {
    xn = r;
    var x = 0;
    do {
      if ((il && (Gu = null), (rl = 0), (il = !1), 25 <= x))
        throw Error(n(301));
      if (((x += 1), (Wi = Qn = null), r.updateQueue != null)) {
        var C = r.updateQueue;
        (C.lastEffect = null),
          (C.events = null),
          (C.stores = null),
          C.memoCache != null && (C.memoCache.index = 0);
      }
      (O.H = jl), (C = o(p, g));
    } while (il);
    return C;
  }
  function g_() {
    var r = O.H,
      o = r.useState()[0];
    return (
      (o = typeof o.then == "function" ? ef(o) : o),
      (r = r.useState()[0]),
      (Qn !== null ? Qn.memoizedState : null) !== r && (xn.flags |= 1024),
      o
    );
  }
  function fp() {
    var r = Pu !== 0;
    return (Pu = 0), r;
  }
  function $c(r, o, p) {
    (o.updateQueue = r.updateQueue), (o.flags &= -2053), (r.lanes &= ~p);
  }
  function _h(r) {
    if (nn) {
      for (r = r.memoizedState; r !== null; ) {
        var o = r.queue;
        o !== null && (o.pending = null), (r = r.next);
      }
      nn = !1;
    }
    (uo = 0), (Wi = Qn = xn = null), (il = !1), (rl = Pu = 0), (Gu = null);
  }
  function ga() {
    var r = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Wi === null ? (xn.memoizedState = Wi = r) : (Wi = Wi.next = r), Wi;
  }
  function Ni() {
    if (Qn === null) {
      var r = xn.alternate;
      r = r !== null ? r.memoizedState : null;
    } else r = Qn.next;
    var o = Wi === null ? xn.memoizedState : Wi.next;
    if (o !== null) (Wi = o), (Qn = r);
    else {
      if (r === null)
        throw xn.alternate === null ? Error(n(467)) : Error(n(310));
      (Qn = r),
        (r = {
          memoizedState: Qn.memoizedState,
          baseState: Qn.baseState,
          baseQueue: Qn.baseQueue,
          queue: Qn.queue,
          next: null,
        }),
        Wi === null ? (xn.memoizedState = Wi = r) : (Wi = Wi.next = r);
    }
    return Wi;
  }
  var Ah;
  Ah = function () {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  };
  function ef(r) {
    var o = rl;
    return (
      (rl += 1),
      Gu === null && (Gu = []),
      (r = Ko(Gu, r, o)),
      (o = xn),
      (Wi === null ? o.memoizedState : Wi.next) === null &&
        ((o = o.alternate),
        (O.H = o === null || o.memoizedState === null ? ol : fo)),
      r
    );
  }
  function zu(r) {
    if (r !== null && typeof r == "object") {
      if (typeof r.then == "function") return ef(r);
      if (r.$$typeof === A) return Ta(r);
    }
    throw Error(n(438, String(r)));
  }
  function is(r) {
    var o = null,
      p = xn.updateQueue;
    if ((p !== null && (o = p.memoCache), o == null)) {
      var g = xn.alternate;
      g !== null &&
        ((g = g.updateQueue),
        g !== null &&
          ((g = g.memoCache),
          g != null &&
            (o = {
              data: g.data.map(function (x) {
                return x.slice();
              }),
              index: 0,
            })));
    }
    if (
      (o == null && (o = { data: [], index: 0 }),
      p === null && ((p = Ah()), (xn.updateQueue = p)),
      (p.memoCache = o),
      (p = o.data[o.index]),
      p === void 0)
    )
      for (p = o.data[o.index] = Array(r), g = 0; g < r; g++) p[g] = B;
    return o.index++, p;
  }
  function Ai(r, o) {
    return typeof o == "function" ? o(r) : o;
  }
  function as(r) {
    var o = Ni();
    return ir(o, Qn, r);
  }
  function ir(r, o, p) {
    var g = r.queue;
    if (g === null) throw Error(n(311));
    g.lastRenderedReducer = p;
    var x = r.baseQueue,
      C = g.pending;
    if (C !== null) {
      if (x !== null) {
        var G = x.next;
        (x.next = C.next), (C.next = G);
      }
      (o.baseQueue = x = C), (g.pending = null);
    }
    if (((C = r.baseState), x === null)) r.memoizedState = C;
    else {
      o = x.next;
      var Q = (G = null),
        he = null,
        Ce = o,
        ct = !1;
      do {
        var xt = Ce.lane & -536870913;
        if (xt !== Ce.lane ? (Zt & xt) === xt : (uo & xt) === xt) {
          var ke = Ce.revertLane;
          if (ke === 0)
            he !== null &&
              (he = he.next =
                {
                  lane: 0,
                  revertLane: 0,
                  action: Ce.action,
                  hasEagerState: Ce.hasEagerState,
                  eagerState: Ce.eagerState,
                  next: null,
                }),
              xt === Yl && (ct = !0);
          else if ((uo & ke) === ke) {
            (Ce = Ce.next), ke === Yl && (ct = !0);
            continue;
          } else
            (xt = {
              lane: 0,
              revertLane: Ce.revertLane,
              action: Ce.action,
              hasEagerState: Ce.hasEagerState,
              eagerState: Ce.eagerState,
              next: null,
            }),
              he === null ? ((Q = he = xt), (G = C)) : (he = he.next = xt),
              (xn.lanes |= ke),
              (fs |= ke);
          (xt = Ce.action),
            al && p(C, xt),
            (C = Ce.hasEagerState ? Ce.eagerState : p(C, xt));
        } else
          (ke = {
            lane: xt,
            revertLane: Ce.revertLane,
            action: Ce.action,
            hasEagerState: Ce.hasEagerState,
            eagerState: Ce.eagerState,
            next: null,
          }),
            he === null ? ((Q = he = ke), (G = C)) : (he = he.next = ke),
            (xn.lanes |= xt),
            (fs |= xt);
        Ce = Ce.next;
      } while (Ce !== null && Ce !== o);
      if (
        (he === null ? (G = C) : (he.next = Q),
        !Qa(C, r.memoizedState) && ((ta = !0), ct && ((p = tl), p !== null)))
      )
        throw p;
      (r.memoizedState = C),
        (r.baseState = G),
        (r.baseQueue = he),
        (g.lastRenderedState = C);
    }
    return x === null && (g.lanes = 0), [r.memoizedState, g.dispatch];
  }
  function xh(r) {
    var o = Ni(),
      p = o.queue;
    if (p === null) throw Error(n(311));
    p.lastRenderedReducer = r;
    var g = p.dispatch,
      x = p.pending,
      C = o.memoizedState;
    if (x !== null) {
      p.pending = null;
      var G = (x = x.next);
      do (C = r(C, G.action)), (G = G.next);
      while (G !== x);
      Qa(C, o.memoizedState) || (ta = !0),
        (o.memoizedState = C),
        o.baseQueue === null && (o.baseState = C),
        (p.lastRenderedState = C);
    }
    return [C, g];
  }
  function xg(r, o, p) {
    var g = xn,
      x = Ni(),
      C = Fn;
    if (C) {
      if (p === void 0) throw Error(n(407));
      p = p();
    } else p = o();
    var G = !Qa((Qn || x).memoizedState, p);
    if (
      (G && ((x.memoizedState = p), (ta = !0)),
      (x = x.queue),
      mp(Sg.bind(null, g, x, r), [r]),
      x.getSnapshot !== o || G || (Wi !== null && Wi.memoizedState.tag & 1))
    ) {
      if (
        ((g.flags |= 2048),
        Es(9, sl.bind(null, g, x, p, o), { destroy: void 0 }, null),
        ti === null)
      )
        throw Error(n(349));
      C || (uo & 60) !== 0 || Pa(g, o, p);
    }
    return p;
  }
  function Pa(r, o, p) {
    (r.flags |= 16384),
      (r = { getSnapshot: o, value: p }),
      (o = xn.updateQueue),
      o === null
        ? ((o = Ah()), (xn.updateQueue = o), (o.stores = [r]))
        : ((p = o.stores), p === null ? (o.stores = [r]) : p.push(r));
  }
  function sl(r, o, p, g) {
    (o.value = p), (o.getSnapshot = g), Mg(o) && bg(r);
  }
  function Sg(r, o, p) {
    return p(function () {
      Mg(o) && bg(r);
    });
  }
  function Mg(r) {
    var o = r.getSnapshot;
    r = r.value;
    try {
      var p = o();
      return !Qa(r, p);
    } catch {
      return !0;
    }
  }
  function bg(r) {
    var o = eo(r, 2);
    o !== null && Ki(o, r, 2);
  }
  function hp(r) {
    var o = ga();
    if (typeof r == "function") {
      var p = r;
      if (((r = p()), al)) {
        le(!0);
        try {
          p();
        } finally {
          le(!1);
        }
      }
    }
    return (
      (o.memoizedState = o.baseState = r),
      (o.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ai,
        lastRenderedState: r,
      }),
      o
    );
  }
  function dp(r, o, p, g) {
    return (r.baseState = p), ir(r, Qn, typeof g == "function" ? g : Ai);
  }
  function v_(r, o, p, g, x) {
    if (Th(r)) throw Error(n(485));
    if (((r = o.action), r !== null)) {
      var C = {
        payload: x,
        action: r,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function (G) {
          C.listeners.push(G);
        },
      };
      O.T !== null ? p(!0) : (C.isTransition = !1),
        g(C),
        (p = o.pending),
        p === null
          ? ((C.next = o.pending = C), pp(o, C))
          : ((C.next = p.next), (o.pending = p.next = C));
    }
  }
  function pp(r, o) {
    var p = o.action,
      g = o.payload,
      x = r.state;
    if (o.isTransition) {
      var C = O.T,
        G = {};
      O.T = G;
      try {
        var Q = p(x, g),
          he = O.S;
        he !== null && he(G, Q), Eg(r, o, Q);
      } catch (Ce) {
        co(r, o, Ce);
      } finally {
        O.T = C;
      }
    } else
      try {
        (C = p(x, g)), Eg(r, o, C);
      } catch (Ce) {
        co(r, o, Ce);
      }
  }
  function Eg(r, o, p) {
    p !== null && typeof p == "object" && typeof p.then == "function"
      ? p.then(
          function (g) {
            Jl(r, o, g);
          },
          function (g) {
            return co(r, o, g);
          }
        )
      : Jl(r, o, p);
  }
  function Jl(r, o, p) {
    (o.status = "fulfilled"),
      (o.value = p),
      Tg(o),
      (r.state = p),
      (o = r.pending),
      o !== null &&
        ((p = o.next),
        p === o ? (r.pending = null) : ((p = p.next), (o.next = p), pp(r, p)));
  }
  function co(r, o, p) {
    var g = r.pending;
    if (((r.pending = null), g !== null)) {
      g = g.next;
      do (o.status = "rejected"), (o.reason = p), Tg(o), (o = o.next);
      while (o !== g);
    }
    r.action = null;
  }
  function Tg(r) {
    r = r.listeners;
    for (var o = 0; o < r.length; o++) (0, r[o])();
  }
  function Cg(r, o) {
    return o;
  }
  function Rg(r, o) {
    if (Fn) {
      var p = ti.formState;
      if (p !== null) {
        e: {
          var g = xn;
          if (Fn) {
            if (la) {
              t: {
                for (var x = la, C = Ir; x.nodeType !== 8; ) {
                  if (!C) {
                    x = null;
                    break t;
                  }
                  if (((x = bo(x.nextSibling)), x === null)) {
                    x = null;
                    break t;
                  }
                }
                (C = x.data), (x = C === "F!" || C === "F" ? x : null);
              }
              if (x) {
                (la = bo(x.nextSibling)), (g = x.data === "F!");
                break e;
              }
            }
            Vl(g);
          }
          g = !1;
        }
        g && (o = p[0]);
      }
    }
    return (
      (p = ga()),
      (p.memoizedState = p.baseState = o),
      (g = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Cg,
        lastRenderedState: o,
      }),
      (p.queue = g),
      (p = _p.bind(null, xn, g)),
      (g.dispatch = p),
      (g = hp(!1)),
      (C = tf.bind(null, xn, !1, g.queue)),
      (g = ga()),
      (x = { state: o, dispatch: null, action: r, pending: null }),
      (g.queue = x),
      (p = v_.bind(null, xn, x, C, p)),
      (x.dispatch = p),
      (g.memoizedState = r),
      [o, p, !1]
    );
  }
  function Hu(r) {
    var o = Ni();
    return wg(o, Qn, r);
  }
  function wg(r, o, p) {
    (o = ir(r, o, Cg)[0]),
      (r = as(Ai)[0]),
      (o =
        typeof o == "object" && o !== null && typeof o.then == "function"
          ? ef(o)
          : o);
    var g = Ni(),
      x = g.queue,
      C = x.dispatch;
    return (
      p !== g.memoizedState &&
        ((xn.flags |= 2048),
        Es(9, y_.bind(null, x, p), { destroy: void 0 }, null)),
      [o, C, r]
    );
  }
  function y_(r, o) {
    r.action = o;
  }
  function Bg(r) {
    var o = Ni(),
      p = Qn;
    if (p !== null) return wg(o, p, r);
    Ni(), (o = o.memoizedState), (p = Ni());
    var g = p.queue.dispatch;
    return (p.memoizedState = r), [o, g, !1];
  }
  function Es(r, o, p, g) {
    return (
      (r = { tag: r, create: o, inst: p, deps: g, next: null }),
      (o = xn.updateQueue),
      o === null && ((o = Ah()), (xn.updateQueue = o)),
      (p = o.lastEffect),
      p === null
        ? (o.lastEffect = r.next = r)
        : ((g = p.next), (p.next = r), (r.next = g), (o.lastEffect = r)),
      r
    );
  }
  function Dg() {
    return Ni().memoizedState;
  }
  function Sh(r, o, p, g) {
    var x = ga();
    (xn.flags |= r),
      (x.memoizedState = Es(
        1 | o,
        p,
        { destroy: void 0 },
        g === void 0 ? null : g
      ));
  }
  function Mh(r, o, p, g) {
    var x = Ni();
    g = g === void 0 ? null : g;
    var C = x.memoizedState.inst;
    Qn !== null && g !== null && Wl(g, Qn.memoizedState.deps)
      ? (x.memoizedState = Es(o, p, C, g))
      : ((xn.flags |= r), (x.memoizedState = Es(1 | o, p, C, g)));
  }
  function Ug(r, o) {
    Sh(8390656, 8, r, o);
  }
  function mp(r, o) {
    Mh(2048, 8, r, o);
  }
  function Og(r, o) {
    return Mh(4, 2, r, o);
  }
  function Lg(r, o) {
    return Mh(4, 4, r, o);
  }
  function Ng(r, o) {
    if (typeof o == "function") {
      r = r();
      var p = o(r);
      return function () {
        typeof p == "function" ? p() : o(null);
      };
    }
    if (o != null)
      return (
        (r = r()),
        (o.current = r),
        function () {
          o.current = null;
        }
      );
  }
  function Ig(r, o, p) {
    (p = p != null ? p.concat([r]) : null), Mh(4, 4, Ng.bind(null, o, r), p);
  }
  function gp() {}
  function Fg(r, o) {
    var p = Ni();
    o = o === void 0 ? null : o;
    var g = p.memoizedState;
    return o !== null && Wl(o, g[1]) ? g[0] : ((p.memoizedState = [r, o]), r);
  }
  function Pg(r, o) {
    var p = Ni();
    o = o === void 0 ? null : o;
    var g = p.memoizedState;
    if (o !== null && Wl(o, g[1])) return g[0];
    if (((g = r()), al)) {
      le(!0);
      try {
        r();
      } finally {
        le(!1);
      }
    }
    return (p.memoizedState = [g, o]), g;
  }
  function bh(r, o, p) {
    return p === void 0 || (uo & 1073741824) !== 0
      ? (r.memoizedState = o)
      : ((r.memoizedState = p), (r = Mr()), (xn.lanes |= r), (fs |= r), p);
  }
  function Gg(r, o, p, g) {
    return Qa(p, o)
      ? p
      : kl.current !== null
      ? ((r = bh(r, p, g)), Qa(r, o) || (ta = !0), r)
      : (uo & 42) === 0
      ? ((ta = !0), (r.memoizedState = p))
      : ((r = Mr()), (xn.lanes |= r), (fs |= r), o);
  }
  function zg(r, o, p, g, x) {
    var C = j.p;
    j.p = C !== 0 && 8 > C ? C : 8;
    var G = O.T,
      Q = {};
    (O.T = Q), tf(r, !1, o, p);
    try {
      var he = x(),
        Ce = O.S;
      if (
        (Ce !== null && Ce(Q, he),
        he !== null && typeof he == "object" && typeof he.then == "function")
      ) {
        var ct = nl(he, g);
        ql(r, o, ct, ka(r));
      } else ql(r, o, g, ka(r));
    } catch (xt) {
      ql(r, o, { then: function () {}, status: "rejected", reason: xt }, ka());
    } finally {
      (j.p = C), (O.T = G);
    }
  }
  function __() {}
  function vp(r, o, p, g) {
    if (r.tag !== 5) throw Error(n(476));
    var x = Hg(r).queue;
    zg(
      r,
      x,
      o,
      se,
      p === null
        ? __
        : function () {
            return Vg(r), p(g);
          }
    );
  }
  function Hg(r) {
    var o = r.memoizedState;
    if (o !== null) return o;
    o = {
      memoizedState: se,
      baseState: se,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ai,
        lastRenderedState: se,
      },
      next: null,
    };
    var p = {};
    return (
      (o.next = {
        memoizedState: p,
        baseState: p,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Ai,
          lastRenderedState: p,
        },
        next: null,
      }),
      (r.memoizedState = o),
      (r = r.alternate),
      r !== null && (r.memoizedState = o),
      o
    );
  }
  function Vg(r) {
    var o = Hg(r).next.queue;
    ql(r, o, {}, ka());
  }
  function Eh() {
    return Ta(Xp);
  }
  function yp() {
    return Ni().memoizedState;
  }
  function kg() {
    return Ni().memoizedState;
  }
  function Xg(r) {
    for (var o = r.return; o !== null; ) {
      switch (o.tag) {
        case 24:
        case 3:
          var p = ka();
          r = xr(p);
          var g = Sr(o, r, p);
          g !== null && (Ki(g, o, p), cl(g, o, p)),
            (o = { cache: lp() }),
            (r.payload = o);
          return;
      }
      o = o.return;
    }
  }
  function Yg(r, o, p) {
    var g = ka();
    (p = {
      lane: g,
      revertLane: 0,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      Th(r)
        ? Wg(o, p)
        : ((p = zl(r, o, p, g)), p !== null && (Ki(p, r, g), Jg(p, o, g)));
  }
  function _p(r, o, p) {
    var g = ka();
    ql(r, o, p, g);
  }
  function ql(r, o, p, g) {
    var x = {
      lane: g,
      revertLane: 0,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    };
    if (Th(r)) Wg(o, x);
    else {
      var C = r.alternate;
      if (
        r.lanes === 0 &&
        (C === null || C.lanes === 0) &&
        ((C = o.lastRenderedReducer), C !== null)
      )
        try {
          var G = o.lastRenderedState,
            Q = C(G, p);
          if (((x.hasEagerState = !0), (x.eagerState = Q), Qa(Q, G)))
            return Hc(r, o, x, 0), ti === null && zc(), !1;
        } catch {
        } finally {
        }
      if (((p = zl(r, o, x, g)), p !== null))
        return Ki(p, r, g), Jg(p, o, g), !0;
    }
    return !1;
  }
  function tf(r, o, p, g) {
    if (
      ((g = {
        lane: 2,
        revertLane: M_(),
        action: g,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      Th(r))
    ) {
      if (o) throw Error(n(479));
    } else (o = zl(r, p, g, 2)), o !== null && Ki(o, r, 2);
  }
  function Th(r) {
    var o = r.alternate;
    return r === xn || (o !== null && o === xn);
  }
  function Wg(r, o) {
    il = nn = !0;
    var p = r.pending;
    p === null ? (o.next = o) : ((o.next = p.next), (p.next = o)),
      (r.pending = o);
  }
  function Jg(r, o, p) {
    if ((p & 4194176) !== 0) {
      var g = o.lanes;
      (g &= r.pendingLanes), (p |= g), (o.lanes = p), ui(r, p);
    }
  }
  var Ts = {
    readContext: Ta,
    use: zu,
    useCallback: Ci,
    useContext: Ci,
    useEffect: Ci,
    useImperativeHandle: Ci,
    useLayoutEffect: Ci,
    useInsertionEffect: Ci,
    useMemo: Ci,
    useReducer: Ci,
    useRef: Ci,
    useState: Ci,
    useDebugValue: Ci,
    useDeferredValue: Ci,
    useTransition: Ci,
    useSyncExternalStore: Ci,
    useId: Ci,
  };
  (Ts.useCacheRefresh = Ci),
    (Ts.useMemoCache = Ci),
    (Ts.useHostTransitionStatus = Ci),
    (Ts.useFormState = Ci),
    (Ts.useActionState = Ci),
    (Ts.useOptimistic = Ci);
  var ol = {
    readContext: Ta,
    use: zu,
    useCallback: function (r, o) {
      return (ga().memoizedState = [r, o === void 0 ? null : o]), r;
    },
    useContext: Ta,
    useEffect: Ug,
    useImperativeHandle: function (r, o, p) {
      (p = p != null ? p.concat([r]) : null),
        Sh(4194308, 4, Ng.bind(null, o, r), p);
    },
    useLayoutEffect: function (r, o) {
      return Sh(4194308, 4, r, o);
    },
    useInsertionEffect: function (r, o) {
      Sh(4, 2, r, o);
    },
    useMemo: function (r, o) {
      var p = ga();
      o = o === void 0 ? null : o;
      var g = r();
      if (al) {
        le(!0);
        try {
          r();
        } finally {
          le(!1);
        }
      }
      return (p.memoizedState = [g, o]), g;
    },
    useReducer: function (r, o, p) {
      var g = ga();
      if (p !== void 0) {
        var x = p(o);
        if (al) {
          le(!0);
          try {
            p(o);
          } finally {
            le(!1);
          }
        }
      } else x = o;
      return (
        (g.memoizedState = g.baseState = x),
        (r = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: r,
          lastRenderedState: x,
        }),
        (g.queue = r),
        (r = r.dispatch = Yg.bind(null, xn, r)),
        [g.memoizedState, r]
      );
    },
    useRef: function (r) {
      var o = ga();
      return (r = { current: r }), (o.memoizedState = r);
    },
    useState: function (r) {
      r = hp(r);
      var o = r.queue,
        p = _p.bind(null, xn, o);
      return (o.dispatch = p), [r.memoizedState, p];
    },
    useDebugValue: gp,
    useDeferredValue: function (r, o) {
      var p = ga();
      return bh(p, r, o);
    },
    useTransition: function () {
      var r = hp(!1);
      return (
        (r = zg.bind(null, xn, r.queue, !0, !1)),
        (ga().memoizedState = r),
        [!1, r]
      );
    },
    useSyncExternalStore: function (r, o, p) {
      var g = xn,
        x = ga();
      if (Fn) {
        if (p === void 0) throw Error(n(407));
        p = p();
      } else {
        if (((p = o()), ti === null)) throw Error(n(349));
        (Zt & 60) !== 0 || Pa(g, o, p);
      }
      x.memoizedState = p;
      var C = { value: p, getSnapshot: o };
      return (
        (x.queue = C),
        Ug(Sg.bind(null, g, C, r), [r]),
        (g.flags |= 2048),
        Es(9, sl.bind(null, g, C, p, o), { destroy: void 0 }, null),
        p
      );
    },
    useId: function () {
      var r = ga(),
        o = ti.identifierPrefix;
      if (Fn) {
        var p = no,
          g = As;
        (p = (g & ~(1 << (32 - Be(g) - 1))).toString(32) + p),
          (o = ":" + o + "R" + p),
          (p = Pu++),
          0 < p && (o += "H" + p.toString(32)),
          (o += ":");
      } else (p = m_++), (o = ":" + o + "r" + p.toString(32) + ":");
      return (r.memoizedState = o);
    },
    useCacheRefresh: function () {
      return (ga().memoizedState = Xg.bind(null, xn));
    },
  };
  (ol.useMemoCache = is),
    (ol.useHostTransitionStatus = Eh),
    (ol.useFormState = Rg),
    (ol.useActionState = Rg),
    (ol.useOptimistic = function (r) {
      var o = ga();
      o.memoizedState = o.baseState = r;
      var p = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null,
      };
      return (
        (o.queue = p), (o = tf.bind(null, xn, !0, p)), (p.dispatch = o), [r, o]
      );
    });
  var fo = {
    readContext: Ta,
    use: zu,
    useCallback: Fg,
    useContext: Ta,
    useEffect: mp,
    useImperativeHandle: Ig,
    useInsertionEffect: Og,
    useLayoutEffect: Lg,
    useMemo: Pg,
    useReducer: as,
    useRef: Dg,
    useState: function () {
      return as(Ai);
    },
    useDebugValue: gp,
    useDeferredValue: function (r, o) {
      var p = Ni();
      return Gg(p, Qn.memoizedState, r, o);
    },
    useTransition: function () {
      var r = as(Ai)[0],
        o = Ni().memoizedState;
      return [typeof r == "boolean" ? r : ef(r), o];
    },
    useSyncExternalStore: xg,
    useId: yp,
  };
  (fo.useCacheRefresh = kg),
    (fo.useMemoCache = is),
    (fo.useHostTransitionStatus = Eh),
    (fo.useFormState = Hu),
    (fo.useActionState = Hu),
    (fo.useOptimistic = function (r, o) {
      var p = Ni();
      return dp(p, Qn, r, o);
    });
  var jl = {
    readContext: Ta,
    use: zu,
    useCallback: Fg,
    useContext: Ta,
    useEffect: mp,
    useImperativeHandle: Ig,
    useInsertionEffect: Og,
    useLayoutEffect: Lg,
    useMemo: Pg,
    useReducer: xh,
    useRef: Dg,
    useState: function () {
      return xh(Ai);
    },
    useDebugValue: gp,
    useDeferredValue: function (r, o) {
      var p = Ni();
      return Qn === null ? bh(p, r, o) : Gg(p, Qn.memoizedState, r, o);
    },
    useTransition: function () {
      var r = xh(Ai)[0],
        o = Ni().memoizedState;
      return [typeof r == "boolean" ? r : ef(r), o];
    },
    useSyncExternalStore: xg,
    useId: yp,
  };
  (jl.useCacheRefresh = kg),
    (jl.useMemoCache = is),
    (jl.useHostTransitionStatus = Eh),
    (jl.useFormState = Bg),
    (jl.useActionState = Bg),
    (jl.useOptimistic = function (r, o) {
      var p = Ni();
      return Qn !== null
        ? dp(p, Qn, r, o)
        : ((p.baseState = r), [r, p.queue.dispatch]);
    });
  function Ap(r, o, p, g) {
    (o = r.memoizedState),
      (p = p(g, o)),
      (p = p == null ? o : U({}, o, p)),
      (r.memoizedState = p),
      r.lanes === 0 && (r.updateQueue.baseState = p);
  }
  var xp = {
    isMounted: function (r) {
      return (r = r._reactInternals) ? oe(r) === r : !1;
    },
    enqueueSetState: function (r, o, p) {
      r = r._reactInternals;
      var g = ka(),
        x = xr(g);
      (x.payload = o),
        p != null && (x.callback = p),
        (o = Sr(r, x, g)),
        o !== null && (Ki(o, r, g), cl(o, r, g));
    },
    enqueueReplaceState: function (r, o, p) {
      r = r._reactInternals;
      var g = ka(),
        x = xr(g);
      (x.tag = 1),
        (x.payload = o),
        p != null && (x.callback = p),
        (o = Sr(r, x, g)),
        o !== null && (Ki(o, r, g), cl(o, r, g));
    },
    enqueueForceUpdate: function (r, o) {
      r = r._reactInternals;
      var p = ka(),
        g = xr(p);
      (g.tag = 2),
        o != null && (g.callback = o),
        (o = Sr(r, g, p)),
        o !== null && (Ki(o, r, p), cl(o, r, p));
    },
  };
  function qg(r, o, p, g, x, C, G) {
    return (
      (r = r.stateNode),
      typeof r.shouldComponentUpdate == "function"
        ? r.shouldComponentUpdate(g, C, G)
        : o.prototype && o.prototype.isPureReactComponent
        ? !ns(p, g) || !ns(x, C)
        : !0
    );
  }
  function jg(r, o, p, g) {
    (r = o.state),
      typeof o.componentWillReceiveProps == "function" &&
        o.componentWillReceiveProps(p, g),
      typeof o.UNSAFE_componentWillReceiveProps == "function" &&
        o.UNSAFE_componentWillReceiveProps(p, g),
      o.state !== r && xp.enqueueReplaceState(o, o.state, null);
  }
  function Kl(r, o) {
    var p = o;
    if ("ref" in o) {
      p = {};
      for (var g in o) g !== "ref" && (p[g] = o[g]);
    }
    if ((r = r.defaultProps)) {
      p === o && (p = U({}, p));
      for (var x in r) p[x] === void 0 && (p[x] = r[x]);
    }
    return p;
  }
  var Ch =
    typeof reportError == "function"
      ? reportError
      : function (r) {
          if (
            typeof window == "object" &&
            typeof window.ErrorEvent == "function"
          ) {
            var o = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof r == "object" &&
                r !== null &&
                typeof r.message == "string"
                  ? String(r.message)
                  : String(r),
              error: r,
            });
            if (!window.dispatchEvent(o)) return;
          } else if (
            typeof process == "object" &&
            typeof process.emit == "function"
          ) {
            process.emit("uncaughtException", r);
            return;
          }
          console.error(r);
        };
  function Kg(r) {
    Ch(r);
  }
  function Zg(r) {
    console.error(r);
  }
  function Qg(r) {
    Ch(r);
  }
  function Rh(r, o) {
    try {
      var p = r.onUncaughtError;
      p(o.value, { componentStack: o.stack });
    } catch (g) {
      setTimeout(function () {
        throw g;
      });
    }
  }
  function $g(r, o, p) {
    try {
      var g = r.onCaughtError;
      g(p.value, {
        componentStack: p.stack,
        errorBoundary: o.tag === 1 ? o.stateNode : null,
      });
    } catch (x) {
      setTimeout(function () {
        throw x;
      });
    }
  }
  function Sp(r, o, p) {
    return (
      (p = xr(p)),
      (p.tag = 3),
      (p.payload = { element: null }),
      (p.callback = function () {
        Rh(r, o);
      }),
      p
    );
  }
  function Mp(r) {
    return (r = xr(r)), (r.tag = 3), r;
  }
  function ev(r, o, p, g) {
    var x = p.type.getDerivedStateFromError;
    if (typeof x == "function") {
      var C = g.value;
      (r.payload = function () {
        return x(C);
      }),
        (r.callback = function () {
          $g(o, p, g);
        });
    }
    var G = p.stateNode;
    G !== null &&
      typeof G.componentDidCatch == "function" &&
      (r.callback = function () {
        $g(o, p, g),
          typeof x != "function" &&
            (ji === null ? (ji = new Set([this])) : ji.add(this));
        var Q = g.stack;
        this.componentDidCatch(g.value, {
          componentStack: Q !== null ? Q : "",
        });
      });
  }
  function A_(r, o, p, g, x) {
    if (
      ((p.flags |= 32768),
      g !== null && typeof g == "object" && typeof g.then == "function")
    ) {
      if (
        ((o = p.alternate),
        o !== null && af(o, p, x, !0),
        (p = nr.current),
        p !== null)
      ) {
        switch (p.tag) {
          case 13:
            return (
              Ss === null ? hf() : p.alternate === null && vi === 0 && (vi = 3),
              (p.flags &= -257),
              (p.flags |= 65536),
              (p.lanes = x),
              g === mh
                ? (p.flags |= 16384)
                : ((o = p.updateQueue),
                  o === null ? (p.updateQueue = new Set([g])) : o.add(g),
                  cn(r, g, x)),
              !1
            );
          case 22:
            return (
              (p.flags |= 65536),
              g === mh
                ? (p.flags |= 16384)
                : ((o = p.updateQueue),
                  o === null
                    ? ((o = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([g]),
                      }),
                      (p.updateQueue = o))
                    : ((p = o.retryQueue),
                      p === null ? (o.retryQueue = new Set([g])) : p.add(g)),
                  cn(r, g, x)),
              !1
            );
        }
        throw Error(n(435, p.tag));
      }
      return cn(r, g, x), hf(), !1;
    }
    if (Fn)
      return (
        (o = nr.current),
        o !== null
          ? ((o.flags & 65536) === 0 && (o.flags |= 256),
            (o.flags |= 65536),
            (o.lanes = x),
            g !== Wc && ((r = Error(n(422), { cause: g })), xs(tr(r, p))))
          : (g !== Wc && ((o = Error(n(423), { cause: g })), xs(tr(o, p))),
            (r = r.current.alternate),
            (r.flags |= 65536),
            (x &= -x),
            (r.lanes |= x),
            (g = tr(g, p)),
            (x = Sp(r.stateNode, g, x)),
            Wu(r, x),
            vi !== 4 && (vi = 2)),
        !1
      );
    var C = Error(n(520), { cause: g });
    if (
      ((C = tr(C, p)),
      ff === null ? (ff = [C]) : ff.push(C),
      vi !== 4 && (vi = 2),
      o === null)
    )
      return !0;
    (g = tr(g, p)), (p = o);
    do {
      switch (p.tag) {
        case 3:
          return (
            (p.flags |= 65536),
            (r = x & -x),
            (p.lanes |= r),
            (r = Sp(p.stateNode, g, r)),
            Wu(p, r),
            !1
          );
        case 1:
          if (
            ((o = p.type),
            (C = p.stateNode),
            (p.flags & 128) === 0 &&
              (typeof o.getDerivedStateFromError == "function" ||
                (C !== null &&
                  typeof C.componentDidCatch == "function" &&
                  (ji === null || !ji.has(C)))))
          )
            return (
              (p.flags |= 65536),
              (x &= -x),
              (p.lanes |= x),
              (x = Mp(x)),
              ev(x, r, p, g),
              Wu(p, x),
              !1
            );
      }
      p = p.return;
    } while (p !== null);
    return !1;
  }
  var _r = Error(n(461)),
    ta = !1;
  function na(r, o, p, g) {
    o.child = r === null ? ao(o, null, p, g) : io(o, r.child, p, g);
  }
  function bp(r, o, p, g, x) {
    p = p.render;
    var C = o.ref;
    if ("ref" in g) {
      var G = {};
      for (var Q in g) Q !== "ref" && (G[Q] = g[Q]);
    } else G = g;
    return (
      Ql(o),
      (g = cp(r, o, p, G, C, x)),
      (Q = fp()),
      r !== null && !ta
        ? ($c(r, o, x), Ii(r, o, x))
        : (Fn && Q && Yc(o), (o.flags |= 1), na(r, o, g, x), o.child)
    );
  }
  function Ep(r, o, p, g, x) {
    if (r === null) {
      var C = p.type;
      return typeof C == "function" &&
        !_o(C) &&
        C.defaultProps === void 0 &&
        p.compare === null
        ? ((o.tag = 15), (o.type = C), Tp(r, o, C, g, x))
        : ((r = Ku(p.type, null, g, o, o.mode, x)),
          (r.ref = o.ref),
          (r.return = o),
          (o.child = r));
    }
    if (((C = r.child), !Op(r, x))) {
      var G = C.memoizedProps;
      if (
        ((p = p.compare), (p = p !== null ? p : ns), p(G, g) && r.ref === o.ref)
      )
        return Ii(r, o, x);
    }
    return (
      (o.flags |= 1),
      (r = Ha(C, g)),
      (r.ref = o.ref),
      (r.return = o),
      (o.child = r)
    );
  }
  function Tp(r, o, p, g, x) {
    if (r !== null) {
      var C = r.memoizedProps;
      if (ns(C, g) && r.ref === o.ref)
        if (((ta = !1), (o.pendingProps = g = C), Op(r, x)))
          (r.flags & 131072) !== 0 && (ta = !0);
        else return (o.lanes = r.lanes), Ii(r, o, x);
    }
    return Rp(r, o, p, g, x);
  }
  function tv(r, o, p) {
    var g = o.pendingProps,
      x = g.children,
      C = (o.stateNode._pendingVisibility & 2) !== 0,
      G = r !== null ? r.memoizedState : null;
    if ((Vu(r, o), g.mode === "hidden" || C)) {
      if ((o.flags & 128) !== 0) {
        if (((g = G !== null ? G.baseLanes | p : p), r !== null)) {
          for (x = o.child = r.child, C = 0; x !== null; )
            (C = C | x.lanes | x.childLanes), (x = x.sibling);
          o.childLanes = C & ~g;
        } else (o.childLanes = 0), (o.child = null);
        return Cp(r, o, g, p);
      }
      if ((p & 536870912) !== 0)
        (o.memoizedState = { baseLanes: 0, cachePool: null }),
          r !== null && Fu(o, G !== null ? G.cachePool : null),
          G !== null ? Qo(o, G) : vh(),
          op(o);
      else
        return (
          (o.lanes = o.childLanes = 536870912),
          Cp(r, o, G !== null ? G.baseLanes | p : p, p)
        );
    } else
      G !== null
        ? (Fu(o, G.cachePool), Qo(o, G), so(), (o.memoizedState = null))
        : (r !== null && Fu(o, null), vh(), so());
    return na(r, o, x, p), o.child;
  }
  function Cp(r, o, p, g) {
    var x = Qc();
    return (
      (x = x === null ? null : { parent: Li._currentValue, pool: x }),
      (o.memoizedState = { baseLanes: p, cachePool: x }),
      r !== null && Fu(o, null),
      vh(),
      op(o),
      r !== null && af(r, o, g, !0),
      null
    );
  }
  function Vu(r, o) {
    var p = o.ref;
    if (p === null) r !== null && r.ref !== null && (o.flags |= 2097664);
    else {
      if (typeof p != "function" && typeof p != "object") throw Error(n(284));
      (r === null || r.ref !== p) && (o.flags |= 2097664);
    }
  }
  function Rp(r, o, p, g, x) {
    return (
      Ql(o),
      (p = cp(r, o, p, g, void 0, x)),
      (g = fp()),
      r !== null && !ta
        ? ($c(r, o, x), Ii(r, o, x))
        : (Fn && g && Yc(o), (o.flags |= 1), na(r, o, p, x), o.child)
    );
  }
  function nv(r, o, p, g, x, C) {
    return (
      Ql(o),
      (o.updateQueue = null),
      (p = Ag(o, g, p, x)),
      _g(r),
      (g = fp()),
      r !== null && !ta
        ? ($c(r, o, C), Ii(r, o, C))
        : (Fn && g && Yc(o), (o.flags |= 1), na(r, o, p, C), o.child)
    );
  }
  function iv(r, o, p, g, x) {
    if ((Ql(o), o.stateNode === null)) {
      var C = Wo,
        G = p.contextType;
      typeof G == "object" && G !== null && (C = Ta(G)),
        (C = new p(g, C)),
        (o.memoizedState =
          C.state !== null && C.state !== void 0 ? C.state : null),
        (C.updater = xp),
        (o.stateNode = C),
        (C._reactInternals = o),
        (C = o.stateNode),
        (C.props = g),
        (C.state = o.memoizedState),
        (C.refs = {}),
        Ga(o),
        (G = p.contextType),
        (C.context = typeof G == "object" && G !== null ? Ta(G) : Wo),
        (C.state = o.memoizedState),
        (G = p.getDerivedStateFromProps),
        typeof G == "function" && (Ap(o, p, G, g), (C.state = o.memoizedState)),
        typeof p.getDerivedStateFromProps == "function" ||
          typeof C.getSnapshotBeforeUpdate == "function" ||
          (typeof C.UNSAFE_componentWillMount != "function" &&
            typeof C.componentWillMount != "function") ||
          ((G = C.state),
          typeof C.componentWillMount == "function" && C.componentWillMount(),
          typeof C.UNSAFE_componentWillMount == "function" &&
            C.UNSAFE_componentWillMount(),
          G !== C.state && xp.enqueueReplaceState(C, C.state, null),
          ss(o, g, C, x),
          Ca(),
          (C.state = o.memoizedState)),
        typeof C.componentDidMount == "function" && (o.flags |= 4194308),
        (g = !0);
    } else if (r === null) {
      C = o.stateNode;
      var Q = o.memoizedProps,
        he = Kl(p, Q);
      C.props = he;
      var Ce = C.context,
        ct = p.contextType;
      (G = Wo), typeof ct == "object" && ct !== null && (G = Ta(ct));
      var xt = p.getDerivedStateFromProps;
      (ct =
        typeof xt == "function" ||
        typeof C.getSnapshotBeforeUpdate == "function"),
        (Q = o.pendingProps !== Q),
        ct ||
          (typeof C.UNSAFE_componentWillReceiveProps != "function" &&
            typeof C.componentWillReceiveProps != "function") ||
          ((Q || Ce !== G) && jg(o, C, g, G)),
        (Ji = !1);
      var ke = o.memoizedState;
      (C.state = ke),
        ss(o, g, C, x),
        Ca(),
        (Ce = o.memoizedState),
        Q || ke !== Ce || Ji
          ? (typeof xt == "function" &&
              (Ap(o, p, xt, g), (Ce = o.memoizedState)),
            (he = Ji || qg(o, p, he, g, ke, Ce, G))
              ? (ct ||
                  (typeof C.UNSAFE_componentWillMount != "function" &&
                    typeof C.componentWillMount != "function") ||
                  (typeof C.componentWillMount == "function" &&
                    C.componentWillMount(),
                  typeof C.UNSAFE_componentWillMount == "function" &&
                    C.UNSAFE_componentWillMount()),
                typeof C.componentDidMount == "function" &&
                  (o.flags |= 4194308))
              : (typeof C.componentDidMount == "function" &&
                  (o.flags |= 4194308),
                (o.memoizedProps = g),
                (o.memoizedState = Ce)),
            (C.props = g),
            (C.state = Ce),
            (C.context = G),
            (g = he))
          : (typeof C.componentDidMount == "function" && (o.flags |= 4194308),
            (g = !1));
    } else {
      (C = o.stateNode),
        Lh(r, o),
        (G = o.memoizedProps),
        (ct = Kl(p, G)),
        (C.props = ct),
        (xt = o.pendingProps),
        (ke = C.context),
        (Ce = p.contextType),
        (he = Wo),
        typeof Ce == "object" && Ce !== null && (he = Ta(Ce)),
        (Q = p.getDerivedStateFromProps),
        (Ce =
          typeof Q == "function" ||
          typeof C.getSnapshotBeforeUpdate == "function") ||
          (typeof C.UNSAFE_componentWillReceiveProps != "function" &&
            typeof C.componentWillReceiveProps != "function") ||
          ((G !== xt || ke !== he) && jg(o, C, g, he)),
        (Ji = !1),
        (ke = o.memoizedState),
        (C.state = ke),
        ss(o, g, C, x),
        Ca();
      var ot = o.memoizedState;
      G !== xt ||
      ke !== ot ||
      Ji ||
      (r !== null && r.dependencies !== null && Xu(r.dependencies))
        ? (typeof Q == "function" && (Ap(o, p, Q, g), (ot = o.memoizedState)),
          (ct =
            Ji ||
            qg(o, p, ct, g, ke, ot, he) ||
            (r !== null && r.dependencies !== null && Xu(r.dependencies)))
            ? (Ce ||
                (typeof C.UNSAFE_componentWillUpdate != "function" &&
                  typeof C.componentWillUpdate != "function") ||
                (typeof C.componentWillUpdate == "function" &&
                  C.componentWillUpdate(g, ot, he),
                typeof C.UNSAFE_componentWillUpdate == "function" &&
                  C.UNSAFE_componentWillUpdate(g, ot, he)),
              typeof C.componentDidUpdate == "function" && (o.flags |= 4),
              typeof C.getSnapshotBeforeUpdate == "function" &&
                (o.flags |= 1024))
            : (typeof C.componentDidUpdate != "function" ||
                (G === r.memoizedProps && ke === r.memoizedState) ||
                (o.flags |= 4),
              typeof C.getSnapshotBeforeUpdate != "function" ||
                (G === r.memoizedProps && ke === r.memoizedState) ||
                (o.flags |= 1024),
              (o.memoizedProps = g),
              (o.memoizedState = ot)),
          (C.props = g),
          (C.state = ot),
          (C.context = he),
          (g = ct))
        : (typeof C.componentDidUpdate != "function" ||
            (G === r.memoizedProps && ke === r.memoizedState) ||
            (o.flags |= 4),
          typeof C.getSnapshotBeforeUpdate != "function" ||
            (G === r.memoizedProps && ke === r.memoizedState) ||
            (o.flags |= 1024),
          (g = !1));
    }
    return (
      (C = g),
      Vu(r, o),
      (g = (o.flags & 128) !== 0),
      C || g
        ? ((C = o.stateNode),
          (p =
            g && typeof p.getDerivedStateFromError != "function"
              ? null
              : C.render()),
          (o.flags |= 1),
          r !== null && g
            ? ((o.child = io(o, r.child, null, x)),
              (o.child = io(o, null, p, x)))
            : na(r, o, p, x),
          (o.memoizedState = C.state),
          (r = o.child))
        : (r = Ii(r, o, x)),
      r
    );
  }
  function wp(r, o, p, g) {
    return Lu(), (o.flags |= 256), na(r, o, p, g), o.child;
  }
  var Bp = { dehydrated: null, treeContext: null, retryLane: 0 };
  function ua(r) {
    return { baseLanes: r, cachePool: lo() };
  }
  function wh(r, o, p) {
    return (r = r !== null ? r.childLanes & ~p : 0), o && (r |= Va), r;
  }
  function av(r, o, p) {
    var g = o.pendingProps,
      x = !1,
      C = (o.flags & 128) !== 0,
      G;
    if (
      ((G = C) ||
        (G =
          r !== null && r.memoizedState === null ? !1 : (Yi.current & 2) !== 0),
      G && ((x = !0), (o.flags &= -129)),
      (G = (o.flags & 32) !== 0),
      (o.flags &= -33),
      r === null)
    ) {
      if (Fn) {
        if ((x ? ro(o) : so(), Fn)) {
          var Q = la,
            he;
          if ((he = Q)) {
            e: {
              for (he = Q, Q = Ir; he.nodeType !== 8; ) {
                if (!Q) {
                  Q = null;
                  break e;
                }
                if (((he = bo(he.nextSibling)), he === null)) {
                  Q = null;
                  break e;
                }
              }
              Q = he;
            }
            Q !== null
              ? ((o.memoizedState = {
                  dehydrated: Q,
                  treeContext: to !== null ? { id: As, overflow: no } : null,
                  retryLane: 536870912,
                }),
                (he = zi(18, null, null, 0)),
                (he.stateNode = Q),
                (he.return = o),
                (o.child = he),
                (Ea = o),
                (la = null),
                (he = !0))
              : (he = !1);
          }
          he || Vl(o);
        }
        if (
          ((Q = o.memoizedState),
          Q !== null && ((Q = Q.dehydrated), Q !== null))
        )
          return Q.data === "$!" ? (o.lanes = 16) : (o.lanes = 536870912), null;
        Ms(o);
      }
      return (
        (Q = g.children),
        (g = g.fallback),
        x
          ? (so(),
            (x = o.mode),
            (Q = Up({ mode: "hidden", children: Q }, x)),
            (g = gl(g, x, p, null)),
            (Q.return = o),
            (g.return = o),
            (Q.sibling = g),
            (o.child = Q),
            (x = o.child),
            (x.memoizedState = ua(p)),
            (x.childLanes = wh(r, G, p)),
            (o.memoizedState = Bp),
            g)
          : (ro(o), Dp(o, Q))
      );
    }
    if (
      ((he = r.memoizedState), he !== null && ((Q = he.dehydrated), Q !== null))
    ) {
      if (C)
        o.flags & 256
          ? (ro(o), (o.flags &= -257), (o = Bh(r, o, p)))
          : o.memoizedState !== null
          ? (so(), (o.child = r.child), (o.flags |= 128), (o = null))
          : (so(),
            (x = g.fallback),
            (Q = o.mode),
            (g = Up({ mode: "visible", children: g.children }, Q)),
            (x = gl(x, Q, p, null)),
            (x.flags |= 2),
            (g.return = o),
            (x.return = o),
            (g.sibling = x),
            (o.child = g),
            io(o, r.child, null, p),
            (g = o.child),
            (g.memoizedState = ua(p)),
            (g.childLanes = wh(r, G, p)),
            (o.memoizedState = Bp),
            (o = x));
      else if ((ro(o), Q.data === "$!")) {
        if (((G = Q.nextSibling && Q.nextSibling.dataset), G)) var Ce = G.dgst;
        (G = Ce),
          (g = Error(n(419))),
          (g.stack = ""),
          (g.digest = G),
          xs({ value: g, source: null, stack: null }),
          (o = Bh(r, o, p));
      } else if (
        (ta || af(r, o, p, !1), (G = (p & r.childLanes) !== 0), ta || G)
      ) {
        if (((G = ti), G !== null)) {
          if (((g = p & -p), (g & 42) !== 0)) g = 1;
          else
            switch (g) {
              case 2:
                g = 1;
                break;
              case 8:
                g = 4;
                break;
              case 32:
                g = 16;
                break;
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                g = 64;
                break;
              case 268435456:
                g = 134217728;
                break;
              default:
                g = 0;
            }
          if (
            ((g = (g & (G.suspendedLanes | p)) !== 0 ? 0 : g),
            g !== 0 && g !== he.retryLane)
          )
            throw ((he.retryLane = g), eo(r, g), Ki(G, r, g), _r);
        }
        Q.data === "$?" || hf(), (o = Bh(r, o, p));
      } else
        Q.data === "$?"
          ? ((o.flags |= 128),
            (o.child = r.child),
            (o = ru.bind(null, r)),
            (Q._reactRetry = o),
            (o = null))
          : ((r = he.treeContext),
            (la = bo(Q.nextSibling)),
            (Ea = o),
            (Fn = !0),
            (Nr = null),
            (Ir = !1),
            r !== null &&
              ((ci[vr++] = As),
              (ci[vr++] = no),
              (ci[vr++] = to),
              (As = r.id),
              (no = r.overflow),
              (to = o)),
            (o = Dp(o, g.children)),
            (o.flags |= 4096));
      return o;
    }
    return x
      ? (so(),
        (x = g.fallback),
        (Q = o.mode),
        (he = r.child),
        (Ce = he.sibling),
        (g = Ha(he, { mode: "hidden", children: g.children })),
        (g.subtreeFlags = he.subtreeFlags & 31457280),
        Ce !== null
          ? (x = Ha(Ce, x))
          : ((x = gl(x, Q, p, null)), (x.flags |= 2)),
        (x.return = o),
        (g.return = o),
        (g.sibling = x),
        (o.child = g),
        (g = x),
        (x = o.child),
        (Q = r.child.memoizedState),
        Q === null
          ? (Q = ua(p))
          : ((he = Q.cachePool),
            he !== null
              ? ((Ce = Li._currentValue),
                (he = he.parent !== Ce ? { parent: Ce, pool: Ce } : he))
              : (he = lo()),
            (Q = { baseLanes: Q.baseLanes | p, cachePool: he })),
        (x.memoizedState = Q),
        (x.childLanes = wh(r, G, p)),
        (o.memoizedState = Bp),
        g)
      : (ro(o),
        (p = r.child),
        (r = p.sibling),
        (p = Ha(p, { mode: "visible", children: g.children })),
        (p.return = o),
        (p.sibling = null),
        r !== null &&
          ((G = o.deletions),
          G === null ? ((o.deletions = [r]), (o.flags |= 16)) : G.push(r)),
        (o.child = p),
        (o.memoizedState = null),
        p);
  }
  function Dp(r, o) {
    return (
      (o = Up({ mode: "visible", children: o }, r.mode)),
      (o.return = r),
      (r.child = o)
    );
  }
  function Up(r, o) {
    return Np(r, o, 0, null);
  }
  function Bh(r, o, p) {
    return (
      io(o, r.child, null, p),
      (r = Dp(o, o.pendingProps.children)),
      (r.flags |= 2),
      (o.memoizedState = null),
      r
    );
  }
  function Dh(r, o, p) {
    r.lanes |= o;
    var g = r.alternate;
    g !== null && (g.lanes |= o), Ar(r.return, o, p);
  }
  function ll(r, o, p, g, x) {
    var C = r.memoizedState;
    C === null
      ? (r.memoizedState = {
          isBackwards: o,
          rendering: null,
          renderingStartTime: 0,
          last: g,
          tail: p,
          tailMode: x,
        })
      : ((C.isBackwards = o),
        (C.rendering = null),
        (C.renderingStartTime = 0),
        (C.last = g),
        (C.tail = p),
        (C.tailMode = x));
  }
  function Zl(r, o, p) {
    var g = o.pendingProps,
      x = g.revealOrder,
      C = g.tail;
    if ((na(r, o, g.children, p), (g = Yi.current), (g & 2) !== 0))
      (g = (g & 1) | 2), (o.flags |= 128);
    else {
      if (r !== null && (r.flags & 128) !== 0)
        e: for (r = o.child; r !== null; ) {
          if (r.tag === 13) r.memoizedState !== null && Dh(r, p, o);
          else if (r.tag === 19) Dh(r, p, o);
          else if (r.child !== null) {
            (r.child.return = r), (r = r.child);
            continue;
          }
          if (r === o) break e;
          for (; r.sibling === null; ) {
            if (r.return === null || r.return === o) break e;
            r = r.return;
          }
          (r.sibling.return = r.return), (r = r.sibling);
        }
      g &= 1;
    }
    switch ((We(Yi, g), x)) {
      case "forwards":
        for (p = o.child, x = null; p !== null; )
          (r = p.alternate),
            r !== null && Iu(r) === null && (x = p),
            (p = p.sibling);
        (p = x),
          p === null
            ? ((x = o.child), (o.child = null))
            : ((x = p.sibling), (p.sibling = null)),
          ll(o, !1, x, p, C);
        break;
      case "backwards":
        for (p = null, x = o.child, o.child = null; x !== null; ) {
          if (((r = x.alternate), r !== null && Iu(r) === null)) {
            o.child = x;
            break;
          }
          (r = x.sibling), (x.sibling = p), (p = x), (x = r);
        }
        ll(o, !0, p, null, C);
        break;
      case "together":
        ll(o, !1, null, null, void 0);
        break;
      default:
        o.memoizedState = null;
    }
    return o.child;
  }
  function Ii(r, o, p) {
    if (
      (r !== null && (o.dependencies = r.dependencies),
      (fs |= o.lanes),
      (p & o.childLanes) === 0)
    )
      if (r !== null) {
        if ((af(r, o, p, !1), (p & o.childLanes) === 0)) return null;
      } else return null;
    if (r !== null && o.child !== r.child) throw Error(n(153));
    if (o.child !== null) {
      for (
        r = o.child, p = Ha(r, r.pendingProps), o.child = p, p.return = o;
        r.sibling !== null;

      )
        (r = r.sibling),
          (p = p.sibling = Ha(r, r.pendingProps)),
          (p.return = o);
      p.sibling = null;
    }
    return o.child;
  }
  function Op(r, o) {
    return (r.lanes & o) !== 0
      ? !0
      : ((r = r.dependencies), !!(r !== null && Xu(r)));
  }
  function x_(r, o, p) {
    switch (o.tag) {
      case 3:
        ft(o, o.stateNode.containerInfo),
          ul(o, Li, r.memoizedState.cache),
          Lu();
        break;
      case 27:
      case 5:
        rt(o);
        break;
      case 4:
        ft(o, o.stateNode.containerInfo);
        break;
      case 10:
        ul(o, o.type, o.memoizedProps.value);
        break;
      case 13:
        var g = o.memoizedState;
        if (g !== null)
          return g.dehydrated !== null
            ? (ro(o), (o.flags |= 128), null)
            : (p & o.child.childLanes) !== 0
            ? av(r, o, p)
            : (ro(o), (r = Ii(r, o, p)), r !== null ? r.sibling : null);
        ro(o);
        break;
      case 19:
        var x = (r.flags & 128) !== 0;
        if (
          ((g = (p & o.childLanes) !== 0),
          g || (af(r, o, p, !1), (g = (p & o.childLanes) !== 0)),
          x)
        ) {
          if (g) return Zl(r, o, p);
          o.flags |= 128;
        }
        if (
          ((x = o.memoizedState),
          x !== null &&
            ((x.rendering = null), (x.tail = null), (x.lastEffect = null)),
          We(Yi, Yi.current),
          g)
        )
          break;
        return null;
      case 22:
      case 23:
        return (o.lanes = 0), tv(r, o, p);
      case 24:
        ul(o, Li, r.memoizedState.cache);
    }
    return Ii(r, o, p);
  }
  function nf(r, o, p) {
    if (r !== null)
      if (r.memoizedProps !== o.pendingProps) ta = !0;
      else {
        if (!Op(r, p) && (o.flags & 128) === 0) return (ta = !1), x_(r, o, p);
        ta = (r.flags & 131072) !== 0;
      }
    else (ta = !1), Fn && (o.flags & 1048576) !== 0 && rp(o, Xc, o.index);
    switch (((o.lanes = 0), o.tag)) {
      case 16:
        e: {
          r = o.pendingProps;
          var g = o.elementType,
            x = g._init;
          if (((g = x(g._payload)), (o.type = g), typeof g == "function"))
            _o(g)
              ? ((r = Kl(g, r)), (o.tag = 1), (o = iv(null, o, g, r, p)))
              : ((o.tag = 0), (o = Rp(null, o, g, r, p)));
          else {
            if (g != null) {
              if (((x = g.$$typeof), x === M)) {
                (o.tag = 11), (o = bp(null, o, g, r, p));
                break e;
              } else if (x === b) {
                (o.tag = 14), (o = Ep(null, o, g, r, p));
                break e;
              }
            }
            throw ((o = F(g) || g), Error(n(306, o, "")));
          }
        }
        return o;
      case 0:
        return Rp(r, o, o.type, o.pendingProps, p);
      case 1:
        return (g = o.type), (x = Kl(g, o.pendingProps)), iv(r, o, g, x, p);
      case 3:
        e: {
          if ((ft(o, o.stateNode.containerInfo), r === null))
            throw Error(n(387));
          var C = o.pendingProps;
          (x = o.memoizedState), (g = x.element), Lh(r, o), ss(o, C, null, p);
          var G = o.memoizedState;
          if (
            ((C = G.cache),
            ul(o, Li, C),
            C !== x.cache && Uh(o, [Li], p, !0),
            Ca(),
            (C = G.element),
            x.isDehydrated)
          )
            if (
              ((x = { element: C, isDehydrated: !1, cache: G.cache }),
              (o.updateQueue.baseState = x),
              (o.memoizedState = x),
              o.flags & 256)
            ) {
              o = wp(r, o, C, p);
              break e;
            } else if (C !== g) {
              (g = tr(Error(n(424)), o)), xs(g), (o = wp(r, o, C, p));
              break e;
            } else
              for (
                la = bo(o.stateNode.containerInfo.firstChild),
                  Ea = o,
                  Fn = !0,
                  Nr = null,
                  Ir = !0,
                  p = ao(o, null, C, p),
                  o.child = p;
                p;

              )
                (p.flags = (p.flags & -3) | 4096), (p = p.sibling);
          else {
            if ((Lu(), C === g)) {
              o = Ii(r, o, p);
              break e;
            }
            na(r, o, C, p);
          }
          o = o.child;
        }
        return o;
      case 26:
        return (
          Vu(r, o),
          r === null
            ? (p = pS(o.type, null, o.pendingProps, null))
              ? (o.memoizedState = p)
              : Fn ||
                ((p = o.type),
                (r = o.pendingProps),
                (g = fv(Ie.current).createElement(p)),
                (g[pn] = o),
                (g[en] = r),
                Xa(g, p, r),
                ne(g),
                (o.stateNode = g))
            : (o.memoizedState = pS(
                o.type,
                r.memoizedProps,
                o.pendingProps,
                r.memoizedState
              )),
          null
        );
      case 27:
        return (
          rt(o),
          r === null &&
            Fn &&
            ((g = o.stateNode = fS(o.type, o.pendingProps, Ie.current)),
            (Ea = o),
            (Ir = !0),
            (la = bo(g.firstChild))),
          (g = o.pendingProps.children),
          r !== null || Fn ? na(r, o, g, p) : (o.child = io(o, null, g, p)),
          Vu(r, o),
          o.child
        );
      case 5:
        return (
          r === null &&
            Fn &&
            ((x = g = la) &&
              ((g = fC(g, o.type, o.pendingProps, Ir)),
              g !== null
                ? ((o.stateNode = g),
                  (Ea = o),
                  (la = bo(g.firstChild)),
                  (Ir = !1),
                  (x = !0))
                : (x = !1)),
            x || Vl(o)),
          rt(o),
          (x = o.type),
          (C = o.pendingProps),
          (G = r !== null ? r.memoizedProps : null),
          (g = C.children),
          U_(x, C) ? (g = null) : G !== null && U_(x, G) && (o.flags |= 32),
          o.memoizedState !== null &&
            ((x = cp(r, o, g_, null, null, p)), (Xp._currentValue = x)),
          Vu(r, o),
          na(r, o, g, p),
          o.child
        );
      case 6:
        return (
          r === null &&
            Fn &&
            ((r = p = la) &&
              ((p = hC(p, o.pendingProps, Ir)),
              p !== null
                ? ((o.stateNode = p), (Ea = o), (la = null), (r = !0))
                : (r = !1)),
            r || Vl(o)),
          null
        );
      case 13:
        return av(r, o, p);
      case 4:
        return (
          ft(o, o.stateNode.containerInfo),
          (g = o.pendingProps),
          r === null ? (o.child = io(o, null, g, p)) : na(r, o, g, p),
          o.child
        );
      case 11:
        return bp(r, o, o.type, o.pendingProps, p);
      case 7:
        return na(r, o, o.pendingProps, p), o.child;
      case 8:
        return na(r, o, o.pendingProps.children, p), o.child;
      case 12:
        return na(r, o, o.pendingProps.children, p), o.child;
      case 10:
        return (
          (g = o.pendingProps),
          ul(o, o.type, g.value),
          na(r, o, g.children, p),
          o.child
        );
      case 9:
        return (
          (x = o.type._context),
          (g = o.pendingProps.children),
          Ql(o),
          (x = Ta(x)),
          (g = g(x)),
          (o.flags |= 1),
          na(r, o, g, p),
          o.child
        );
      case 14:
        return Ep(r, o, o.type, o.pendingProps, p);
      case 15:
        return Tp(r, o, o.type, o.pendingProps, p);
      case 19:
        return Zl(r, o, p);
      case 22:
        return tv(r, o, p);
      case 24:
        return (
          Ql(o),
          (g = Ta(Li)),
          r === null
            ? ((x = Qc()),
              x === null &&
                ((x = ti),
                (C = lp()),
                (x.pooledCache = C),
                C.refCount++,
                C !== null && (x.pooledCacheLanes |= p),
                (x = C)),
              (o.memoizedState = { parent: g, cache: x }),
              Ga(o),
              ul(o, Li, x))
            : ((r.lanes & p) !== 0 && (Lh(r, o), ss(o, null, null, p), Ca()),
              (x = r.memoizedState),
              (C = o.memoizedState),
              x.parent !== g
                ? ((x = { parent: g, cache: g }),
                  (o.memoizedState = x),
                  o.lanes === 0 &&
                    (o.memoizedState = o.updateQueue.baseState = x),
                  ul(o, Li, g))
                : ((g = C.cache),
                  ul(o, Li, g),
                  g !== x.cache && Uh(o, [Li], p, !0))),
          na(r, o, o.pendingProps.children, p),
          o.child
        );
      case 29:
        throw o.pendingProps;
    }
    throw Error(n(156, o.tag));
  }
  var ku = be(null),
    Cs = null,
    rs = null;
  function ul(r, o, p) {
    We(ku, o._currentValue), (o._currentValue = p);
  }
  function ho(r) {
    (r._currentValue = ku.current), it(ku);
  }
  function Ar(r, o, p) {
    for (; r !== null; ) {
      var g = r.alternate;
      if (
        ((r.childLanes & o) !== o
          ? ((r.childLanes |= o), g !== null && (g.childLanes |= o))
          : g !== null && (g.childLanes & o) !== o && (g.childLanes |= o),
        r === p)
      )
        break;
      r = r.return;
    }
  }
  function Uh(r, o, p, g) {
    var x = r.child;
    for (x !== null && (x.return = r); x !== null; ) {
      var C = x.dependencies;
      if (C !== null) {
        var G = x.child;
        C = C.firstContext;
        e: for (; C !== null; ) {
          var Q = C;
          C = x;
          for (var he = 0; he < o.length; he++)
            if (Q.context === o[he]) {
              (C.lanes |= p),
                (Q = C.alternate),
                Q !== null && (Q.lanes |= p),
                Ar(C.return, p, r),
                g || (G = null);
              break e;
            }
          C = Q.next;
        }
      } else if (x.tag === 18) {
        if (((G = x.return), G === null)) throw Error(n(341));
        (G.lanes |= p),
          (C = G.alternate),
          C !== null && (C.lanes |= p),
          Ar(G, p, r),
          (G = null);
      } else G = x.child;
      if (G !== null) G.return = x;
      else
        for (G = x; G !== null; ) {
          if (G === r) {
            G = null;
            break;
          }
          if (((x = G.sibling), x !== null)) {
            (x.return = G.return), (G = x);
            break;
          }
          G = G.return;
        }
      x = G;
    }
  }
  function af(r, o, p, g) {
    r = null;
    for (var x = o, C = !1; x !== null; ) {
      if (!C) {
        if ((x.flags & 524288) !== 0) C = !0;
        else if ((x.flags & 262144) !== 0) break;
      }
      if (x.tag === 10) {
        var G = x.alternate;
        if (G === null) throw Error(n(387));
        if (((G = G.memoizedProps), G !== null)) {
          var Q = x.type;
          Qa(x.pendingProps.value, G.value) ||
            (r !== null ? r.push(Q) : (r = [Q]));
        }
      } else if (x === $.current) {
        if (((G = x.alternate), G === null)) throw Error(n(387));
        G.memoizedState.memoizedState !== x.memoizedState.memoizedState &&
          (r !== null ? r.push(Xp) : (r = [Xp]));
      }
      x = x.return;
    }
    r !== null && Uh(o, r, p, g), (o.flags |= 262144);
  }
  function Xu(r) {
    for (r = r.firstContext; r !== null; ) {
      if (!Qa(r.context._currentValue, r.memoizedValue)) return !0;
      r = r.next;
    }
    return !1;
  }
  function Ql(r) {
    (Cs = r),
      (rs = null),
      (r = r.dependencies),
      r !== null && (r.firstContext = null);
  }
  function Ta(r) {
    return Yu(Cs, r);
  }
  function Oh(r, o) {
    return Cs === null && Ql(r), Yu(r, o);
  }
  function Yu(r, o) {
    var p = o._currentValue;
    if (((o = { context: o, memoizedValue: p, next: null }), rs === null)) {
      if (r === null) throw Error(n(308));
      (rs = o),
        (r.dependencies = { lanes: 0, firstContext: o }),
        (r.flags |= 524288);
    } else rs = rs.next = o;
    return p;
  }
  var Ji = !1;
  function Ga(r) {
    r.updateQueue = {
      baseState: r.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null,
    };
  }
  function Lh(r, o) {
    (r = r.updateQueue),
      o.updateQueue === r &&
        (o.updateQueue = {
          baseState: r.baseState,
          firstBaseUpdate: r.firstBaseUpdate,
          lastBaseUpdate: r.lastBaseUpdate,
          shared: r.shared,
          callbacks: null,
        });
  }
  function xr(r) {
    return { lane: r, tag: 0, payload: null, callback: null, next: null };
  }
  function Sr(r, o, p) {
    var g = r.updateQueue;
    if (g === null) return null;
    if (((g = g.shared), (un & 2) !== 0)) {
      var x = g.pending;
      return (
        x === null ? (o.next = o) : ((o.next = x.next), (x.next = o)),
        (g.pending = o),
        (o = kc(r)),
        Vc(r, null, p),
        o
      );
    }
    return Hc(r, g, o, p), kc(r);
  }
  function cl(r, o, p) {
    if (
      ((o = o.updateQueue), o !== null && ((o = o.shared), (p & 4194176) !== 0))
    ) {
      var g = o.lanes;
      (g &= r.pendingLanes), (p |= g), (o.lanes = p), ui(r, p);
    }
  }
  function Wu(r, o) {
    var p = r.updateQueue,
      g = r.alternate;
    if (g !== null && ((g = g.updateQueue), p === g)) {
      var x = null,
        C = null;
      if (((p = p.firstBaseUpdate), p !== null)) {
        do {
          var G = {
            lane: p.lane,
            tag: p.tag,
            payload: p.payload,
            callback: null,
            next: null,
          };
          C === null ? (x = C = G) : (C = C.next = G), (p = p.next);
        } while (p !== null);
        C === null ? (x = C = o) : (C = C.next = o);
      } else x = C = o;
      (p = {
        baseState: g.baseState,
        firstBaseUpdate: x,
        lastBaseUpdate: C,
        shared: g.shared,
        callbacks: g.callbacks,
      }),
        (r.updateQueue = p);
      return;
    }
    (r = p.lastBaseUpdate),
      r === null ? (p.firstBaseUpdate = o) : (r.next = o),
      (p.lastBaseUpdate = o);
  }
  var ar = !1;
  function Ca() {
    if (ar) {
      var r = tl;
      if (r !== null) throw r;
    }
  }
  function ss(r, o, p, g) {
    ar = !1;
    var x = r.updateQueue;
    Ji = !1;
    var C = x.firstBaseUpdate,
      G = x.lastBaseUpdate,
      Q = x.shared.pending;
    if (Q !== null) {
      x.shared.pending = null;
      var he = Q,
        Ce = he.next;
      (he.next = null), G === null ? (C = Ce) : (G.next = Ce), (G = he);
      var ct = r.alternate;
      ct !== null &&
        ((ct = ct.updateQueue),
        (Q = ct.lastBaseUpdate),
        Q !== G &&
          (Q === null ? (ct.firstBaseUpdate = Ce) : (Q.next = Ce),
          (ct.lastBaseUpdate = he)));
    }
    if (C !== null) {
      var xt = x.baseState;
      (G = 0), (ct = Ce = he = null), (Q = C);
      do {
        var ke = Q.lane & -536870913,
          ot = ke !== Q.lane;
        if (ot ? (Zt & ke) === ke : (g & ke) === ke) {
          ke !== 0 && ke === Yl && (ar = !0),
            ct !== null &&
              (ct = ct.next =
                {
                  lane: 0,
                  tag: Q.tag,
                  payload: Q.payload,
                  callback: null,
                  next: null,
                });
          e: {
            var Jt = r,
              fn = Q;
            ke = o;
            var Zi = p;
            switch (fn.tag) {
              case 1:
                if (((Jt = fn.payload), typeof Jt == "function")) {
                  xt = Jt.call(Zi, xt, ke);
                  break e;
                }
                xt = Jt;
                break e;
              case 3:
                Jt.flags = (Jt.flags & -65537) | 128;
              case 0:
                if (
                  ((Jt = fn.payload),
                  (ke = typeof Jt == "function" ? Jt.call(Zi, xt, ke) : Jt),
                  ke == null)
                )
                  break e;
                xt = U({}, xt, ke);
                break e;
              case 2:
                Ji = !0;
            }
          }
          (ke = Q.callback),
            ke !== null &&
              ((r.flags |= 64),
              ot && (r.flags |= 8192),
              (ot = x.callbacks),
              ot === null ? (x.callbacks = [ke]) : ot.push(ke));
        } else
          (ot = {
            lane: ke,
            tag: Q.tag,
            payload: Q.payload,
            callback: Q.callback,
            next: null,
          }),
            ct === null ? ((Ce = ct = ot), (he = xt)) : (ct = ct.next = ot),
            (G |= ke);
        if (((Q = Q.next), Q === null)) {
          if (((Q = x.shared.pending), Q === null)) break;
          (ot = Q),
            (Q = ot.next),
            (ot.next = null),
            (x.lastBaseUpdate = ot),
            (x.shared.pending = null);
        }
      } while (!0);
      ct === null && (he = xt),
        (x.baseState = he),
        (x.firstBaseUpdate = Ce),
        (x.lastBaseUpdate = ct),
        C === null && (x.shared.lanes = 0),
        (fs |= G),
        (r.lanes = G),
        (r.memoizedState = xt);
    }
  }
  function Rs(r, o) {
    if (typeof r != "function") throw Error(n(191, r));
    r.call(o);
  }
  function ws(r, o) {
    var p = r.callbacks;
    if (p !== null)
      for (r.callbacks = null, r = 0; r < p.length; r++) Rs(p[r], o);
  }
  function Fi(r, o) {
    try {
      var p = o.updateQueue,
        g = p !== null ? p.lastEffect : null;
      if (g !== null) {
        var x = g.next;
        p = x;
        do {
          if ((p.tag & r) === r) {
            g = void 0;
            var C = p.create,
              G = p.inst;
            (g = C()), (G.destroy = g);
          }
          p = p.next;
        } while (p !== x);
      }
    } catch (Q) {
      bt(o, o.return, Q);
    }
  }
  function Fr(r, o, p) {
    try {
      var g = o.updateQueue,
        x = g !== null ? g.lastEffect : null;
      if (x !== null) {
        var C = x.next;
        g = C;
        do {
          if ((g.tag & r) === r) {
            var G = g.inst,
              Q = G.destroy;
            if (Q !== void 0) {
              (G.destroy = void 0), (x = o);
              var he = p;
              try {
                Q();
              } catch (Ce) {
                bt(x, he, Ce);
              }
            }
          }
          g = g.next;
        } while (g !== C);
      }
    } catch (Ce) {
      bt(o, o.return, Ce);
    }
  }
  function po(r) {
    var o = r.updateQueue;
    if (o !== null) {
      var p = r.stateNode;
      try {
        ws(o, p);
      } catch (g) {
        bt(r, r.return, g);
      }
    }
  }
  function rf(r, o, p) {
    (p.props = Kl(r.type, r.memoizedProps)), (p.state = r.memoizedState);
    try {
      p.componentWillUnmount();
    } catch (g) {
      bt(r, o, g);
    }
  }
  function Pi(r, o) {
    try {
      var p = r.ref;
      if (p !== null) {
        var g = r.stateNode;
        switch (r.tag) {
          case 26:
          case 27:
          case 5:
            var x = g;
            break;
          default:
            x = g;
        }
        typeof p == "function" ? (r.refCleanup = p(x)) : (p.current = x);
      }
    } catch (C) {
      bt(r, o, C);
    }
  }
  function ei(r, o) {
    var p = r.ref,
      g = r.refCleanup;
    if (p !== null)
      if (typeof g == "function")
        try {
          g();
        } catch (x) {
          bt(r, o, x);
        } finally {
          (r.refCleanup = null),
            (r = r.alternate),
            r != null && (r.refCleanup = null);
        }
      else if (typeof p == "function")
        try {
          p(null);
        } catch (x) {
          bt(r, o, x);
        }
      else p.current = null;
  }
  function Pn(r) {
    var o = r.type,
      p = r.memoizedProps,
      g = r.stateNode;
    try {
      e: switch (o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          p.autoFocus && g.focus();
          break e;
        case "img":
          p.src ? (g.src = p.src) : p.srcSet && (g.srcset = p.srcSet);
      }
    } catch (x) {
      bt(r, r.return, x);
    }
  }
  function Pr(r, o, p) {
    try {
      var g = r.stateNode;
      sC(g, r.type, p, o), (g[en] = o);
    } catch (x) {
      bt(r, r.return, x);
    }
  }
  function os(r) {
    return (
      r.tag === 5 || r.tag === 3 || r.tag === 26 || r.tag === 27 || r.tag === 4
    );
  }
  function sf(r) {
    e: for (;;) {
      for (; r.sibling === null; ) {
        if (r.return === null || os(r.return)) return null;
        r = r.return;
      }
      for (
        r.sibling.return = r.return, r = r.sibling;
        r.tag !== 5 && r.tag !== 6 && r.tag !== 27 && r.tag !== 18;

      ) {
        if (r.flags & 2 || r.child === null || r.tag === 4) continue e;
        (r.child.return = r), (r = r.child);
      }
      if (!(r.flags & 2)) return r.stateNode;
    }
  }
  function rr(r, o, p) {
    var g = r.tag;
    if (g === 5 || g === 6)
      (r = r.stateNode),
        o
          ? p.nodeType === 8
            ? p.parentNode.insertBefore(r, o)
            : p.insertBefore(r, o)
          : (p.nodeType === 8
              ? ((o = p.parentNode), o.insertBefore(r, p))
              : ((o = p), o.appendChild(r)),
            (p = p._reactRootContainer),
            p != null || o.onclick !== null || (o.onclick = cv));
    else if (g !== 4 && g !== 27 && ((r = r.child), r !== null))
      for (rr(r, o, p), r = r.sibling; r !== null; )
        rr(r, o, p), (r = r.sibling);
  }
  function mo(r, o, p) {
    var g = r.tag;
    if (g === 5 || g === 6)
      (r = r.stateNode), o ? p.insertBefore(r, o) : p.appendChild(r);
    else if (g !== 4 && g !== 27 && ((r = r.child), r !== null))
      for (mo(r, o, p), r = r.sibling; r !== null; )
        mo(r, o, p), (r = r.sibling);
  }
  var ls = !1,
    mi = !1,
    fl = !1,
    Nh = typeof WeakSet == "function" ? WeakSet : Set,
    Gi = null,
    Ih = !1;
  function Ju(r, o) {
    if (((r = r.containerInfo), (B_ = vv), (r = $d(r)), Gc(r))) {
      if ("selectionStart" in r)
        var p = { start: r.selectionStart, end: r.selectionEnd };
      else
        e: {
          p = ((p = r.ownerDocument) && p.defaultView) || window;
          var g = p.getSelection && p.getSelection();
          if (g && g.rangeCount !== 0) {
            p = g.anchorNode;
            var x = g.anchorOffset,
              C = g.focusNode;
            g = g.focusOffset;
            try {
              p.nodeType, C.nodeType;
            } catch {
              p = null;
              break e;
            }
            var G = 0,
              Q = -1,
              he = -1,
              Ce = 0,
              ct = 0,
              xt = r,
              ke = null;
            t: for (;;) {
              for (
                var ot;
                xt !== p || (x !== 0 && xt.nodeType !== 3) || (Q = G + x),
                  xt !== C || (g !== 0 && xt.nodeType !== 3) || (he = G + g),
                  xt.nodeType === 3 && (G += xt.nodeValue.length),
                  (ot = xt.firstChild) !== null;

              )
                (ke = xt), (xt = ot);
              for (;;) {
                if (xt === r) break t;
                if (
                  (ke === p && ++Ce === x && (Q = G),
                  ke === C && ++ct === g && (he = G),
                  (ot = xt.nextSibling) !== null)
                )
                  break;
                (xt = ke), (ke = xt.parentNode);
              }
              xt = ot;
            }
            p = Q === -1 || he === -1 ? null : { start: Q, end: he };
          } else p = null;
        }
      p = p || { start: 0, end: 0 };
    } else p = null;
    for (
      D_ = { focusedElem: r, selectionRange: p }, vv = !1, Gi = o;
      Gi !== null;

    )
      if (
        ((o = Gi), (r = o.child), (o.subtreeFlags & 1028) !== 0 && r !== null)
      )
        (r.return = o), (Gi = r);
      else
        for (; Gi !== null; ) {
          switch (((o = Gi), (C = o.alternate), (r = o.flags), o.tag)) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((r & 1024) !== 0 && C !== null) {
                (r = void 0),
                  (p = o),
                  (x = C.memoizedProps),
                  (C = C.memoizedState),
                  (g = p.stateNode);
                try {
                  var Jt = Kl(p.type, x, p.elementType === p.type);
                  (r = g.getSnapshotBeforeUpdate(Jt, C)),
                    (g.__reactInternalSnapshotBeforeUpdate = r);
                } catch (fn) {
                  bt(p, p.return, fn);
                }
              }
              break;
            case 3:
              if ((r & 1024) !== 0) {
                if (
                  ((r = o.stateNode.containerInfo), (p = r.nodeType), p === 9)
                )
                  N_(r);
                else if (p === 1)
                  switch (r.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      N_(r);
                      break;
                    default:
                      r.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((r & 1024) !== 0) throw Error(n(163));
          }
          if (((r = o.sibling), r !== null)) {
            (r.return = o.return), (Gi = r);
            break;
          }
          Gi = o.return;
        }
    return (Jt = Ih), (Ih = !1), Jt;
  }
  function qu(r, o, p) {
    var g = p.flags;
    switch (p.tag) {
      case 0:
      case 11:
      case 15:
        Bs(r, p), g & 4 && Fi(5, p);
        break;
      case 1:
        if ((Bs(r, p), g & 4))
          if (((r = p.stateNode), o === null))
            try {
              r.componentDidMount();
            } catch (Q) {
              bt(p, p.return, Q);
            }
          else {
            var x = Kl(p.type, o.memoizedProps);
            o = o.memoizedState;
            try {
              r.componentDidUpdate(x, o, r.__reactInternalSnapshotBeforeUpdate);
            } catch (Q) {
              bt(p, p.return, Q);
            }
          }
        g & 64 && po(p), g & 512 && Pi(p, p.return);
        break;
      case 3:
        if ((Bs(r, p), g & 64 && ((g = p.updateQueue), g !== null))) {
          if (((r = null), p.child !== null))
            switch (p.child.tag) {
              case 27:
              case 5:
                r = p.child.stateNode;
                break;
              case 1:
                r = p.child.stateNode;
            }
          try {
            ws(g, r);
          } catch (Q) {
            bt(p, p.return, Q);
          }
        }
        break;
      case 26:
        Bs(r, p), g & 512 && Pi(p, p.return);
        break;
      case 27:
      case 5:
        Bs(r, p), o === null && g & 4 && Pn(p), g & 512 && Pi(p, p.return);
        break;
      case 12:
        Bs(r, p);
        break;
      case 13:
        Bs(r, p), g & 4 && rv(r, p);
        break;
      case 22:
        if (((x = p.memoizedState !== null || ls), !x)) {
          o = (o !== null && o.memoizedState !== null) || mi;
          var C = ls,
            G = mi;
          (ls = x),
            (mi = o) && !G ? cs(r, p, (p.subtreeFlags & 8772) !== 0) : Bs(r, p),
            (ls = C),
            (mi = G);
        }
        g & 512 &&
          (p.memoizedProps.mode === "manual"
            ? Pi(p, p.return)
            : ei(p, p.return));
        break;
      default:
        Bs(r, p);
    }
  }
  function Fh(r) {
    var o = r.alternate;
    o !== null && ((r.alternate = null), Fh(o)),
      (r.child = null),
      (r.deletions = null),
      (r.sibling = null),
      r.tag === 5 && ((o = r.stateNode), o !== null && St(o)),
      (r.stateNode = null),
      (r.return = null),
      (r.dependencies = null),
      (r.memoizedProps = null),
      (r.memoizedState = null),
      (r.pendingProps = null),
      (r.stateNode = null),
      (r.updateQueue = null);
  }
  var gi = null,
    ca = !1;
  function Ra(r, o, p) {
    for (p = p.child; p !== null; ) Ph(r, o, p), (p = p.sibling);
  }
  function Ph(r, o, p) {
    if (nt && typeof nt.onCommitFiberUnmount == "function")
      try {
        nt.onCommitFiberUnmount(mt, p);
      } catch {}
    switch (p.tag) {
      case 26:
        mi || ei(p, o),
          Ra(r, o, p),
          p.memoizedState
            ? p.memoizedState.count--
            : p.stateNode && ((p = p.stateNode), p.parentNode.removeChild(p));
        break;
      case 27:
        mi || ei(p, o);
        var g = gi,
          x = ca;
        for (
          gi = p.stateNode, Ra(r, o, p), p = p.stateNode, o = p.attributes;
          o.length;

        )
          p.removeAttributeNode(o[0]);
        St(p), (gi = g), (ca = x);
        break;
      case 5:
        mi || ei(p, o);
      case 6:
        x = gi;
        var C = ca;
        if (((gi = null), Ra(r, o, p), (gi = x), (ca = C), gi !== null))
          if (ca)
            try {
              (r = gi),
                (g = p.stateNode),
                r.nodeType === 8
                  ? r.parentNode.removeChild(g)
                  : r.removeChild(g);
            } catch (G) {
              bt(p, o, G);
            }
          else
            try {
              gi.removeChild(p.stateNode);
            } catch (G) {
              bt(p, o, G);
            }
        break;
      case 18:
        gi !== null &&
          (ca
            ? ((o = gi),
              (p = p.stateNode),
              o.nodeType === 8
                ? L_(o.parentNode, p)
                : o.nodeType === 1 && L_(o, p),
              qp(o))
            : L_(gi, p.stateNode));
        break;
      case 4:
        (g = gi),
          (x = ca),
          (gi = p.stateNode.containerInfo),
          (ca = !0),
          Ra(r, o, p),
          (gi = g),
          (ca = x);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        mi || Fr(2, p, o), mi || Fr(4, p, o), Ra(r, o, p);
        break;
      case 1:
        mi ||
          (ei(p, o),
          (g = p.stateNode),
          typeof g.componentWillUnmount == "function" && rf(p, o, g)),
          Ra(r, o, p);
        break;
      case 21:
        Ra(r, o, p);
        break;
      case 22:
        mi || ei(p, o),
          (mi = (g = mi) || p.memoizedState !== null),
          Ra(r, o, p),
          (mi = g);
        break;
      default:
        Ra(r, o, p);
    }
  }
  function rv(r, o) {
    if (
      o.memoizedState === null &&
      ((r = o.alternate),
      r !== null &&
        ((r = r.memoizedState), r !== null && ((r = r.dehydrated), r !== null)))
    )
      try {
        qp(r);
      } catch (p) {
        bt(o, o.return, p);
      }
  }
  function of(r) {
    switch (r.tag) {
      case 13:
      case 19:
        var o = r.stateNode;
        return o === null && (o = r.stateNode = new Nh()), o;
      case 22:
        return (
          (r = r.stateNode),
          (o = r._retryCache),
          o === null && (o = r._retryCache = new Nh()),
          o
        );
      default:
        throw Error(n(435, r.tag));
    }
  }
  function lf(r, o) {
    var p = of(r);
    o.forEach(function (g) {
      var x = ze.bind(null, r, g);
      p.has(g) || (p.add(g), g.then(x, x));
    });
  }
  function za(r, o) {
    var p = o.deletions;
    if (p !== null)
      for (var g = 0; g < p.length; g++) {
        var x = p[g],
          C = r,
          G = o,
          Q = G;
        e: for (; Q !== null; ) {
          switch (Q.tag) {
            case 27:
            case 5:
              (gi = Q.stateNode), (ca = !1);
              break e;
            case 3:
              (gi = Q.stateNode.containerInfo), (ca = !0);
              break e;
            case 4:
              (gi = Q.stateNode.containerInfo), (ca = !0);
              break e;
          }
          Q = Q.return;
        }
        if (gi === null) throw Error(n(160));
        Ph(C, G, x),
          (gi = null),
          (ca = !1),
          (C = x.alternate),
          C !== null && (C.return = null),
          (x.return = null);
      }
    if (o.subtreeFlags & 13878)
      for (o = o.child; o !== null; ) $l(o, r), (o = o.sibling);
  }
  var wa = null;
  function $l(r, o) {
    var p = r.alternate,
      g = r.flags;
    switch (r.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        za(o, r),
          Ba(r),
          g & 4 && (Fr(3, r, r.return), Fi(3, r), Fr(5, r, r.return));
        break;
      case 1:
        za(o, r),
          Ba(r),
          g & 512 && (mi || p === null || ei(p, p.return)),
          g & 64 &&
            ls &&
            ((r = r.updateQueue),
            r !== null &&
              ((g = r.callbacks),
              g !== null &&
                ((p = r.shared.hiddenCallbacks),
                (r.shared.hiddenCallbacks = p === null ? g : p.concat(g)))));
        break;
      case 26:
        var x = wa;
        if (
          (za(o, r),
          Ba(r),
          g & 512 && (mi || p === null || ei(p, p.return)),
          g & 4)
        ) {
          var C = p !== null ? p.memoizedState : null;
          if (((g = r.memoizedState), p === null))
            if (g === null)
              if (r.stateNode === null) {
                e: {
                  (g = r.type),
                    (p = r.memoizedProps),
                    (x = x.ownerDocument || x);
                  t: switch (g) {
                    case "title":
                      (C = x.getElementsByTagName("title")[0]),
                        (!C ||
                          C[Je] ||
                          C[pn] ||
                          C.namespaceURI === "http://www.w3.org/2000/svg" ||
                          C.hasAttribute("itemprop")) &&
                          ((C = x.createElement(g)),
                          x.head.insertBefore(
                            C,
                            x.querySelector("head > title")
                          )),
                        Xa(C, g, p),
                        (C[pn] = r),
                        ne(C),
                        (g = C);
                      break e;
                    case "link":
                      var G = vS("link", "href", x).get(g + (p.href || ""));
                      if (G) {
                        for (var Q = 0; Q < G.length; Q++)
                          if (
                            ((C = G[Q]),
                            C.getAttribute("href") ===
                              (p.href == null ? null : p.href) &&
                              C.getAttribute("rel") ===
                                (p.rel == null ? null : p.rel) &&
                              C.getAttribute("title") ===
                                (p.title == null ? null : p.title) &&
                              C.getAttribute("crossorigin") ===
                                (p.crossOrigin == null ? null : p.crossOrigin))
                          ) {
                            G.splice(Q, 1);
                            break t;
                          }
                      }
                      (C = x.createElement(g)),
                        Xa(C, g, p),
                        x.head.appendChild(C);
                      break;
                    case "meta":
                      if (
                        (G = vS("meta", "content", x).get(
                          g + (p.content || "")
                        ))
                      ) {
                        for (Q = 0; Q < G.length; Q++)
                          if (
                            ((C = G[Q]),
                            C.getAttribute("content") ===
                              (p.content == null ? null : "" + p.content) &&
                              C.getAttribute("name") ===
                                (p.name == null ? null : p.name) &&
                              C.getAttribute("property") ===
                                (p.property == null ? null : p.property) &&
                              C.getAttribute("http-equiv") ===
                                (p.httpEquiv == null ? null : p.httpEquiv) &&
                              C.getAttribute("charset") ===
                                (p.charSet == null ? null : p.charSet))
                          ) {
                            G.splice(Q, 1);
                            break t;
                          }
                      }
                      (C = x.createElement(g)),
                        Xa(C, g, p),
                        x.head.appendChild(C);
                      break;
                    default:
                      throw Error(n(468, g));
                  }
                  (C[pn] = r), ne(C), (g = C);
                }
                r.stateNode = g;
              } else yS(x, r.type, r.stateNode);
            else r.stateNode = gS(x, g, r.memoizedProps);
          else
            C !== g
              ? (C === null
                  ? p.stateNode !== null &&
                    ((p = p.stateNode), p.parentNode.removeChild(p))
                  : C.count--,
                g === null
                  ? yS(x, r.type, r.stateNode)
                  : gS(x, g, r.memoizedProps))
              : g === null &&
                r.stateNode !== null &&
                Pr(r, r.memoizedProps, p.memoizedProps);
        }
        break;
      case 27:
        if (g & 4 && r.alternate === null) {
          (x = r.stateNode), (C = r.memoizedProps);
          try {
            for (var he = x.firstChild; he; ) {
              var Ce = he.nextSibling,
                ct = he.nodeName;
              he[Je] ||
                ct === "HEAD" ||
                ct === "BODY" ||
                ct === "SCRIPT" ||
                ct === "STYLE" ||
                (ct === "LINK" && he.rel.toLowerCase() === "stylesheet") ||
                x.removeChild(he),
                (he = Ce);
            }
            for (var xt = r.type, ke = x.attributes; ke.length; )
              x.removeAttributeNode(ke[0]);
            Xa(x, xt, C), (x[pn] = r), (x[en] = C);
          } catch (Jt) {
            bt(r, r.return, Jt);
          }
        }
      case 5:
        if (
          (za(o, r),
          Ba(r),
          g & 512 && (mi || p === null || ei(p, p.return)),
          r.flags & 32)
        ) {
          x = r.stateNode;
          try {
            ea(x, "");
          } catch (Jt) {
            bt(r, r.return, Jt);
          }
        }
        g & 4 &&
          r.stateNode != null &&
          ((x = r.memoizedProps), Pr(r, x, p !== null ? p.memoizedProps : x)),
          g & 1024 && (fl = !0);
        break;
      case 6:
        if ((za(o, r), Ba(r), g & 4)) {
          if (r.stateNode === null) throw Error(n(162));
          (g = r.memoizedProps), (p = r.stateNode);
          try {
            p.nodeValue = g;
          } catch (Jt) {
            bt(r, r.return, Jt);
          }
        }
        break;
      case 3:
        if (
          ((pv = null),
          (x = wa),
          (wa = hv(o.containerInfo)),
          za(o, r),
          (wa = x),
          Ba(r),
          g & 4 && p !== null && p.memoizedState.isDehydrated)
        )
          try {
            qp(o.containerInfo);
          } catch (Jt) {
            bt(r, r.return, Jt);
          }
        fl && ((fl = !1), hl(r));
        break;
      case 4:
        (g = wa),
          (wa = hv(r.stateNode.containerInfo)),
          za(o, r),
          Ba(r),
          (wa = g);
        break;
      case 12:
        za(o, r), Ba(r);
        break;
      case 13:
        za(o, r),
          Ba(r),
          r.child.flags & 8192 &&
            (r.memoizedState !== null) !=
              (p !== null && p.memoizedState !== null) &&
            (Sn = Ee()),
          g & 4 &&
            ((g = r.updateQueue),
            g !== null && ((r.updateQueue = null), lf(r, g)));
        break;
      case 22:
        if (
          (g & 512 && (mi || p === null || ei(p, p.return)),
          (he = r.memoizedState !== null),
          (Ce = p !== null && p.memoizedState !== null),
          (ct = ls),
          (xt = mi),
          (ls = ct || he),
          (mi = xt || Ce),
          za(o, r),
          (mi = xt),
          (ls = ct),
          Ba(r),
          (o = r.stateNode),
          (o._current = r),
          (o._visibility &= -3),
          (o._visibility |= o._pendingVisibility & 2),
          g & 8192 &&
            ((o._visibility = he ? o._visibility & -2 : o._visibility | 1),
            he && ((o = ls || mi), p === null || Ce || o || us(r)),
            r.memoizedProps === null || r.memoizedProps.mode !== "manual"))
        )
          e: for (p = null, o = r; ; ) {
            if (o.tag === 5 || o.tag === 26 || o.tag === 27) {
              if (p === null) {
                Ce = p = o;
                try {
                  if (((x = Ce.stateNode), he))
                    (C = x.style),
                      typeof C.setProperty == "function"
                        ? C.setProperty("display", "none", "important")
                        : (C.display = "none");
                  else {
                    (G = Ce.stateNode), (Q = Ce.memoizedProps.style);
                    var ot =
                      Q != null && Q.hasOwnProperty("display")
                        ? Q.display
                        : null;
                    G.style.display =
                      ot == null || typeof ot == "boolean"
                        ? ""
                        : ("" + ot).trim();
                  }
                } catch (Jt) {
                  bt(Ce, Ce.return, Jt);
                }
              }
            } else if (o.tag === 6) {
              if (p === null) {
                Ce = o;
                try {
                  Ce.stateNode.nodeValue = he ? "" : Ce.memoizedProps;
                } catch (Jt) {
                  bt(Ce, Ce.return, Jt);
                }
              }
            } else if (
              ((o.tag !== 22 && o.tag !== 23) ||
                o.memoizedState === null ||
                o === r) &&
              o.child !== null
            ) {
              (o.child.return = o), (o = o.child);
              continue;
            }
            if (o === r) break e;
            for (; o.sibling === null; ) {
              if (o.return === null || o.return === r) break e;
              p === o && (p = null), (o = o.return);
            }
            p === o && (p = null),
              (o.sibling.return = o.return),
              (o = o.sibling);
          }
        g & 4 &&
          ((g = r.updateQueue),
          g !== null &&
            ((p = g.retryQueue),
            p !== null && ((g.retryQueue = null), lf(r, p))));
        break;
      case 19:
        za(o, r),
          Ba(r),
          g & 4 &&
            ((g = r.updateQueue),
            g !== null && ((r.updateQueue = null), lf(r, g)));
        break;
      case 21:
        break;
      default:
        za(o, r), Ba(r);
    }
  }
  function Ba(r) {
    var o = r.flags;
    if (o & 2) {
      try {
        if (r.tag !== 27) {
          e: {
            for (var p = r.return; p !== null; ) {
              if (os(p)) {
                var g = p;
                break e;
              }
              p = p.return;
            }
            throw Error(n(160));
          }
          switch (g.tag) {
            case 27:
              var x = g.stateNode,
                C = sf(r);
              mo(r, C, x);
              break;
            case 5:
              var G = g.stateNode;
              g.flags & 32 && (ea(G, ""), (g.flags &= -33));
              var Q = sf(r);
              mo(r, Q, G);
              break;
            case 3:
            case 4:
              var he = g.stateNode.containerInfo,
                Ce = sf(r);
              rr(r, Ce, he);
              break;
            default:
              throw Error(n(161));
          }
        }
      } catch (ct) {
        bt(r, r.return, ct);
      }
      r.flags &= -3;
    }
    o & 4096 && (r.flags &= -4097);
  }
  function hl(r) {
    if (r.subtreeFlags & 1024)
      for (r = r.child; r !== null; ) {
        var o = r;
        hl(o),
          o.tag === 5 && o.flags & 1024 && o.stateNode.reset(),
          (r = r.sibling);
      }
  }
  function Bs(r, o) {
    if (o.subtreeFlags & 8772)
      for (o = o.child; o !== null; ) qu(r, o.alternate, o), (o = o.sibling);
  }
  function us(r) {
    for (r = r.child; r !== null; ) {
      var o = r;
      switch (o.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Fr(4, o, o.return), us(o);
          break;
        case 1:
          ei(o, o.return);
          var p = o.stateNode;
          typeof p.componentWillUnmount == "function" && rf(o, o.return, p),
            us(o);
          break;
        case 26:
        case 27:
        case 5:
          ei(o, o.return), us(o);
          break;
        case 22:
          ei(o, o.return), o.memoizedState === null && us(o);
          break;
        default:
          us(o);
      }
      r = r.sibling;
    }
  }
  function cs(r, o, p) {
    for (p = p && (o.subtreeFlags & 8772) !== 0, o = o.child; o !== null; ) {
      var g = o.alternate,
        x = r,
        C = o,
        G = C.flags;
      switch (C.tag) {
        case 0:
        case 11:
        case 15:
          cs(x, C, p), Fi(4, C);
          break;
        case 1:
          if (
            (cs(x, C, p),
            (g = C),
            (x = g.stateNode),
            typeof x.componentDidMount == "function")
          )
            try {
              x.componentDidMount();
            } catch (Ce) {
              bt(g, g.return, Ce);
            }
          if (((g = C), (x = g.updateQueue), x !== null)) {
            var Q = g.stateNode;
            try {
              var he = x.shared.hiddenCallbacks;
              if (he !== null)
                for (x.shared.hiddenCallbacks = null, x = 0; x < he.length; x++)
                  Rs(he[x], Q);
            } catch (Ce) {
              bt(g, g.return, Ce);
            }
          }
          p && G & 64 && po(C), Pi(C, C.return);
          break;
        case 26:
        case 27:
        case 5:
          cs(x, C, p), p && g === null && G & 4 && Pn(C), Pi(C, C.return);
          break;
        case 12:
          cs(x, C, p);
          break;
        case 13:
          cs(x, C, p), p && G & 4 && rv(x, C);
          break;
        case 22:
          C.memoizedState === null && cs(x, C, p), Pi(C, C.return);
          break;
        default:
          cs(x, C, p);
      }
      o = o.sibling;
    }
  }
  function sr(r, o) {
    var p = null;
    r !== null &&
      r.memoizedState !== null &&
      r.memoizedState.cachePool !== null &&
      (p = r.memoizedState.cachePool.pool),
      (r = null),
      o.memoizedState !== null &&
        o.memoizedState.cachePool !== null &&
        (r = o.memoizedState.cachePool.pool),
      r !== p && (r != null && r.refCount++, p != null && $o(p));
  }
  function Gr(r, o) {
    (r = null),
      o.alternate !== null && (r = o.alternate.memoizedState.cache),
      (o = o.memoizedState.cache),
      o !== r && (o.refCount++, r != null && $o(r));
  }
  function fi(r, o, p, g) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; ) go(r, o, p, g), (o = o.sibling);
  }
  function go(r, o, p, g) {
    var x = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        fi(r, o, p, g), x & 2048 && Fi(9, o);
        break;
      case 3:
        fi(r, o, p, g),
          x & 2048 &&
            ((r = null),
            o.alternate !== null && (r = o.alternate.memoizedState.cache),
            (o = o.memoizedState.cache),
            o !== r && (o.refCount++, r != null && $o(r)));
        break;
      case 12:
        if (x & 2048) {
          fi(r, o, p, g), (r = o.stateNode);
          try {
            var C = o.memoizedProps,
              G = C.id,
              Q = C.onPostCommit;
            typeof Q == "function" &&
              Q(
                G,
                o.alternate === null ? "mount" : "update",
                r.passiveEffectDuration,
                -0
              );
          } catch (he) {
            bt(o, o.return, he);
          }
        } else fi(r, o, p, g);
        break;
      case 23:
        break;
      case 22:
        (C = o.stateNode),
          o.memoizedState !== null
            ? C._visibility & 4
              ? fi(r, o, p, g)
              : Vn(r, o)
            : C._visibility & 4
            ? fi(r, o, p, g)
            : ((C._visibility |= 4),
              ln(r, o, p, g, (o.subtreeFlags & 10256) !== 0)),
          x & 2048 && sr(o.alternate, o);
        break;
      case 24:
        fi(r, o, p, g), x & 2048 && Gr(o.alternate, o);
        break;
      default:
        fi(r, o, p, g);
    }
  }
  function ln(r, o, p, g, x) {
    for (x = x && (o.subtreeFlags & 10256) !== 0, o = o.child; o !== null; ) {
      var C = r,
        G = o,
        Q = p,
        he = g,
        Ce = G.flags;
      switch (G.tag) {
        case 0:
        case 11:
        case 15:
          ln(C, G, Q, he, x), Fi(8, G);
          break;
        case 23:
          break;
        case 22:
          var ct = G.stateNode;
          G.memoizedState !== null
            ? ct._visibility & 4
              ? ln(C, G, Q, he, x)
              : Vn(C, G)
            : ((ct._visibility |= 4), ln(C, G, Q, he, x)),
            x && Ce & 2048 && sr(G.alternate, G);
          break;
        case 24:
          ln(C, G, Q, he, x), x && Ce & 2048 && Gr(G.alternate, G);
          break;
        default:
          ln(C, G, Q, he, x);
      }
      o = o.sibling;
    }
  }
  function Vn(r, o) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; ) {
        var p = r,
          g = o,
          x = g.flags;
        switch (g.tag) {
          case 22:
            Vn(p, g), x & 2048 && sr(g.alternate, g);
            break;
          case 24:
            Vn(p, g), x & 2048 && Gr(g.alternate, g);
            break;
          default:
            Vn(p, g);
        }
        o = o.sibling;
      }
  }
  var xi = 8192;
  function vo(r) {
    if (r.subtreeFlags & xi)
      for (r = r.child; r !== null; ) eu(r), (r = r.sibling);
  }
  function eu(r) {
    switch (r.tag) {
      case 26:
        vo(r),
          r.flags & xi &&
            r.memoizedState !== null &&
            EC(wa, r.memoizedState, r.memoizedProps);
        break;
      case 5:
        vo(r);
        break;
      case 3:
      case 4:
        var o = wa;
        (wa = hv(r.stateNode.containerInfo)), vo(r), (wa = o);
        break;
      case 22:
        r.memoizedState === null &&
          ((o = r.alternate),
          o !== null && o.memoizedState !== null
            ? ((o = xi), (xi = 16777216), vo(r), (xi = o))
            : vo(r));
        break;
      default:
        vo(r);
    }
  }
  function dl(r) {
    var o = r.alternate;
    if (o !== null && ((r = o.child), r !== null)) {
      o.child = null;
      do (o = r.sibling), (r.sibling = null), (r = o);
      while (r !== null);
    }
  }
  function pl(r) {
    var o = r.deletions;
    if ((r.flags & 16) !== 0) {
      if (o !== null)
        for (var p = 0; p < o.length; p++) {
          var g = o[p];
          (Gi = g), sv(g, r);
        }
      dl(r);
    }
    if (r.subtreeFlags & 10256)
      for (r = r.child; r !== null; ) ju(r), (r = r.sibling);
  }
  function ju(r) {
    switch (r.tag) {
      case 0:
      case 11:
      case 15:
        pl(r), r.flags & 2048 && Fr(9, r, r.return);
        break;
      case 3:
        pl(r);
        break;
      case 12:
        pl(r);
        break;
      case 22:
        var o = r.stateNode;
        r.memoizedState !== null &&
        o._visibility & 4 &&
        (r.return === null || r.return.tag !== 13)
          ? ((o._visibility &= -5), yo(r))
          : pl(r);
        break;
      default:
        pl(r);
    }
  }
  function yo(r) {
    var o = r.deletions;
    if ((r.flags & 16) !== 0) {
      if (o !== null)
        for (var p = 0; p < o.length; p++) {
          var g = o[p];
          (Gi = g), sv(g, r);
        }
      dl(r);
    }
    for (r = r.child; r !== null; ) {
      switch (((o = r), o.tag)) {
        case 0:
        case 11:
        case 15:
          Fr(8, o, o.return), yo(o);
          break;
        case 22:
          (p = o.stateNode),
            p._visibility & 4 && ((p._visibility &= -5), yo(o));
          break;
        default:
          yo(o);
      }
      r = r.sibling;
    }
  }
  function sv(r, o) {
    for (; Gi !== null; ) {
      var p = Gi;
      switch (p.tag) {
        case 0:
        case 11:
        case 15:
          Fr(8, p, o);
          break;
        case 23:
        case 22:
          if (p.memoizedState !== null && p.memoizedState.cachePool !== null) {
            var g = p.memoizedState.cachePool.pool;
            g != null && g.refCount++;
          }
          break;
        case 24:
          $o(p.memoizedState.cache);
      }
      if (((g = p.child), g !== null)) (g.return = p), (Gi = g);
      else
        e: for (p = r; Gi !== null; ) {
          g = Gi;
          var x = g.sibling,
            C = g.return;
          if ((Fh(g), g === p)) {
            Gi = null;
            break e;
          }
          if (x !== null) {
            (x.return = C), (Gi = x);
            break e;
          }
          Gi = C;
        }
    }
  }
  function Lp(r, o, p, g) {
    (this.tag = r),
      (this.key = p),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.refCleanup = this.ref = null),
      (this.pendingProps = o),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = g),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function zi(r, o, p, g) {
    return new Lp(r, o, p, g);
  }
  function _o(r) {
    return (r = r.prototype), !(!r || !r.isReactComponent);
  }
  function Ha(r, o) {
    var p = r.alternate;
    return (
      p === null
        ? ((p = zi(r.tag, o, r.key, r.mode)),
          (p.elementType = r.elementType),
          (p.type = r.type),
          (p.stateNode = r.stateNode),
          (p.alternate = r),
          (r.alternate = p))
        : ((p.pendingProps = o),
          (p.type = r.type),
          (p.flags = 0),
          (p.subtreeFlags = 0),
          (p.deletions = null)),
      (p.flags = r.flags & 31457280),
      (p.childLanes = r.childLanes),
      (p.lanes = r.lanes),
      (p.child = r.child),
      (p.memoizedProps = r.memoizedProps),
      (p.memoizedState = r.memoizedState),
      (p.updateQueue = r.updateQueue),
      (o = r.dependencies),
      (p.dependencies =
        o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }),
      (p.sibling = r.sibling),
      (p.index = r.index),
      (p.ref = r.ref),
      (p.refCleanup = r.refCleanup),
      p
    );
  }
  function ml(r, o) {
    r.flags &= 31457282;
    var p = r.alternate;
    return (
      p === null
        ? ((r.childLanes = 0),
          (r.lanes = o),
          (r.child = null),
          (r.subtreeFlags = 0),
          (r.memoizedProps = null),
          (r.memoizedState = null),
          (r.updateQueue = null),
          (r.dependencies = null),
          (r.stateNode = null))
        : ((r.childLanes = p.childLanes),
          (r.lanes = p.lanes),
          (r.child = p.child),
          (r.subtreeFlags = 0),
          (r.deletions = null),
          (r.memoizedProps = p.memoizedProps),
          (r.memoizedState = p.memoizedState),
          (r.updateQueue = p.updateQueue),
          (r.type = p.type),
          (o = p.dependencies),
          (r.dependencies =
            o === null
              ? null
              : { lanes: o.lanes, firstContext: o.firstContext })),
      r
    );
  }
  function Ku(r, o, p, g, x, C) {
    var G = 0;
    if (((g = r), typeof r == "function")) _o(r) && (G = 1);
    else if (typeof r == "string")
      G = MC(r, p, $e.current)
        ? 26
        : r === "html" || r === "head" || r === "body"
        ? 27
        : 5;
    else
      e: switch (r) {
        case f:
          return gl(p.children, x, C, o);
        case d:
          (G = 8), (x |= 24);
          break;
        case m:
          return (
            (r = zi(12, p, o, x | 2)), (r.elementType = m), (r.lanes = C), r
          );
        case T:
          return (r = zi(13, p, o, x)), (r.elementType = T), (r.lanes = C), r;
        case E:
          return (r = zi(19, p, o, x)), (r.elementType = E), (r.lanes = C), r;
        case D:
          return Np(p, x, C, o);
        default:
          if (typeof r == "object" && r !== null)
            switch (r.$$typeof) {
              case v:
              case A:
                G = 10;
                break e;
              case _:
                G = 9;
                break e;
              case M:
                G = 11;
                break e;
              case b:
                G = 14;
                break e;
              case w:
                (G = 16), (g = null);
                break e;
            }
          (G = 29),
            (p = Error(n(130, r === null ? "null" : typeof r, ""))),
            (g = null);
      }
    return (
      (o = zi(G, p, o, x)), (o.elementType = r), (o.type = g), (o.lanes = C), o
    );
  }
  function gl(r, o, p, g) {
    return (r = zi(7, r, g, o)), (r.lanes = p), r;
  }
  function Np(r, o, p, g) {
    (r = zi(22, r, g, o)), (r.elementType = D), (r.lanes = p);
    var x = {
      _visibility: 1,
      _pendingVisibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null,
      _current: null,
      detach: function () {
        var C = x._current;
        if (C === null) throw Error(n(456));
        if ((x._pendingVisibility & 2) === 0) {
          var G = eo(C, 2);
          G !== null && ((x._pendingVisibility |= 2), Ki(G, C, 2));
        }
      },
      attach: function () {
        var C = x._current;
        if (C === null) throw Error(n(456));
        if ((x._pendingVisibility & 2) !== 0) {
          var G = eo(C, 2);
          G !== null && ((x._pendingVisibility &= -3), Ki(G, C, 2));
        }
      },
    };
    return (r.stateNode = x), r;
  }
  function qi(r, o, p) {
    return (r = zi(6, r, null, o)), (r.lanes = p), r;
  }
  function uf(r, o, p) {
    return (
      (o = zi(4, r.children !== null ? r.children : [], r.key, o)),
      (o.lanes = p),
      (o.stateNode = {
        containerInfo: r.containerInfo,
        pendingChildren: null,
        implementation: r.implementation,
      }),
      o
    );
  }
  function zr(r) {
    r.flags |= 4;
  }
  function vl(r, o) {
    if (o.type !== "stylesheet" || (o.state.loading & 4) !== 0)
      r.flags &= -16777217;
    else if (((r.flags |= 16777216), !_S(o))) {
      if (
        ((o = nr.current),
        o !== null &&
          ((Zt & 4194176) === Zt
            ? Ss !== null
            : ((Zt & 62914560) !== Zt && (Zt & 536870912) === 0) || o !== Ss))
      )
        throw ((Nu = mh), sp);
      r.flags |= 8192;
    }
  }
  function Hr(r, o) {
    o !== null && (r.flags |= 4),
      r.flags & 16384 &&
        ((o = r.tag !== 22 ? Ft() : 536870912), (r.lanes |= o), (Us |= o));
  }
  function cf(r, o) {
    if (!Fn)
      switch (r.tailMode) {
        case "hidden":
          o = r.tail;
          for (var p = null; o !== null; )
            o.alternate !== null && (p = o), (o = o.sibling);
          p === null ? (r.tail = null) : (p.sibling = null);
          break;
        case "collapsed":
          p = r.tail;
          for (var g = null; p !== null; )
            p.alternate !== null && (g = p), (p = p.sibling);
          g === null
            ? o || r.tail === null
              ? (r.tail = null)
              : (r.tail.sibling = null)
            : (g.sibling = null);
      }
  }
  function bi(r) {
    var o = r.alternate !== null && r.alternate.child === r.child,
      p = 0,
      g = 0;
    if (o)
      for (var x = r.child; x !== null; )
        (p |= x.lanes | x.childLanes),
          (g |= x.subtreeFlags & 31457280),
          (g |= x.flags & 31457280),
          (x.return = r),
          (x = x.sibling);
    else
      for (x = r.child; x !== null; )
        (p |= x.lanes | x.childLanes),
          (g |= x.subtreeFlags),
          (g |= x.flags),
          (x.return = r),
          (x = x.sibling);
    return (r.subtreeFlags |= g), (r.childLanes = p), o;
  }
  function S_(r, o, p) {
    var g = o.pendingProps;
    switch ((qo(o), o.tag)) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bi(o), null;
      case 1:
        return bi(o), null;
      case 3:
        return (
          (p = o.stateNode),
          (g = null),
          r !== null && (g = r.memoizedState.cache),
          o.memoizedState.cache !== g && (o.flags |= 2048),
          ho(Li),
          Pe(),
          p.pendingContext &&
            ((p.context = p.pendingContext), (p.pendingContext = null)),
          (r === null || r.child === null) &&
            (Ou(o)
              ? zr(o)
              : r === null ||
                (r.memoizedState.isDehydrated && (o.flags & 256) === 0) ||
                ((o.flags |= 1024), Nr !== null && (Yr(Nr), (Nr = null)))),
          bi(o),
          null
        );
      case 26:
        return (
          (p = o.memoizedState),
          r === null
            ? (zr(o),
              p !== null ? (bi(o), vl(o, p)) : (bi(o), (o.flags &= -16777217)))
            : p
            ? p !== r.memoizedState
              ? (zr(o), bi(o), vl(o, p))
              : (bi(o), (o.flags &= -16777217))
            : (r.memoizedProps !== g && zr(o), bi(o), (o.flags &= -16777217)),
          null
        );
      case 27:
        Ue(o), (p = Ie.current);
        var x = o.type;
        if (r !== null && o.stateNode != null) r.memoizedProps !== g && zr(o);
        else {
          if (!g) {
            if (o.stateNode === null) throw Error(n(166));
            return bi(o), null;
          }
          (r = $e.current),
            Ou(o) ? pg(o) : ((r = fS(x, g, p)), (o.stateNode = r), zr(o));
        }
        return bi(o), null;
      case 5:
        if ((Ue(o), (p = o.type), r !== null && o.stateNode != null))
          r.memoizedProps !== g && zr(o);
        else {
          if (!g) {
            if (o.stateNode === null) throw Error(n(166));
            return bi(o), null;
          }
          if (((r = $e.current), Ou(o))) pg(o);
          else {
            switch (((x = fv(Ie.current)), r)) {
              case 1:
                r = x.createElementNS("http://www.w3.org/2000/svg", p);
                break;
              case 2:
                r = x.createElementNS("http://www.w3.org/1998/Math/MathML", p);
                break;
              default:
                switch (p) {
                  case "svg":
                    r = x.createElementNS("http://www.w3.org/2000/svg", p);
                    break;
                  case "math":
                    r = x.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      p
                    );
                    break;
                  case "script":
                    (r = x.createElement("div")),
                      (r.innerHTML = "<script></script>"),
                      (r = r.removeChild(r.firstChild));
                    break;
                  case "select":
                    (r =
                      typeof g.is == "string"
                        ? x.createElement("select", { is: g.is })
                        : x.createElement("select")),
                      g.multiple
                        ? (r.multiple = !0)
                        : g.size && (r.size = g.size);
                    break;
                  default:
                    r =
                      typeof g.is == "string"
                        ? x.createElement(p, { is: g.is })
                        : x.createElement(p);
                }
            }
            (r[pn] = o), (r[en] = g);
            e: for (x = o.child; x !== null; ) {
              if (x.tag === 5 || x.tag === 6) r.appendChild(x.stateNode);
              else if (x.tag !== 4 && x.tag !== 27 && x.child !== null) {
                (x.child.return = x), (x = x.child);
                continue;
              }
              if (x === o) break e;
              for (; x.sibling === null; ) {
                if (x.return === null || x.return === o) break e;
                x = x.return;
              }
              (x.sibling.return = x.return), (x = x.sibling);
            }
            o.stateNode = r;
            e: switch ((Xa(r, p, g), p)) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!g.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
            r && zr(o);
          }
        }
        return bi(o), (o.flags &= -16777217), null;
      case 6:
        if (r && o.stateNode != null) r.memoizedProps !== g && zr(o);
        else {
          if (typeof g != "string" && o.stateNode === null) throw Error(n(166));
          if (((r = Ie.current), Ou(o))) {
            if (
              ((r = o.stateNode),
              (p = o.memoizedProps),
              (g = null),
              (x = Ea),
              x !== null)
            )
              switch (x.tag) {
                case 27:
                case 5:
                  g = x.memoizedProps;
              }
            (r[pn] = o),
              (r = !!(
                r.nodeValue === p ||
                (g !== null && g.suppressHydrationWarning === !0) ||
                rS(r.nodeValue, p)
              )),
              r || Vl(o);
          } else (r = fv(r).createTextNode(g)), (r[pn] = o), (o.stateNode = r);
        }
        return bi(o), null;
      case 13:
        if (
          ((g = o.memoizedState),
          r === null ||
            (r.memoizedState !== null && r.memoizedState.dehydrated !== null))
        ) {
          if (((x = Ou(o)), g !== null && g.dehydrated !== null)) {
            if (r === null) {
              if (!x) throw Error(n(318));
              if (
                ((x = o.memoizedState),
                (x = x !== null ? x.dehydrated : null),
                !x)
              )
                throw Error(n(317));
              x[pn] = o;
            } else
              Lu(),
                (o.flags & 128) === 0 && (o.memoizedState = null),
                (o.flags |= 4);
            bi(o), (x = !1);
          } else Nr !== null && (Yr(Nr), (Nr = null)), (x = !0);
          if (!x) return o.flags & 256 ? (Ms(o), o) : (Ms(o), null);
        }
        if ((Ms(o), (o.flags & 128) !== 0)) return (o.lanes = p), o;
        if (
          ((p = g !== null), (r = r !== null && r.memoizedState !== null), p)
        ) {
          (g = o.child),
            (x = null),
            g.alternate !== null &&
              g.alternate.memoizedState !== null &&
              g.alternate.memoizedState.cachePool !== null &&
              (x = g.alternate.memoizedState.cachePool.pool);
          var C = null;
          g.memoizedState !== null &&
            g.memoizedState.cachePool !== null &&
            (C = g.memoizedState.cachePool.pool),
            C !== x && (g.flags |= 2048);
        }
        return (
          p !== r && p && (o.child.flags |= 8192),
          Hr(o, o.updateQueue),
          bi(o),
          null
        );
      case 4:
        return Pe(), r === null && C_(o.stateNode.containerInfo), bi(o), null;
      case 10:
        return ho(o.type), bi(o), null;
      case 19:
        if ((it(Yi), (x = o.memoizedState), x === null)) return bi(o), null;
        if (((g = (o.flags & 128) !== 0), (C = x.rendering), C === null))
          if (g) cf(x, !1);
          else {
            if (vi !== 0 || (r !== null && (r.flags & 128) !== 0))
              for (r = o.child; r !== null; ) {
                if (((C = Iu(r)), C !== null)) {
                  for (
                    o.flags |= 128,
                      cf(x, !1),
                      r = C.updateQueue,
                      o.updateQueue = r,
                      Hr(o, r),
                      o.subtreeFlags = 0,
                      r = p,
                      p = o.child;
                    p !== null;

                  )
                    ml(p, r), (p = p.sibling);
                  return We(Yi, (Yi.current & 1) | 2), o.child;
                }
                r = r.sibling;
              }
            x.tail !== null &&
              Ee() > wn &&
              ((o.flags |= 128), (g = !0), cf(x, !1), (o.lanes = 4194304));
          }
        else {
          if (!g)
            if (((r = Iu(C)), r !== null)) {
              if (
                ((o.flags |= 128),
                (g = !0),
                (r = r.updateQueue),
                (o.updateQueue = r),
                Hr(o, r),
                cf(x, !0),
                x.tail === null &&
                  x.tailMode === "hidden" &&
                  !C.alternate &&
                  !Fn)
              )
                return bi(o), null;
            } else
              2 * Ee() - x.renderingStartTime > wn &&
                p !== 536870912 &&
                ((o.flags |= 128), (g = !0), cf(x, !1), (o.lanes = 4194304));
          x.isBackwards
            ? ((C.sibling = o.child), (o.child = C))
            : ((r = x.last),
              r !== null ? (r.sibling = C) : (o.child = C),
              (x.last = C));
        }
        return x.tail !== null
          ? ((o = x.tail),
            (x.rendering = o),
            (x.tail = o.sibling),
            (x.renderingStartTime = Ee()),
            (o.sibling = null),
            (r = Yi.current),
            We(Yi, g ? (r & 1) | 2 : r & 1),
            o)
          : (bi(o), null);
      case 22:
      case 23:
        return (
          Ms(o),
          Zc(),
          (g = o.memoizedState !== null),
          r !== null
            ? (r.memoizedState !== null) !== g && (o.flags |= 8192)
            : g && (o.flags |= 8192),
          g
            ? (p & 536870912) !== 0 &&
              (o.flags & 128) === 0 &&
              (bi(o), o.subtreeFlags & 6 && (o.flags |= 8192))
            : bi(o),
          (p = o.updateQueue),
          p !== null && Hr(o, p.retryQueue),
          (p = null),
          r !== null &&
            r.memoizedState !== null &&
            r.memoizedState.cachePool !== null &&
            (p = r.memoizedState.cachePool.pool),
          (g = null),
          o.memoizedState !== null &&
            o.memoizedState.cachePool !== null &&
            (g = o.memoizedState.cachePool.pool),
          g !== p && (o.flags |= 2048),
          r !== null && it(oo),
          null
        );
      case 24:
        return (
          (p = null),
          r !== null && (p = r.memoizedState.cache),
          o.memoizedState.cache !== p && (o.flags |= 2048),
          ho(Li),
          bi(o),
          null
        );
      case 25:
        return null;
    }
    throw Error(n(156, o.tag));
  }
  function Ri(r, o) {
    switch ((qo(o), o.tag)) {
      case 1:
        return (
          (r = o.flags), r & 65536 ? ((o.flags = (r & -65537) | 128), o) : null
        );
      case 3:
        return (
          ho(Li),
          Pe(),
          (r = o.flags),
          (r & 65536) !== 0 && (r & 128) === 0
            ? ((o.flags = (r & -65537) | 128), o)
            : null
        );
      case 26:
      case 27:
      case 5:
        return Ue(o), null;
      case 13:
        if (
          (Ms(o), (r = o.memoizedState), r !== null && r.dehydrated !== null)
        ) {
          if (o.alternate === null) throw Error(n(340));
          Lu();
        }
        return (
          (r = o.flags), r & 65536 ? ((o.flags = (r & -65537) | 128), o) : null
        );
      case 19:
        return it(Yi), null;
      case 4:
        return Pe(), null;
      case 10:
        return ho(o.type), null;
      case 22:
      case 23:
        return (
          Ms(o),
          Zc(),
          r !== null && it(oo),
          (r = o.flags),
          r & 65536 ? ((o.flags = (r & -65537) | 128), o) : null
        );
      case 24:
        return ho(Li), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function Ip(r, o) {
    switch ((qo(o), o.tag)) {
      case 3:
        ho(Li), Pe();
        break;
      case 26:
      case 27:
      case 5:
        Ue(o);
        break;
      case 4:
        Pe();
        break;
      case 13:
        Ms(o);
        break;
      case 19:
        it(Yi);
        break;
      case 10:
        ho(o.type);
        break;
      case 22:
      case 23:
        Ms(o), Zc(), r !== null && it(oo);
        break;
      case 24:
        ho(Li);
    }
  }
  var tu = {
      getCacheForType: function (r) {
        var o = Ta(Li),
          p = o.data.get(r);
        return p === void 0 && ((p = r()), o.data.set(r, p)), p;
      },
    },
    Ao = typeof WeakMap == "function" ? WeakMap : Map,
    un = 0,
    ti = null,
    bn = null,
    Zt = 0,
    ri = 0,
    kn = null,
    Hi = !1,
    Da = !1,
    yl = !1,
    xo = 0,
    vi = 0,
    fs = 0,
    Ds = 0,
    Zu = 0,
    Va = 0,
    Us = 0,
    ff = null,
    Rn = null,
    ni = !1,
    Sn = 0,
    wn = 1 / 0,
    $n = null,
    ji = null,
    Vr = !1,
    kr = null,
    nu = 0,
    hs = 0,
    Si = null,
    Xr = 0,
    So = null;
  function ka() {
    if ((un & 2) !== 0 && Zt !== 0) return Zt & -Zt;
    if (O.T !== null) {
      var r = Yl;
      return r !== 0 ? r : M_();
    }
    return Di();
  }
  function Mr() {
    Va === 0 && (Va = (Zt & 536870912) === 0 || Fn ? Nt() : 536870912);
    var r = nr.current;
    return r !== null && (r.flags |= 32), Va;
  }
  function Ki(r, o, p) {
    ((r === ti && ri === 2) || r.cancelPendingCommit !== null) &&
      (Mo(r, 0), br(r, Zt, Va, !1)),
      vn(r, p),
      ((un & 2) === 0 || r !== ti) &&
        (r === ti &&
          ((un & 2) === 0 && (Ds |= p), vi === 4 && br(r, Zt, Va, !1)),
        si(r));
  }
  function Qu(r, o, p) {
    if ((un & 6) !== 0) throw Error(n(327));
    var g = (!p && (o & 60) === 0 && (o & r.expiredLanes) === 0) || Ct(r, o),
      x = g ? c(r, o) : au(r, o, !0),
      C = g;
    do {
      if (x === 0) {
        Da && !g && br(r, o, 0, !1);
        break;
      } else if (x === 6) br(r, o, 0, !Hi);
      else {
        if (((p = r.current.alternate), C && !Fp(p))) {
          (x = au(r, o, !1)), (C = !1);
          continue;
        }
        if (x === 2) {
          if (((C = o), r.errorRecoveryDisabledLanes & C)) var G = 0;
          else
            (G = r.pendingLanes & -536870913),
              (G = G !== 0 ? G : G & 536870912 ? 536870912 : 0);
          if (G !== 0) {
            o = G;
            e: {
              var Q = r;
              x = ff;
              var he = Q.current.memoizedState.isDehydrated;
              if (
                (he && (Mo(Q, G).flags |= 256), (G = au(Q, G, !1)), G !== 2)
              ) {
                if (yl && !he) {
                  (Q.errorRecoveryDisabledLanes |= C), (Ds |= C), (x = 4);
                  break e;
                }
                (C = Rn), (Rn = x), C !== null && Yr(C);
              }
              x = G;
            }
            if (((C = !1), x !== 2)) continue;
          }
        }
        if (x === 1) {
          Mo(r, 0), br(r, o, 0, !0);
          break;
        }
        e: {
          switch (((g = r), x)) {
            case 0:
            case 1:
              throw Error(n(345));
            case 4:
              if ((o & 4194176) === o) {
                br(g, o, Va, !Hi);
                break e;
              }
              break;
            case 2:
              Rn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(n(329));
          }
          if (
            ((g.finishedWork = p),
            (g.finishedLanes = o),
            (o & 62914560) === o && ((C = Sn + 300 - Ee()), 10 < C))
          ) {
            if ((br(g, o, Va, !Hi), dt(g, 0) !== 0)) break e;
            g.timeoutHandle = lS(
              Gh.bind(null, g, p, Rn, $n, ni, o, Va, Ds, Us, Hi, 2, -0, 0),
              C
            );
            break e;
          }
          Gh(g, p, Rn, $n, ni, o, Va, Ds, Us, Hi, 0, -0, 0);
        }
      }
      break;
    } while (!0);
    si(r);
  }
  function Yr(r) {
    Rn === null ? (Rn = r) : Rn.push.apply(Rn, r);
  }
  function Gh(r, o, p, g, x, C, G, Q, he, Ce, ct, xt, ke) {
    var ot = o.subtreeFlags;
    if (
      (ot & 8192 || (ot & 16785408) === 16785408) &&
      ((kp = { stylesheets: null, count: 0, unsuspend: bC }),
      eu(o),
      (o = TC()),
      o !== null)
    ) {
      (r.cancelPendingCommit = o(
        _e.bind(null, r, p, g, x, G, Q, he, 1, xt, ke)
      )),
        br(r, C, G, !Ce);
      return;
    }
    _e(r, p, g, x, G, Q, he, ct, xt, ke);
  }
  function Fp(r) {
    for (var o = r; ; ) {
      var p = o.tag;
      if (
        (p === 0 || p === 11 || p === 15) &&
        o.flags & 16384 &&
        ((p = o.updateQueue), p !== null && ((p = p.stores), p !== null))
      )
        for (var g = 0; g < p.length; g++) {
          var x = p[g],
            C = x.getSnapshot;
          x = x.value;
          try {
            if (!Qa(C(), x)) return !1;
          } catch {
            return !1;
          }
        }
      if (((p = o.child), o.subtreeFlags & 16384 && p !== null))
        (p.return = o), (o = p);
      else {
        if (o === r) break;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === r) return !0;
          o = o.return;
        }
        (o.sibling.return = o.return), (o = o.sibling);
      }
    }
    return !0;
  }
  function br(r, o, p, g) {
    (o &= ~Zu),
      (o &= ~Ds),
      (r.suspendedLanes |= o),
      (r.pingedLanes &= ~o),
      g && (r.warmLanes |= o),
      (g = r.expirationTimes);
    for (var x = o; 0 < x; ) {
      var C = 31 - Be(x),
        G = 1 << C;
      (g[C] = -1), (x &= ~G);
    }
    p !== 0 && Bi(r, p, o);
  }
  function iu() {
    return (un & 6) === 0 ? (Bn(0), !1) : !0;
  }
  function Os() {
    if (bn !== null) {
      if (ri === 0) var r = bn.return;
      else (r = bn), (rs = Cs = null), _h(r), (Zo = null), (qc = 0), (r = bn);
      for (; r !== null; ) Ip(r.alternate, r), (r = r.return);
      bn = null;
    }
  }
  function Mo(r, o) {
    (r.finishedWork = null), (r.finishedLanes = 0);
    var p = r.timeoutHandle;
    p !== -1 && ((r.timeoutHandle = -1), lC(p)),
      (p = r.cancelPendingCommit),
      p !== null && ((r.cancelPendingCommit = null), p()),
      Os(),
      (ti = r),
      (bn = p = Ha(r.current, null)),
      (Zt = o),
      (ri = 0),
      (kn = null),
      (Hi = !1),
      (Da = Ct(r, o)),
      (yl = !1),
      (Us = Va = Zu = Ds = fs = vi = 0),
      (Rn = ff = null),
      (ni = !1),
      (o & 8) !== 0 && (o |= o & 32);
    var g = r.entangledLanes;
    if (g !== 0)
      for (r = r.entanglements, g &= o; 0 < g; ) {
        var x = 31 - Be(g),
          C = 1 << x;
        (o |= r[x]), (g &= ~C);
      }
    return (xo = o), zc(), p;
  }
  function _l(r, o) {
    (xn = null),
      (O.H = Ts),
      o === jo
        ? ((o = qn()), (ri = 3))
        : o === sp
        ? ((o = qn()), (ri = 4))
        : (ri =
            o === _r
              ? 8
              : o !== null &&
                typeof o == "object" &&
                typeof o.then == "function"
              ? 6
              : 1),
      (kn = o),
      bn === null && ((vi = 1), Rh(r, tr(o, r.current)));
  }
  function $u() {
    var r = O.H;
    return (O.H = Ts), r === null ? Ts : r;
  }
  function zh() {
    var r = O.A;
    return (O.A = tu), r;
  }
  function hf() {
    (vi = 4),
      Hi || ((Zt & 4194176) !== Zt && nr.current !== null) || (Da = !0),
      ((fs & 134217727) === 0 && (Ds & 134217727) === 0) ||
        ti === null ||
        br(ti, Zt, Va, !1);
  }
  function au(r, o, p) {
    var g = un;
    un |= 2;
    var x = $u(),
      C = zh();
    (ti !== r || Zt !== o) && (($n = null), Mo(r, o)), (o = !1);
    var G = vi;
    e: do
      try {
        if (ri !== 0 && bn !== null) {
          var Q = bn,
            he = kn;
          switch (ri) {
            case 8:
              Os(), (G = 6);
              break e;
            case 3:
            case 2:
            case 6:
              nr.current === null && (o = !0);
              var Ce = ri;
              if (((ri = 0), (kn = null), R(r, Q, he, Ce), p && Da)) {
                G = 0;
                break e;
              }
              break;
            default:
              (Ce = ri), (ri = 0), (kn = null), R(r, Q, he, Ce);
          }
        }
        Pp(), (G = vi);
        break;
      } catch (ct) {
        _l(r, ct);
      }
    while (!0);
    return (
      o && r.shellSuspendCounter++,
      (rs = Cs = null),
      (un = g),
      (O.H = x),
      (O.A = C),
      bn === null && ((ti = null), (Zt = 0), zc()),
      G
    );
  }
  function Pp() {
    for (; bn !== null; ) y(bn);
  }
  function c(r, o) {
    var p = un;
    un |= 2;
    var g = $u(),
      x = zh();
    ti !== r || Zt !== o
      ? (($n = null), (wn = Ee() + 500), Mo(r, o))
      : (Da = Ct(r, o));
    e: do
      try {
        if (ri !== 0 && bn !== null) {
          o = bn;
          var C = kn;
          t: switch (ri) {
            case 1:
              (ri = 0), (kn = null), R(r, o, C, 1);
              break;
            case 2:
              if (gg(C)) {
                (ri = 0), (kn = null), S(o);
                break;
              }
              (o = function () {
                ri === 2 && ti === r && (ri = 7), si(r);
              }),
                C.then(o, o);
              break e;
            case 3:
              ri = 7;
              break e;
            case 4:
              ri = 5;
              break e;
            case 7:
              gg(C)
                ? ((ri = 0), (kn = null), S(o))
                : ((ri = 0), (kn = null), R(r, o, C, 7));
              break;
            case 5:
              var G = null;
              switch (bn.tag) {
                case 26:
                  G = bn.memoizedState;
                case 5:
                case 27:
                  var Q = bn;
                  if (!G || _S(G)) {
                    (ri = 0), (kn = null);
                    var he = Q.sibling;
                    if (he !== null) bn = he;
                    else {
                      var Ce = Q.return;
                      Ce !== null ? ((bn = Ce), L(Ce)) : (bn = null);
                    }
                    break t;
                  }
              }
              (ri = 0), (kn = null), R(r, o, C, 5);
              break;
            case 6:
              (ri = 0), (kn = null), R(r, o, C, 6);
              break;
            case 8:
              Os(), (vi = 6);
              break e;
            default:
              throw Error(n(462));
          }
        }
        h();
        break;
      } catch (ct) {
        _l(r, ct);
      }
    while (!0);
    return (
      (rs = Cs = null),
      (O.H = g),
      (O.A = x),
      (un = p),
      bn !== null ? 0 : ((ti = null), (Zt = 0), zc(), vi)
    );
  }
  function h() {
    for (; bn !== null && !k(); ) y(bn);
  }
  function y(r) {
    var o = nf(r.alternate, r, xo);
    (r.memoizedProps = r.pendingProps), o === null ? L(r) : (bn = o);
  }
  function S(r) {
    var o = r,
      p = o.alternate;
    switch (o.tag) {
      case 15:
      case 0:
        o = nv(p, o, o.pendingProps, o.type, void 0, Zt);
        break;
      case 11:
        o = nv(p, o, o.pendingProps, o.type.render, o.ref, Zt);
        break;
      case 5:
        _h(o);
      default:
        Ip(p, o), (o = bn = ml(o, xo)), (o = nf(p, o, xo));
    }
    (r.memoizedProps = r.pendingProps), o === null ? L(r) : (bn = o);
  }
  function R(r, o, p, g) {
    (rs = Cs = null), _h(o), (Zo = null), (qc = 0);
    var x = o.return;
    try {
      if (A_(r, x, o, p, Zt)) {
        (vi = 1), Rh(r, tr(p, r.current)), (bn = null);
        return;
      }
    } catch (C) {
      if (x !== null) throw ((bn = x), C);
      (vi = 1), Rh(r, tr(p, r.current)), (bn = null);
      return;
    }
    o.flags & 32768
      ? (Fn || g === 1
          ? (r = !0)
          : Da || (Zt & 536870912) !== 0
          ? (r = !1)
          : ((Hi = r = !0),
            (g === 2 || g === 3 || g === 6) &&
              ((g = nr.current),
              g !== null && g.tag === 13 && (g.flags |= 16384))),
        ee(o, r))
      : L(o);
  }
  function L(r) {
    var o = r;
    do {
      if ((o.flags & 32768) !== 0) {
        ee(o, Hi);
        return;
      }
      r = o.return;
      var p = S_(o.alternate, o, xo);
      if (p !== null) {
        bn = p;
        return;
      }
      if (((o = o.sibling), o !== null)) {
        bn = o;
        return;
      }
      bn = o = r;
    } while (o !== null);
    vi === 0 && (vi = 5);
  }
  function ee(r, o) {
    do {
      var p = Ri(r.alternate, r);
      if (p !== null) {
        (p.flags &= 32767), (bn = p);
        return;
      }
      if (
        ((p = r.return),
        p !== null &&
          ((p.flags |= 32768), (p.subtreeFlags = 0), (p.deletions = null)),
        !o && ((r = r.sibling), r !== null))
      ) {
        bn = r;
        return;
      }
      bn = r = p;
    } while (r !== null);
    (vi = 6), (bn = null);
  }
  function _e(r, o, p, g, x, C, G, Q, he, Ce) {
    var ct = O.T,
      xt = j.p;
    try {
      (j.p = 2), (O.T = null), Le(r, o, p, g, xt, x, C, G, Q, he, Ce);
    } finally {
      (O.T = ct), (j.p = xt);
    }
  }
  function Le(r, o, p, g, x, C, G, Q) {
    do Et();
    while (kr !== null);
    if ((un & 6) !== 0) throw Error(n(327));
    var he = r.finishedWork;
    if (((g = r.finishedLanes), he === null)) return null;
    if (((r.finishedWork = null), (r.finishedLanes = 0), he === r.current))
      throw Error(n(177));
    (r.callbackNode = null),
      (r.callbackPriority = 0),
      (r.cancelPendingCommit = null);
    var Ce = he.lanes | he.childLanes;
    if (
      ((Ce |= $s),
      ai(r, g, Ce, C, G, Q),
      r === ti && ((bn = ti = null), (Zt = 0)),
      ((he.subtreeFlags & 10256) === 0 && (he.flags & 10256) === 0) ||
        Vr ||
        ((Vr = !0),
        (hs = Ce),
        (Si = p),
        De(Ke, function () {
          return Et(), null;
        })),
      (p = (he.flags & 15990) !== 0),
      (he.subtreeFlags & 15990) !== 0 || p
        ? ((p = O.T),
          (O.T = null),
          (C = j.p),
          (j.p = 2),
          (G = un),
          (un |= 4),
          Ju(r, he),
          $l(he, r),
          ep(D_, r.containerInfo),
          (vv = !!B_),
          (D_ = B_ = null),
          (r.current = he),
          qu(r, he.alternate, he),
          de(),
          (un = G),
          (j.p = C),
          (O.T = p))
        : (r.current = he),
      Vr ? ((Vr = !1), (kr = r), (nu = g)) : ut(r, Ce),
      (Ce = r.pendingLanes),
      Ce === 0 && (ji = null),
      Ze(he.stateNode),
      si(r),
      o !== null)
    )
      for (x = r.onRecoverableError, he = 0; he < o.length; he++)
        (Ce = o[he]), x(Ce.value, { componentStack: Ce.stack });
    return (
      (nu & 3) !== 0 && Et(),
      (Ce = r.pendingLanes),
      (g & 4194218) !== 0 && (Ce & 42) !== 0
        ? r === So
          ? Xr++
          : ((Xr = 0), (So = r))
        : (Xr = 0),
      Bn(0),
      null
    );
  }
  function ut(r, o) {
    (r.pooledCacheLanes &= o) === 0 &&
      ((o = r.pooledCache), o != null && ((r.pooledCache = null), $o(o)));
  }
  function Et() {
    if (kr !== null) {
      var r = kr,
        o = hs;
      hs = 0;
      var p = di(nu),
        g = O.T,
        x = j.p;
      try {
        if (((j.p = 32 > p ? 32 : p), (O.T = null), kr === null)) var C = !1;
        else {
          (p = Si), (Si = null);
          var G = kr,
            Q = nu;
          if (((kr = null), (nu = 0), (un & 6) !== 0)) throw Error(n(331));
          var he = un;
          if (
            ((un |= 4),
            ju(G.current),
            go(G, G.current, Q, p),
            (un = he),
            Bn(0, !1),
            nt && typeof nt.onPostCommitFiberRoot == "function")
          )
            try {
              nt.onPostCommitFiberRoot(mt, G);
            } catch {}
          C = !0;
        }
        return C;
      } finally {
        (j.p = x), (O.T = g), ut(r, o);
      }
    }
    return !1;
  }
  function Ot(r, o, p) {
    (o = tr(p, o)),
      (o = Sp(r.stateNode, o, 2)),
      (r = Sr(r, o, 2)),
      r !== null && (vn(r, 2), si(r));
  }
  function bt(r, o, p) {
    if (r.tag === 3) Ot(r, r, p);
    else
      for (; o !== null; ) {
        if (o.tag === 3) {
          Ot(o, r, p);
          break;
        } else if (o.tag === 1) {
          var g = o.stateNode;
          if (
            typeof o.type.getDerivedStateFromError == "function" ||
            (typeof g.componentDidCatch == "function" &&
              (ji === null || !ji.has(g)))
          ) {
            (r = tr(p, r)),
              (p = Mp(2)),
              (g = Sr(o, p, 2)),
              g !== null && (ev(p, g, o, r), vn(g, 2), si(g));
            break;
          }
        }
        o = o.return;
      }
  }
  function cn(r, o, p) {
    var g = r.pingCache;
    if (g === null) {
      g = r.pingCache = new Ao();
      var x = new Set();
      g.set(o, x);
    } else (x = g.get(o)), x === void 0 && ((x = new Set()), g.set(o, x));
    x.has(p) ||
      ((yl = !0), x.add(p), (r = Wr.bind(null, r, o, p)), o.then(r, r));
  }
  function Wr(r, o, p) {
    var g = r.pingCache;
    g !== null && g.delete(o),
      (r.pingedLanes |= r.suspendedLanes & p),
      (r.warmLanes &= ~p),
      ti === r &&
        (Zt & p) === p &&
        (vi === 4 || (vi === 3 && (Zt & 62914560) === Zt && 300 > Ee() - Sn)
          ? (un & 2) === 0 && Mo(r, 0)
          : (Zu |= p),
        Us === Zt && (Us = 0)),
      si(r);
  }
  function ec(r, o) {
    o === 0 && (o = Ft()), (r = eo(r, o)), r !== null && (vn(r, o), si(r));
  }
  function ru(r) {
    var o = r.memoizedState,
      p = 0;
    o !== null && (p = o.retryLane), ec(r, p);
  }
  function ze(r, o) {
    var p = 0;
    switch (r.tag) {
      case 13:
        var g = r.stateNode,
          x = r.memoizedState;
        x !== null && (p = x.retryLane);
        break;
      case 19:
        g = r.stateNode;
        break;
      case 22:
        g = r.stateNode._retryCache;
        break;
      default:
        throw Error(n(314));
    }
    g !== null && g.delete(o), ec(r, p);
  }
  function De(r, o) {
    return Ve(r, o);
  }
  var Xe = null,
    Mt = null,
    Wt = !1,
    ii = !1,
    tn = !1,
    En = 0;
  function si(r) {
    r !== Mt &&
      r.next === null &&
      (Mt === null ? (Xe = Mt = r) : (Mt = Mt.next = r)),
      (ii = !0),
      Wt || ((Wt = !0), $2(Al));
  }
  function Bn(r, o) {
    if (!tn && ii) {
      tn = !0;
      do
        for (var p = !1, g = Xe; g !== null; ) {
          if (r !== 0) {
            var x = g.pendingLanes;
            if (x === 0) var C = 0;
            else {
              var G = g.suspendedLanes,
                Q = g.pingedLanes;
              (C = (1 << (31 - Be(42 | r) + 1)) - 1),
                (C &= x & ~(G & ~Q)),
                (C = C & 201326677 ? (C & 201326677) | 1 : C ? C | 2 : 0);
            }
            C !== 0 && ((p = !0), Qx(g, C));
          } else
            (C = Zt),
              (C = dt(g, g === ti ? C : 0)),
              (C & 3) === 0 || Ct(g, C) || ((p = !0), Qx(g, C));
          g = g.next;
        }
      while (p);
      tn = !1;
    }
  }
  function Al() {
    ii = Wt = !1;
    var r = 0;
    En !== 0 && (oC() && (r = En), (En = 0));
    for (var o = Ee(), p = null, g = Xe; g !== null; ) {
      var x = g.next,
        C = ov(g, o);
      C === 0
        ? ((g.next = null),
          p === null ? (Xe = x) : (p.next = x),
          x === null && (Mt = p))
        : ((p = g), (r !== 0 || (C & 3) !== 0) && (ii = !0)),
        (g = x);
    }
    Bn(r);
  }
  function ov(r, o) {
    for (
      var p = r.suspendedLanes,
        g = r.pingedLanes,
        x = r.expirationTimes,
        C = r.pendingLanes & -62914561;
      0 < C;

    ) {
      var G = 31 - Be(C),
        Q = 1 << G,
        he = x[G];
      he === -1
        ? ((Q & p) === 0 || (Q & g) !== 0) && (x[G] = Ht(Q, o))
        : he <= o && (r.expiredLanes |= Q),
        (C &= ~Q);
    }
    if (
      ((o = ti),
      (p = Zt),
      (p = dt(r, r === o ? p : 0)),
      (g = r.callbackNode),
      p === 0 || (r === o && ri === 2) || r.cancelPendingCommit !== null)
    )
      return (
        g !== null && g !== null && X(g),
        (r.callbackNode = null),
        (r.callbackPriority = 0)
      );
    if ((p & 3) === 0 || Ct(r, p)) {
      if (((o = p & -p), o === r.callbackPriority)) return o;
      switch ((g !== null && X(g), di(p))) {
        case 2:
        case 8:
          p = tt;
          break;
        case 32:
          p = Ke;
          break;
        case 268435456:
          p = Ut;
          break;
        default:
          p = Ke;
      }
      return (
        (g = Zx.bind(null, r)),
        (p = Ve(p, g)),
        (r.callbackPriority = o),
        (r.callbackNode = p),
        o
      );
    }
    return (
      g !== null && g !== null && X(g),
      (r.callbackPriority = 2),
      (r.callbackNode = null),
      2
    );
  }
  function Zx(r, o) {
    var p = r.callbackNode;
    if (Et() && r.callbackNode !== p) return null;
    var g = Zt;
    return (
      (g = dt(r, r === ti ? g : 0)),
      g === 0
        ? null
        : (Qu(r, g, o),
          ov(r, Ee()),
          r.callbackNode != null && r.callbackNode === p
            ? Zx.bind(null, r)
            : null)
    );
  }
  function Qx(r, o) {
    if (Et()) return null;
    Qu(r, o, !0);
  }
  function $2(r) {
    uC(function () {
      (un & 6) !== 0 ? Ve(He, r) : r();
    });
  }
  function M_() {
    return En === 0 && (En = Nt()), En;
  }
  function $x(r) {
    return r == null || typeof r == "symbol" || typeof r == "boolean"
      ? null
      : typeof r == "function"
      ? r
      : wr("" + r);
  }
  function eS(r, o) {
    var p = o.ownerDocument.createElement("input");
    return (
      (p.name = o.name),
      (p.value = o.value),
      r.id && p.setAttribute("form", r.id),
      o.parentNode.insertBefore(p, o),
      (r = new FormData(r)),
      p.parentNode.removeChild(p),
      r
    );
  }
  function eC(r, o, p, g, x) {
    if (o === "submit" && p && p.stateNode === x) {
      var C = $x((x[en] || null).action),
        G = g.submitter;
      G &&
        ((o = (o = G[en] || null)
          ? $x(o.formAction)
          : G.getAttribute("formAction")),
        o !== null && ((C = o), (G = null)));
      var Q = new Ia("action", "action", null, g, x);
      r.push({
        event: Q,
        listeners: [
          {
            instance: null,
            listener: function () {
              if (g.defaultPrevented) {
                if (En !== 0) {
                  var he = G ? eS(x, G) : new FormData(x);
                  vp(
                    p,
                    { pending: !0, data: he, method: x.method, action: C },
                    null,
                    he
                  );
                }
              } else
                typeof C == "function" &&
                  (Q.preventDefault(),
                  (he = G ? eS(x, G) : new FormData(x)),
                  vp(
                    p,
                    { pending: !0, data: he, method: x.method, action: C },
                    C,
                    he
                  ));
            },
            currentTarget: x,
          },
        ],
      });
    }
  }
  for (var b_ = 0; b_ < Qs.length; b_++) {
    var E_ = Qs[b_],
      tC = E_.toLowerCase(),
      nC = E_[0].toUpperCase() + E_.slice(1);
    Lr(tC, "on" + nC);
  }
  Lr(ip, "onAnimationEnd"),
    Lr(er, "onAnimationIteration"),
    Lr(ap, "onAnimationStart"),
    Lr("dblclick", "onDoubleClick"),
    Lr("focusin", "onFocus"),
    Lr("focusout", "onBlur"),
    Lr(Zs, "onTransitionRun"),
    Lr(Uu, "onTransitionStart"),
    Lr(Yo, "onTransitionCancel"),
    Lr(hh, "onTransitionEnd"),
    lt("onMouseEnter", ["mouseout", "mouseover"]),
    lt("onMouseLeave", ["mouseout", "mouseover"]),
    lt("onPointerEnter", ["pointerout", "pointerover"]),
    lt("onPointerLeave", ["pointerout", "pointerover"]),
    Ye(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ),
    Ye(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ),
    Ye("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    Ye(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ),
    Ye(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ),
    Ye(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
  var Gp =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ),
    iC = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle"
        .split(" ")
        .concat(Gp)
    );
  function tS(r, o) {
    o = (o & 4) !== 0;
    for (var p = 0; p < r.length; p++) {
      var g = r[p],
        x = g.event;
      g = g.listeners;
      e: {
        var C = void 0;
        if (o)
          for (var G = g.length - 1; 0 <= G; G--) {
            var Q = g[G],
              he = Q.instance,
              Ce = Q.currentTarget;
            if (((Q = Q.listener), he !== C && x.isPropagationStopped()))
              break e;
            (C = Q), (x.currentTarget = Ce);
            try {
              C(x);
            } catch (ct) {
              Ch(ct);
            }
            (x.currentTarget = null), (C = he);
          }
        else
          for (G = 0; G < g.length; G++) {
            if (
              ((Q = g[G]),
              (he = Q.instance),
              (Ce = Q.currentTarget),
              (Q = Q.listener),
              he !== C && x.isPropagationStopped())
            )
              break e;
            (C = Q), (x.currentTarget = Ce);
            try {
              C(x);
            } catch (ct) {
              Ch(ct);
            }
            (x.currentTarget = null), (C = he);
          }
      }
    }
  }
  function Gn(r, o) {
    var p = o[te];
    p === void 0 && (p = o[te] = new Set());
    var g = r + "__bubble";
    p.has(g) || (nS(o, r, 2, !1), p.add(g));
  }
  function T_(r, o, p) {
    var g = 0;
    o && (g |= 4), nS(p, r, g, o);
  }
  var lv = "_reactListening" + Math.random().toString(36).slice(2);
  function C_(r) {
    if (!r[lv]) {
      (r[lv] = !0),
        Se.forEach(function (p) {
          p !== "selectionchange" && (iC.has(p) || T_(p, !1, r), T_(p, !0, r));
        });
      var o = r.nodeType === 9 ? r : r.ownerDocument;
      o === null || o[lv] || ((o[lv] = !0), T_("selectionchange", !1, o));
    }
  }
  function nS(r, o, p, g) {
    switch (ES(o)) {
      case 2:
        var x = wC;
        break;
      case 8:
        x = BC;
        break;
      default:
        x = z_;
    }
    (p = x.bind(null, o, p, r)),
      (x = void 0),
      !Vs ||
        (o !== "touchstart" && o !== "touchmove" && o !== "wheel") ||
        (x = !0),
      g
        ? x !== void 0
          ? r.addEventListener(o, p, { capture: !0, passive: x })
          : r.addEventListener(o, p, !0)
        : x !== void 0
        ? r.addEventListener(o, p, { passive: x })
        : r.addEventListener(o, p, !1);
  }
  function R_(r, o, p, g, x) {
    var C = g;
    if ((o & 1) === 0 && (o & 2) === 0 && g !== null)
      e: for (;;) {
        if (g === null) return;
        var G = g.tag;
        if (G === 3 || G === 4) {
          var Q = g.stateNode.containerInfo;
          if (Q === x || (Q.nodeType === 8 && Q.parentNode === x)) break;
          if (G === 4)
            for (G = g.return; G !== null; ) {
              var he = G.tag;
              if (
                (he === 3 || he === 4) &&
                ((he = G.stateNode.containerInfo),
                he === x || (he.nodeType === 8 && he.parentNode === x))
              )
                return;
              G = G.return;
            }
          for (; Q !== null; ) {
            if (((G = yt(Q)), G === null)) return;
            if (
              ((he = G.tag), he === 5 || he === 6 || he === 26 || he === 27)
            ) {
              g = C = G;
              continue e;
            }
            Q = Q.parentNode;
          }
        }
        g = g.return;
      }
    Eu(function () {
      var Ce = C,
        ct = es(p),
        xt = [];
      e: {
        var ke = dh.get(r);
        if (ke !== void 0) {
          var ot = Ia,
            Jt = r;
          switch (r) {
            case "keypress":
              if (Br(p) === 0) break e;
            case "keydown":
            case "keyup":
              ot = Xd;
              break;
            case "focusin":
              (Jt = "focus"), (ot = Js);
              break;
            case "focusout":
              (Jt = "blur"), (ot = Js);
              break;
            case "beforeblur":
            case "afterblur":
              ot = Js;
              break;
            case "click":
              if (p.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              ot = Nl;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              ot = Vd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              ot = Wd;
              break;
            case ip:
            case er:
            case ap:
              ot = ih;
              break;
            case hh:
              ot = qs;
              break;
            case "scroll":
            case "scrollend":
              ot = Cu;
              break;
            case "wheel":
              ot = f_;
              break;
            case "copy":
            case "cut":
            case "paste":
              ot = Ka;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              ot = ah;
              break;
            case "toggle":
            case "beforetoggle":
              ot = Ho;
          }
          var fn = (o & 4) !== 0,
            Zi = !fn && (r === "scroll" || r === "scrollend"),
            Oe = fn ? (ke !== null ? ke + "Capture" : null) : ke;
          fn = [];
          for (var Te = Ce, Fe; Te !== null; ) {
            var _t = Te;
            if (
              ((Fe = _t.stateNode),
              (_t = _t.tag),
              (_t !== 5 && _t !== 26 && _t !== 27) ||
                Fe === null ||
                Oe === null ||
                ((_t = ts(Te, Oe)), _t != null && fn.push(zp(Te, _t, Fe))),
              Zi)
            )
              break;
            Te = Te.return;
          }
          0 < fn.length &&
            ((ke = new ot(ke, Jt, null, p, ct)),
            xt.push({ event: ke, listeners: fn }));
        }
      }
      if ((o & 7) === 0) {
        e: {
          if (
            ((ke = r === "mouseover" || r === "pointerover"),
            (ot = r === "mouseout" || r === "pointerout"),
            ke &&
              p !== $r &&
              (Jt = p.relatedTarget || p.fromElement) &&
              (yt(Jt) || Jt[H]))
          )
            break e;
          if (
            (ot || ke) &&
            ((ke =
              ct.window === ct
                ? ct
                : (ke = ct.ownerDocument)
                ? ke.defaultView || ke.parentWindow
                : window),
            ot
              ? ((Jt = p.relatedTarget || p.toElement),
                (ot = Ce),
                (Jt = Jt ? yt(Jt) : null),
                Jt !== null &&
                  ((Zi = oe(Jt)),
                  (fn = Jt.tag),
                  Jt !== Zi || (fn !== 5 && fn !== 27 && fn !== 6)) &&
                  (Jt = null))
              : ((ot = null), (Jt = Ce)),
            ot !== Jt)
          ) {
            if (
              ((fn = Nl),
              (_t = "onMouseLeave"),
              (Oe = "onMouseEnter"),
              (Te = "mouse"),
              (r === "pointerout" || r === "pointerover") &&
                ((fn = ah),
                (_t = "onPointerLeave"),
                (Oe = "onPointerEnter"),
                (Te = "pointer")),
              (Zi = ot == null ? ke : re(ot)),
              (Fe = Jt == null ? ke : re(Jt)),
              (ke = new fn(_t, Te + "leave", ot, p, ct)),
              (ke.target = Zi),
              (ke.relatedTarget = Fe),
              (_t = null),
              yt(ct) === Ce &&
                ((fn = new fn(Oe, Te + "enter", Jt, p, ct)),
                (fn.target = Fe),
                (fn.relatedTarget = Zi),
                (_t = fn)),
              (Zi = _t),
              ot && Jt)
            )
              t: {
                for (fn = ot, Oe = Jt, Te = 0, Fe = fn; Fe; Fe = Hh(Fe)) Te++;
                for (Fe = 0, _t = Oe; _t; _t = Hh(_t)) Fe++;
                for (; 0 < Te - Fe; ) (fn = Hh(fn)), Te--;
                for (; 0 < Fe - Te; ) (Oe = Hh(Oe)), Fe--;
                for (; Te--; ) {
                  if (fn === Oe || (Oe !== null && fn === Oe.alternate))
                    break t;
                  (fn = Hh(fn)), (Oe = Hh(Oe));
                }
                fn = null;
              }
            else fn = null;
            ot !== null && iS(xt, ke, ot, fn, !1),
              Jt !== null && Zi !== null && iS(xt, Zi, Jt, fn, !0);
          }
        }
        e: {
          if (
            ((ke = Ce ? re(Ce) : window),
            (ot = ke.nodeName && ke.nodeName.toLowerCase()),
            ot === "select" || (ot === "input" && ke.type === "file"))
          )
            var kt = sh;
          else if (Kd(ke))
            if (oh) kt = Xo;
            else {
              kt = hg;
              var Dn = h_;
            }
          else
            (ot = ke.nodeName),
              !ot ||
              ot.toLowerCase() !== "input" ||
              (ke.type !== "checkbox" && ke.type !== "radio")
                ? Ce && Qr(Ce.elementType) && (kt = sh)
                : (kt = Pc);
          if (kt && (kt = kt(r, Ce))) {
            Za(xt, kt, p, ct);
            break e;
          }
          Dn && Dn(r, ke, Ce),
            r === "focusout" &&
              Ce &&
              ke.type === "number" &&
              Ce.memoizedProps.value != null &&
              Tn(ke, "number", ke.value);
        }
        switch (((Dn = Ce ? re(Ce) : window), r)) {
          case "focusin":
            (Kd(Dn) || Dn.contentEditable === "true") &&
              ((Pl = Dn), (tp = Ce), (Du = null));
            break;
          case "focusout":
            Du = tp = Pl = null;
            break;
          case "mousedown":
            ch = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (ch = !1), Or(xt, p, ct);
            break;
          case "selectionchange":
            if (uh) break;
          case "keydown":
          case "keyup":
            Or(xt, p, ct);
        }
        var Kt;
        if (Uc)
          e: {
            switch (r) {
              case "compositionstart":
                var an = "onCompositionStart";
                break e;
              case "compositionend":
                an = "onCompositionEnd";
                break e;
              case "compositionupdate":
                an = "onCompositionUpdate";
                break e;
            }
            an = void 0;
          }
        else
          ko
            ? Nc(r, p) && (an = "onCompositionEnd")
            : r === "keydown" &&
              p.keyCode === 229 &&
              (an = "onCompositionStart");
        an &&
          (Lc &&
            p.locale !== "ko" &&
            (ko || an !== "onCompositionStart"
              ? an === "onCompositionEnd" && ko && (Kt = Tu())
              : ((Ui = ct),
                (Ol = "value" in Ui ? Ui.value : Ui.textContent),
                (ko = !0))),
          (Dn = uv(Ce, an)),
          0 < Dn.length &&
            ((an = new gr(an, r, null, p, ct)),
            xt.push({ event: an, listeners: Dn }),
            Kt
              ? (an.data = Kt)
              : ((Kt = qd(p)), Kt !== null && (an.data = Kt)))),
          (Kt = Oc ? Ic(r, p) : jd(r, p)) &&
            ((an = uv(Ce, "onBeforeInput")),
            0 < an.length &&
              ((Dn = new gr("onBeforeInput", "beforeinput", null, p, ct)),
              xt.push({ event: Dn, listeners: an }),
              (Dn.data = Kt))),
          eC(xt, r, Ce, p, ct);
      }
      tS(xt, o);
    });
  }
  function zp(r, o, p) {
    return { instance: r, listener: o, currentTarget: p };
  }
  function uv(r, o) {
    for (var p = o + "Capture", g = []; r !== null; ) {
      var x = r,
        C = x.stateNode;
      (x = x.tag),
        (x !== 5 && x !== 26 && x !== 27) ||
          C === null ||
          ((x = ts(r, p)),
          x != null && g.unshift(zp(r, x, C)),
          (x = ts(r, o)),
          x != null && g.push(zp(r, x, C))),
        (r = r.return);
    }
    return g;
  }
  function Hh(r) {
    if (r === null) return null;
    do r = r.return;
    while (r && r.tag !== 5 && r.tag !== 27);
    return r || null;
  }
  function iS(r, o, p, g, x) {
    for (var C = o._reactName, G = []; p !== null && p !== g; ) {
      var Q = p,
        he = Q.alternate,
        Ce = Q.stateNode;
      if (((Q = Q.tag), he !== null && he === g)) break;
      (Q !== 5 && Q !== 26 && Q !== 27) ||
        Ce === null ||
        ((he = Ce),
        x
          ? ((Ce = ts(p, C)), Ce != null && G.unshift(zp(p, Ce, he)))
          : x || ((Ce = ts(p, C)), Ce != null && G.push(zp(p, Ce, he)))),
        (p = p.return);
    }
    G.length !== 0 && r.push({ event: o, listeners: G });
  }
  var aC = /\r\n?/g,
    rC = /\u0000|\uFFFD/g;
  function aS(r) {
    return (typeof r == "string" ? r : "" + r)
      .replace(
        aC,
        `
`
      )
      .replace(rC, "");
  }
  function rS(r, o) {
    return (o = aS(o)), aS(r) === o;
  }
  function cv() {}
  function hi(r, o, p, g, x, C) {
    switch (p) {
      case "children":
        typeof g == "string"
          ? o === "body" || (o === "textarea" && g === "") || ea(r, g)
          : (typeof g == "number" || typeof g == "bigint") &&
            o !== "body" &&
            ea(r, "" + g);
        break;
      case "className":
        yn(r, "class", g);
        break;
      case "tabIndex":
        yn(r, "tabindex", g);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        yn(r, p, g);
        break;
      case "style":
        Dl(r, g, C);
        break;
      case "data":
        if (o !== "object") {
          yn(r, "data", g);
          break;
        }
      case "src":
      case "href":
        if (g === "" && (o !== "a" || p !== "href")) {
          r.removeAttribute(p);
          break;
        }
        if (
          g == null ||
          typeof g == "function" ||
          typeof g == "symbol" ||
          typeof g == "boolean"
        ) {
          r.removeAttribute(p);
          break;
        }
        (g = wr("" + g)), r.setAttribute(p, g);
        break;
      case "action":
      case "formAction":
        if (typeof g == "function") {
          r.setAttribute(
            p,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof C == "function" &&
            (p === "formAction"
              ? (o !== "input" && hi(r, o, "name", x.name, x, null),
                hi(r, o, "formEncType", x.formEncType, x, null),
                hi(r, o, "formMethod", x.formMethod, x, null),
                hi(r, o, "formTarget", x.formTarget, x, null))
              : (hi(r, o, "encType", x.encType, x, null),
                hi(r, o, "method", x.method, x, null),
                hi(r, o, "target", x.target, x, null)));
        if (g == null || typeof g == "symbol" || typeof g == "boolean") {
          r.removeAttribute(p);
          break;
        }
        (g = wr("" + g)), r.setAttribute(p, g);
        break;
      case "onClick":
        g != null && (r.onclick = cv);
        break;
      case "onScroll":
        g != null && Gn("scroll", r);
        break;
      case "onScrollEnd":
        g != null && Gn("scrollend", r);
        break;
      case "dangerouslySetInnerHTML":
        if (g != null) {
          if (typeof g != "object" || !("__html" in g)) throw Error(n(61));
          if (((p = g.__html), p != null)) {
            if (x.children != null) throw Error(n(60));
            r.innerHTML = p;
          }
        }
        break;
      case "multiple":
        r.multiple = g && typeof g != "function" && typeof g != "symbol";
        break;
      case "muted":
        r.muted = g && typeof g != "function" && typeof g != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (
          g == null ||
          typeof g == "function" ||
          typeof g == "boolean" ||
          typeof g == "symbol"
        ) {
          r.removeAttribute("xlink:href");
          break;
        }
        (p = wr("" + g)),
          r.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", p);
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        g != null && typeof g != "function" && typeof g != "symbol"
          ? r.setAttribute(p, "" + g)
          : r.removeAttribute(p);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        g && typeof g != "function" && typeof g != "symbol"
          ? r.setAttribute(p, "")
          : r.removeAttribute(p);
        break;
      case "capture":
      case "download":
        g === !0
          ? r.setAttribute(p, "")
          : g !== !1 &&
            g != null &&
            typeof g != "function" &&
            typeof g != "symbol"
          ? r.setAttribute(p, g)
          : r.removeAttribute(p);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        g != null &&
        typeof g != "function" &&
        typeof g != "symbol" &&
        !isNaN(g) &&
        1 <= g
          ? r.setAttribute(p, g)
          : r.removeAttribute(p);
        break;
      case "rowSpan":
      case "start":
        g == null || typeof g == "function" || typeof g == "symbol" || isNaN(g)
          ? r.removeAttribute(p)
          : r.setAttribute(p, g);
        break;
      case "popover":
        Gn("beforetoggle", r), Gn("toggle", r), Pt(r, "popover", g);
        break;
      case "xlinkActuate":
        Vt(r, "http://www.w3.org/1999/xlink", "xlink:actuate", g);
        break;
      case "xlinkArcrole":
        Vt(r, "http://www.w3.org/1999/xlink", "xlink:arcrole", g);
        break;
      case "xlinkRole":
        Vt(r, "http://www.w3.org/1999/xlink", "xlink:role", g);
        break;
      case "xlinkShow":
        Vt(r, "http://www.w3.org/1999/xlink", "xlink:show", g);
        break;
      case "xlinkTitle":
        Vt(r, "http://www.w3.org/1999/xlink", "xlink:title", g);
        break;
      case "xlinkType":
        Vt(r, "http://www.w3.org/1999/xlink", "xlink:type", g);
        break;
      case "xmlBase":
        Vt(r, "http://www.w3.org/XML/1998/namespace", "xml:base", g);
        break;
      case "xmlLang":
        Vt(r, "http://www.w3.org/XML/1998/namespace", "xml:lang", g);
        break;
      case "xmlSpace":
        Vt(r, "http://www.w3.org/XML/1998/namespace", "xml:space", g);
        break;
      case "is":
        Pt(r, "is", g);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < p.length) ||
          (p[0] !== "o" && p[0] !== "O") ||
          (p[1] !== "n" && p[1] !== "N")) &&
          ((p = Rc.get(p) || p), Pt(r, p, g));
    }
  }
  function w_(r, o, p, g, x, C) {
    switch (p) {
      case "style":
        Dl(r, g, C);
        break;
      case "dangerouslySetInnerHTML":
        if (g != null) {
          if (typeof g != "object" || !("__html" in g)) throw Error(n(61));
          if (((p = g.__html), p != null)) {
            if (x.children != null) throw Error(n(60));
            r.innerHTML = p;
          }
        }
        break;
      case "children":
        typeof g == "string"
          ? ea(r, g)
          : (typeof g == "number" || typeof g == "bigint") && ea(r, "" + g);
        break;
      case "onScroll":
        g != null && Gn("scroll", r);
        break;
      case "onScrollEnd":
        g != null && Gn("scrollend", r);
        break;
      case "onClick":
        g != null && (r.onclick = cv);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Ne.hasOwnProperty(p))
          e: {
            if (
              p[0] === "o" &&
              p[1] === "n" &&
              ((x = p.endsWith("Capture")),
              (o = p.slice(2, x ? p.length - 7 : void 0)),
              (C = r[en] || null),
              (C = C != null ? C[p] : null),
              typeof C == "function" && r.removeEventListener(o, C, x),
              typeof g == "function")
            ) {
              typeof C != "function" &&
                C !== null &&
                (p in r
                  ? (r[p] = null)
                  : r.hasAttribute(p) && r.removeAttribute(p)),
                r.addEventListener(o, g, x);
              break e;
            }
            p in r
              ? (r[p] = g)
              : g === !0
              ? r.setAttribute(p, "")
              : Pt(r, p, g);
          }
    }
  }
  function Xa(r, o, p) {
    switch (o) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Gn("error", r), Gn("load", r);
        var g = !1,
          x = !1,
          C;
        for (C in p)
          if (p.hasOwnProperty(C)) {
            var G = p[C];
            if (G != null)
              switch (C) {
                case "src":
                  g = !0;
                  break;
                case "srcSet":
                  x = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(n(137, o));
                default:
                  hi(r, o, C, G, p, null);
              }
          }
        x && hi(r, o, "srcSet", p.srcSet, p, null),
          g && hi(r, o, "src", p.src, p, null);
        return;
      case "input":
        Gn("invalid", r);
        var Q = (C = G = x = null),
          he = null,
          Ce = null;
        for (g in p)
          if (p.hasOwnProperty(g)) {
            var ct = p[g];
            if (ct != null)
              switch (g) {
                case "name":
                  x = ct;
                  break;
                case "type":
                  G = ct;
                  break;
                case "checked":
                  he = ct;
                  break;
                case "defaultChecked":
                  Ce = ct;
                  break;
                case "value":
                  C = ct;
                  break;
                case "defaultValue":
                  Q = ct;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ct != null) throw Error(n(137, o));
                  break;
                default:
                  hi(r, o, g, ct, p, null);
              }
          }
        Zn(r, C, Q, he, Ce, G, x, !1), qt(r);
        return;
      case "select":
        Gn("invalid", r), (g = G = C = null);
        for (x in p)
          if (p.hasOwnProperty(x) && ((Q = p[x]), Q != null))
            switch (x) {
              case "value":
                C = Q;
                break;
              case "defaultValue":
                G = Q;
                break;
              case "multiple":
                g = Q;
              default:
                hi(r, o, x, Q, p, null);
            }
        (o = C),
          (p = G),
          (r.multiple = !!g),
          o != null ? Nn(r, !!g, o, !1) : p != null && Nn(r, !!g, p, !0);
        return;
      case "textarea":
        Gn("invalid", r), (C = x = g = null);
        for (G in p)
          if (p.hasOwnProperty(G) && ((Q = p[G]), Q != null))
            switch (G) {
              case "value":
                g = Q;
                break;
              case "defaultValue":
                x = Q;
                break;
              case "children":
                C = Q;
                break;
              case "dangerouslySetInnerHTML":
                if (Q != null) throw Error(n(91));
                break;
              default:
                hi(r, o, G, Q, p, null);
            }
        Sa(r, g, x, C), qt(r);
        return;
      case "option":
        for (he in p)
          if (p.hasOwnProperty(he) && ((g = p[he]), g != null))
            switch (he) {
              case "selected":
                r.selected =
                  g && typeof g != "function" && typeof g != "symbol";
                break;
              default:
                hi(r, o, he, g, p, null);
            }
        return;
      case "dialog":
        Gn("cancel", r), Gn("close", r);
        break;
      case "iframe":
      case "object":
        Gn("load", r);
        break;
      case "video":
      case "audio":
        for (g = 0; g < Gp.length; g++) Gn(Gp[g], r);
        break;
      case "image":
        Gn("error", r), Gn("load", r);
        break;
      case "details":
        Gn("toggle", r);
        break;
      case "embed":
      case "source":
      case "link":
        Gn("error", r), Gn("load", r);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (Ce in p)
          if (p.hasOwnProperty(Ce) && ((g = p[Ce]), g != null))
            switch (Ce) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(n(137, o));
              default:
                hi(r, o, Ce, g, p, null);
            }
        return;
      default:
        if (Qr(o)) {
          for (ct in p)
            p.hasOwnProperty(ct) &&
              ((g = p[ct]), g !== void 0 && w_(r, o, ct, g, p, void 0));
          return;
        }
    }
    for (Q in p)
      p.hasOwnProperty(Q) && ((g = p[Q]), g != null && hi(r, o, Q, g, p, null));
  }
  function sC(r, o, p, g) {
    switch (o) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var x = null,
          C = null,
          G = null,
          Q = null,
          he = null,
          Ce = null,
          ct = null;
        for (ot in p) {
          var xt = p[ot];
          if (p.hasOwnProperty(ot) && xt != null)
            switch (ot) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                he = xt;
              default:
                g.hasOwnProperty(ot) || hi(r, o, ot, null, g, xt);
            }
        }
        for (var ke in g) {
          var ot = g[ke];
          if (
            ((xt = p[ke]), g.hasOwnProperty(ke) && (ot != null || xt != null))
          )
            switch (ke) {
              case "type":
                C = ot;
                break;
              case "name":
                x = ot;
                break;
              case "checked":
                Ce = ot;
                break;
              case "defaultChecked":
                ct = ot;
                break;
              case "value":
                G = ot;
                break;
              case "defaultValue":
                Q = ot;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (ot != null) throw Error(n(137, o));
                break;
              default:
                ot !== xt && hi(r, o, ke, ot, g, xt);
            }
        }
        on(r, G, Q, he, Ce, ct, C, x);
        return;
      case "select":
        ot = G = Q = ke = null;
        for (C in p)
          if (((he = p[C]), p.hasOwnProperty(C) && he != null))
            switch (C) {
              case "value":
                break;
              case "multiple":
                ot = he;
              default:
                g.hasOwnProperty(C) || hi(r, o, C, null, g, he);
            }
        for (x in g)
          if (
            ((C = g[x]),
            (he = p[x]),
            g.hasOwnProperty(x) && (C != null || he != null))
          )
            switch (x) {
              case "value":
                ke = C;
                break;
              case "defaultValue":
                Q = C;
                break;
              case "multiple":
                G = C;
              default:
                C !== he && hi(r, o, x, C, g, he);
            }
        (o = Q),
          (p = G),
          (g = ot),
          ke != null
            ? Nn(r, !!p, ke, !1)
            : !!g != !!p &&
              (o != null ? Nn(r, !!p, o, !0) : Nn(r, !!p, p ? [] : "", !1));
        return;
      case "textarea":
        ot = ke = null;
        for (Q in p)
          if (
            ((x = p[Q]),
            p.hasOwnProperty(Q) && x != null && !g.hasOwnProperty(Q))
          )
            switch (Q) {
              case "value":
                break;
              case "children":
                break;
              default:
                hi(r, o, Q, null, g, x);
            }
        for (G in g)
          if (
            ((x = g[G]),
            (C = p[G]),
            g.hasOwnProperty(G) && (x != null || C != null))
          )
            switch (G) {
              case "value":
                ke = x;
                break;
              case "defaultValue":
                ot = x;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (x != null) throw Error(n(91));
                break;
              default:
                x !== C && hi(r, o, G, x, g, C);
            }
        Mi(r, ke, ot);
        return;
      case "option":
        for (var Jt in p)
          if (
            ((ke = p[Jt]),
            p.hasOwnProperty(Jt) && ke != null && !g.hasOwnProperty(Jt))
          )
            switch (Jt) {
              case "selected":
                r.selected = !1;
                break;
              default:
                hi(r, o, Jt, null, g, ke);
            }
        for (he in g)
          if (
            ((ke = g[he]),
            (ot = p[he]),
            g.hasOwnProperty(he) && ke !== ot && (ke != null || ot != null))
          )
            switch (he) {
              case "selected":
                r.selected =
                  ke && typeof ke != "function" && typeof ke != "symbol";
                break;
              default:
                hi(r, o, he, ke, g, ot);
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var fn in p)
          (ke = p[fn]),
            p.hasOwnProperty(fn) &&
              ke != null &&
              !g.hasOwnProperty(fn) &&
              hi(r, o, fn, null, g, ke);
        for (Ce in g)
          if (
            ((ke = g[Ce]),
            (ot = p[Ce]),
            g.hasOwnProperty(Ce) && ke !== ot && (ke != null || ot != null))
          )
            switch (Ce) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (ke != null) throw Error(n(137, o));
                break;
              default:
                hi(r, o, Ce, ke, g, ot);
            }
        return;
      default:
        if (Qr(o)) {
          for (var Zi in p)
            (ke = p[Zi]),
              p.hasOwnProperty(Zi) &&
                ke !== void 0 &&
                !g.hasOwnProperty(Zi) &&
                w_(r, o, Zi, void 0, g, ke);
          for (ct in g)
            (ke = g[ct]),
              (ot = p[ct]),
              !g.hasOwnProperty(ct) ||
                ke === ot ||
                (ke === void 0 && ot === void 0) ||
                w_(r, o, ct, ke, g, ot);
          return;
        }
    }
    for (var Oe in p)
      (ke = p[Oe]),
        p.hasOwnProperty(Oe) &&
          ke != null &&
          !g.hasOwnProperty(Oe) &&
          hi(r, o, Oe, null, g, ke);
    for (xt in g)
      (ke = g[xt]),
        (ot = p[xt]),
        !g.hasOwnProperty(xt) ||
          ke === ot ||
          (ke == null && ot == null) ||
          hi(r, o, xt, ke, g, ot);
  }
  var B_ = null,
    D_ = null;
  function fv(r) {
    return r.nodeType === 9 ? r : r.ownerDocument;
  }
  function sS(r) {
    switch (r) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function oS(r, o) {
    if (r === 0)
      switch (o) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return r === 1 && o === "foreignObject" ? 0 : r;
  }
  function U_(r, o) {
    return (
      r === "textarea" ||
      r === "noscript" ||
      typeof o.children == "string" ||
      typeof o.children == "number" ||
      typeof o.children == "bigint" ||
      (typeof o.dangerouslySetInnerHTML == "object" &&
        o.dangerouslySetInnerHTML !== null &&
        o.dangerouslySetInnerHTML.__html != null)
    );
  }
  var O_ = null;
  function oC() {
    var r = window.event;
    return r && r.type === "popstate"
      ? r === O_
        ? !1
        : ((O_ = r), !0)
      : ((O_ = null), !1);
  }
  var lS = typeof setTimeout == "function" ? setTimeout : void 0,
    lC = typeof clearTimeout == "function" ? clearTimeout : void 0,
    uS = typeof Promise == "function" ? Promise : void 0,
    uC =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof uS < "u"
        ? function (r) {
            return uS.resolve(null).then(r).catch(cC);
          }
        : lS;
  function cC(r) {
    setTimeout(function () {
      throw r;
    });
  }
  function L_(r, o) {
    var p = o,
      g = 0;
    do {
      var x = p.nextSibling;
      if ((r.removeChild(p), x && x.nodeType === 8))
        if (((p = x.data), p === "/$")) {
          if (g === 0) {
            r.removeChild(x), qp(o);
            return;
          }
          g--;
        } else (p !== "$" && p !== "$?" && p !== "$!") || g++;
      p = x;
    } while (p);
    qp(o);
  }
  function N_(r) {
    var o = r.firstChild;
    for (o && o.nodeType === 10 && (o = o.nextSibling); o; ) {
      var p = o;
      switch (((o = o.nextSibling), p.nodeName)) {
        case "HTML":
        case "HEAD":
        case "BODY":
          N_(p), St(p);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (p.rel.toLowerCase() === "stylesheet") continue;
      }
      r.removeChild(p);
    }
  }
  function fC(r, o, p, g) {
    for (; r.nodeType === 1; ) {
      var x = p;
      if (r.nodeName.toLowerCase() !== o.toLowerCase()) {
        if (!g && (r.nodeName !== "INPUT" || r.type !== "hidden")) break;
      } else if (g) {
        if (!r[Je])
          switch (o) {
            case "meta":
              if (!r.hasAttribute("itemprop")) break;
              return r;
            case "link":
              if (
                ((C = r.getAttribute("rel")),
                C === "stylesheet" && r.hasAttribute("data-precedence"))
              )
                break;
              if (
                C !== x.rel ||
                r.getAttribute("href") !== (x.href == null ? null : x.href) ||
                r.getAttribute("crossorigin") !==
                  (x.crossOrigin == null ? null : x.crossOrigin) ||
                r.getAttribute("title") !== (x.title == null ? null : x.title)
              )
                break;
              return r;
            case "style":
              if (r.hasAttribute("data-precedence")) break;
              return r;
            case "script":
              if (
                ((C = r.getAttribute("src")),
                (C !== (x.src == null ? null : x.src) ||
                  r.getAttribute("type") !== (x.type == null ? null : x.type) ||
                  r.getAttribute("crossorigin") !==
                    (x.crossOrigin == null ? null : x.crossOrigin)) &&
                  C &&
                  r.hasAttribute("async") &&
                  !r.hasAttribute("itemprop"))
              )
                break;
              return r;
            default:
              return r;
          }
      } else if (o === "input" && r.type === "hidden") {
        var C = x.name == null ? null : "" + x.name;
        if (x.type === "hidden" && r.getAttribute("name") === C) return r;
      } else return r;
      if (((r = bo(r.nextSibling)), r === null)) break;
    }
    return null;
  }
  function hC(r, o, p) {
    if (o === "") return null;
    for (; r.nodeType !== 3; )
      if (
        ((r.nodeType !== 1 || r.nodeName !== "INPUT" || r.type !== "hidden") &&
          !p) ||
        ((r = bo(r.nextSibling)), r === null)
      )
        return null;
    return r;
  }
  function bo(r) {
    for (; r != null; r = r.nextSibling) {
      var o = r.nodeType;
      if (o === 1 || o === 3) break;
      if (o === 8) {
        if (
          ((o = r.data),
          o === "$" || o === "$!" || o === "$?" || o === "F!" || o === "F")
        )
          break;
        if (o === "/$") return null;
      }
    }
    return r;
  }
  function cS(r) {
    r = r.previousSibling;
    for (var o = 0; r; ) {
      if (r.nodeType === 8) {
        var p = r.data;
        if (p === "$" || p === "$!" || p === "$?") {
          if (o === 0) return r;
          o--;
        } else p === "/$" && o++;
      }
      r = r.previousSibling;
    }
    return null;
  }
  function fS(r, o, p) {
    switch (((o = fv(p)), r)) {
      case "html":
        if (((r = o.documentElement), !r)) throw Error(n(452));
        return r;
      case "head":
        if (((r = o.head), !r)) throw Error(n(453));
        return r;
      case "body":
        if (((r = o.body), !r)) throw Error(n(454));
        return r;
      default:
        throw Error(n(451));
    }
  }
  var Ls = new Map(),
    hS = new Set();
  function hv(r) {
    return typeof r.getRootNode == "function"
      ? r.getRootNode()
      : r.ownerDocument;
  }
  var su = j.d;
  j.d = { f: dC, r: pC, D: mC, C: gC, L: vC, m: yC, X: AC, S: _C, M: xC };
  function dC() {
    var r = su.f(),
      o = iu();
    return r || o;
  }
  function pC(r) {
    var o = z(r);
    o !== null && o.tag === 5 && o.type === "form" ? Vg(o) : su.r(r);
  }
  var Vh = typeof document > "u" ? null : document;
  function dS(r, o, p) {
    var g = Vh;
    if (g && typeof o == "string" && o) {
      var x = Xt(o);
      (x = 'link[rel="' + r + '"][href="' + x + '"]'),
        typeof p == "string" && (x += '[crossorigin="' + p + '"]'),
        hS.has(x) ||
          (hS.add(x),
          (r = { rel: r, crossOrigin: p, href: o }),
          g.querySelector(x) === null &&
            ((o = g.createElement("link")),
            Xa(o, "link", r),
            ne(o),
            g.head.appendChild(o)));
    }
  }
  function mC(r) {
    su.D(r), dS("dns-prefetch", r, null);
  }
  function gC(r, o) {
    su.C(r, o), dS("preconnect", r, o);
  }
  function vC(r, o, p) {
    su.L(r, o, p);
    var g = Vh;
    if (g && r && o) {
      var x = 'link[rel="preload"][as="' + Xt(o) + '"]';
      o === "image" && p && p.imageSrcSet
        ? ((x += '[imagesrcset="' + Xt(p.imageSrcSet) + '"]'),
          typeof p.imageSizes == "string" &&
            (x += '[imagesizes="' + Xt(p.imageSizes) + '"]'))
        : (x += '[href="' + Xt(r) + '"]');
      var C = x;
      switch (o) {
        case "style":
          C = kh(r);
          break;
        case "script":
          C = Xh(r);
      }
      Ls.has(C) ||
        ((r = U(
          {
            rel: "preload",
            href: o === "image" && p && p.imageSrcSet ? void 0 : r,
            as: o,
          },
          p
        )),
        Ls.set(C, r),
        g.querySelector(x) !== null ||
          (o === "style" && g.querySelector(Hp(C))) ||
          (o === "script" && g.querySelector(Vp(C))) ||
          ((o = g.createElement("link")),
          Xa(o, "link", r),
          ne(o),
          g.head.appendChild(o)));
    }
  }
  function yC(r, o) {
    su.m(r, o);
    var p = Vh;
    if (p && r) {
      var g = o && typeof o.as == "string" ? o.as : "script",
        x =
          'link[rel="modulepreload"][as="' + Xt(g) + '"][href="' + Xt(r) + '"]',
        C = x;
      switch (g) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          C = Xh(r);
      }
      if (
        !Ls.has(C) &&
        ((r = U({ rel: "modulepreload", href: r }, o)),
        Ls.set(C, r),
        p.querySelector(x) === null)
      ) {
        switch (g) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (p.querySelector(Vp(C))) return;
        }
        (g = p.createElement("link")),
          Xa(g, "link", r),
          ne(g),
          p.head.appendChild(g);
      }
    }
  }
  function _C(r, o, p) {
    su.S(r, o, p);
    var g = Vh;
    if (g && r) {
      var x = pe(g).hoistableStyles,
        C = kh(r);
      o = o || "default";
      var G = x.get(C);
      if (!G) {
        var Q = { loading: 0, preload: null };
        if ((G = g.querySelector(Hp(C)))) Q.loading = 5;
        else {
          (r = U({ rel: "stylesheet", href: r, "data-precedence": o }, p)),
            (p = Ls.get(C)) && I_(r, p);
          var he = (G = g.createElement("link"));
          ne(he),
            Xa(he, "link", r),
            (he._p = new Promise(function (Ce, ct) {
              (he.onload = Ce), (he.onerror = ct);
            })),
            he.addEventListener("load", function () {
              Q.loading |= 1;
            }),
            he.addEventListener("error", function () {
              Q.loading |= 2;
            }),
            (Q.loading |= 4),
            dv(G, o, g);
        }
        (G = { type: "stylesheet", instance: G, count: 1, state: Q }),
          x.set(C, G);
      }
    }
  }
  function AC(r, o) {
    su.X(r, o);
    var p = Vh;
    if (p && r) {
      var g = pe(p).hoistableScripts,
        x = Xh(r),
        C = g.get(x);
      C ||
        ((C = p.querySelector(Vp(x))),
        C ||
          ((r = U({ src: r, async: !0 }, o)),
          (o = Ls.get(x)) && F_(r, o),
          (C = p.createElement("script")),
          ne(C),
          Xa(C, "link", r),
          p.head.appendChild(C)),
        (C = { type: "script", instance: C, count: 1, state: null }),
        g.set(x, C));
    }
  }
  function xC(r, o) {
    su.M(r, o);
    var p = Vh;
    if (p && r) {
      var g = pe(p).hoistableScripts,
        x = Xh(r),
        C = g.get(x);
      C ||
        ((C = p.querySelector(Vp(x))),
        C ||
          ((r = U({ src: r, async: !0, type: "module" }, o)),
          (o = Ls.get(x)) && F_(r, o),
          (C = p.createElement("script")),
          ne(C),
          Xa(C, "link", r),
          p.head.appendChild(C)),
        (C = { type: "script", instance: C, count: 1, state: null }),
        g.set(x, C));
    }
  }
  function pS(r, o, p, g) {
    var x = (x = Ie.current) ? hv(x) : null;
    if (!x) throw Error(n(446));
    switch (r) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof p.precedence == "string" && typeof p.href == "string"
          ? ((o = kh(p.href)),
            (p = pe(x).hoistableStyles),
            (g = p.get(o)),
            g ||
              ((g = { type: "style", instance: null, count: 0, state: null }),
              p.set(o, g)),
            g)
          : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (
          p.rel === "stylesheet" &&
          typeof p.href == "string" &&
          typeof p.precedence == "string"
        ) {
          r = kh(p.href);
          var C = pe(x).hoistableStyles,
            G = C.get(r);
          if (
            (G ||
              ((x = x.ownerDocument || x),
              (G = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null },
              }),
              C.set(r, G),
              (C = x.querySelector(Hp(r))) &&
                !C._p &&
                ((G.instance = C), (G.state.loading = 5)),
              Ls.has(r) ||
                ((p = {
                  rel: "preload",
                  as: "style",
                  href: p.href,
                  crossOrigin: p.crossOrigin,
                  integrity: p.integrity,
                  media: p.media,
                  hrefLang: p.hrefLang,
                  referrerPolicy: p.referrerPolicy,
                }),
                Ls.set(r, p),
                C || SC(x, r, p, G.state))),
            o && g === null)
          )
            throw Error(n(528, ""));
          return G;
        }
        if (o && g !== null) throw Error(n(529, ""));
        return null;
      case "script":
        return (
          (o = p.async),
          (p = p.src),
          typeof p == "string" &&
          o &&
          typeof o != "function" &&
          typeof o != "symbol"
            ? ((o = Xh(p)),
              (p = pe(x).hoistableScripts),
              (g = p.get(o)),
              g ||
                ((g = {
                  type: "script",
                  instance: null,
                  count: 0,
                  state: null,
                }),
                p.set(o, g)),
              g)
            : { type: "void", instance: null, count: 0, state: null }
        );
      default:
        throw Error(n(444, r));
    }
  }
  function kh(r) {
    return 'href="' + Xt(r) + '"';
  }
  function Hp(r) {
    return 'link[rel="stylesheet"][' + r + "]";
  }
  function mS(r) {
    return U({}, r, { "data-precedence": r.precedence, precedence: null });
  }
  function SC(r, o, p, g) {
    r.querySelector('link[rel="preload"][as="style"][' + o + "]")
      ? (g.loading = 1)
      : ((o = r.createElement("link")),
        (g.preload = o),
        o.addEventListener("load", function () {
          return (g.loading |= 1);
        }),
        o.addEventListener("error", function () {
          return (g.loading |= 2);
        }),
        Xa(o, "link", p),
        ne(o),
        r.head.appendChild(o));
  }
  function Xh(r) {
    return '[src="' + Xt(r) + '"]';
  }
  function Vp(r) {
    return "script[async]" + r;
  }
  function gS(r, o, p) {
    if ((o.count++, o.instance === null))
      switch (o.type) {
        case "style":
          var g = r.querySelector('style[data-href~="' + Xt(p.href) + '"]');
          if (g) return (o.instance = g), ne(g), g;
          var x = U({}, p, {
            "data-href": p.href,
            "data-precedence": p.precedence,
            href: null,
            precedence: null,
          });
          return (
            (g = (r.ownerDocument || r).createElement("style")),
            ne(g),
            Xa(g, "style", x),
            dv(g, p.precedence, r),
            (o.instance = g)
          );
        case "stylesheet":
          x = kh(p.href);
          var C = r.querySelector(Hp(x));
          if (C) return (o.state.loading |= 4), (o.instance = C), ne(C), C;
          (g = mS(p)),
            (x = Ls.get(x)) && I_(g, x),
            (C = (r.ownerDocument || r).createElement("link")),
            ne(C);
          var G = C;
          return (
            (G._p = new Promise(function (Q, he) {
              (G.onload = Q), (G.onerror = he);
            })),
            Xa(C, "link", g),
            (o.state.loading |= 4),
            dv(C, p.precedence, r),
            (o.instance = C)
          );
        case "script":
          return (
            (C = Xh(p.src)),
            (x = r.querySelector(Vp(C)))
              ? ((o.instance = x), ne(x), x)
              : ((g = p),
                (x = Ls.get(C)) && ((g = U({}, p)), F_(g, x)),
                (r = r.ownerDocument || r),
                (x = r.createElement("script")),
                ne(x),
                Xa(x, "link", g),
                r.head.appendChild(x),
                (o.instance = x))
          );
        case "void":
          return null;
        default:
          throw Error(n(443, o.type));
      }
    else
      o.type === "stylesheet" &&
        (o.state.loading & 4) === 0 &&
        ((g = o.instance), (o.state.loading |= 4), dv(g, p.precedence, r));
    return o.instance;
  }
  function dv(r, o, p) {
    for (
      var g = p.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ),
        x = g.length ? g[g.length - 1] : null,
        C = x,
        G = 0;
      G < g.length;
      G++
    ) {
      var Q = g[G];
      if (Q.dataset.precedence === o) C = Q;
      else if (C !== x) break;
    }
    C
      ? C.parentNode.insertBefore(r, C.nextSibling)
      : ((o = p.nodeType === 9 ? p.head : p), o.insertBefore(r, o.firstChild));
  }
  function I_(r, o) {
    r.crossOrigin == null && (r.crossOrigin = o.crossOrigin),
      r.referrerPolicy == null && (r.referrerPolicy = o.referrerPolicy),
      r.title == null && (r.title = o.title);
  }
  function F_(r, o) {
    r.crossOrigin == null && (r.crossOrigin = o.crossOrigin),
      r.referrerPolicy == null && (r.referrerPolicy = o.referrerPolicy),
      r.integrity == null && (r.integrity = o.integrity);
  }
  var pv = null;
  function vS(r, o, p) {
    if (pv === null) {
      var g = new Map(),
        x = (pv = new Map());
      x.set(p, g);
    } else (x = pv), (g = x.get(p)), g || ((g = new Map()), x.set(p, g));
    if (g.has(r)) return g;
    for (
      g.set(r, null), p = p.getElementsByTagName(r), x = 0;
      x < p.length;
      x++
    ) {
      var C = p[x];
      if (
        !(
          C[Je] ||
          C[pn] ||
          (r === "link" && C.getAttribute("rel") === "stylesheet")
        ) &&
        C.namespaceURI !== "http://www.w3.org/2000/svg"
      ) {
        var G = C.getAttribute(o) || "";
        G = r + G;
        var Q = g.get(G);
        Q ? Q.push(C) : g.set(G, [C]);
      }
    }
    return g;
  }
  function yS(r, o, p) {
    (r = r.ownerDocument || r),
      r.head.insertBefore(
        p,
        o === "title" ? r.querySelector("head > title") : null
      );
  }
  function MC(r, o, p) {
    if (p === 1 || o.itemProp != null) return !1;
    switch (r) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (
          typeof o.precedence != "string" ||
          typeof o.href != "string" ||
          o.href === ""
        )
          break;
        return !0;
      case "link":
        if (
          typeof o.rel != "string" ||
          typeof o.href != "string" ||
          o.href === "" ||
          o.onLoad ||
          o.onError
        )
          break;
        switch (o.rel) {
          case "stylesheet":
            return (
              (r = o.disabled), typeof o.precedence == "string" && r == null
            );
          default:
            return !0;
        }
      case "script":
        if (
          o.async &&
          typeof o.async != "function" &&
          typeof o.async != "symbol" &&
          !o.onLoad &&
          !o.onError &&
          o.src &&
          typeof o.src == "string"
        )
          return !0;
    }
    return !1;
  }
  function _S(r) {
    return !(r.type === "stylesheet" && (r.state.loading & 3) === 0);
  }
  var kp = null;
  function bC() {}
  function EC(r, o, p) {
    if (kp === null) throw Error(n(475));
    var g = kp;
    if (
      o.type === "stylesheet" &&
      (typeof p.media != "string" || matchMedia(p.media).matches !== !1) &&
      (o.state.loading & 4) === 0
    ) {
      if (o.instance === null) {
        var x = kh(p.href),
          C = r.querySelector(Hp(x));
        if (C) {
          (r = C._p),
            r !== null &&
              typeof r == "object" &&
              typeof r.then == "function" &&
              (g.count++, (g = mv.bind(g)), r.then(g, g)),
            (o.state.loading |= 4),
            (o.instance = C),
            ne(C);
          return;
        }
        (C = r.ownerDocument || r),
          (p = mS(p)),
          (x = Ls.get(x)) && I_(p, x),
          (C = C.createElement("link")),
          ne(C);
        var G = C;
        (G._p = new Promise(function (Q, he) {
          (G.onload = Q), (G.onerror = he);
        })),
          Xa(C, "link", p),
          (o.instance = C);
      }
      g.stylesheets === null && (g.stylesheets = new Map()),
        g.stylesheets.set(o, r),
        (r = o.state.preload) &&
          (o.state.loading & 3) === 0 &&
          (g.count++,
          (o = mv.bind(g)),
          r.addEventListener("load", o),
          r.addEventListener("error", o));
    }
  }
  function TC() {
    if (kp === null) throw Error(n(475));
    var r = kp;
    return (
      r.stylesheets && r.count === 0 && P_(r, r.stylesheets),
      0 < r.count
        ? function (o) {
            var p = setTimeout(function () {
              if ((r.stylesheets && P_(r, r.stylesheets), r.unsuspend)) {
                var g = r.unsuspend;
                (r.unsuspend = null), g();
              }
            }, 6e4);
            return (
              (r.unsuspend = o),
              function () {
                (r.unsuspend = null), clearTimeout(p);
              }
            );
          }
        : null
    );
  }
  function mv() {
    if ((this.count--, this.count === 0)) {
      if (this.stylesheets) P_(this, this.stylesheets);
      else if (this.unsuspend) {
        var r = this.unsuspend;
        (this.unsuspend = null), r();
      }
    }
  }
  var gv = null;
  function P_(r, o) {
    (r.stylesheets = null),
      r.unsuspend !== null &&
        (r.count++,
        (gv = new Map()),
        o.forEach(CC, r),
        (gv = null),
        mv.call(r));
  }
  function CC(r, o) {
    if (!(o.state.loading & 4)) {
      var p = gv.get(r);
      if (p) var g = p.get(null);
      else {
        (p = new Map()), gv.set(r, p);
        for (
          var x = r.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ),
            C = 0;
          C < x.length;
          C++
        ) {
          var G = x[C];
          (G.nodeName === "LINK" || G.getAttribute("media") !== "not all") &&
            (p.set(G.dataset.precedence, G), (g = G));
        }
        g && p.set(null, g);
      }
      (x = o.instance),
        (G = x.getAttribute("data-precedence")),
        (C = p.get(G) || g),
        C === g && p.set(null, x),
        p.set(G, x),
        this.count++,
        (g = mv.bind(this)),
        x.addEventListener("load", g),
        x.addEventListener("error", g),
        C
          ? C.parentNode.insertBefore(x, C.nextSibling)
          : ((r = r.nodeType === 9 ? r.head : r),
            r.insertBefore(x, r.firstChild)),
        (o.state.loading |= 4);
    }
  }
  var Xp = {
    $$typeof: A,
    Provider: null,
    Consumer: null,
    _currentValue: se,
    _currentValue2: se,
    _threadCount: 0,
  };
  function RC(r, o, p, g, x, C, G, Q) {
    (this.tag = 1),
      (this.containerInfo = r),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = -1),
      (this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null),
      (this.callbackPriority = 0),
      (this.expirationTimes = gn(-1)),
      (this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.finishedLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = gn(0)),
      (this.hiddenUpdates = gn(null)),
      (this.identifierPrefix = g),
      (this.onUncaughtError = x),
      (this.onCaughtError = C),
      (this.onRecoverableError = G),
      (this.pooledCache = null),
      (this.pooledCacheLanes = 0),
      (this.formState = Q),
      (this.incompleteTransitions = new Map());
  }
  function AS(r, o, p, g, x, C, G, Q, he, Ce, ct, xt) {
    return (
      (r = new RC(r, o, p, G, Q, he, Ce, xt)),
      (o = 1),
      C === !0 && (o |= 24),
      (C = zi(3, null, null, o)),
      (r.current = C),
      (C.stateNode = r),
      (o = lp()),
      o.refCount++,
      (r.pooledCache = o),
      o.refCount++,
      (C.memoizedState = { element: g, isDehydrated: p, cache: o }),
      Ga(C),
      r
    );
  }
  function xS(r) {
    return r ? ((r = Wo), r) : Wo;
  }
  function SS(r, o, p, g, x, C) {
    (x = xS(x)),
      g.context === null ? (g.context = x) : (g.pendingContext = x),
      (g = xr(o)),
      (g.payload = { element: p }),
      (C = C === void 0 ? null : C),
      C !== null && (g.callback = C),
      (p = Sr(r, g, o)),
      p !== null && (Ki(p, r, o), cl(p, r, o));
  }
  function MS(r, o) {
    if (((r = r.memoizedState), r !== null && r.dehydrated !== null)) {
      var p = r.retryLane;
      r.retryLane = p !== 0 && p < o ? p : o;
    }
  }
  function G_(r, o) {
    MS(r, o), (r = r.alternate) && MS(r, o);
  }
  function bS(r) {
    if (r.tag === 13) {
      var o = eo(r, 67108864);
      o !== null && Ki(o, r, 67108864), G_(r, 67108864);
    }
  }
  var vv = !0;
  function wC(r, o, p, g) {
    var x = O.T;
    O.T = null;
    var C = j.p;
    try {
      (j.p = 2), z_(r, o, p, g);
    } finally {
      (j.p = C), (O.T = x);
    }
  }
  function BC(r, o, p, g) {
    var x = O.T;
    O.T = null;
    var C = j.p;
    try {
      (j.p = 8), z_(r, o, p, g);
    } finally {
      (j.p = C), (O.T = x);
    }
  }
  function z_(r, o, p, g) {
    if (vv) {
      var x = H_(g);
      if (x === null) R_(r, o, g, yv, p), TS(r, g);
      else if (UC(x, r, o, p, g)) g.stopPropagation();
      else if ((TS(r, g), o & 4 && -1 < DC.indexOf(r))) {
        for (; x !== null; ) {
          var C = z(x);
          if (C !== null)
            switch (C.tag) {
              case 3:
                if (((C = C.stateNode), C.current.memoizedState.isDehydrated)) {
                  var G = gt(C.pendingLanes);
                  if (G !== 0) {
                    var Q = C;
                    for (Q.pendingLanes |= 2, Q.entangledLanes |= 2; G; ) {
                      var he = 1 << (31 - Be(G));
                      (Q.entanglements[1] |= he), (G &= ~he);
                    }
                    si(C), (un & 6) === 0 && ((wn = Ee() + 500), Bn(0));
                  }
                }
                break;
              case 13:
                (Q = eo(C, 2)), Q !== null && Ki(Q, C, 2), iu(), G_(C, 2);
            }
          if (((C = H_(g)), C === null && R_(r, o, g, yv, p), C === x)) break;
          x = C;
        }
        x !== null && g.stopPropagation();
      } else R_(r, o, g, null, p);
    }
  }
  function H_(r) {
    return (r = es(r)), V_(r);
  }
  var yv = null;
  function V_(r) {
    if (((yv = null), (r = yt(r)), r !== null)) {
      var o = oe(r);
      if (o === null) r = null;
      else {
        var p = o.tag;
        if (p === 13) {
          if (((r = me(o)), r !== null)) return r;
          r = null;
        } else if (p === 3) {
          if (o.stateNode.current.memoizedState.isDehydrated)
            return o.tag === 3 ? o.stateNode.containerInfo : null;
          r = null;
        } else o !== r && (r = null);
      }
    }
    return (yv = r), null;
  }
  function ES(r) {
    switch (r) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (we()) {
          case He:
            return 2;
          case tt:
            return 8;
          case Ke:
          case st:
            return 32;
          case Ut:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var k_ = !1,
    tc = null,
    nc = null,
    ic = null,
    Yp = new Map(),
    Wp = new Map(),
    ac = [],
    DC =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
  function TS(r, o) {
    switch (r) {
      case "focusin":
      case "focusout":
        tc = null;
        break;
      case "dragenter":
      case "dragleave":
        nc = null;
        break;
      case "mouseover":
      case "mouseout":
        ic = null;
        break;
      case "pointerover":
      case "pointerout":
        Yp.delete(o.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Wp.delete(o.pointerId);
    }
  }
  function Jp(r, o, p, g, x, C) {
    return r === null || r.nativeEvent !== C
      ? ((r = {
          blockedOn: o,
          domEventName: p,
          eventSystemFlags: g,
          nativeEvent: C,
          targetContainers: [x],
        }),
        o !== null && ((o = z(o)), o !== null && bS(o)),
        r)
      : ((r.eventSystemFlags |= g),
        (o = r.targetContainers),
        x !== null && o.indexOf(x) === -1 && o.push(x),
        r);
  }
  function UC(r, o, p, g, x) {
    switch (o) {
      case "focusin":
        return (tc = Jp(tc, r, o, p, g, x)), !0;
      case "dragenter":
        return (nc = Jp(nc, r, o, p, g, x)), !0;
      case "mouseover":
        return (ic = Jp(ic, r, o, p, g, x)), !0;
      case "pointerover":
        var C = x.pointerId;
        return Yp.set(C, Jp(Yp.get(C) || null, r, o, p, g, x)), !0;
      case "gotpointercapture":
        return (
          (C = x.pointerId), Wp.set(C, Jp(Wp.get(C) || null, r, o, p, g, x)), !0
        );
    }
    return !1;
  }
  function CS(r) {
    var o = yt(r.target);
    if (o !== null) {
      var p = oe(o);
      if (p !== null) {
        if (((o = p.tag), o === 13)) {
          if (((o = me(p)), o !== null)) {
            (r.blockedOn = o),
              pi(r.priority, function () {
                if (p.tag === 13) {
                  var g = ka(),
                    x = eo(p, g);
                  x !== null && Ki(x, p, g), G_(p, g);
                }
              });
            return;
          }
        } else if (o === 3 && p.stateNode.current.memoizedState.isDehydrated) {
          r.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
          return;
        }
      }
    }
    r.blockedOn = null;
  }
  function _v(r) {
    if (r.blockedOn !== null) return !1;
    for (var o = r.targetContainers; 0 < o.length; ) {
      var p = H_(r.nativeEvent);
      if (p === null) {
        p = r.nativeEvent;
        var g = new p.constructor(p.type, p);
        ($r = g), p.target.dispatchEvent(g), ($r = null);
      } else return (o = z(p)), o !== null && bS(o), (r.blockedOn = p), !1;
      o.shift();
    }
    return !0;
  }
  function RS(r, o, p) {
    _v(r) && p.delete(o);
  }
  function OC() {
    (k_ = !1),
      tc !== null && _v(tc) && (tc = null),
      nc !== null && _v(nc) && (nc = null),
      ic !== null && _v(ic) && (ic = null),
      Yp.forEach(RS),
      Wp.forEach(RS);
  }
  function Av(r, o) {
    r.blockedOn === o &&
      ((r.blockedOn = null),
      k_ ||
        ((k_ = !0),
        s.unstable_scheduleCallback(s.unstable_NormalPriority, OC)));
  }
  var xv = null;
  function wS(r) {
    xv !== r &&
      ((xv = r),
      s.unstable_scheduleCallback(s.unstable_NormalPriority, function () {
        xv === r && (xv = null);
        for (var o = 0; o < r.length; o += 3) {
          var p = r[o],
            g = r[o + 1],
            x = r[o + 2];
          if (typeof g != "function") {
            if (V_(g || p) === null) continue;
            break;
          }
          var C = z(p);
          C !== null &&
            (r.splice(o, 3),
            (o -= 3),
            vp(C, { pending: !0, data: x, method: p.method, action: g }, g, x));
        }
      }));
  }
  function qp(r) {
    function o(he) {
      return Av(he, r);
    }
    tc !== null && Av(tc, r),
      nc !== null && Av(nc, r),
      ic !== null && Av(ic, r),
      Yp.forEach(o),
      Wp.forEach(o);
    for (var p = 0; p < ac.length; p++) {
      var g = ac[p];
      g.blockedOn === r && (g.blockedOn = null);
    }
    for (; 0 < ac.length && ((p = ac[0]), p.blockedOn === null); )
      CS(p), p.blockedOn === null && ac.shift();
    if (((p = (r.ownerDocument || r).$$reactFormReplay), p != null))
      for (g = 0; g < p.length; g += 3) {
        var x = p[g],
          C = p[g + 1],
          G = x[en] || null;
        if (typeof C == "function") G || wS(p);
        else if (G) {
          var Q = null;
          if (C && C.hasAttribute("formAction")) {
            if (((x = C), (G = C[en] || null))) Q = G.formAction;
            else if (V_(x) !== null) continue;
          } else Q = G.action;
          typeof Q == "function" ? (p[g + 1] = Q) : (p.splice(g, 3), (g -= 3)),
            wS(p);
        }
      }
  }
  function X_(r) {
    this._internalRoot = r;
  }
  (Sv.prototype.render = X_.prototype.render =
    function (r) {
      var o = this._internalRoot;
      if (o === null) throw Error(n(409));
      var p = o.current,
        g = ka();
      SS(p, g, r, o, null, null);
    }),
    (Sv.prototype.unmount = X_.prototype.unmount =
      function () {
        var r = this._internalRoot;
        if (r !== null) {
          this._internalRoot = null;
          var o = r.containerInfo;
          r.tag === 0 && Et(),
            SS(r.current, 2, null, r, null, null),
            iu(),
            (o[H] = null);
        }
      });
  function Sv(r) {
    this._internalRoot = r;
  }
  Sv.prototype.unstable_scheduleHydration = function (r) {
    if (r) {
      var o = Di();
      r = { blockedOn: null, target: r, priority: o };
      for (var p = 0; p < ac.length && o !== 0 && o < ac[p].priority; p++);
      ac.splice(p, 0, r), p === 0 && CS(r);
    }
  };
  var BS = e.version;
  if (BS !== "19.0.0") throw Error(n(527, BS, "19.0.0"));
  j.findDOMNode = function (r) {
    var o = r._reactInternals;
    if (o === void 0)
      throw typeof r.render == "function"
        ? Error(n(188))
        : ((r = Object.keys(r).join(",")), Error(n(268, r)));
    return (
      (r = Y(o)),
      (r = r !== null ? ae(r) : null),
      (r = r === null ? null : r.stateNode),
      r
    );
  };
  var LC = {
    bundleType: 0,
    version: "19.0.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: O,
    findFiberByHostInstance: yt,
    reconcilerVersion: "19.0.0",
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Mv = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Mv.isDisabled && Mv.supportsFiber)
      try {
        (mt = Mv.inject(LC)), (nt = Mv);
      } catch {}
  }
  return (
    (Kp.createRoot = function (r, o) {
      if (!i(r)) throw Error(n(299));
      var p = !1,
        g = "",
        x = Kg,
        C = Zg,
        G = Qg,
        Q = null;
      return (
        o != null &&
          (o.unstable_strictMode === !0 && (p = !0),
          o.identifierPrefix !== void 0 && (g = o.identifierPrefix),
          o.onUncaughtError !== void 0 && (x = o.onUncaughtError),
          o.onCaughtError !== void 0 && (C = o.onCaughtError),
          o.onRecoverableError !== void 0 && (G = o.onRecoverableError),
          o.unstable_transitionCallbacks !== void 0 &&
            (Q = o.unstable_transitionCallbacks)),
        (o = AS(r, 1, !1, null, null, p, g, x, C, G, Q, null)),
        (r[H] = o.current),
        C_(r.nodeType === 8 ? r.parentNode : r),
        new X_(o)
      );
    }),
    (Kp.hydrateRoot = function (r, o, p) {
      if (!i(r)) throw Error(n(299));
      var g = !1,
        x = "",
        C = Kg,
        G = Zg,
        Q = Qg,
        he = null,
        Ce = null;
      return (
        p != null &&
          (p.unstable_strictMode === !0 && (g = !0),
          p.identifierPrefix !== void 0 && (x = p.identifierPrefix),
          p.onUncaughtError !== void 0 && (C = p.onUncaughtError),
          p.onCaughtError !== void 0 && (G = p.onCaughtError),
          p.onRecoverableError !== void 0 && (Q = p.onRecoverableError),
          p.unstable_transitionCallbacks !== void 0 &&
            (he = p.unstable_transitionCallbacks),
          p.formState !== void 0 && (Ce = p.formState)),
        (o = AS(r, 1, !0, o, p ?? null, g, x, C, G, Q, he, Ce)),
        (o.context = xS(null)),
        (p = o.current),
        (g = ka()),
        (x = xr(g)),
        (x.callback = null),
        Sr(p, x, g),
        (o.current.lanes = g),
        vn(o, g),
        si(o),
        (r[H] = o.current),
        C_(r),
        new Sv(o)
      );
    }),
    (Kp.version = "19.0.0"),
    Kp
  );
}
var zS;
function kC() {
  if (zS) return J_.exports;
  zS = 1;
  function s() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s);
      } catch (e) {
        console.error(e);
      }
  }
  return s(), (J_.exports = VC()), J_.exports;
}
var XC = kC();
const YC = My(XC);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Od = "173",
  Rf = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  wf = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  lE = 0,
  fA = 1,
  uE = 2,
  WC = 3,
  cE = 0,
  by = 1,
  gm = 2,
  wo = 3,
  Tl = 0,
  hr = 1,
  jr = 2,
  Ml = 0,
  Hf = 1,
  hA = 2,
  dA = 3,
  pA = 4,
  fE = 5,
  mc = 100,
  hE = 101,
  dE = 102,
  pE = 103,
  mE = 104,
  gE = 200,
  vE = 201,
  yE = 202,
  _E = 203,
  D0 = 204,
  U0 = 205,
  AE = 206,
  xE = 207,
  SE = 208,
  ME = 209,
  bE = 210,
  EE = 211,
  TE = 212,
  CE = 213,
  RE = 214,
  O0 = 0,
  L0 = 1,
  N0 = 2,
  Yf = 3,
  I0 = 4,
  F0 = 5,
  P0 = 6,
  G0 = 7,
  Vm = 0,
  wE = 1,
  BE = 2,
  bl = 0,
  DE = 1,
  UE = 2,
  OE = 3,
  VA = 4,
  LE = 5,
  NE = 6,
  IE = 7,
  mA = "attached",
  FE = "detached",
  Ac = 300,
  Cl = 301,
  xc = 302,
  Sd = 303,
  wm = 304,
  Ld = 306,
  Sc = 1e3,
  sa = 1001,
  Md = 1002,
  Kn = 1003,
  Ey = 1004,
  JC = 1004,
  Of = 1005,
  qC = 1005,
  In = 1006,
  yd = 1007,
  jC = 1007,
  ms = 1008,
  gA = 1008,
  Zr = 1009,
  Ty = 1010,
  Cy = 1011,
  bd = 1012,
  km = 1013,
  Rl = 1014,
  yi = 1015,
  va = 1016,
  Ry = 1017,
  wy = 1018,
  Wf = 1020,
  kA = 35902,
  XA = 1021,
  YA = 1022,
  oa = 1023,
  WA = 1024,
  JA = 1025,
  Vf = 1026,
  Jf = 1027,
  vc = 1028,
  Xm = 1029,
  qA = 1030,
  By = 1031,
  KC = 1032,
  Dy = 1033,
  vm = 33776,
  ym = 33777,
  _m = 33778,
  Am = 33779,
  z0 = 35840,
  H0 = 35841,
  V0 = 35842,
  k0 = 35843,
  X0 = 36196,
  Y0 = 37492,
  W0 = 37496,
  J0 = 37808,
  q0 = 37809,
  j0 = 37810,
  K0 = 37811,
  Z0 = 37812,
  Q0 = 37813,
  $0 = 37814,
  ey = 37815,
  ty = 37816,
  ny = 37817,
  iy = 37818,
  ay = 37819,
  ry = 37820,
  sy = 37821,
  xm = 36492,
  oy = 36494,
  ly = 36495,
  jA = 36283,
  uy = 36284,
  cy = 36285,
  fy = 36286,
  PE = 2200,
  GE = 2201,
  zE = 2202,
  Ed = 2300,
  Td = 2301,
  b0 = 2302,
  Lf = 2400,
  Nf = 2401,
  Bm = 2402,
  Uy = 2500,
  KA = 2501,
  HE = 0,
  ZA = 1,
  hy = 2,
  VE = 3200,
  QA = 3201,
  ZC = 3202,
  QC = 3203,
  Ec = 0,
  kE = 1,
  gu = "",
  Wa = "srgb",
  Oo = "srgb-linear",
  Dm = "linear",
  oi = "srgb",
  $C = 0,
  Bf = 7680,
  eR = 7681,
  tR = 7682,
  nR = 7683,
  iR = 34055,
  aR = 34056,
  rR = 5386,
  sR = 512,
  oR = 513,
  lR = 514,
  uR = 515,
  cR = 516,
  fR = 517,
  hR = 518,
  vA = 519,
  XE = 512,
  YE = 513,
  WE = 514,
  $A = 515,
  JE = 516,
  qE = 517,
  jE = 518,
  KE = 519,
  Um = 35044,
  dR = 35048,
  pR = 35040,
  mR = 35045,
  gR = 35049,
  vR = 35041,
  yR = 35046,
  _R = 35050,
  AR = 35042,
  xR = "100",
  yA = "300 es",
  Do = 2e3,
  Om = 2001,
  SR = { COMPUTE: "compute", RENDER: "render" };
let wl = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    const n = this._listeners;
    return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    const n = this._listeners;
    if (n === void 0) return;
    const i = n[e];
    if (i !== void 0) {
      const a = i.indexOf(t);
      a !== -1 && i.splice(a, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const n = t[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let a = 0, l = i.length; a < l; a++) i[a].call(this, e);
      e.target = null;
    }
  }
};
const lr = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let HS = 1234567;
const kf = Math.PI / 180,
  Cd = 180 / Math.PI;
function gs() {
  const s = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    lr[s & 255] +
    lr[(s >> 8) & 255] +
    lr[(s >> 16) & 255] +
    lr[(s >> 24) & 255] +
    "-" +
    lr[e & 255] +
    lr[(e >> 8) & 255] +
    "-" +
    lr[((e >> 16) & 15) | 64] +
    lr[(e >> 24) & 255] +
    "-" +
    lr[(t & 63) | 128] +
    lr[(t >> 8) & 255] +
    "-" +
    lr[(t >> 16) & 255] +
    lr[(t >> 24) & 255] +
    lr[n & 255] +
    lr[(n >> 8) & 255] +
    lr[(n >> 16) & 255] +
    lr[(n >> 24) & 255]
  ).toLowerCase();
}
function dn(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function ex(s, e) {
  return ((s % e) + e) % e;
}
function MR(s, e, t, n, i) {
  return n + ((s - e) * (i - n)) / (t - e);
}
function bR(s, e, t) {
  return s !== e ? (t - s) / (e - s) : 0;
}
function Sm(s, e, t) {
  return (1 - t) * s + t * e;
}
function ER(s, e, t, n) {
  return Sm(s, e, 1 - Math.exp(-t * n));
}
function TR(s, e = 1) {
  return e - Math.abs(ex(s, e * 2) - e);
}
function CR(s, e, t) {
  return s <= e
    ? 0
    : s >= t
    ? 1
    : ((s = (s - e) / (t - e)), s * s * (3 - 2 * s));
}
function RR(s, e, t) {
  return s <= e
    ? 0
    : s >= t
    ? 1
    : ((s = (s - e) / (t - e)), s * s * s * (s * (s * 6 - 15) + 10));
}
function wR(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function BR(s, e) {
  return s + Math.random() * (e - s);
}
function DR(s) {
  return s * (0.5 - Math.random());
}
function UR(s) {
  s !== void 0 && (HS = s);
  let e = (HS += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function OR(s) {
  return s * kf;
}
function LR(s) {
  return s * Cd;
}
function NR(s) {
  return (s & (s - 1)) === 0 && s !== 0;
}
function IR(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function FR(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function PR(s, e, t, n, i) {
  const a = Math.cos,
    l = Math.sin,
    u = a(t / 2),
    f = l(t / 2),
    d = a((e + n) / 2),
    m = l((e + n) / 2),
    v = a((e - n) / 2),
    _ = l((e - n) / 2),
    A = a((n - e) / 2),
    M = l((n - e) / 2);
  switch (i) {
    case "XYX":
      s.set(u * m, f * v, f * _, u * d);
      break;
    case "YZY":
      s.set(f * _, u * m, f * v, u * d);
      break;
    case "ZXZ":
      s.set(f * v, f * _, u * m, u * d);
      break;
    case "XZX":
      s.set(u * m, f * M, f * A, u * d);
      break;
    case "YXY":
      s.set(f * A, u * m, f * M, u * d);
      break;
    case "ZYZ":
      s.set(f * M, f * A, u * m, u * d);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function Rr(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function An(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const tx = {
  DEG2RAD: kf,
  RAD2DEG: Cd,
  generateUUID: gs,
  clamp: dn,
  euclideanModulo: ex,
  mapLinear: MR,
  inverseLerp: bR,
  lerp: Sm,
  damp: ER,
  pingpong: TR,
  smoothstep: CR,
  smootherstep: RR,
  randInt: wR,
  randFloat: BR,
  randFloatSpread: DR,
  seededRandom: UR,
  degToRad: OR,
  radToDeg: LR,
  isPowerOfTwo: NR,
  ceilPowerOfTwo: IR,
  floorPowerOfTwo: FR,
  setQuaternionFromProperEuler: PR,
  normalize: An,
  denormalize: Rr,
};
class at {
  constructor(e = 0, t = 0) {
    (at.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * n + i[6]),
      (this.y = i[1] * t + i[4] * n + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = dn(this.x, e.x, t.x)), (this.y = dn(this.y, e.y, t.y)), this
    );
  }
  clampScalar(e, t) {
    return (this.x = dn(this.x, e, t)), (this.y = dn(this.y, e, t)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(dn(n, e, t));
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(dn(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      a = this.x - e.x,
      l = this.y - e.y;
    return (this.x = a * n - l * i + e.x), (this.y = a * i + l * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class hn {
  constructor(e, t, n, i, a, l, u, f, d) {
    (hn.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, a, l, u, f, d);
  }
  set(e, t, n, i, a, l, u, f, d) {
    const m = this.elements;
    return (
      (m[0] = e),
      (m[1] = i),
      (m[2] = u),
      (m[3] = t),
      (m[4] = a),
      (m[5] = f),
      (m[6] = n),
      (m[7] = l),
      (m[8] = d),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      a = this.elements,
      l = n[0],
      u = n[3],
      f = n[6],
      d = n[1],
      m = n[4],
      v = n[7],
      _ = n[2],
      A = n[5],
      M = n[8],
      T = i[0],
      E = i[3],
      b = i[6],
      w = i[1],
      D = i[4],
      B = i[7],
      I = i[2],
      N = i[5],
      P = i[8];
    return (
      (a[0] = l * T + u * w + f * I),
      (a[3] = l * E + u * D + f * N),
      (a[6] = l * b + u * B + f * P),
      (a[1] = d * T + m * w + v * I),
      (a[4] = d * E + m * D + v * N),
      (a[7] = d * b + m * B + v * P),
      (a[2] = _ * T + A * w + M * I),
      (a[5] = _ * E + A * D + M * N),
      (a[8] = _ * b + A * B + M * P),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      a = e[3],
      l = e[4],
      u = e[5],
      f = e[6],
      d = e[7],
      m = e[8];
    return (
      t * l * m - t * u * d - n * a * m + n * u * f + i * a * d - i * l * f
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      a = e[3],
      l = e[4],
      u = e[5],
      f = e[6],
      d = e[7],
      m = e[8],
      v = m * l - u * d,
      _ = u * f - m * a,
      A = d * a - l * f,
      M = t * v + n * _ + i * A;
    if (M === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / M;
    return (
      (e[0] = v * T),
      (e[1] = (i * d - m * n) * T),
      (e[2] = (u * n - i * l) * T),
      (e[3] = _ * T),
      (e[4] = (m * t - i * f) * T),
      (e[5] = (i * a - u * t) * T),
      (e[6] = A * T),
      (e[7] = (n * f - d * t) * T),
      (e[8] = (l * t - n * a) * T),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, i, a, l, u) {
    const f = Math.cos(a),
      d = Math.sin(a);
    return (
      this.set(
        n * f,
        n * d,
        -n * (f * l + d * u) + l + e,
        -i * d,
        i * f,
        -i * (-d * l + f * u) + u + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(Z_.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Z_.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Z_.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Z_ = new hn();
function ZE(s) {
  for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return !0;
  return !1;
}
const GR = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function md(s, e) {
  return new GR[s](e);
}
function Lm(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function QE() {
  const s = Lm("canvas");
  return (s.style.display = "block"), s;
}
const VS = {};
function dd(s) {
  s in VS || ((VS[s] = !0), console.warn(s));
}
function zR(s, e, t) {
  return new Promise(function (n, i) {
    function a() {
      switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case s.WAIT_FAILED:
          i();
          break;
        case s.TIMEOUT_EXPIRED:
          setTimeout(a, t);
          break;
        default:
          n();
      }
    }
    setTimeout(a, t);
  });
}
function HR(s) {
  const e = s.elements;
  (e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15]);
}
function VR(s) {
  const e = s.elements;
  e[11] === -1
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
}
const kS = new hn().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  ),
  XS = new hn().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
function kR() {
  const s = {
      enabled: !0,
      workingColorSpace: Oo,
      spaces: {},
      convert: function (i, a, l) {
        return (
          this.enabled === !1 ||
            a === l ||
            !a ||
            !l ||
            (this.spaces[a].transfer === oi &&
              ((i.r = Au(i.r)), (i.g = Au(i.g)), (i.b = Au(i.b))),
            this.spaces[a].primaries !== this.spaces[l].primaries &&
              (i.applyMatrix3(this.spaces[a].toXYZ),
              i.applyMatrix3(this.spaces[l].fromXYZ)),
            this.spaces[l].transfer === oi &&
              ((i.r = _d(i.r)), (i.g = _d(i.g)), (i.b = _d(i.b)))),
          i
        );
      },
      fromWorkingColorSpace: function (i, a) {
        return this.convert(i, this.workingColorSpace, a);
      },
      toWorkingColorSpace: function (i, a) {
        return this.convert(i, a, this.workingColorSpace);
      },
      getPrimaries: function (i) {
        return this.spaces[i].primaries;
      },
      getTransfer: function (i) {
        return i === gu ? Dm : this.spaces[i].transfer;
      },
      getLuminanceCoefficients: function (i, a = this.workingColorSpace) {
        return i.fromArray(this.spaces[a].luminanceCoefficients);
      },
      define: function (i) {
        Object.assign(this.spaces, i);
      },
      _getMatrix: function (i, a, l) {
        return i.copy(this.spaces[a].toXYZ).multiply(this.spaces[l].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (i) {
        return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (i = this.workingColorSpace) {
        return this.spaces[i].workingColorSpaceConfig.unpackColorSpace;
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    n = [0.3127, 0.329];
  return (
    s.define({
      [Oo]: {
        primaries: e,
        whitePoint: n,
        transfer: Dm,
        toXYZ: kS,
        fromXYZ: XS,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: Wa },
        outputColorSpaceConfig: { drawingBufferColorSpace: Wa },
      },
      [Wa]: {
        primaries: e,
        whitePoint: n,
        transfer: oi,
        toXYZ: kS,
        fromXYZ: XS,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: Wa },
      },
    }),
    s
  );
}
const zn = kR();
function Au(s) {
  return s < 0.04045
    ? s * 0.0773993808
    : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function _d(s) {
  return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
let Yh;
class $E {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Yh === void 0 && (Yh = Lm("canvas")),
        (Yh.width = e.width),
        (Yh.height = e.height);
      const n = Yh.getContext("2d");
      e instanceof ImageData
        ? n.putImageData(e, 0, 0)
        : n.drawImage(e, 0, 0, e.width, e.height),
        (t = Yh);
    }
    return t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Lm("canvas");
      (t.width = e.width), (t.height = e.height);
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height),
        a = i.data;
      for (let l = 0; l < a.length; l++) a[l] = Au(a[l] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(Au(t[n] / 255) * 255))
          : (t[n] = Au(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let XR = 0;
class If {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: XR++ }),
      (this.uuid = gs()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let a;
      if (Array.isArray(i)) {
        a = [];
        for (let l = 0, u = i.length; l < u; l++)
          i[l].isDataTexture ? a.push(Q_(i[l].image)) : a.push(Q_(i[l]));
      } else a = Q_(i);
      n.url = a;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function Q_(s) {
  return (typeof HTMLImageElement < "u" && s instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && s instanceof ImageBitmap)
    ? $E.getDataURL(s)
    : s.data
    ? {
        data: Array.from(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let YR = 0;
class Wn extends wl {
  constructor(
    e = Wn.DEFAULT_IMAGE,
    t = Wn.DEFAULT_MAPPING,
    n = sa,
    i = sa,
    a = In,
    l = ms,
    u = oa,
    f = Zr,
    d = Wn.DEFAULT_ANISOTROPY,
    m = gu
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: YR++ }),
      (this.uuid = gs()),
      (this.name = ""),
      (this.source = new If(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = a),
      (this.minFilter = l),
      (this.anisotropy = d),
      (this.format = u),
      (this.internalFormat = null),
      (this.type = f),
      (this.offset = new at(0, 0)),
      (this.repeat = new at(1, 1)),
      (this.center = new at(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new hn()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = m),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.renderTarget = e.renderTarget),
      (this.isRenderTargetTexture = e.isRenderTargetTexture),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Ac) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Sc:
          e.x = e.x - Math.floor(e.x);
          break;
        case sa:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Md:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Sc:
          e.y = e.y - Math.floor(e.y);
          break;
        case sa:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Md:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Wn.DEFAULT_IMAGE = null;
Wn.DEFAULT_MAPPING = Ac;
Wn.DEFAULT_ANISOTROPY = 1;
class Hn {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (Hn.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      a = this.w,
      l = e.elements;
    return (
      (this.x = l[0] * t + l[4] * n + l[8] * i + l[12] * a),
      (this.y = l[1] * t + l[5] * n + l[9] * i + l[13] * a),
      (this.z = l[2] * t + l[6] * n + l[10] * i + l[14] * a),
      (this.w = l[3] * t + l[7] * n + l[11] * i + l[15] * a),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, a;
    const f = e.elements,
      d = f[0],
      m = f[4],
      v = f[8],
      _ = f[1],
      A = f[5],
      M = f[9],
      T = f[2],
      E = f[6],
      b = f[10];
    if (
      Math.abs(m - _) < 0.01 &&
      Math.abs(v - T) < 0.01 &&
      Math.abs(M - E) < 0.01
    ) {
      if (
        Math.abs(m + _) < 0.1 &&
        Math.abs(v + T) < 0.1 &&
        Math.abs(M + E) < 0.1 &&
        Math.abs(d + A + b - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const D = (d + 1) / 2,
        B = (A + 1) / 2,
        I = (b + 1) / 2,
        N = (m + _) / 4,
        P = (v + T) / 4,
        F = (M + E) / 4;
      return (
        D > B && D > I
          ? D < 0.01
            ? ((n = 0), (i = 0.707106781), (a = 0.707106781))
            : ((n = Math.sqrt(D)), (i = N / n), (a = P / n))
          : B > I
          ? B < 0.01
            ? ((n = 0.707106781), (i = 0), (a = 0.707106781))
            : ((i = Math.sqrt(B)), (n = N / i), (a = F / i))
          : I < 0.01
          ? ((n = 0.707106781), (i = 0.707106781), (a = 0))
          : ((a = Math.sqrt(I)), (n = P / a), (i = F / a)),
        this.set(n, i, a, t),
        this
      );
    }
    let w = Math.sqrt(
      (E - M) * (E - M) + (v - T) * (v - T) + (_ - m) * (_ - m)
    );
    return (
      Math.abs(w) < 0.001 && (w = 1),
      (this.x = (E - M) / w),
      (this.y = (v - T) / w),
      (this.z = (_ - m) / w),
      (this.w = Math.acos((d + A + b - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = dn(this.x, e.x, t.x)),
      (this.y = dn(this.y, e.y, t.y)),
      (this.z = dn(this.z, e.z, t.z)),
      (this.w = dn(this.w, e.w, t.w)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = dn(this.x, e, t)),
      (this.y = dn(this.y, e, t)),
      (this.z = dn(this.z, e, t)),
      (this.w = dn(this.w, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(dn(n, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Oy extends wl {
  constructor(e = 1, t = 1, n = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Hn(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Hn(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    n = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: In,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      n
    );
    const a = new Wn(
      i,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.colorSpace
    );
    (a.flipY = !1),
      (a.generateMipmaps = n.generateMipmaps),
      (a.internalFormat = n.internalFormat),
      (this.textures = []);
    const l = n.count;
    for (let u = 0; u < l; u++)
      (this.textures[u] = a.clone()),
        (this.textures[u].isRenderTargetTexture = !0),
        (this.textures[u].renderTarget = this);
    (this.depthBuffer = n.depthBuffer),
      (this.stencilBuffer = n.stencilBuffer),
      (this.resolveDepthBuffer = n.resolveDepthBuffer),
      (this.resolveStencilBuffer = n.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = n.depthTexture),
      (this.samples = n.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e);
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      (this.width = e), (this.height = t), (this.depth = n);
      for (let i = 0, a = this.textures.length; i < a; i++)
        (this.textures[i].image.width = e),
          (this.textures[i].image.height = t),
          (this.textures[i].image.depth = n);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let n = 0, i = e.textures.length; n < i; n++)
      (this.textures[n] = e.textures[n].clone()),
        (this.textures[n].isRenderTargetTexture = !0),
        (this.textures[n].renderTarget = this);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new If(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ha extends Oy {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), (this.isWebGLRenderTarget = !0);
  }
}
class Ym extends Wn {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = Kn),
      (this.minFilter = Kn),
      (this.wrapR = sa),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class WR extends ha {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = n),
      (this.texture = new Ym(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Ly extends Wn {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = Kn),
      (this.minFilter = Kn),
      (this.wrapR = sa),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class JR extends ha {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = n),
      (this.texture = new Ly(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class La {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i);
  }
  static slerpFlat(e, t, n, i, a, l, u) {
    let f = n[i + 0],
      d = n[i + 1],
      m = n[i + 2],
      v = n[i + 3];
    const _ = a[l + 0],
      A = a[l + 1],
      M = a[l + 2],
      T = a[l + 3];
    if (u === 0) {
      (e[t + 0] = f), (e[t + 1] = d), (e[t + 2] = m), (e[t + 3] = v);
      return;
    }
    if (u === 1) {
      (e[t + 0] = _), (e[t + 1] = A), (e[t + 2] = M), (e[t + 3] = T);
      return;
    }
    if (v !== T || f !== _ || d !== A || m !== M) {
      let E = 1 - u;
      const b = f * _ + d * A + m * M + v * T,
        w = b >= 0 ? 1 : -1,
        D = 1 - b * b;
      if (D > Number.EPSILON) {
        const I = Math.sqrt(D),
          N = Math.atan2(I, b * w);
        (E = Math.sin(E * N) / I), (u = Math.sin(u * N) / I);
      }
      const B = u * w;
      if (
        ((f = f * E + _ * B),
        (d = d * E + A * B),
        (m = m * E + M * B),
        (v = v * E + T * B),
        E === 1 - u)
      ) {
        const I = 1 / Math.sqrt(f * f + d * d + m * m + v * v);
        (f *= I), (d *= I), (m *= I), (v *= I);
      }
    }
    (e[t] = f), (e[t + 1] = d), (e[t + 2] = m), (e[t + 3] = v);
  }
  static multiplyQuaternionsFlat(e, t, n, i, a, l) {
    const u = n[i],
      f = n[i + 1],
      d = n[i + 2],
      m = n[i + 3],
      v = a[l],
      _ = a[l + 1],
      A = a[l + 2],
      M = a[l + 3];
    return (
      (e[t] = u * M + m * v + f * A - d * _),
      (e[t + 1] = f * M + m * _ + d * v - u * A),
      (e[t + 2] = d * M + m * A + u * _ - f * v),
      (e[t + 3] = m * M - u * v - f * _ - d * A),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const n = e._x,
      i = e._y,
      a = e._z,
      l = e._order,
      u = Math.cos,
      f = Math.sin,
      d = u(n / 2),
      m = u(i / 2),
      v = u(a / 2),
      _ = f(n / 2),
      A = f(i / 2),
      M = f(a / 2);
    switch (l) {
      case "XYZ":
        (this._x = _ * m * v + d * A * M),
          (this._y = d * A * v - _ * m * M),
          (this._z = d * m * M + _ * A * v),
          (this._w = d * m * v - _ * A * M);
        break;
      case "YXZ":
        (this._x = _ * m * v + d * A * M),
          (this._y = d * A * v - _ * m * M),
          (this._z = d * m * M - _ * A * v),
          (this._w = d * m * v + _ * A * M);
        break;
      case "ZXY":
        (this._x = _ * m * v - d * A * M),
          (this._y = d * A * v + _ * m * M),
          (this._z = d * m * M + _ * A * v),
          (this._w = d * m * v - _ * A * M);
        break;
      case "ZYX":
        (this._x = _ * m * v - d * A * M),
          (this._y = d * A * v + _ * m * M),
          (this._z = d * m * M - _ * A * v),
          (this._w = d * m * v + _ * A * M);
        break;
      case "YZX":
        (this._x = _ * m * v + d * A * M),
          (this._y = d * A * v + _ * m * M),
          (this._z = d * m * M - _ * A * v),
          (this._w = d * m * v - _ * A * M);
        break;
      case "XZY":
        (this._x = _ * m * v - d * A * M),
          (this._y = d * A * v - _ * m * M),
          (this._z = d * m * M + _ * A * v),
          (this._w = d * m * v + _ * A * M);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      i = Math.sin(n);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      i = t[4],
      a = t[8],
      l = t[1],
      u = t[5],
      f = t[9],
      d = t[2],
      m = t[6],
      v = t[10],
      _ = n + u + v;
    if (_ > 0) {
      const A = 0.5 / Math.sqrt(_ + 1);
      (this._w = 0.25 / A),
        (this._x = (m - f) * A),
        (this._y = (a - d) * A),
        (this._z = (l - i) * A);
    } else if (n > u && n > v) {
      const A = 2 * Math.sqrt(1 + n - u - v);
      (this._w = (m - f) / A),
        (this._x = 0.25 * A),
        (this._y = (i + l) / A),
        (this._z = (a + d) / A);
    } else if (u > v) {
      const A = 2 * Math.sqrt(1 + u - n - v);
      (this._w = (a - d) / A),
        (this._x = (i + l) / A),
        (this._y = 0.25 * A),
        (this._z = (f + m) / A);
    } else {
      const A = 2 * Math.sqrt(1 + v - n - u);
      (this._w = (l - i) / A),
        (this._x = (a + d) / A),
        (this._y = (f + m) / A),
        (this._z = 0.25 * A);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(dn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      i = e._y,
      a = e._z,
      l = e._w,
      u = t._x,
      f = t._y,
      d = t._z,
      m = t._w;
    return (
      (this._x = n * m + l * u + i * d - a * f),
      (this._y = i * m + l * f + a * u - n * d),
      (this._z = a * m + l * d + n * f - i * u),
      (this._w = l * m - n * u - i * f - a * d),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x,
      i = this._y,
      a = this._z,
      l = this._w;
    let u = l * e._w + n * e._x + i * e._y + a * e._z;
    if (
      (u < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (u = -u))
        : this.copy(e),
      u >= 1)
    )
      return (this._w = l), (this._x = n), (this._y = i), (this._z = a), this;
    const f = 1 - u * u;
    if (f <= Number.EPSILON) {
      const A = 1 - t;
      return (
        (this._w = A * l + t * this._w),
        (this._x = A * n + t * this._x),
        (this._y = A * i + t * this._y),
        (this._z = A * a + t * this._z),
        this.normalize(),
        this
      );
    }
    const d = Math.sqrt(f),
      m = Math.atan2(d, u),
      v = Math.sin((1 - t) * m) / d,
      _ = Math.sin(t * m) / d;
    return (
      (this._w = l * v + this._w * _),
      (this._x = n * v + this._x * _),
      (this._y = i * v + this._y * _),
      (this._z = a * v + this._z * _),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      n = Math.random(),
      i = Math.sqrt(1 - n),
      a = Math.sqrt(n);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      a * Math.sin(t),
      a * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class ie {
  constructor(e = 0, t = 0, n = 0) {
    (ie.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(YS.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(YS.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[3] * n + a[6] * i),
      (this.y = a[1] * t + a[4] * n + a[7] * i),
      (this.z = a[2] * t + a[5] * n + a[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      a = e.elements,
      l = 1 / (a[3] * t + a[7] * n + a[11] * i + a[15]);
    return (
      (this.x = (a[0] * t + a[4] * n + a[8] * i + a[12]) * l),
      (this.y = (a[1] * t + a[5] * n + a[9] * i + a[13]) * l),
      (this.z = (a[2] * t + a[6] * n + a[10] * i + a[14]) * l),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      a = e.x,
      l = e.y,
      u = e.z,
      f = e.w,
      d = 2 * (l * i - u * n),
      m = 2 * (u * t - a * i),
      v = 2 * (a * n - l * t);
    return (
      (this.x = t + f * d + l * v - u * m),
      (this.y = n + f * m + u * d - a * v),
      (this.z = i + f * v + a * m - l * d),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * n + a[8] * i),
      (this.y = a[1] * t + a[5] * n + a[9] * i),
      (this.z = a[2] * t + a[6] * n + a[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = dn(this.x, e.x, t.x)),
      (this.y = dn(this.y, e.y, t.y)),
      (this.z = dn(this.z, e.z, t.z)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = dn(this.x, e, t)),
      (this.y = dn(this.y, e, t)),
      (this.z = dn(this.z, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(dn(n, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      i = e.y,
      a = e.z,
      l = t.x,
      u = t.y,
      f = t.z;
    return (
      (this.x = i * f - a * u),
      (this.y = a * l - n * f),
      (this.z = n * u - i * l),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return $_.copy(this).projectOnVector(e), this.sub($_);
  }
  reflect(e) {
    return this.sub($_.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(dn(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      n = Math.sqrt(1 - t * t);
    return (
      (this.x = n * Math.cos(e)), (this.y = t), (this.z = n * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const $_ = new ie(),
  YS = new La();
class ya {
  constructor(
    e = new ie(1 / 0, 1 / 0, 1 / 0),
    t = new ie(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Eo.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Eo.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Eo.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const a = n.getAttribute("position");
      if (t === !0 && a !== void 0 && e.isInstancedMesh !== !0)
        for (let l = 0, u = a.count; l < u; l++)
          e.isMesh === !0
            ? e.getVertexPosition(l, Eo)
            : Eo.fromBufferAttribute(a, l),
            Eo.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Eo);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            bv.copy(e.boundingBox))
          : (n.boundingBox === null && n.computeBoundingBox(),
            bv.copy(n.boundingBox)),
          bv.applyMatrix4(e.matrixWorld),
          this.union(bv);
    }
    const i = e.children;
    for (let a = 0, l = i.length; a < l; a++) this.expandByObject(i[a], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Eo),
      Eo.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Zp),
      Ev.subVectors(this.max, Zp),
      Wh.subVectors(e.a, Zp),
      Jh.subVectors(e.b, Zp),
      qh.subVectors(e.c, Zp),
      sc.subVectors(Jh, Wh),
      oc.subVectors(qh, Jh),
      df.subVectors(Wh, qh);
    let t = [
      0,
      -sc.z,
      sc.y,
      0,
      -oc.z,
      oc.y,
      0,
      -df.z,
      df.y,
      sc.z,
      0,
      -sc.x,
      oc.z,
      0,
      -oc.x,
      df.z,
      0,
      -df.x,
      -sc.y,
      sc.x,
      0,
      -oc.y,
      oc.x,
      0,
      -df.y,
      df.x,
      0,
    ];
    return !e1(t, Wh, Jh, qh, Ev) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !e1(t, Wh, Jh, qh, Ev))
      ? !1
      : (Tv.crossVectors(sc, oc),
        (t = [Tv.x, Tv.y, Tv.z]),
        e1(t, Wh, Jh, qh, Ev));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Eo).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Eo).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (ou[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        ou[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        ou[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        ou[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        ou[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        ou[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        ou[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        ou[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(ou),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const ou = [
    new ie(),
    new ie(),
    new ie(),
    new ie(),
    new ie(),
    new ie(),
    new ie(),
    new ie(),
  ],
  Eo = new ie(),
  bv = new ya(),
  Wh = new ie(),
  Jh = new ie(),
  qh = new ie(),
  sc = new ie(),
  oc = new ie(),
  df = new ie(),
  Zp = new ie(),
  Ev = new ie(),
  Tv = new ie(),
  pf = new ie();
function e1(s, e, t, n, i) {
  for (let a = 0, l = s.length - 3; a <= l; a += 3) {
    pf.fromArray(s, a);
    const u =
        i.x * Math.abs(pf.x) + i.y * Math.abs(pf.y) + i.z * Math.abs(pf.z),
      f = e.dot(pf),
      d = t.dot(pf),
      m = n.dot(pf);
    if (Math.max(-Math.max(f, d, m), Math.min(f, d, m)) > u) return !1;
  }
  return !0;
}
const qR = new ya(),
  Qp = new ie(),
  t1 = new ie();
class Na {
  constructor(e = new ie(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : qR.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let a = 0, l = e.length; a < l; a++)
      i = Math.max(i, n.distanceToSquared(e[a]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Qp.subVectors(e, this.center);
    const t = Qp.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t),
        i = (n - this.radius) * 0.5;
      this.center.addScaledVector(Qp, i / n), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (t1.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Qp.copy(e.center).add(t1)),
            this.expandByPoint(Qp.copy(e.center).sub(t1))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const lu = new ie(),
  n1 = new ie(),
  Cv = new ie(),
  lc = new ie(),
  i1 = new ie(),
  Rv = new ie(),
  a1 = new ie();
class $f {
  constructor(e = new ie(), t = new ie(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, lu)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = lu.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (lu.copy(this.origin).addScaledVector(this.direction, t),
        lu.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    n1.copy(e).add(t).multiplyScalar(0.5),
      Cv.copy(t).sub(e).normalize(),
      lc.copy(this.origin).sub(n1);
    const a = e.distanceTo(t) * 0.5,
      l = -this.direction.dot(Cv),
      u = lc.dot(this.direction),
      f = -lc.dot(Cv),
      d = lc.lengthSq(),
      m = Math.abs(1 - l * l);
    let v, _, A, M;
    if (m > 0)
      if (((v = l * f - u), (_ = l * u - f), (M = a * m), v >= 0))
        if (_ >= -M)
          if (_ <= M) {
            const T = 1 / m;
            (v *= T),
              (_ *= T),
              (A = v * (v + l * _ + 2 * u) + _ * (l * v + _ + 2 * f) + d);
          } else
            (_ = a),
              (v = Math.max(0, -(l * _ + u))),
              (A = -v * v + _ * (_ + 2 * f) + d);
        else
          (_ = -a),
            (v = Math.max(0, -(l * _ + u))),
            (A = -v * v + _ * (_ + 2 * f) + d);
      else
        _ <= -M
          ? ((v = Math.max(0, -(-l * a + u))),
            (_ = v > 0 ? -a : Math.min(Math.max(-a, -f), a)),
            (A = -v * v + _ * (_ + 2 * f) + d))
          : _ <= M
          ? ((v = 0),
            (_ = Math.min(Math.max(-a, -f), a)),
            (A = _ * (_ + 2 * f) + d))
          : ((v = Math.max(0, -(l * a + u))),
            (_ = v > 0 ? a : Math.min(Math.max(-a, -f), a)),
            (A = -v * v + _ * (_ + 2 * f) + d));
    else
      (_ = l > 0 ? -a : a),
        (v = Math.max(0, -(l * _ + u))),
        (A = -v * v + _ * (_ + 2 * f) + d);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, v),
      i && i.copy(n1).addScaledVector(Cv, _),
      A
    );
  }
  intersectSphere(e, t) {
    lu.subVectors(e.center, this.origin);
    const n = lu.dot(this.direction),
      i = lu.dot(lu) - n * n,
      a = e.radius * e.radius;
    if (i > a) return null;
    const l = Math.sqrt(a - i),
      u = n - l,
      f = n + l;
    return f < 0 ? null : u < 0 ? this.at(f, t) : this.at(u, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, a, l, u, f;
    const d = 1 / this.direction.x,
      m = 1 / this.direction.y,
      v = 1 / this.direction.z,
      _ = this.origin;
    return (
      d >= 0
        ? ((n = (e.min.x - _.x) * d), (i = (e.max.x - _.x) * d))
        : ((n = (e.max.x - _.x) * d), (i = (e.min.x - _.x) * d)),
      m >= 0
        ? ((a = (e.min.y - _.y) * m), (l = (e.max.y - _.y) * m))
        : ((a = (e.max.y - _.y) * m), (l = (e.min.y - _.y) * m)),
      n > l ||
      a > i ||
      ((a > n || isNaN(n)) && (n = a),
      (l < i || isNaN(i)) && (i = l),
      v >= 0
        ? ((u = (e.min.z - _.z) * v), (f = (e.max.z - _.z) * v))
        : ((u = (e.max.z - _.z) * v), (f = (e.min.z - _.z) * v)),
      n > f || u > i) ||
      ((u > n || n !== n) && (n = u), (f < i || i !== i) && (i = f), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, lu) !== null;
  }
  intersectTriangle(e, t, n, i, a) {
    i1.subVectors(t, e), Rv.subVectors(n, e), a1.crossVectors(i1, Rv);
    let l = this.direction.dot(a1),
      u;
    if (l > 0) {
      if (i) return null;
      u = 1;
    } else if (l < 0) (u = -1), (l = -l);
    else return null;
    lc.subVectors(this.origin, e);
    const f = u * this.direction.dot(Rv.crossVectors(lc, Rv));
    if (f < 0) return null;
    const d = u * this.direction.dot(i1.cross(lc));
    if (d < 0 || f + d > l) return null;
    const m = -u * lc.dot(a1);
    return m < 0 ? null : this.at(m / l, a);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Qt {
  constructor(e, t, n, i, a, l, u, f, d, m, v, _, A, M, T, E) {
    (Qt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, a, l, u, f, d, m, v, _, A, M, T, E);
  }
  set(e, t, n, i, a, l, u, f, d, m, v, _, A, M, T, E) {
    const b = this.elements;
    return (
      (b[0] = e),
      (b[4] = t),
      (b[8] = n),
      (b[12] = i),
      (b[1] = a),
      (b[5] = l),
      (b[9] = u),
      (b[13] = f),
      (b[2] = d),
      (b[6] = m),
      (b[10] = v),
      (b[14] = _),
      (b[3] = A),
      (b[7] = M),
      (b[11] = T),
      (b[15] = E),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Qt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      i = 1 / jh.setFromMatrixColumn(e, 0).length(),
      a = 1 / jh.setFromMatrixColumn(e, 1).length(),
      l = 1 / jh.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * i),
      (t[1] = n[1] * i),
      (t[2] = n[2] * i),
      (t[3] = 0),
      (t[4] = n[4] * a),
      (t[5] = n[5] * a),
      (t[6] = n[6] * a),
      (t[7] = 0),
      (t[8] = n[8] * l),
      (t[9] = n[9] * l),
      (t[10] = n[10] * l),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      a = e.z,
      l = Math.cos(n),
      u = Math.sin(n),
      f = Math.cos(i),
      d = Math.sin(i),
      m = Math.cos(a),
      v = Math.sin(a);
    if (e.order === "XYZ") {
      const _ = l * m,
        A = l * v,
        M = u * m,
        T = u * v;
      (t[0] = f * m),
        (t[4] = -f * v),
        (t[8] = d),
        (t[1] = A + M * d),
        (t[5] = _ - T * d),
        (t[9] = -u * f),
        (t[2] = T - _ * d),
        (t[6] = M + A * d),
        (t[10] = l * f);
    } else if (e.order === "YXZ") {
      const _ = f * m,
        A = f * v,
        M = d * m,
        T = d * v;
      (t[0] = _ + T * u),
        (t[4] = M * u - A),
        (t[8] = l * d),
        (t[1] = l * v),
        (t[5] = l * m),
        (t[9] = -u),
        (t[2] = A * u - M),
        (t[6] = T + _ * u),
        (t[10] = l * f);
    } else if (e.order === "ZXY") {
      const _ = f * m,
        A = f * v,
        M = d * m,
        T = d * v;
      (t[0] = _ - T * u),
        (t[4] = -l * v),
        (t[8] = M + A * u),
        (t[1] = A + M * u),
        (t[5] = l * m),
        (t[9] = T - _ * u),
        (t[2] = -l * d),
        (t[6] = u),
        (t[10] = l * f);
    } else if (e.order === "ZYX") {
      const _ = l * m,
        A = l * v,
        M = u * m,
        T = u * v;
      (t[0] = f * m),
        (t[4] = M * d - A),
        (t[8] = _ * d + T),
        (t[1] = f * v),
        (t[5] = T * d + _),
        (t[9] = A * d - M),
        (t[2] = -d),
        (t[6] = u * f),
        (t[10] = l * f);
    } else if (e.order === "YZX") {
      const _ = l * f,
        A = l * d,
        M = u * f,
        T = u * d;
      (t[0] = f * m),
        (t[4] = T - _ * v),
        (t[8] = M * v + A),
        (t[1] = v),
        (t[5] = l * m),
        (t[9] = -u * m),
        (t[2] = -d * m),
        (t[6] = A * v + M),
        (t[10] = _ - T * v);
    } else if (e.order === "XZY") {
      const _ = l * f,
        A = l * d,
        M = u * f,
        T = u * d;
      (t[0] = f * m),
        (t[4] = -v),
        (t[8] = d * m),
        (t[1] = _ * v + T),
        (t[5] = l * m),
        (t[9] = A * v - M),
        (t[2] = M * v - A),
        (t[6] = u * m),
        (t[10] = T * v + _);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(jR, e, KR);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return (
      ds.subVectors(e, t),
      ds.lengthSq() === 0 && (ds.z = 1),
      ds.normalize(),
      uc.crossVectors(n, ds),
      uc.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (ds.x += 1e-4) : (ds.z += 1e-4),
        ds.normalize(),
        uc.crossVectors(n, ds)),
      uc.normalize(),
      wv.crossVectors(ds, uc),
      (i[0] = uc.x),
      (i[4] = wv.x),
      (i[8] = ds.x),
      (i[1] = uc.y),
      (i[5] = wv.y),
      (i[9] = ds.y),
      (i[2] = uc.z),
      (i[6] = wv.z),
      (i[10] = ds.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      a = this.elements,
      l = n[0],
      u = n[4],
      f = n[8],
      d = n[12],
      m = n[1],
      v = n[5],
      _ = n[9],
      A = n[13],
      M = n[2],
      T = n[6],
      E = n[10],
      b = n[14],
      w = n[3],
      D = n[7],
      B = n[11],
      I = n[15],
      N = i[0],
      P = i[4],
      F = i[8],
      O = i[12],
      U = i[1],
      W = i[5],
      J = i[9],
      q = i[13],
      Z = i[2],
      ue = i[6],
      K = i[10],
      ge = i[14],
      oe = i[3],
      me = i[7],
      V = i[11],
      Y = i[15];
    return (
      (a[0] = l * N + u * U + f * Z + d * oe),
      (a[4] = l * P + u * W + f * ue + d * me),
      (a[8] = l * F + u * J + f * K + d * V),
      (a[12] = l * O + u * q + f * ge + d * Y),
      (a[1] = m * N + v * U + _ * Z + A * oe),
      (a[5] = m * P + v * W + _ * ue + A * me),
      (a[9] = m * F + v * J + _ * K + A * V),
      (a[13] = m * O + v * q + _ * ge + A * Y),
      (a[2] = M * N + T * U + E * Z + b * oe),
      (a[6] = M * P + T * W + E * ue + b * me),
      (a[10] = M * F + T * J + E * K + b * V),
      (a[14] = M * O + T * q + E * ge + b * Y),
      (a[3] = w * N + D * U + B * Z + I * oe),
      (a[7] = w * P + D * W + B * ue + I * me),
      (a[11] = w * F + D * J + B * K + I * V),
      (a[15] = w * O + D * q + B * ge + I * Y),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      i = e[8],
      a = e[12],
      l = e[1],
      u = e[5],
      f = e[9],
      d = e[13],
      m = e[2],
      v = e[6],
      _ = e[10],
      A = e[14],
      M = e[3],
      T = e[7],
      E = e[11],
      b = e[15];
    return (
      M *
        (+a * f * v -
          i * d * v -
          a * u * _ +
          n * d * _ +
          i * u * A -
          n * f * A) +
      T *
        (+t * f * A -
          t * d * _ +
          a * l * _ -
          i * l * A +
          i * d * m -
          a * f * m) +
      E *
        (+t * d * v -
          t * u * A -
          a * l * v +
          n * l * A +
          a * u * m -
          n * d * m) +
      b *
        (-i * u * m - t * f * v + t * u * _ + i * l * v - n * l * _ + n * f * m)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      a = e[3],
      l = e[4],
      u = e[5],
      f = e[6],
      d = e[7],
      m = e[8],
      v = e[9],
      _ = e[10],
      A = e[11],
      M = e[12],
      T = e[13],
      E = e[14],
      b = e[15],
      w = v * E * d - T * _ * d + T * f * A - u * E * A - v * f * b + u * _ * b,
      D = M * _ * d - m * E * d - M * f * A + l * E * A + m * f * b - l * _ * b,
      B = m * T * d - M * v * d + M * u * A - l * T * A - m * u * b + l * v * b,
      I = M * v * f - m * T * f - M * u * _ + l * T * _ + m * u * E - l * v * E,
      N = t * w + n * D + i * B + a * I;
    if (N === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / N;
    return (
      (e[0] = w * P),
      (e[1] =
        (T * _ * a -
          v * E * a -
          T * i * A +
          n * E * A +
          v * i * b -
          n * _ * b) *
        P),
      (e[2] =
        (u * E * a -
          T * f * a +
          T * i * d -
          n * E * d -
          u * i * b +
          n * f * b) *
        P),
      (e[3] =
        (v * f * a -
          u * _ * a -
          v * i * d +
          n * _ * d +
          u * i * A -
          n * f * A) *
        P),
      (e[4] = D * P),
      (e[5] =
        (m * E * a -
          M * _ * a +
          M * i * A -
          t * E * A -
          m * i * b +
          t * _ * b) *
        P),
      (e[6] =
        (M * f * a -
          l * E * a -
          M * i * d +
          t * E * d +
          l * i * b -
          t * f * b) *
        P),
      (e[7] =
        (l * _ * a -
          m * f * a +
          m * i * d -
          t * _ * d -
          l * i * A +
          t * f * A) *
        P),
      (e[8] = B * P),
      (e[9] =
        (M * v * a -
          m * T * a -
          M * n * A +
          t * T * A +
          m * n * b -
          t * v * b) *
        P),
      (e[10] =
        (l * T * a -
          M * u * a +
          M * n * d -
          t * T * d -
          l * n * b +
          t * u * b) *
        P),
      (e[11] =
        (m * u * a -
          l * v * a -
          m * n * d +
          t * v * d +
          l * n * A -
          t * u * A) *
        P),
      (e[12] = I * P),
      (e[13] =
        (m * T * i -
          M * v * i +
          M * n * _ -
          t * T * _ -
          m * n * E +
          t * v * E) *
        P),
      (e[14] =
        (M * u * i -
          l * T * i -
          M * n * f +
          t * T * f +
          l * n * E -
          t * u * E) *
        P),
      (e[15] =
        (l * v * i -
          m * u * i +
          m * n * f -
          t * v * f -
          l * n * _ +
          t * u * _) *
        P),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      a = e.z;
    return (
      (t[0] *= n),
      (t[4] *= i),
      (t[8] *= a),
      (t[1] *= n),
      (t[5] *= i),
      (t[9] *= a),
      (t[2] *= n),
      (t[6] *= i),
      (t[10] *= a),
      (t[3] *= n),
      (t[7] *= i),
      (t[11] *= a),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      a = 1 - n,
      l = e.x,
      u = e.y,
      f = e.z,
      d = a * l,
      m = a * u;
    return (
      this.set(
        d * l + n,
        d * u - i * f,
        d * f + i * u,
        0,
        d * u + i * f,
        m * u + n,
        m * f - i * l,
        0,
        d * f - i * u,
        m * f + i * l,
        a * f * f + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, i, a, l) {
    return this.set(1, n, a, 0, e, 1, l, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const i = this.elements,
      a = t._x,
      l = t._y,
      u = t._z,
      f = t._w,
      d = a + a,
      m = l + l,
      v = u + u,
      _ = a * d,
      A = a * m,
      M = a * v,
      T = l * m,
      E = l * v,
      b = u * v,
      w = f * d,
      D = f * m,
      B = f * v,
      I = n.x,
      N = n.y,
      P = n.z;
    return (
      (i[0] = (1 - (T + b)) * I),
      (i[1] = (A + B) * I),
      (i[2] = (M - D) * I),
      (i[3] = 0),
      (i[4] = (A - B) * N),
      (i[5] = (1 - (_ + b)) * N),
      (i[6] = (E + w) * N),
      (i[7] = 0),
      (i[8] = (M + D) * P),
      (i[9] = (E - w) * P),
      (i[10] = (1 - (_ + T)) * P),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const i = this.elements;
    let a = jh.set(i[0], i[1], i[2]).length();
    const l = jh.set(i[4], i[5], i[6]).length(),
      u = jh.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (a = -a),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      To.copy(this);
    const d = 1 / a,
      m = 1 / l,
      v = 1 / u;
    return (
      (To.elements[0] *= d),
      (To.elements[1] *= d),
      (To.elements[2] *= d),
      (To.elements[4] *= m),
      (To.elements[5] *= m),
      (To.elements[6] *= m),
      (To.elements[8] *= v),
      (To.elements[9] *= v),
      (To.elements[10] *= v),
      t.setFromRotationMatrix(To),
      (n.x = a),
      (n.y = l),
      (n.z = u),
      this
    );
  }
  makePerspective(e, t, n, i, a, l, u = Do) {
    const f = this.elements,
      d = (2 * a) / (t - e),
      m = (2 * a) / (n - i),
      v = (t + e) / (t - e),
      _ = (n + i) / (n - i);
    let A, M;
    if (u === Do) (A = -(l + a) / (l - a)), (M = (-2 * l * a) / (l - a));
    else if (u === Om) (A = -l / (l - a)), (M = (-l * a) / (l - a));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + u
      );
    return (
      (f[0] = d),
      (f[4] = 0),
      (f[8] = v),
      (f[12] = 0),
      (f[1] = 0),
      (f[5] = m),
      (f[9] = _),
      (f[13] = 0),
      (f[2] = 0),
      (f[6] = 0),
      (f[10] = A),
      (f[14] = M),
      (f[3] = 0),
      (f[7] = 0),
      (f[11] = -1),
      (f[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, i, a, l, u = Do) {
    const f = this.elements,
      d = 1 / (t - e),
      m = 1 / (n - i),
      v = 1 / (l - a),
      _ = (t + e) * d,
      A = (n + i) * m;
    let M, T;
    if (u === Do) (M = (l + a) * v), (T = -2 * v);
    else if (u === Om) (M = a * v), (T = -1 * v);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + u
      );
    return (
      (f[0] = 2 * d),
      (f[4] = 0),
      (f[8] = 0),
      (f[12] = -_),
      (f[1] = 0),
      (f[5] = 2 * m),
      (f[9] = 0),
      (f[13] = -A),
      (f[2] = 0),
      (f[6] = 0),
      (f[10] = T),
      (f[14] = -M),
      (f[3] = 0),
      (f[7] = 0),
      (f[11] = 0),
      (f[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
const jh = new ie(),
  To = new Qt(),
  jR = new ie(0, 0, 0),
  KR = new ie(1, 1, 1),
  uc = new ie(),
  wv = new ie(),
  ds = new ie(),
  WS = new Qt(),
  JS = new La();
class vs {
  constructor(e = 0, t = 0, n = 0, i = vs.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements,
      a = i[0],
      l = i[4],
      u = i[8],
      f = i[1],
      d = i[5],
      m = i[9],
      v = i[2],
      _ = i[6],
      A = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(dn(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-m, A)), (this._z = Math.atan2(-l, a)))
            : ((this._x = Math.atan2(_, d)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-dn(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._y = Math.atan2(u, A)), (this._z = Math.atan2(f, d)))
            : ((this._y = Math.atan2(-v, a)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(dn(_, -1, 1))),
          Math.abs(_) < 0.9999999
            ? ((this._y = Math.atan2(-v, A)), (this._z = Math.atan2(-l, d)))
            : ((this._y = 0), (this._z = Math.atan2(f, a)));
        break;
      case "ZYX":
        (this._y = Math.asin(-dn(v, -1, 1))),
          Math.abs(v) < 0.9999999
            ? ((this._x = Math.atan2(_, A)), (this._z = Math.atan2(f, a)))
            : ((this._x = 0), (this._z = Math.atan2(-l, d)));
        break;
      case "YZX":
        (this._z = Math.asin(dn(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._x = Math.atan2(-m, d)), (this._y = Math.atan2(-v, a)))
            : ((this._x = 0), (this._y = Math.atan2(u, A)));
        break;
      case "XZY":
        (this._z = Math.asin(-dn(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(_, d)), (this._y = Math.atan2(u, a)))
            : ((this._x = Math.atan2(-m, A)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return (
      WS.makeRotationFromQuaternion(e), this.setFromRotationMatrix(WS, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return JS.setFromEuler(this), this.setFromQuaternion(JS, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
vs.DEFAULT_ORDER = "XYZ";
class Rd {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let ZR = 0;
const qS = new ie(),
  Kh = new La(),
  uu = new Qt(),
  Bv = new ie(),
  $p = new ie(),
  QR = new ie(),
  $R = new La(),
  jS = new ie(1, 0, 0),
  KS = new ie(0, 1, 0),
  ZS = new ie(0, 0, 1),
  QS = { type: "added" },
  ew = { type: "removed" },
  Zh = { type: "childadded", child: null },
  r1 = { type: "childremoved", child: null };
class On extends wl {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: ZR++ }),
      (this.uuid = gs()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = On.DEFAULT_UP.clone());
    const e = new ie(),
      t = new vs(),
      n = new La(),
      i = new ie(1, 1, 1);
    function a() {
      n.setFromEuler(t, !1);
    }
    function l() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(a),
      n._onChange(l),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Qt() },
        normalMatrix: { value: new hn() },
      }),
      (this.matrix = new Qt()),
      (this.matrixWorld = new Qt()),
      (this.matrixAutoUpdate = On.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = On.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Rd()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Kh.setFromAxisAngle(e, t), this.quaternion.multiply(Kh), this;
  }
  rotateOnWorldAxis(e, t) {
    return Kh.setFromAxisAngle(e, t), this.quaternion.premultiply(Kh), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(jS, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(KS, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(ZS, e);
  }
  translateOnAxis(e, t) {
    return (
      qS.copy(e).applyQuaternion(this.quaternion),
      this.position.add(qS.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(jS, e);
  }
  translateY(e) {
    return this.translateOnAxis(KS, e);
  }
  translateZ(e) {
    return this.translateOnAxis(ZS, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(uu.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, n) {
    e.isVector3 ? Bv.copy(e) : Bv.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      $p.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? uu.lookAt($p, Bv, this.up)
        : uu.lookAt(Bv, $p, this.up),
      this.quaternion.setFromRotationMatrix(uu),
      i &&
        (uu.extractRotation(i.matrixWorld),
        Kh.setFromRotationMatrix(uu),
        this.quaternion.premultiply(Kh.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(QS),
            (Zh.child = e),
            this.dispatchEvent(Zh),
            (Zh.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(ew),
        (r1.child = e),
        this.dispatchEvent(r1),
        (r1.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      uu.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), uu.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(uu),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(QS),
      (Zh.child = e),
      this.dispatchEvent(Zh),
      (Zh.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const l = this.children[n].getObjectByProperty(e, t);
      if (l !== void 0) return l;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let a = 0, l = i.length; a < l; a++)
      i[a].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose($p, e, QR), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose($p, $R, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      t === !0)
    ) {
      const i = this.children;
      for (let a = 0, l = i.length; a < l; a++) i[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((u) => ({
          boxInitialized: u.boxInitialized,
          boxMin: u.box.min.toArray(),
          boxMax: u.box.max.toArray(),
          sphereInitialized: u.sphereInitialized,
          sphereRadius: u.sphere.radius,
          sphereCenter: u.sphere.center.toArray(),
        }))),
        (i.maxInstanceCount = this._maxInstanceCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }));
    function a(u, f) {
      return u[f.uuid] === void 0 && (u[f.uuid] = f.toJSON(e)), f.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = a(e.geometries, this.geometry);
      const u = this.geometry.parameters;
      if (u !== void 0 && u.shapes !== void 0) {
        const f = u.shapes;
        if (Array.isArray(f))
          for (let d = 0, m = f.length; d < m; d++) {
            const v = f[d];
            a(e.shapes, v);
          }
        else a(e.shapes, f);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (a(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const u = [];
        for (let f = 0, d = this.material.length; f < d; f++)
          u.push(a(e.materials, this.material[f]));
        i.material = u;
      } else i.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let u = 0; u < this.children.length; u++)
        i.children.push(this.children[u].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let u = 0; u < this.animations.length; u++) {
        const f = this.animations[u];
        i.animations.push(a(e.animations, f));
      }
    }
    if (t) {
      const u = l(e.geometries),
        f = l(e.materials),
        d = l(e.textures),
        m = l(e.images),
        v = l(e.shapes),
        _ = l(e.skeletons),
        A = l(e.animations),
        M = l(e.nodes);
      u.length > 0 && (n.geometries = u),
        f.length > 0 && (n.materials = f),
        d.length > 0 && (n.textures = d),
        m.length > 0 && (n.images = m),
        v.length > 0 && (n.shapes = v),
        _.length > 0 && (n.skeletons = _),
        A.length > 0 && (n.animations = A),
        M.length > 0 && (n.nodes = M);
    }
    return (n.object = i), n;
    function l(u) {
      const f = [];
      for (const d in u) {
        const m = u[d];
        delete m.metadata, f.push(m);
      }
      return f;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
On.DEFAULT_UP = new ie(0, 1, 0);
On.DEFAULT_MATRIX_AUTO_UPDATE = !0;
On.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Co = new ie(),
  cu = new ie(),
  s1 = new ie(),
  fu = new ie(),
  Qh = new ie(),
  $h = new ie(),
  $S = new ie(),
  o1 = new ie(),
  l1 = new ie(),
  u1 = new ie(),
  c1 = new Hn(),
  f1 = new Hn(),
  h1 = new Hn();
class Kr {
  constructor(e = new ie(), t = new ie(), n = new ie()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), Co.subVectors(e, t), i.cross(Co);
    const a = i.lengthSq();
    return a > 0 ? i.multiplyScalar(1 / Math.sqrt(a)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, a) {
    Co.subVectors(i, t), cu.subVectors(n, t), s1.subVectors(e, t);
    const l = Co.dot(Co),
      u = Co.dot(cu),
      f = Co.dot(s1),
      d = cu.dot(cu),
      m = cu.dot(s1),
      v = l * d - u * u;
    if (v === 0) return a.set(0, 0, 0), null;
    const _ = 1 / v,
      A = (d * f - u * m) * _,
      M = (l * m - u * f) * _;
    return a.set(1 - A - M, M, A);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, fu) === null
      ? !1
      : fu.x >= 0 && fu.y >= 0 && fu.x + fu.y <= 1;
  }
  static getInterpolation(e, t, n, i, a, l, u, f) {
    return this.getBarycoord(e, t, n, i, fu) === null
      ? ((f.x = 0),
        (f.y = 0),
        "z" in f && (f.z = 0),
        "w" in f && (f.w = 0),
        null)
      : (f.setScalar(0),
        f.addScaledVector(a, fu.x),
        f.addScaledVector(l, fu.y),
        f.addScaledVector(u, fu.z),
        f);
  }
  static getInterpolatedAttribute(e, t, n, i, a, l) {
    return (
      c1.setScalar(0),
      f1.setScalar(0),
      h1.setScalar(0),
      c1.fromBufferAttribute(e, t),
      f1.fromBufferAttribute(e, n),
      h1.fromBufferAttribute(e, i),
      l.setScalar(0),
      l.addScaledVector(c1, a.x),
      l.addScaledVector(f1, a.y),
      l.addScaledVector(h1, a.z),
      l
    );
  }
  static isFrontFacing(e, t, n, i) {
    return Co.subVectors(n, t), cu.subVectors(e, t), Co.cross(cu).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Co.subVectors(this.c, this.b),
      cu.subVectors(this.a, this.b),
      Co.cross(cu).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Kr.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Kr.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, i, a) {
    return Kr.getInterpolation(e, this.a, this.b, this.c, t, n, i, a);
  }
  containsPoint(e) {
    return Kr.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Kr.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      i = this.b,
      a = this.c;
    let l, u;
    Qh.subVectors(i, n), $h.subVectors(a, n), o1.subVectors(e, n);
    const f = Qh.dot(o1),
      d = $h.dot(o1);
    if (f <= 0 && d <= 0) return t.copy(n);
    l1.subVectors(e, i);
    const m = Qh.dot(l1),
      v = $h.dot(l1);
    if (m >= 0 && v <= m) return t.copy(i);
    const _ = f * v - m * d;
    if (_ <= 0 && f >= 0 && m <= 0)
      return (l = f / (f - m)), t.copy(n).addScaledVector(Qh, l);
    u1.subVectors(e, a);
    const A = Qh.dot(u1),
      M = $h.dot(u1);
    if (M >= 0 && A <= M) return t.copy(a);
    const T = A * d - f * M;
    if (T <= 0 && d >= 0 && M <= 0)
      return (u = d / (d - M)), t.copy(n).addScaledVector($h, u);
    const E = m * M - A * v;
    if (E <= 0 && v - m >= 0 && A - M >= 0)
      return (
        $S.subVectors(a, i),
        (u = (v - m) / (v - m + (A - M))),
        t.copy(i).addScaledVector($S, u)
      );
    const b = 1 / (E + T + _);
    return (
      (l = T * b),
      (u = _ * b),
      t.copy(n).addScaledVector(Qh, l).addScaledVector($h, u)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const eT = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  cc = { h: 0, s: 0, l: 0 },
  Dv = { h: 0, s: 0, l: 0 };
function d1(s, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? s + (e - s) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? s + (e - s) * 6 * (2 / 3 - t)
      : s
  );
}
class Dt {
  constructor(e, t, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, n)
    );
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Wa) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      zn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, n, i = zn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = n),
      zn.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, n, i = zn.workingColorSpace) {
    if (((e = ex(e, 1)), (t = dn(t, 0, 1)), (n = dn(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const a = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        l = 2 * n - a;
      (this.r = d1(l, a, e + 1 / 3)),
        (this.g = d1(l, a, e)),
        (this.b = d1(l, a, e - 1 / 3));
    }
    return zn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Wa) {
    function n(a) {
      a !== void 0 &&
        parseFloat(a) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let a;
      const l = i[1],
        u = i[2];
      switch (l) {
        case "rgb":
        case "rgba":
          if (
            (a =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                u
              ))
          )
            return (
              n(a[4]),
              this.setRGB(
                Math.min(255, parseInt(a[1], 10)) / 255,
                Math.min(255, parseInt(a[2], 10)) / 255,
                Math.min(255, parseInt(a[3], 10)) / 255,
                t
              )
            );
          if (
            (a =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                u
              ))
          )
            return (
              n(a[4]),
              this.setRGB(
                Math.min(100, parseInt(a[1], 10)) / 100,
                Math.min(100, parseInt(a[2], 10)) / 100,
                Math.min(100, parseInt(a[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (a =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                u
              ))
          )
            return (
              n(a[4]),
              this.setHSL(
                parseFloat(a[1]) / 360,
                parseFloat(a[2]) / 100,
                parseFloat(a[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const a = i[1],
        l = a.length;
      if (l === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          t
        );
      if (l === 6) return this.setHex(parseInt(a, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Wa) {
    const n = eT[e.toLowerCase()];
    return (
      n !== void 0
        ? this.setHex(n, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Au(e.r)), (this.g = Au(e.g)), (this.b = Au(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = _d(e.r)), (this.g = _d(e.g)), (this.b = _d(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Wa) {
    return (
      zn.fromWorkingColorSpace(ur.copy(this), e),
      Math.round(dn(ur.r * 255, 0, 255)) * 65536 +
        Math.round(dn(ur.g * 255, 0, 255)) * 256 +
        Math.round(dn(ur.b * 255, 0, 255))
    );
  }
  getHexString(e = Wa) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = zn.workingColorSpace) {
    zn.fromWorkingColorSpace(ur.copy(this), t);
    const n = ur.r,
      i = ur.g,
      a = ur.b,
      l = Math.max(n, i, a),
      u = Math.min(n, i, a);
    let f, d;
    const m = (u + l) / 2;
    if (u === l) (f = 0), (d = 0);
    else {
      const v = l - u;
      switch (((d = m <= 0.5 ? v / (l + u) : v / (2 - l - u)), l)) {
        case n:
          f = (i - a) / v + (i < a ? 6 : 0);
          break;
        case i:
          f = (a - n) / v + 2;
          break;
        case a:
          f = (n - i) / v + 4;
          break;
      }
      f /= 6;
    }
    return (e.h = f), (e.s = d), (e.l = m), e;
  }
  getRGB(e, t = zn.workingColorSpace) {
    return (
      zn.fromWorkingColorSpace(ur.copy(this), t),
      (e.r = ur.r),
      (e.g = ur.g),
      (e.b = ur.b),
      e
    );
  }
  getStyle(e = Wa) {
    zn.fromWorkingColorSpace(ur.copy(this), e);
    const t = ur.r,
      n = ur.g,
      i = ur.b;
    return e !== Wa
      ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(cc), this.setHSL(cc.h + e, cc.s + t, cc.l + n);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(cc), e.getHSL(Dv);
    const n = Sm(cc.h, Dv.h, t),
      i = Sm(cc.s, Dv.s, t),
      a = Sm(cc.l, Dv.l, t);
    return this.setHSL(n, i, a), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      n = this.g,
      i = this.b,
      a = e.elements;
    return (
      (this.r = a[0] * t + a[3] * n + a[6] * i),
      (this.g = a[1] * t + a[4] * n + a[7] * i),
      (this.b = a[2] * t + a[5] * n + a[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ur = new Dt();
Dt.NAMES = eT;
let tw = 0;
class _a extends wl {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: tw++ }),
      (this.uuid = gs()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Hf),
      (this.side = Tl),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = D0),
      (this.blendDst = U0),
      (this.blendEquation = mc),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Dt(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Yf),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = vA),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Bf),
      (this.stencilZFail = Bf),
      (this.stencilZPass = Bf),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (n.dispersion = this.dispersion),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (n.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Hf && (n.blending = this.blending),
      this.side !== Tl && (n.side = this.side),
      this.vertexColors === !0 && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = !0),
      this.blendSrc !== D0 && (n.blendSrc = this.blendSrc),
      this.blendDst !== U0 && (n.blendDst = this.blendDst),
      this.blendEquation !== mc && (n.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (n.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (n.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
      this.depthFunc !== Yf && (n.depthFunc = this.depthFunc),
      this.depthTest === !1 && (n.depthTest = this.depthTest),
      this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (n.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== vA && (n.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (n.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Bf && (n.stencilFail = this.stencilFail),
      this.stencilZFail !== Bf && (n.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Bf && (n.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (n.alphaHash = !0),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (n.forceSinglePass = !0),
      this.wireframe === !0 && (n.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = !0),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(a) {
      const l = [];
      for (const u in a) {
        const f = a[u];
        delete f.metadata, l.push(f);
      }
      return l;
    }
    if (t) {
      const a = i(e.textures),
        l = i(e.images);
      a.length > 0 && (n.textures = a), l.length > 0 && (n.images = l);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let a = 0; a !== i; ++a) n[a] = t[a].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class fr extends _a {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Dt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new vs()),
      (this.combine = Vm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const vu = nw();
function nw() {
  const s = new ArrayBuffer(4),
    e = new Float32Array(s),
    t = new Uint32Array(s),
    n = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let f = 0; f < 256; ++f) {
    const d = f - 127;
    d < -27
      ? ((n[f] = 0), (n[f | 256] = 32768), (i[f] = 24), (i[f | 256] = 24))
      : d < -14
      ? ((n[f] = 1024 >> (-d - 14)),
        (n[f | 256] = (1024 >> (-d - 14)) | 32768),
        (i[f] = -d - 1),
        (i[f | 256] = -d - 1))
      : d <= 15
      ? ((n[f] = (d + 15) << 10),
        (n[f | 256] = ((d + 15) << 10) | 32768),
        (i[f] = 13),
        (i[f | 256] = 13))
      : d < 128
      ? ((n[f] = 31744), (n[f | 256] = 64512), (i[f] = 24), (i[f | 256] = 24))
      : ((n[f] = 31744), (n[f | 256] = 64512), (i[f] = 13), (i[f | 256] = 13));
  }
  const a = new Uint32Array(2048),
    l = new Uint32Array(64),
    u = new Uint32Array(64);
  for (let f = 1; f < 1024; ++f) {
    let d = f << 13,
      m = 0;
    for (; (d & 8388608) === 0; ) (d <<= 1), (m -= 8388608);
    (d &= -8388609), (m += 947912704), (a[f] = d | m);
  }
  for (let f = 1024; f < 2048; ++f) a[f] = 939524096 + ((f - 1024) << 13);
  for (let f = 1; f < 31; ++f) l[f] = f << 23;
  (l[31] = 1199570944), (l[32] = 2147483648);
  for (let f = 33; f < 63; ++f) l[f] = 2147483648 + ((f - 32) << 23);
  l[63] = 3347054592;
  for (let f = 1; f < 64; ++f) f !== 32 && (u[f] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: a,
    exponentTable: l,
    offsetTable: u,
  };
}
function qr(s) {
  Math.abs(s) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (s = dn(s, -65504, 65504)),
    (vu.floatView[0] = s);
  const e = vu.uint32View[0],
    t = (e >> 23) & 511;
  return vu.baseTable[t] + ((e & 8388607) >> vu.shiftTable[t]);
}
function dm(s) {
  const e = s >> 10;
  return (
    (vu.uint32View[0] =
      vu.mantissaTable[vu.offsetTable[e] + (s & 1023)] + vu.exponentTable[e]),
    vu.floatView[0]
  );
}
const Ff = { toHalfFloat: qr, fromHalfFloat: dm },
  fa = new ie(),
  Uv = new at();
let iw = 0;
class Yn {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      Object.defineProperty(this, "id", { value: iw++ }),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n),
      (this.usage = Um),
      (this.updateRanges = []),
      (this.gpuType = yi),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let i = 0, a = this.itemSize; i < a; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        Uv.fromBufferAttribute(this, t),
          Uv.applyMatrix3(e),
          this.setXY(t, Uv.x, Uv.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        fa.fromBufferAttribute(this, t),
          fa.applyMatrix3(e),
          this.setXYZ(t, fa.x, fa.y, fa.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      fa.fromBufferAttribute(this, t),
        fa.applyMatrix4(e),
        this.setXYZ(t, fa.x, fa.y, fa.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      fa.fromBufferAttribute(this, t),
        fa.applyNormalMatrix(e),
        this.setXYZ(t, fa.x, fa.y, fa.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      fa.fromBufferAttribute(this, t),
        fa.transformDirection(e),
        this.setXYZ(t, fa.x, fa.y, fa.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = Rr(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = An(n, this.array)),
      (this.array[e * this.itemSize + t] = n),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = An(t, this.array)), (n = An(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = An(t, this.array)),
        (n = An(n, this.array)),
        (i = An(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, a) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = An(t, this.array)),
        (n = An(n, this.array)),
        (i = An(i, this.array)),
        (a = An(a, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      (this.array[e + 3] = a),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Um && (e.usage = this.usage),
      e
    );
  }
}
class aw extends Yn {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class rw extends Yn {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class sw extends Yn {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class ow extends Yn {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class nx extends Yn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class lw extends Yn {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class ix extends Yn {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class uw extends Yn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = dm(this.array[e * this.itemSize]);
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.array[e * this.itemSize] = qr(t)),
      this
    );
  }
  getY(e) {
    let t = dm(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.array[e * this.itemSize + 1] = qr(t)),
      this
    );
  }
  getZ(e) {
    let t = dm(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.array[e * this.itemSize + 2] = qr(t)),
      this
    );
  }
  getW(e) {
    let t = dm(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.array[e * this.itemSize + 3] = qr(t)),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = An(t, this.array)), (n = An(n, this.array))),
      (this.array[e + 0] = qr(t)),
      (this.array[e + 1] = qr(n)),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = An(t, this.array)),
        (n = An(n, this.array)),
        (i = An(i, this.array))),
      (this.array[e + 0] = qr(t)),
      (this.array[e + 1] = qr(n)),
      (this.array[e + 2] = qr(i)),
      this
    );
  }
  setXYZW(e, t, n, i, a) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = An(t, this.array)),
        (n = An(n, this.array)),
        (i = An(i, this.array)),
        (a = An(a, this.array))),
      (this.array[e + 0] = qr(t)),
      (this.array[e + 1] = qr(n)),
      (this.array[e + 2] = qr(i)),
      (this.array[e + 3] = qr(a)),
      this
    );
  }
}
class Yt extends Yn {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let cw = 0;
const Ns = new Qt(),
  p1 = new On(),
  ed = new ie(),
  ps = new ya(),
  em = new ya(),
  Oa = new ie();
class mn extends wl {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: cw++ }),
      (this.uuid = gs()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (ZE(e) ? ix : nx)(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e) {
    return (this.indirect = e), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new hn().getNormalMatrix(e);
      n.applyNormalMatrix(a), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Ns.makeRotationFromQuaternion(e), this.applyMatrix4(Ns), this;
  }
  rotateX(e) {
    return Ns.makeRotationX(e), this.applyMatrix4(Ns), this;
  }
  rotateY(e) {
    return Ns.makeRotationY(e), this.applyMatrix4(Ns), this;
  }
  rotateZ(e) {
    return Ns.makeRotationZ(e), this.applyMatrix4(Ns), this;
  }
  translate(e, t, n) {
    return Ns.makeTranslation(e, t, n), this.applyMatrix4(Ns), this;
  }
  scale(e, t, n) {
    return Ns.makeScale(e, t, n), this.applyMatrix4(Ns), this;
  }
  lookAt(e) {
    return p1.lookAt(e), p1.updateMatrix(), this.applyMatrix4(p1.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(ed).negate(),
      this.translate(ed.x, ed.y, ed.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const n = [];
      for (let i = 0, a = e.length; i < a; i++) {
        const l = e[i];
        n.push(l.x, l.y, l.z || 0);
      }
      this.setAttribute("position", new Yt(n, 3));
    } else {
      const n = Math.min(e.length, t.count);
      for (let i = 0; i < n; i++) {
        const a = e[i];
        t.setXYZ(i, a.x, a.y, a.z || 0);
      }
      e.length > t.count &&
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
        ),
        (t.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ya());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new ie(-1 / 0, -1 / 0, -1 / 0),
          new ie(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, i = t.length; n < i; n++) {
          const a = t[n];
          ps.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Oa.addVectors(this.boundingBox.min, ps.min),
                this.boundingBox.expandByPoint(Oa),
                Oa.addVectors(this.boundingBox.max, ps.max),
                this.boundingBox.expandByPoint(Oa))
              : (this.boundingBox.expandByPoint(ps.min),
                this.boundingBox.expandByPoint(ps.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Na());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new ie(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((ps.setFromBufferAttribute(e), t))
        for (let a = 0, l = t.length; a < l; a++) {
          const u = t[a];
          em.setFromBufferAttribute(u),
            this.morphTargetsRelative
              ? (Oa.addVectors(ps.min, em.min),
                ps.expandByPoint(Oa),
                Oa.addVectors(ps.max, em.max),
                ps.expandByPoint(Oa))
              : (ps.expandByPoint(em.min), ps.expandByPoint(em.max));
        }
      ps.getCenter(n);
      let i = 0;
      for (let a = 0, l = e.count; a < l; a++)
        Oa.fromBufferAttribute(e, a),
          (i = Math.max(i, n.distanceToSquared(Oa)));
      if (t)
        for (let a = 0, l = t.length; a < l; a++) {
          const u = t[a],
            f = this.morphTargetsRelative;
          for (let d = 0, m = u.count; d < m; d++)
            Oa.fromBufferAttribute(u, d),
              f && (ed.fromBufferAttribute(e, d), Oa.add(ed)),
              (i = Math.max(i, n.distanceToSquared(Oa)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const n = t.position,
      i = t.normal,
      a = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Yn(new Float32Array(4 * n.count), 4));
    const l = this.getAttribute("tangent"),
      u = [],
      f = [];
    for (let F = 0; F < n.count; F++) (u[F] = new ie()), (f[F] = new ie());
    const d = new ie(),
      m = new ie(),
      v = new ie(),
      _ = new at(),
      A = new at(),
      M = new at(),
      T = new ie(),
      E = new ie();
    function b(F, O, U) {
      d.fromBufferAttribute(n, F),
        m.fromBufferAttribute(n, O),
        v.fromBufferAttribute(n, U),
        _.fromBufferAttribute(a, F),
        A.fromBufferAttribute(a, O),
        M.fromBufferAttribute(a, U),
        m.sub(d),
        v.sub(d),
        A.sub(_),
        M.sub(_);
      const W = 1 / (A.x * M.y - M.x * A.y);
      isFinite(W) &&
        (T.copy(m)
          .multiplyScalar(M.y)
          .addScaledVector(v, -A.y)
          .multiplyScalar(W),
        E.copy(v)
          .multiplyScalar(A.x)
          .addScaledVector(m, -M.x)
          .multiplyScalar(W),
        u[F].add(T),
        u[O].add(T),
        u[U].add(T),
        f[F].add(E),
        f[O].add(E),
        f[U].add(E));
    }
    let w = this.groups;
    w.length === 0 && (w = [{ start: 0, count: e.count }]);
    for (let F = 0, O = w.length; F < O; ++F) {
      const U = w[F],
        W = U.start,
        J = U.count;
      for (let q = W, Z = W + J; q < Z; q += 3)
        b(e.getX(q + 0), e.getX(q + 1), e.getX(q + 2));
    }
    const D = new ie(),
      B = new ie(),
      I = new ie(),
      N = new ie();
    function P(F) {
      I.fromBufferAttribute(i, F), N.copy(I);
      const O = u[F];
      D.copy(O),
        D.sub(I.multiplyScalar(I.dot(O))).normalize(),
        B.crossVectors(N, O);
      const W = B.dot(f[F]) < 0 ? -1 : 1;
      l.setXYZW(F, D.x, D.y, D.z, W);
    }
    for (let F = 0, O = w.length; F < O; ++F) {
      const U = w[F],
        W = U.start,
        J = U.count;
      for (let q = W, Z = W + J; q < Z; q += 3)
        P(e.getX(q + 0)), P(e.getX(q + 1)), P(e.getX(q + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new Yn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let _ = 0, A = n.count; _ < A; _++) n.setXYZ(_, 0, 0, 0);
      const i = new ie(),
        a = new ie(),
        l = new ie(),
        u = new ie(),
        f = new ie(),
        d = new ie(),
        m = new ie(),
        v = new ie();
      if (e)
        for (let _ = 0, A = e.count; _ < A; _ += 3) {
          const M = e.getX(_ + 0),
            T = e.getX(_ + 1),
            E = e.getX(_ + 2);
          i.fromBufferAttribute(t, M),
            a.fromBufferAttribute(t, T),
            l.fromBufferAttribute(t, E),
            m.subVectors(l, a),
            v.subVectors(i, a),
            m.cross(v),
            u.fromBufferAttribute(n, M),
            f.fromBufferAttribute(n, T),
            d.fromBufferAttribute(n, E),
            u.add(m),
            f.add(m),
            d.add(m),
            n.setXYZ(M, u.x, u.y, u.z),
            n.setXYZ(T, f.x, f.y, f.z),
            n.setXYZ(E, d.x, d.y, d.z);
        }
      else
        for (let _ = 0, A = t.count; _ < A; _ += 3)
          i.fromBufferAttribute(t, _ + 0),
            a.fromBufferAttribute(t, _ + 1),
            l.fromBufferAttribute(t, _ + 2),
            m.subVectors(l, a),
            v.subVectors(i, a),
            m.cross(v),
            n.setXYZ(_ + 0, m.x, m.y, m.z),
            n.setXYZ(_ + 1, m.x, m.y, m.z),
            n.setXYZ(_ + 2, m.x, m.y, m.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Oa.fromBufferAttribute(e, t),
        Oa.normalize(),
        e.setXYZ(t, Oa.x, Oa.y, Oa.z);
  }
  toNonIndexed() {
    function e(u, f) {
      const d = u.array,
        m = u.itemSize,
        v = u.normalized,
        _ = new d.constructor(f.length * m);
      let A = 0,
        M = 0;
      for (let T = 0, E = f.length; T < E; T++) {
        u.isInterleavedBufferAttribute
          ? (A = f[T] * u.data.stride + u.offset)
          : (A = f[T] * m);
        for (let b = 0; b < m; b++) _[M++] = d[A++];
      }
      return new Yn(_, m, v);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new mn(),
      n = this.index.array,
      i = this.attributes;
    for (const u in i) {
      const f = i[u],
        d = e(f, n);
      t.setAttribute(u, d);
    }
    const a = this.morphAttributes;
    for (const u in a) {
      const f = [],
        d = a[u];
      for (let m = 0, v = d.length; m < v; m++) {
        const _ = d[m],
          A = e(_, n);
        f.push(A);
      }
      t.morphAttributes[u] = f;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const l = this.groups;
    for (let u = 0, f = l.length; u < f; u++) {
      const d = l[u];
      t.addGroup(d.start, d.count, d.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const f = this.parameters;
      for (const d in f) f[d] !== void 0 && (e[d] = f[d]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const f in n) {
      const d = n[f];
      e.data.attributes[f] = d.toJSON(e.data);
    }
    const i = {};
    let a = !1;
    for (const f in this.morphAttributes) {
      const d = this.morphAttributes[f],
        m = [];
      for (let v = 0, _ = d.length; v < _; v++) {
        const A = d[v];
        m.push(A.toJSON(e.data));
      }
      m.length > 0 && ((i[f] = m), (a = !0));
    }
    a &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const l = this.groups;
    l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l)));
    const u = this.boundingSphere;
    return (
      u !== null &&
        (e.data.boundingSphere = {
          center: u.center.toArray(),
          radius: u.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const d in i) {
      const m = i[d];
      this.setAttribute(d, m.clone(t));
    }
    const a = e.morphAttributes;
    for (const d in a) {
      const m = [],
        v = a[d];
      for (let _ = 0, A = v.length; _ < A; _++) m.push(v[_].clone(t));
      this.morphAttributes[d] = m;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const l = e.groups;
    for (let d = 0, m = l.length; d < m; d++) {
      const v = l[d];
      this.addGroup(v.start, v.count, v.materialIndex);
    }
    const u = e.boundingBox;
    u !== null && (this.boundingBox = u.clone());
    const f = e.boundingSphere;
    return (
      f !== null && (this.boundingSphere = f.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const eM = new Qt(),
  mf = new $f(),
  Ov = new Na(),
  tM = new ie(),
  Lv = new ie(),
  Nv = new ie(),
  Iv = new ie(),
  m1 = new ie(),
  Fv = new ie(),
  nM = new ie(),
  Pv = new ie();
class li extends On {
  constructor(e = new mn(), t = new fr()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let a = 0, l = i.length; a < l; a++) {
          const u = i[a].name || String(a);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[u] = a);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry,
      i = n.attributes.position,
      a = n.morphAttributes.position,
      l = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const u = this.morphTargetInfluences;
    if (a && u) {
      Fv.set(0, 0, 0);
      for (let f = 0, d = a.length; f < d; f++) {
        const m = u[f],
          v = a[f];
        m !== 0 &&
          (m1.fromBufferAttribute(v, e),
          l ? Fv.addScaledVector(m1, m) : Fv.addScaledVector(m1.sub(t), m));
      }
      t.add(Fv);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.material,
      a = this.matrixWorld;
    i !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Ov.copy(n.boundingSphere),
      Ov.applyMatrix4(a),
      mf.copy(e.ray).recast(e.near),
      !(
        Ov.containsPoint(mf.origin) === !1 &&
        (mf.intersectSphere(Ov, tM) === null ||
          mf.origin.distanceToSquared(tM) > (e.far - e.near) ** 2)
      ) &&
        (eM.copy(a).invert(),
        mf.copy(e.ray).applyMatrix4(eM),
        !(n.boundingBox !== null && mf.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(e, t, mf)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const a = this.geometry,
      l = this.material,
      u = a.index,
      f = a.attributes.position,
      d = a.attributes.uv,
      m = a.attributes.uv1,
      v = a.attributes.normal,
      _ = a.groups,
      A = a.drawRange;
    if (u !== null)
      if (Array.isArray(l))
        for (let M = 0, T = _.length; M < T; M++) {
          const E = _[M],
            b = l[E.materialIndex],
            w = Math.max(E.start, A.start),
            D = Math.min(
              u.count,
              Math.min(E.start + E.count, A.start + A.count)
            );
          for (let B = w, I = D; B < I; B += 3) {
            const N = u.getX(B),
              P = u.getX(B + 1),
              F = u.getX(B + 2);
            (i = Gv(this, b, e, n, d, m, v, N, P, F)),
              i &&
                ((i.faceIndex = Math.floor(B / 3)),
                (i.face.materialIndex = E.materialIndex),
                t.push(i));
          }
        }
      else {
        const M = Math.max(0, A.start),
          T = Math.min(u.count, A.start + A.count);
        for (let E = M, b = T; E < b; E += 3) {
          const w = u.getX(E),
            D = u.getX(E + 1),
            B = u.getX(E + 2);
          (i = Gv(this, l, e, n, d, m, v, w, D, B)),
            i && ((i.faceIndex = Math.floor(E / 3)), t.push(i));
        }
      }
    else if (f !== void 0)
      if (Array.isArray(l))
        for (let M = 0, T = _.length; M < T; M++) {
          const E = _[M],
            b = l[E.materialIndex],
            w = Math.max(E.start, A.start),
            D = Math.min(
              f.count,
              Math.min(E.start + E.count, A.start + A.count)
            );
          for (let B = w, I = D; B < I; B += 3) {
            const N = B,
              P = B + 1,
              F = B + 2;
            (i = Gv(this, b, e, n, d, m, v, N, P, F)),
              i &&
                ((i.faceIndex = Math.floor(B / 3)),
                (i.face.materialIndex = E.materialIndex),
                t.push(i));
          }
        }
      else {
        const M = Math.max(0, A.start),
          T = Math.min(f.count, A.start + A.count);
        for (let E = M, b = T; E < b; E += 3) {
          const w = E,
            D = E + 1,
            B = E + 2;
          (i = Gv(this, l, e, n, d, m, v, w, D, B)),
            i && ((i.faceIndex = Math.floor(E / 3)), t.push(i));
        }
      }
  }
}
function fw(s, e, t, n, i, a, l, u) {
  let f;
  if (
    (e.side === hr
      ? (f = n.intersectTriangle(l, a, i, !0, u))
      : (f = n.intersectTriangle(i, a, l, e.side === Tl, u)),
    f === null)
  )
    return null;
  Pv.copy(u), Pv.applyMatrix4(s.matrixWorld);
  const d = t.ray.origin.distanceTo(Pv);
  return d < t.near || d > t.far
    ? null
    : { distance: d, point: Pv.clone(), object: s };
}
function Gv(s, e, t, n, i, a, l, u, f, d) {
  s.getVertexPosition(u, Lv),
    s.getVertexPosition(f, Nv),
    s.getVertexPosition(d, Iv);
  const m = fw(s, e, t, n, Lv, Nv, Iv, nM);
  if (m) {
    const v = new ie();
    Kr.getBarycoord(nM, Lv, Nv, Iv, v),
      i && (m.uv = Kr.getInterpolatedAttribute(i, u, f, d, v, new at())),
      a && (m.uv1 = Kr.getInterpolatedAttribute(a, u, f, d, v, new at())),
      l &&
        ((m.normal = Kr.getInterpolatedAttribute(l, u, f, d, v, new ie())),
        m.normal.dot(n.direction) > 0 && m.normal.multiplyScalar(-1));
    const _ = { a: u, b: f, c: d, normal: new ie(), materialIndex: 0 };
    Kr.getNormal(Lv, Nv, Iv, _.normal), (m.face = _), (m.barycoord = v);
  }
  return m;
}
class eh extends mn {
  constructor(e = 1, t = 1, n = 1, i = 1, a = 1, l = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: a,
        depthSegments: l,
      });
    const u = this;
    (i = Math.floor(i)), (a = Math.floor(a)), (l = Math.floor(l));
    const f = [],
      d = [],
      m = [],
      v = [];
    let _ = 0,
      A = 0;
    M("z", "y", "x", -1, -1, n, t, e, l, a, 0),
      M("z", "y", "x", 1, -1, n, t, -e, l, a, 1),
      M("x", "z", "y", 1, 1, e, n, t, i, l, 2),
      M("x", "z", "y", 1, -1, e, n, -t, i, l, 3),
      M("x", "y", "z", 1, -1, e, t, n, i, a, 4),
      M("x", "y", "z", -1, -1, e, t, -n, i, a, 5),
      this.setIndex(f),
      this.setAttribute("position", new Yt(d, 3)),
      this.setAttribute("normal", new Yt(m, 3)),
      this.setAttribute("uv", new Yt(v, 2));
    function M(T, E, b, w, D, B, I, N, P, F, O) {
      const U = B / P,
        W = I / F,
        J = B / 2,
        q = I / 2,
        Z = N / 2,
        ue = P + 1,
        K = F + 1;
      let ge = 0,
        oe = 0;
      const me = new ie();
      for (let V = 0; V < K; V++) {
        const Y = V * W - q;
        for (let ae = 0; ae < ue; ae++) {
          const fe = ae * U - J;
          (me[T] = fe * w),
            (me[E] = Y * D),
            (me[b] = Z),
            d.push(me.x, me.y, me.z),
            (me[T] = 0),
            (me[E] = 0),
            (me[b] = N > 0 ? 1 : -1),
            m.push(me.x, me.y, me.z),
            v.push(ae / P),
            v.push(1 - V / F),
            (ge += 1);
        }
      }
      for (let V = 0; V < F; V++)
        for (let Y = 0; Y < P; Y++) {
          const ae = _ + Y + ue * V,
            fe = _ + Y + ue * (V + 1),
            j = _ + (Y + 1) + ue * (V + 1),
            se = _ + (Y + 1) + ue * V;
          f.push(ae, fe, se), f.push(fe, j, se), (oe += 6);
        }
      u.addGroup(A, oe, O), (A += oe), (_ += ge);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new eh(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function wd(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const n in s[t]) {
      const i = s[t][n];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][n] = null))
          : (e[t][n] = i.clone())
        : Array.isArray(i)
        ? (e[t][n] = i.slice())
        : (e[t][n] = i);
    }
  }
  return e;
}
function Tr(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const n = wd(s[t]);
    for (const i in n) e[i] = n[i];
  }
  return e;
}
function hw(s) {
  const e = [];
  for (let t = 0; t < s.length; t++) e.push(s[t].clone());
  return e;
}
function tT(s) {
  const e = s.getRenderTarget();
  return e === null
    ? s.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : zn.workingColorSpace;
}
const Ny = { clone: wd, merge: Tr };
var dw = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  pw = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ra extends _a {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = dw),
      (this.fragmentShader = pw),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = wd(e.uniforms)),
      (this.uniformsGroups = hw(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const l = this.uniforms[i].value;
      l && l.isTexture
        ? (t.uniforms[i] = { type: "t", value: l.toJSON(e).uuid })
        : l && l.isColor
        ? (t.uniforms[i] = { type: "c", value: l.getHex() })
        : l && l.isVector2
        ? (t.uniforms[i] = { type: "v2", value: l.toArray() })
        : l && l.isVector3
        ? (t.uniforms[i] = { type: "v3", value: l.toArray() })
        : l && l.isVector4
        ? (t.uniforms[i] = { type: "v4", value: l.toArray() })
        : l && l.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: l.toArray() })
        : l && l.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: l.toArray() })
        : (t.uniforms[i] = { value: l });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const n = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class Iy extends On {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Qt()),
      (this.projectionMatrix = new Qt()),
      (this.projectionMatrixInverse = new Qt()),
      (this.coordinateSystem = Do);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const fc = new ie(),
  iM = new at(),
  aM = new at();
class $i extends Iy {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Cd * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(kf * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Cd * 2 * Math.atan(Math.tan(kf * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, n) {
    fc.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(fc.x, fc.y).multiplyScalar(-e / fc.z),
      fc.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(fc.x, fc.y).multiplyScalar(-e / fc.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, iM, aM), t.subVectors(aM, iM);
  }
  setViewOffset(e, t, n, i, a, l) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = a),
      (this.view.height = l),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(kf * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      i = this.aspect * n,
      a = -0.5 * i;
    const l = this.view;
    if (this.view !== null && this.view.enabled) {
      const f = l.fullWidth,
        d = l.fullHeight;
      (a += (l.offsetX * i) / f),
        (t -= (l.offsetY * n) / d),
        (i *= l.width / f),
        (n *= l.height / d);
    }
    const u = this.filmOffset;
    u !== 0 && (a += (e * u) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        a,
        a + i,
        t,
        t - n,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const td = -90,
  nd = 1;
class nT extends On {
  constructor(e, t, n) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = n),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new $i(td, nd, e, t);
    (i.layers = this.layers), this.add(i);
    const a = new $i(td, nd, e, t);
    (a.layers = this.layers), this.add(a);
    const l = new $i(td, nd, e, t);
    (l.layers = this.layers), this.add(l);
    const u = new $i(td, nd, e, t);
    (u.layers = this.layers), this.add(u);
    const f = new $i(td, nd, e, t);
    (f.layers = this.layers), this.add(f);
    const d = new $i(td, nd, e, t);
    (d.layers = this.layers), this.add(d);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [n, i, a, l, u, f] = t;
    for (const d of t) this.remove(d);
    if (e === Do)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, 1, 0),
        l.up.set(0, 0, 1),
        l.lookAt(0, -1, 0),
        u.up.set(0, 1, 0),
        u.lookAt(0, 0, 1),
        f.up.set(0, 1, 0),
        f.lookAt(0, 0, -1);
    else if (e === Om)
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, 1, 0),
        l.up.set(0, 0, -1),
        l.lookAt(0, -1, 0),
        u.up.set(0, -1, 0),
        u.lookAt(0, 0, 1),
        f.up.set(0, -1, 0),
        f.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const d of t) this.add(d), d.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [a, l, u, f, d, m] = this.children,
      v = e.getRenderTarget(),
      _ = e.getActiveCubeFace(),
      A = e.getActiveMipmapLevel(),
      M = e.xr.enabled;
    e.xr.enabled = !1;
    const T = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0, i),
      e.render(t, a),
      e.setRenderTarget(n, 1, i),
      e.render(t, l),
      e.setRenderTarget(n, 2, i),
      e.render(t, u),
      e.setRenderTarget(n, 3, i),
      e.render(t, f),
      e.setRenderTarget(n, 4, i),
      e.render(t, d),
      (n.texture.generateMipmaps = T),
      e.setRenderTarget(n, 5, i),
      e.render(t, m),
      e.setRenderTarget(v, _, A),
      (e.xr.enabled = M),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class Wm extends Wn {
  constructor(e, t, n, i, a, l, u, f, d, m) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Cl),
      super(e, t, n, i, a, l, u, f, d, m),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class ax extends ha {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: e, height: e, depth: 1 },
      i = [n, n, n, n, n, n];
    (this.texture = new Wm(
      i,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : In);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new eh(5, 5, 5),
      a = new ra({
        name: "CubemapFromEquirect",
        uniforms: wd(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: hr,
        blending: Ml,
      });
    a.uniforms.tEquirect.value = t;
    const l = new li(i, a),
      u = t.minFilter;
    return (
      t.minFilter === ms && (t.minFilter = In),
      new nT(1, 10, this).update(e, l),
      (t.minFilter = u),
      l.geometry.dispose(),
      l.material.dispose(),
      this
    );
  }
  clear(e, t, n, i) {
    const a = e.getRenderTarget();
    for (let l = 0; l < 6; l++) e.setRenderTarget(this, l), e.clear(t, n, i);
    e.setRenderTarget(a);
  }
}
class yu extends On {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const mw = { type: "move" };
class E0 {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new yu()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new yu()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new ie()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new ie())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new yu()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new ie()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new ie())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let i = null,
      a = null,
      l = null;
    const u = this._targetRay,
      f = this._grip,
      d = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (d && e.hand) {
        l = !0;
        for (const T of e.hand.values()) {
          const E = t.getJointPose(T, n),
            b = this._getHandJoint(d, T);
          E !== null &&
            (b.matrix.fromArray(E.transform.matrix),
            b.matrix.decompose(b.position, b.rotation, b.scale),
            (b.matrixWorldNeedsUpdate = !0),
            (b.jointRadius = E.radius)),
            (b.visible = E !== null);
        }
        const m = d.joints["index-finger-tip"],
          v = d.joints["thumb-tip"],
          _ = m.position.distanceTo(v.position),
          A = 0.02,
          M = 0.005;
        d.inputState.pinching && _ > A + M
          ? ((d.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !d.inputState.pinching &&
            _ <= A - M &&
            ((d.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        f !== null &&
          e.gripSpace &&
          ((a = t.getPose(e.gripSpace, n)),
          a !== null &&
            (f.matrix.fromArray(a.transform.matrix),
            f.matrix.decompose(f.position, f.rotation, f.scale),
            (f.matrixWorldNeedsUpdate = !0),
            a.linearVelocity
              ? ((f.hasLinearVelocity = !0),
                f.linearVelocity.copy(a.linearVelocity))
              : (f.hasLinearVelocity = !1),
            a.angularVelocity
              ? ((f.hasAngularVelocity = !0),
                f.angularVelocity.copy(a.angularVelocity))
              : (f.hasAngularVelocity = !1)));
      u !== null &&
        ((i = t.getPose(e.targetRaySpace, n)),
        i === null && a !== null && (i = a),
        i !== null &&
          (u.matrix.fromArray(i.transform.matrix),
          u.matrix.decompose(u.position, u.rotation, u.scale),
          (u.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((u.hasLinearVelocity = !0),
              u.linearVelocity.copy(i.linearVelocity))
            : (u.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((u.hasAngularVelocity = !0),
              u.angularVelocity.copy(i.angularVelocity))
            : (u.hasAngularVelocity = !1),
          this.dispatchEvent(mw)));
    }
    return (
      u !== null && (u.visible = i !== null),
      f !== null && (f.visible = a !== null),
      d !== null && (d.visible = l !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new yu();
      (n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (e.joints[t.jointName] = n),
        e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class Fy {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Dt(e)),
      (this.density = t);
  }
  clone() {
    return new Fy(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Py {
  constructor(e, t = 1, n = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Dt(e)),
      (this.near = t),
      (this.far = n);
  }
  clone() {
    return new Py(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
let Nd = class extends On {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new vs()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new vs()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
};
class Jm {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Um),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = gs());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let i = 0, a = this.stride; i < a; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = gs()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = gs()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Er = new ie();
class Mc {
  constructor(e, t, n, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Er.fromBufferAttribute(this, t),
        Er.applyMatrix4(e),
        this.setXYZ(t, Er.x, Er.y, Er.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Er.fromBufferAttribute(this, t),
        Er.applyNormalMatrix(e),
        this.setXYZ(t, Er.x, Er.y, Er.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Er.fromBufferAttribute(this, t),
        Er.transformDirection(e),
        this.setXYZ(t, Er.x, Er.y, Er.z);
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = Rr(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = An(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = n),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = An(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Rr(t, this.array)), t;
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = An(t, this.array)), (n = An(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = An(t, this.array)),
        (n = An(n, this.array)),
        (i = An(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, a) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = An(t, this.array)),
        (n = An(n, this.array)),
        (i = An(i, this.array)),
        (a = An(a, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = a),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++) t.push(this.data.array[i + a]);
      }
      return new Yn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Mc(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++) t.push(this.data.array[i + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class rx extends _a {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Dt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let id;
const tm = new ie(),
  ad = new ie(),
  rd = new ie(),
  sd = new at(),
  nm = new at(),
  iT = new Qt(),
  zv = new ie(),
  im = new ie(),
  Hv = new ie(),
  rM = new at(),
  g1 = new at(),
  sM = new at();
class aT extends On {
  constructor(e = new rx()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), id === void 0)
    ) {
      id = new mn();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        n = new Jm(t, 5);
      id.setIndex([0, 1, 2, 0, 2, 3]),
        id.setAttribute("position", new Mc(n, 3, 0, !1)),
        id.setAttribute("uv", new Mc(n, 2, 3, !1));
    }
    (this.geometry = id), (this.material = e), (this.center = new at(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      ad.setFromMatrixScale(this.matrixWorld),
      iT.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      rd.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        ad.multiplyScalar(-rd.z);
    const n = this.material.rotation;
    let i, a;
    n !== 0 && ((a = Math.cos(n)), (i = Math.sin(n)));
    const l = this.center;
    Vv(zv.set(-0.5, -0.5, 0), rd, l, ad, i, a),
      Vv(im.set(0.5, -0.5, 0), rd, l, ad, i, a),
      Vv(Hv.set(0.5, 0.5, 0), rd, l, ad, i, a),
      rM.set(0, 0),
      g1.set(1, 0),
      sM.set(1, 1);
    let u = e.ray.intersectTriangle(zv, im, Hv, !1, tm);
    if (
      u === null &&
      (Vv(im.set(-0.5, 0.5, 0), rd, l, ad, i, a),
      g1.set(0, 1),
      (u = e.ray.intersectTriangle(zv, Hv, im, !1, tm)),
      u === null)
    )
      return;
    const f = e.ray.origin.distanceTo(tm);
    f < e.near ||
      f > e.far ||
      t.push({
        distance: f,
        point: tm.clone(),
        uv: Kr.getInterpolation(tm, zv, im, Hv, rM, g1, sM, new at()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Vv(s, e, t, n, i, a) {
  sd.subVectors(s, t).addScalar(0.5).multiply(n),
    i !== void 0
      ? ((nm.x = a * sd.x - i * sd.y), (nm.y = i * sd.x + a * sd.y))
      : nm.copy(sd),
    s.copy(e),
    (s.x += nm.x),
    (s.y += nm.y),
    s.applyMatrix4(iT);
}
const kv = new ie(),
  oM = new ie();
class rT extends On {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, i = t.length; n < i; n++) {
      const a = t[n];
      this.addLevel(a.object.clone(), a.distance, a.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let a;
    for (a = 0; a < i.length && !(t < i[a].distance); a++);
    return (
      i.splice(a, 0, { distance: t, hysteresis: n, object: e }),
      this.add(e),
      this
    );
  }
  removeLevel(e) {
    const t = this.levels;
    for (let n = 0; n < t.length; n++)
      if (t[n].distance === e) {
        const i = t.splice(n, 1);
        return this.remove(i[0].object), !0;
      }
    return !1;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, i;
      for (n = 1, i = t.length; n < i; n++) {
        let a = t[n].distance;
        if ((t[n].object.visible && (a -= a * t[n].hysteresis), e < a)) break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      kv.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(kv);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      kv.setFromMatrixPosition(e.matrixWorld),
        oM.setFromMatrixPosition(this.matrixWorld);
      const n = kv.distanceTo(oM) / e.zoom;
      t[0].object.visible = !0;
      let i, a;
      for (i = 1, a = t.length; i < a; i++) {
        let l = t[i].distance;
        if ((t[i].object.visible && (l -= l * t[i].hysteresis), n >= l))
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < a; i++) t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const n = this.levels;
    for (let i = 0, a = n.length; i < a; i++) {
      const l = n[i];
      t.object.levels.push({
        object: l.object.uuid,
        distance: l.distance,
        hysteresis: l.hysteresis,
      });
    }
    return t;
  }
}
const lM = new ie(),
  uM = new Hn(),
  cM = new Hn(),
  gw = new ie(),
  fM = new Qt(),
  Xv = new ie(),
  v1 = new Na(),
  hM = new Qt(),
  y1 = new $f();
class sx extends li {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = mA),
      (this.bindMatrix = new Qt()),
      (this.bindMatrixInverse = new Qt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new ya()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Xv), this.boundingBox.expandByPoint(Xv);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Na()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Xv), this.boundingSphere.expandByPoint(Xv);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const n = this.material,
      i = this.matrixWorld;
    n !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      v1.copy(this.boundingSphere),
      v1.applyMatrix4(i),
      e.ray.intersectsSphere(v1) !== !1 &&
        (hM.copy(i).invert(),
        y1.copy(e.ray).applyMatrix4(hM),
        !(
          this.boundingBox !== null && y1.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, y1)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Hn(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const a = 1 / e.manhattanLength();
      a !== 1 / 0 ? e.multiplyScalar(a) : e.set(1, 0, 0, 0),
        t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === mA
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === FE
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton,
      i = this.geometry;
    uM.fromBufferAttribute(i.attributes.skinIndex, e),
      cM.fromBufferAttribute(i.attributes.skinWeight, e),
      lM.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let a = 0; a < 4; a++) {
      const l = cM.getComponent(a);
      if (l !== 0) {
        const u = uM.getComponent(a);
        fM.multiplyMatrices(n.bones[u].matrixWorld, n.boneInverses[u]),
          t.addScaledVector(gw.copy(lM).applyMatrix4(fM), l);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Gy extends On {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Uo extends Wn {
  constructor(e = null, t = 1, n = 1, i, a, l, u, f, d = Kn, m = Kn, v, _) {
    super(null, l, u, f, d, m, i, a, v, _),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const dM = new Qt(),
  vw = new Qt();
class qm {
  constructor(e = [], t = []) {
    (this.uuid = gs()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new Qt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new Qt();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a] ? e[a].matrixWorld : vw;
      dM.multiplyMatrices(u, t[a]), dM.toArray(n, a * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new qm(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Uo(t, e, e, oa, yi);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = n),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const a = e.bones[n];
      let l = t[a];
      l === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", a),
        (l = new Gy())),
        this.bones.push(l),
        this.boneInverses.push(new Qt().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let i = 0, a = t.length; i < a; i++) {
      const l = t[i];
      e.bones.push(l.uuid);
      const u = n[i];
      e.boneInverses.push(u.toArray());
    }
    return e;
  }
}
class bc extends Yn {
  constructor(e, t, n, i = 1) {
    super(e, t, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const od = new Qt(),
  pM = new Qt(),
  Yv = [],
  mM = new ya(),
  yw = new Qt(),
  am = new li(),
  rm = new Na();
class ox extends li {
  constructor(e, t, n) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new bc(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < n; i++) this.setMatrixAt(i, yw);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new ya()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, od),
        mM.copy(e.boundingBox).applyMatrix4(od),
        this.boundingBox.union(mM);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Na()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, od),
        rm.copy(e.boundingSphere).applyMatrix4(od),
        this.boundingSphere.union(rm);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      a = n.length + 1,
      l = e * a + 1;
    for (let u = 0; u < n.length; u++) n[u] = i[l + u];
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((am.geometry = this.geometry),
      (am.material = this.material),
      am.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        rm.copy(this.boundingSphere),
        rm.applyMatrix4(n),
        e.ray.intersectsSphere(rm) !== !1))
    )
      for (let a = 0; a < i; a++) {
        this.getMatrixAt(a, od),
          pM.multiplyMatrices(n, od),
          (am.matrixWorld = pM),
          am.raycast(e, Yv);
        for (let l = 0, u = Yv.length; l < u; l++) {
          const f = Yv[l];
          (f.instanceId = a), (f.object = this), t.push(f);
        }
        Yv.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new bc(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences,
      i = n.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new Uo(
        new Float32Array(i * this.count),
        i,
        this.count,
        vc,
        yi
      ));
    const a = this.morphTexture.source.data.data;
    let l = 0;
    for (let d = 0; d < n.length; d++) l += n[d];
    const u = this.geometry.morphTargetsRelative ? 1 : 1 - l,
      f = i * e;
    (a[f] = u), a.set(n, f + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
const _1 = new ie(),
  _w = new ie(),
  Aw = new hn();
class mu {
  constructor(e = new ie(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = _1.subVectors(n, t).cross(_w.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(_1),
      i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const a = -(e.start.dot(this.normal) + this.constant) / i;
    return a < 0 || a > 1 ? null : t.copy(e.start).addScaledVector(n, a);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || Aw.getNormalMatrix(e),
      i = this.coplanarPoint(_1).applyMatrix4(e),
      a = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(a)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const gf = new Na(),
  Wv = new ie();
class jm {
  constructor(
    e = new mu(),
    t = new mu(),
    n = new mu(),
    i = new mu(),
    a = new mu(),
    l = new mu()
  ) {
    this.planes = [e, t, n, i, a, l];
  }
  set(e, t, n, i, a, l) {
    const u = this.planes;
    return (
      u[0].copy(e),
      u[1].copy(t),
      u[2].copy(n),
      u[3].copy(i),
      u[4].copy(a),
      u[5].copy(l),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = Do) {
    const n = this.planes,
      i = e.elements,
      a = i[0],
      l = i[1],
      u = i[2],
      f = i[3],
      d = i[4],
      m = i[5],
      v = i[6],
      _ = i[7],
      A = i[8],
      M = i[9],
      T = i[10],
      E = i[11],
      b = i[12],
      w = i[13],
      D = i[14],
      B = i[15];
    if (
      (n[0].setComponents(f - a, _ - d, E - A, B - b).normalize(),
      n[1].setComponents(f + a, _ + d, E + A, B + b).normalize(),
      n[2].setComponents(f + l, _ + m, E + M, B + w).normalize(),
      n[3].setComponents(f - l, _ - m, E - M, B - w).normalize(),
      n[4].setComponents(f - u, _ - v, E - T, B - D).normalize(),
      t === Do)
    )
      n[5].setComponents(f + u, _ + v, E + T, B + D).normalize();
    else if (t === Om) n[5].setComponents(u, v, T, D).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        gf.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        gf.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(gf);
  }
  intersectsSprite(e) {
    return (
      gf.center.set(0, 0, 0),
      (gf.radius = 0.7071067811865476),
      gf.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(gf)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      i = -e.radius;
    for (let a = 0; a < 6; a++) if (t[a].distanceToPoint(n) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (
        ((Wv.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (Wv.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (Wv.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(Wv) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function A1(s, e) {
  return s - e;
}
function xw(s, e) {
  return s.z - e.z;
}
function Sw(s, e) {
  return e.z - s.z;
}
class Mw {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t, n, i) {
    const a = this.pool,
      l = this.list;
    this.index >= a.length &&
      a.push({ start: -1, count: -1, z: -1, index: -1 });
    const u = a[this.index];
    l.push(u),
      this.index++,
      (u.start = e),
      (u.count = t),
      (u.z = n),
      (u.index = i);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Jr = new Qt(),
  bw = new Dt(1, 1, 1),
  x1 = new jm(),
  Jv = new ya(),
  vf = new Na(),
  sm = new ie(),
  gM = new ie(),
  Ew = new ie(),
  S1 = new Mw(),
  cr = new li(),
  qv = [];
function Tw(s, e, t = 0) {
  const n = e.itemSize;
  if (
    s.isInterleavedBufferAttribute ||
    s.array.constructor !== e.array.constructor
  ) {
    const i = s.count;
    for (let a = 0; a < i; a++)
      for (let l = 0; l < n; l++)
        e.setComponent(a + t, l, s.getComponent(a, l));
  } else e.array.set(s.array, t * n);
  e.needsUpdate = !0;
}
function yf(s, e) {
  if (s.constructor !== e.constructor) {
    const t = Math.min(s.length, e.length);
    for (let n = 0; n < t; n++) e[n] = s[n];
  } else {
    const t = Math.min(s.length, e.length);
    e.set(new s.constructor(s.buffer, 0, t));
  }
}
class sT extends li {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  constructor(e, t, n = t * 2, i) {
    super(new mn(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = n),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      n = new Uo(t, e, e, oa, yi);
    this._matricesTexture = n;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      n = new Uo(t, e, e, Xm, Rl);
    this._indirectTexture = n;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      n = new Uo(t, e, e, oa, yi);
    (n.colorSpace = zn.workingColorSpace), (this._colorsTexture = n);
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      n = this._maxVertexCount,
      i = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const a in e.attributes) {
        const l = e.getAttribute(a),
          { array: u, itemSize: f, normalized: d } = l,
          m = new u.constructor(n * f),
          v = new Yn(m, f, d);
        t.setAttribute(a, v);
      }
      if (e.getIndex() !== null) {
        const a = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        t.setIndex(new Yn(a, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'THREE.BatchedMesh: All geometries must consistently have "index".'
      );
    for (const n in t.attributes) {
      if (!e.hasAttribute(n))
        throw new Error(
          `THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`
        );
      const i = e.getAttribute(n),
        a = t.getAttribute(n);
      if (i.itemSize !== a.itemSize || i.normalized !== a.normalized)
        throw new Error(
          "THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`
      );
  }
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`
      );
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ya());
    const e = this.boundingBox,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let n = 0, i = t.length; n < i; n++) {
      if (t[n].active === !1) continue;
      const a = t[n].geometryIndex;
      this.getMatrixAt(n, Jr),
        this.getBoundingBoxAt(a, Jv).applyMatrix4(Jr),
        e.union(Jv);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Na());
    const e = this.boundingSphere,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let n = 0, i = t.length; n < i; n++) {
      if (t[n].active === !1) continue;
      const a = t[n].geometryIndex;
      this.getMatrixAt(n, Jr),
        this.getBoundingSphereAt(a, vf).applyMatrix4(Jr),
        e.union(vf);
    }
  }
  addInstance(e) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      this._availableInstanceIds.length === 0
    )
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    const n = { visible: !0, active: !0, geometryIndex: e };
    let i = null;
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort(A1),
        (i = this._availableInstanceIds.shift()),
        (this._instanceInfo[i] = n))
      : ((i = this._instanceInfo.length), this._instanceInfo.push(n));
    const a = this._matricesTexture;
    Jr.identity().toArray(a.image.data, i * 16), (a.needsUpdate = !0);
    const l = this._colorsTexture;
    return (
      l && (bw.toArray(l.image.data, i * 4), (l.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      i
    );
  }
  addGeometry(e, t = -1, n = -1) {
    this._initializeGeometry(e), this._validateGeometry(e);
    const i = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0,
      },
      a = this._geometryInfo;
    (i.vertexStart = this._nextVertexStart),
      (i.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t);
    const l = e.getIndex();
    if (
      (l !== null &&
        ((i.indexStart = this._nextIndexStart),
        (i.reservedIndexCount = n === -1 ? l.count : n)),
      (i.indexStart !== -1 &&
        i.indexStart + i.reservedIndexCount > this._maxIndexCount) ||
        i.vertexStart + i.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    let f;
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort(A1),
          (f = this._availableGeometryIds.shift()),
          (a[f] = i))
        : ((f = this._geometryCount), this._geometryCount++, a.push(i)),
      this.setGeometryAt(f, e),
      (this._nextIndexStart = i.indexStart + i.reservedIndexCount),
      (this._nextVertexStart = i.vertexStart + i.reservedVertexCount),
      f
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry,
      i = n.getIndex() !== null,
      a = n.getIndex(),
      l = t.getIndex(),
      u = this._geometryInfo[e];
    if (
      (i && l.count > u.reservedIndexCount) ||
      t.attributes.position.count > u.reservedVertexCount
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const f = u.vertexStart,
      d = u.reservedVertexCount;
    u.vertexCount = t.getAttribute("position").count;
    for (const m in n.attributes) {
      const v = t.getAttribute(m),
        _ = n.getAttribute(m);
      Tw(v, _, f);
      const A = v.itemSize;
      for (let M = v.count, T = d; M < T; M++) {
        const E = f + M;
        for (let b = 0; b < A; b++) _.setComponent(E, b, 0);
      }
      (_.needsUpdate = !0), _.addUpdateRange(f * A, d * A);
    }
    if (i) {
      const m = u.indexStart,
        v = u.reservedIndexCount;
      u.indexCount = t.getIndex().count;
      for (let _ = 0; _ < l.count; _++) a.setX(m + _, f + l.getX(_));
      for (let _ = l.count, A = v; _ < A; _++) a.setX(m + _, f);
      (a.needsUpdate = !0), a.addUpdateRange(m, u.reservedIndexCount);
    }
    return (
      (u.start = i ? u.indexStart : u.vertexStart),
      (u.count = i ? u.indexCount : u.vertexCount),
      (u.boundingBox = null),
      t.boundingBox !== null && (u.boundingBox = t.boundingBox.clone()),
      (u.boundingSphere = null),
      t.boundingSphere !== null &&
        (u.boundingSphere = t.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      e
    );
  }
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1) return this;
    const n = this._instanceInfo;
    for (let i = 0, a = n.length; i < a; i++)
      n[i].active && n[i].geometryIndex === e && this.deleteInstance(i);
    return (
      (t[e].active = !1),
      this._availableGeometryIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  deleteInstance(e) {
    return (
      this.validateInstanceId(e),
      (this._instanceInfo[e].active = !1),
      this._availableInstanceIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  optimize() {
    let e = 0,
      t = 0;
    const n = this._geometryInfo,
      i = n
        .map((l, u) => u)
        .sort((l, u) => n[l].vertexStart - n[u].vertexStart),
      a = this.geometry;
    for (let l = 0, u = n.length; l < u; l++) {
      const f = i[l],
        d = n[f];
      if (d.active !== !1) {
        if (a.index !== null) {
          if (d.indexStart !== t) {
            const { indexStart: m, vertexStart: v, reservedIndexCount: _ } = d,
              A = a.index,
              M = A.array,
              T = e - v;
            for (let E = m; E < m + _; E++) M[E] = M[E] + T;
            A.array.copyWithin(t, m, m + _),
              A.addUpdateRange(t, _),
              (d.indexStart = t);
          }
          t += d.reservedIndexCount;
        }
        if (d.vertexStart !== e) {
          const { vertexStart: m, reservedVertexCount: v } = d,
            _ = a.attributes;
          for (const A in _) {
            const M = _[A],
              { array: T, itemSize: E } = M;
            T.copyWithin(e * E, m * E, (m + v) * E),
              M.addUpdateRange(e * E, v * E);
          }
          d.vertexStart = e;
        }
        (e += d.reservedVertexCount),
          (d.start = a.index ? d.indexStart : d.vertexStart),
          (this._nextIndexStart = a.index
            ? d.indexStart + d.reservedIndexCount
            : 0),
          (this._nextVertexStart = d.vertexStart + d.reservedVertexCount);
      }
    }
    return this;
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const n = this.geometry,
      i = this._geometryInfo[e];
    if (i.boundingBox === null) {
      const a = new ya(),
        l = n.index,
        u = n.attributes.position;
      for (let f = i.start, d = i.start + i.count; f < d; f++) {
        let m = f;
        l && (m = l.getX(m)), a.expandByPoint(sm.fromBufferAttribute(u, m));
      }
      i.boundingBox = a;
    }
    return t.copy(i.boundingBox), t;
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const n = this.geometry,
      i = this._geometryInfo[e];
    if (i.boundingSphere === null) {
      const a = new Na();
      this.getBoundingBoxAt(e, Jv), Jv.getCenter(a.center);
      const l = n.index,
        u = n.attributes.position;
      let f = 0;
      for (let d = i.start, m = i.start + i.count; d < m; d++) {
        let v = d;
        l && (v = l.getX(v)),
          sm.fromBufferAttribute(u, v),
          (f = Math.max(f, a.center.distanceToSquared(sm)));
      }
      (a.radius = Math.sqrt(f)), (i.boundingSphere = a);
    }
    return t.copy(i.boundingSphere), t;
  }
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const n = this._matricesTexture,
      i = this._matricesTexture.image.data;
    return t.toArray(i, e * 16), (n.needsUpdate = !0), this;
  }
  getMatrixAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._matricesTexture.image.data, e * 16)
    );
  }
  setColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._colorsTexture === null && this._initColorsTexture(),
      t.toArray(this._colorsTexture.image.data, e * 4),
      (this._colorsTexture.needsUpdate = !0),
      this
    );
  }
  getColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._colorsTexture.image.data, e * 4)
    );
  }
  setVisibleAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._instanceInfo[e].visible === t
        ? this
        : ((this._instanceInfo[e].visible = t),
          (this._visibilityChanged = !0),
          this)
    );
  }
  getVisibleAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible;
  }
  setGeometryIdAt(e, t) {
    return (
      this.validateInstanceId(e),
      this.validateGeometryId(t),
      (this._instanceInfo[e].geometryIndex = t),
      this
    );
  }
  getGeometryIdAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex;
  }
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const n = this._geometryInfo[e];
    return (
      (t.vertexStart = n.vertexStart),
      (t.vertexCount = n.vertexCount),
      (t.reservedVertexCount = n.reservedVertexCount),
      (t.indexStart = n.indexStart),
      (t.indexCount = n.indexCount),
      (t.reservedIndexCount = n.reservedIndexCount),
      (t.start = n.start),
      (t.count = n.count),
      t
    );
  }
  setInstanceCount(e) {
    const t = this._availableInstanceIds,
      n = this._instanceInfo;
    for (t.sort(A1); t[t.length - 1] === n.length; ) n.pop(), t.pop();
    if (e < n.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`
      );
    const i = new Int32Array(e),
      a = new Int32Array(e);
    yf(this._multiDrawCounts, i),
      yf(this._multiDrawStarts, a),
      (this._multiDrawCounts = i),
      (this._multiDrawStarts = a),
      (this._maxInstanceCount = e);
    const l = this._indirectTexture,
      u = this._matricesTexture,
      f = this._colorsTexture;
    l.dispose(),
      this._initIndirectTexture(),
      yf(l.image.data, this._indirectTexture.image.data),
      u.dispose(),
      this._initMatricesTexture(),
      yf(u.image.data, this._matricesTexture.image.data),
      f &&
        (f.dispose(),
        this._initColorsTexture(),
        yf(f.image.data, this._colorsTexture.image.data));
  }
  setGeometrySize(e, t) {
    const n = [...this._geometryInfo].filter((u) => u.active);
    if (Math.max(...n.map((u) => u.vertexStart + u.reservedVertexCount)) > e)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`
      );
    if (
      this.geometry.index &&
      Math.max(...n.map((f) => f.indexStart + f.reservedIndexCount)) > t
    )
      throw new Error(
        `BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`
      );
    const a = this.geometry;
    a.dispose(),
      (this._maxVertexCount = e),
      (this._maxIndexCount = t),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1),
        (this.geometry = new mn()),
        this._initializeGeometry(a));
    const l = this.geometry;
    a.index && yf(a.index.array, l.index.array);
    for (const u in a.attributes)
      yf(a.attributes[u].array, l.attributes[u].array);
  }
  raycast(e, t) {
    const n = this._instanceInfo,
      i = this._geometryInfo,
      a = this.matrixWorld,
      l = this.geometry;
    (cr.material = this.material),
      (cr.geometry.index = l.index),
      (cr.geometry.attributes = l.attributes),
      cr.geometry.boundingBox === null && (cr.geometry.boundingBox = new ya()),
      cr.geometry.boundingSphere === null &&
        (cr.geometry.boundingSphere = new Na());
    for (let u = 0, f = n.length; u < f; u++) {
      if (!n[u].visible || !n[u].active) continue;
      const d = n[u].geometryIndex,
        m = i[d];
      cr.geometry.setDrawRange(m.start, m.count),
        this.getMatrixAt(u, cr.matrixWorld).premultiply(a),
        this.getBoundingBoxAt(d, cr.geometry.boundingBox),
        this.getBoundingSphereAt(d, cr.geometry.boundingSphere),
        cr.raycast(e, qv);
      for (let v = 0, _ = qv.length; v < _; v++) {
        const A = qv[v];
        (A.object = this), (A.batchId = u), t.push(A);
      }
      qv.length = 0;
    }
    (cr.material = null),
      (cr.geometry.index = null),
      (cr.geometry.attributes = {}),
      cr.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._geometryInfo = e._geometryInfo.map((t) => ({
        ...t,
        boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
        boundingSphere:
          t.boundingSphere !== null ? t.boundingSphere.clone() : null,
      }))),
      (this._instanceInfo = e._instanceInfo.map((t) => ({ ...t }))),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)),
      this
    );
  }
  onBeforeRender(e, t, n, i, a) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const l = i.getIndex(),
      u = l === null ? 1 : l.array.BYTES_PER_ELEMENT,
      f = this._instanceInfo,
      d = this._multiDrawStarts,
      m = this._multiDrawCounts,
      v = this._geometryInfo,
      _ = this.perObjectFrustumCulled,
      A = this._indirectTexture,
      M = A.image.data;
    _ &&
      (Jr.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(
        this.matrixWorld
      ),
      x1.setFromProjectionMatrix(Jr, e.coordinateSystem));
    let T = 0;
    if (this.sortObjects) {
      Jr.copy(this.matrixWorld).invert(),
        sm.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Jr),
        gM
          .set(0, 0, -1)
          .transformDirection(n.matrixWorld)
          .transformDirection(Jr);
      for (let w = 0, D = f.length; w < D; w++)
        if (f[w].visible && f[w].active) {
          const B = f[w].geometryIndex;
          this.getMatrixAt(w, Jr),
            this.getBoundingSphereAt(B, vf).applyMatrix4(Jr);
          let I = !1;
          if ((_ && (I = !x1.intersectsSphere(vf)), !I)) {
            const N = v[B],
              P = Ew.subVectors(vf.center, sm).dot(gM);
            S1.push(N.start, N.count, P, w);
          }
        }
      const E = S1.list,
        b = this.customSort;
      b === null ? E.sort(a.transparent ? Sw : xw) : b.call(this, E, n);
      for (let w = 0, D = E.length; w < D; w++) {
        const B = E[w];
        (d[T] = B.start * u), (m[T] = B.count), (M[T] = B.index), T++;
      }
      S1.reset();
    } else
      for (let E = 0, b = f.length; E < b; E++)
        if (f[E].visible && f[E].active) {
          const w = f[E].geometryIndex;
          let D = !1;
          if (
            (_ &&
              (this.getMatrixAt(E, Jr),
              this.getBoundingSphereAt(w, vf).applyMatrix4(Jr),
              (D = !x1.intersectsSphere(vf))),
            !D)
          ) {
            const B = v[w];
            (d[T] = B.start * u), (m[T] = B.count), (M[T] = E), T++;
          }
        }
    (A.needsUpdate = !0),
      (this._multiDrawCount = T),
      (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, n, i, a, l) {
    this.onBeforeRender(e, null, i, a, l);
  }
}
class dr extends _a {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Dt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const dy = new ie(),
  py = new ie(),
  vM = new Qt(),
  om = new $f(),
  jv = new Na(),
  M1 = new ie(),
  yM = new ie();
class Su extends On {
  constructor(e = new mn(), t = new dr()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [0];
      for (let i = 1, a = t.count; i < a; i++)
        dy.fromBufferAttribute(t, i - 1),
          py.fromBufferAttribute(t, i),
          (n[i] = n[i - 1]),
          (n[i] += dy.distanceTo(py));
      e.setAttribute("lineDistance", new Yt(n, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      a = e.params.Line.threshold,
      l = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      jv.copy(n.boundingSphere),
      jv.applyMatrix4(i),
      (jv.radius += a),
      e.ray.intersectsSphere(jv) === !1)
    )
      return;
    vM.copy(i).invert(), om.copy(e.ray).applyMatrix4(vM);
    const u = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      f = u * u,
      d = this.isLineSegments ? 2 : 1,
      m = n.index,
      _ = n.attributes.position;
    if (m !== null) {
      const A = Math.max(0, l.start),
        M = Math.min(m.count, l.start + l.count);
      for (let T = A, E = M - 1; T < E; T += d) {
        const b = m.getX(T),
          w = m.getX(T + 1),
          D = Kv(this, e, om, f, b, w, T);
        D && t.push(D);
      }
      if (this.isLineLoop) {
        const T = m.getX(M - 1),
          E = m.getX(A),
          b = Kv(this, e, om, f, T, E, M - 1);
        b && t.push(b);
      }
    } else {
      const A = Math.max(0, l.start),
        M = Math.min(_.count, l.start + l.count);
      for (let T = A, E = M - 1; T < E; T += d) {
        const b = Kv(this, e, om, f, T, T + 1, T);
        b && t.push(b);
      }
      if (this.isLineLoop) {
        const T = Kv(this, e, om, f, M - 1, A, M - 1);
        T && t.push(T);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let a = 0, l = i.length; a < l; a++) {
          const u = i[a].name || String(a);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[u] = a);
        }
      }
    }
  }
}
function Kv(s, e, t, n, i, a, l) {
  const u = s.geometry.attributes.position;
  if (
    (dy.fromBufferAttribute(u, i),
    py.fromBufferAttribute(u, a),
    t.distanceSqToSegment(dy, py, M1, yM) > n)
  )
    return;
  M1.applyMatrix4(s.matrixWorld);
  const d = e.ray.origin.distanceTo(M1);
  if (!(d < e.near || d > e.far))
    return {
      distance: d,
      point: yM.clone().applyMatrix4(s.matrixWorld),
      index: l,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: s,
    };
}
const _M = new ie(),
  AM = new ie();
class Lo extends Su {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [];
      for (let i = 0, a = t.count; i < a; i += 2)
        _M.fromBufferAttribute(t, i),
          AM.fromBufferAttribute(t, i + 1),
          (n[i] = i === 0 ? 0 : n[i - 1]),
          (n[i + 1] = n[i] + _M.distanceTo(AM));
      e.setAttribute("lineDistance", new Yt(n, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class lx extends Su {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class zy extends _a {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Dt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const xM = new Qt(),
  _A = new $f(),
  Zv = new Na(),
  Qv = new ie();
class ux extends On {
  constructor(e = new mn(), t = new zy()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      a = e.params.Points.threshold,
      l = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Zv.copy(n.boundingSphere),
      Zv.applyMatrix4(i),
      (Zv.radius += a),
      e.ray.intersectsSphere(Zv) === !1)
    )
      return;
    xM.copy(i).invert(), _A.copy(e.ray).applyMatrix4(xM);
    const u = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      f = u * u,
      d = n.index,
      v = n.attributes.position;
    if (d !== null) {
      const _ = Math.max(0, l.start),
        A = Math.min(d.count, l.start + l.count);
      for (let M = _, T = A; M < T; M++) {
        const E = d.getX(M);
        Qv.fromBufferAttribute(v, E), SM(Qv, E, f, i, e, t, this);
      }
    } else {
      const _ = Math.max(0, l.start),
        A = Math.min(v.count, l.start + l.count);
      for (let M = _, T = A; M < T; M++)
        Qv.fromBufferAttribute(v, M), SM(Qv, M, f, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let a = 0, l = i.length; a < l; a++) {
          const u = i[a].name || String(a);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[u] = a);
        }
      }
    }
  }
}
function SM(s, e, t, n, i, a, l) {
  const u = _A.distanceSqToPoint(s);
  if (u < t) {
    const f = new ie();
    _A.closestPointToPoint(s, f), f.applyMatrix4(n);
    const d = i.ray.origin.distanceTo(f);
    if (d < i.near || d > i.far) return;
    a.push({
      distance: d,
      distanceToRay: Math.sqrt(u),
      point: f,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: l,
    });
  }
}
class oT extends Wn {
  constructor(e, t, n, i, a, l, u, f, d) {
    super(e, t, n, i, a, l, u, f, d),
      (this.isVideoTexture = !0),
      (this.minFilter = l !== void 0 ? l : In),
      (this.magFilter = a !== void 0 ? a : In),
      (this.generateMipmaps = !1);
    const m = this;
    function v() {
      (m.needsUpdate = !0), e.requestVideoFrameCallback(v);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(v);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class Cw extends oT {
  constructor(e, t, n, i, a, l, u, f) {
    super({}, e, t, n, i, a, l, u, f), (this.isVideoFrameTexture = !0);
  }
  update() {}
  clone() {
    return new this.constructor().copy(this);
  }
  setFrame(e) {
    (this.image = e), (this.needsUpdate = !0);
  }
}
class Rw extends Wn {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = Kn),
      (this.minFilter = Kn),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class Hy extends Wn {
  constructor(e, t, n, i, a, l, u, f, d, m, v, _) {
    super(null, l, u, f, d, m, i, a, v, _),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: n }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class ww extends Hy {
  constructor(e, t, n, i, a, l) {
    super(e, t, n, a, l),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = sa),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Bw extends Hy {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, Cl),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class Dw extends Wn {
  constructor(e, t, n, i, a, l, u, f, d) {
    super(e, t, n, i, a, l, u, f, d),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class Vy extends Wn {
  constructor(e, t, n, i, a, l, u, f, d, m = Vf) {
    if (m !== Vf && m !== Jf)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    n === void 0 && m === Vf && (n = Rl),
      n === void 0 && m === Jf && (n = Wf),
      super(null, i, a, l, u, f, m, n, d),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = u !== void 0 ? u : Kn),
      (this.minFilter = f !== void 0 ? f : Kn),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class No {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n,
      i = this.getPoint(0),
      a = 0;
    t.push(0);
    for (let l = 1; l <= e; l++)
      (n = this.getPoint(l / e)), (a += n.distanceTo(i)), t.push(a), (i = n);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const a = n.length;
    let l;
    t ? (l = t) : (l = e * n[a - 1]);
    let u = 0,
      f = a - 1,
      d;
    for (; u <= f; )
      if (((i = Math.floor(u + (f - u) / 2)), (d = n[i] - l), d < 0)) u = i + 1;
      else if (d > 0) f = i - 1;
      else {
        f = i;
        break;
      }
    if (((i = f), n[i] === l)) return i / (a - 1);
    const m = n[i],
      _ = n[i + 1] - m,
      A = (l - m) / _;
    return (i + A) / (a - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      a = e + 1e-4;
    i < 0 && (i = 0), a > 1 && (a = 1);
    const l = this.getPoint(i),
      u = this.getPoint(a),
      f = t || (l.isVector2 ? new at() : new ie());
    return f.copy(u).sub(l).normalize(), f;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new ie(),
      i = [],
      a = [],
      l = [],
      u = new ie(),
      f = new Qt();
    for (let A = 0; A <= e; A++) {
      const M = A / e;
      i[A] = this.getTangentAt(M, new ie());
    }
    (a[0] = new ie()), (l[0] = new ie());
    let d = Number.MAX_VALUE;
    const m = Math.abs(i[0].x),
      v = Math.abs(i[0].y),
      _ = Math.abs(i[0].z);
    m <= d && ((d = m), n.set(1, 0, 0)),
      v <= d && ((d = v), n.set(0, 1, 0)),
      _ <= d && n.set(0, 0, 1),
      u.crossVectors(i[0], n).normalize(),
      a[0].crossVectors(i[0], u),
      l[0].crossVectors(i[0], a[0]);
    for (let A = 1; A <= e; A++) {
      if (
        ((a[A] = a[A - 1].clone()),
        (l[A] = l[A - 1].clone()),
        u.crossVectors(i[A - 1], i[A]),
        u.length() > Number.EPSILON)
      ) {
        u.normalize();
        const M = Math.acos(dn(i[A - 1].dot(i[A]), -1, 1));
        a[A].applyMatrix4(f.makeRotationAxis(u, M));
      }
      l[A].crossVectors(i[A], a[A]);
    }
    if (t === !0) {
      let A = Math.acos(dn(a[0].dot(a[e]), -1, 1));
      (A /= e), i[0].dot(u.crossVectors(a[0], a[e])) > 0 && (A = -A);
      for (let M = 1; M <= e; M++)
        a[M].applyMatrix4(f.makeRotationAxis(i[M], A * M)),
          l[M].crossVectors(i[M], a[M]);
    }
    return { tangents: i, normals: a, binormals: l };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class ky extends No {
  constructor(
    e = 0,
    t = 0,
    n = 1,
    i = 1,
    a = 0,
    l = Math.PI * 2,
    u = !1,
    f = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = n),
      (this.yRadius = i),
      (this.aStartAngle = a),
      (this.aEndAngle = l),
      (this.aClockwise = u),
      (this.aRotation = f);
  }
  getPoint(e, t = new at()) {
    const n = t,
      i = Math.PI * 2;
    let a = this.aEndAngle - this.aStartAngle;
    const l = Math.abs(a) < Number.EPSILON;
    for (; a < 0; ) a += i;
    for (; a > i; ) a -= i;
    a < Number.EPSILON && (l ? (a = 0) : (a = i)),
      this.aClockwise === !0 && !l && (a === i ? (a = -i) : (a = a - i));
    const u = this.aStartAngle + e * a;
    let f = this.aX + this.xRadius * Math.cos(u),
      d = this.aY + this.yRadius * Math.sin(u);
    if (this.aRotation !== 0) {
      const m = Math.cos(this.aRotation),
        v = Math.sin(this.aRotation),
        _ = f - this.aX,
        A = d - this.aY;
      (f = _ * m - A * v + this.aX), (d = _ * v + A * m + this.aY);
    }
    return n.set(f, d);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class lT extends ky {
  constructor(e, t, n, i, a, l) {
    super(e, t, n, n, i, a, l),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function cx() {
  let s = 0,
    e = 0,
    t = 0,
    n = 0;
  function i(a, l, u, f) {
    (s = a),
      (e = u),
      (t = -3 * a + 3 * l - 2 * u - f),
      (n = 2 * a - 2 * l + u + f);
  }
  return {
    initCatmullRom: function (a, l, u, f, d) {
      i(l, u, d * (u - a), d * (f - l));
    },
    initNonuniformCatmullRom: function (a, l, u, f, d, m, v) {
      let _ = (l - a) / d - (u - a) / (d + m) + (u - l) / m,
        A = (u - l) / m - (f - l) / (m + v) + (f - u) / v;
      (_ *= m), (A *= m), i(l, u, _, A);
    },
    calc: function (a) {
      const l = a * a,
        u = l * a;
      return s + e * a + t * l + n * u;
    },
  };
}
const $v = new ie(),
  b1 = new cx(),
  E1 = new cx(),
  T1 = new cx();
class uT extends No {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = n),
      (this.tension = i);
  }
  getPoint(e, t = new ie()) {
    const n = t,
      i = this.points,
      a = i.length,
      l = (a - (this.closed ? 0 : 1)) * e;
    let u = Math.floor(l),
      f = l - u;
    this.closed
      ? (u += u > 0 ? 0 : (Math.floor(Math.abs(u) / a) + 1) * a)
      : f === 0 && u === a - 1 && ((u = a - 2), (f = 1));
    let d, m;
    this.closed || u > 0
      ? (d = i[(u - 1) % a])
      : ($v.subVectors(i[0], i[1]).add(i[0]), (d = $v));
    const v = i[u % a],
      _ = i[(u + 1) % a];
    if (
      (this.closed || u + 2 < a
        ? (m = i[(u + 2) % a])
        : ($v.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]), (m = $v)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const A = this.curveType === "chordal" ? 0.5 : 0.25;
      let M = Math.pow(d.distanceToSquared(v), A),
        T = Math.pow(v.distanceToSquared(_), A),
        E = Math.pow(_.distanceToSquared(m), A);
      T < 1e-4 && (T = 1),
        M < 1e-4 && (M = T),
        E < 1e-4 && (E = T),
        b1.initNonuniformCatmullRom(d.x, v.x, _.x, m.x, M, T, E),
        E1.initNonuniformCatmullRom(d.y, v.y, _.y, m.y, M, T, E),
        T1.initNonuniformCatmullRom(d.z, v.z, _.z, m.z, M, T, E);
    } else
      this.curveType === "catmullrom" &&
        (b1.initCatmullRom(d.x, v.x, _.x, m.x, this.tension),
        E1.initCatmullRom(d.y, v.y, _.y, m.y, this.tension),
        T1.initCatmullRom(d.z, v.z, _.z, m.z, this.tension));
    return n.set(b1.calc(f), E1.calc(f), T1.calc(f)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new ie().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function MM(s, e, t, n, i) {
  const a = (n - e) * 0.5,
    l = (i - t) * 0.5,
    u = s * s,
    f = s * u;
  return (
    (2 * t - 2 * n + a + l) * f + (-3 * t + 3 * n - 2 * a - l) * u + a * s + t
  );
}
function Uw(s, e) {
  const t = 1 - s;
  return t * t * e;
}
function Ow(s, e) {
  return 2 * (1 - s) * s * e;
}
function Lw(s, e) {
  return s * s * e;
}
function Mm(s, e, t, n) {
  return Uw(s, e) + Ow(s, t) + Lw(s, n);
}
function Nw(s, e) {
  const t = 1 - s;
  return t * t * t * e;
}
function Iw(s, e) {
  const t = 1 - s;
  return 3 * t * t * s * e;
}
function Fw(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function Pw(s, e) {
  return s * s * s * e;
}
function bm(s, e, t, n, i) {
  return Nw(s, e) + Iw(s, t) + Fw(s, n) + Pw(s, i);
}
class fx extends No {
  constructor(e = new at(), t = new at(), n = new at(), i = new at()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new at()) {
    const n = t,
      i = this.v0,
      a = this.v1,
      l = this.v2,
      u = this.v3;
    return n.set(bm(e, i.x, a.x, l.x, u.x), bm(e, i.y, a.y, l.y, u.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class cT extends No {
  constructor(e = new ie(), t = new ie(), n = new ie(), i = new ie()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new ie()) {
    const n = t,
      i = this.v0,
      a = this.v1,
      l = this.v2,
      u = this.v3;
    return (
      n.set(
        bm(e, i.x, a.x, l.x, u.x),
        bm(e, i.y, a.y, l.y, u.y),
        bm(e, i.z, a.z, l.z, u.z)
      ),
      n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class hx extends No {
  constructor(e = new at(), t = new at()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new at()) {
    const n = t;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new at()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class fT extends No {
  constructor(e = new ie(), t = new ie()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new ie()) {
    const n = t;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new ie()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class dx extends No {
  constructor(e = new at(), t = new at(), n = new at()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new at()) {
    const n = t,
      i = this.v0,
      a = this.v1,
      l = this.v2;
    return n.set(Mm(e, i.x, a.x, l.x), Mm(e, i.y, a.y, l.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class px extends No {
  constructor(e = new ie(), t = new ie(), n = new ie()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new ie()) {
    const n = t,
      i = this.v0,
      a = this.v1,
      l = this.v2;
    return (
      n.set(Mm(e, i.x, a.x, l.x), Mm(e, i.y, a.y, l.y), Mm(e, i.z, a.z, l.z)), n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class mx extends No {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new at()) {
    const n = t,
      i = this.points,
      a = (i.length - 1) * e,
      l = Math.floor(a),
      u = a - l,
      f = i[l === 0 ? l : l - 1],
      d = i[l],
      m = i[l > i.length - 2 ? i.length - 1 : l + 1],
      v = i[l > i.length - 3 ? i.length - 1 : l + 2];
    return n.set(MM(u, f.x, d.x, m.x, v.x), MM(u, f.y, d.y, m.y, v.y)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new at().fromArray(i));
    }
    return this;
  }
}
var my = Object.freeze({
  __proto__: null,
  ArcCurve: lT,
  CatmullRomCurve3: uT,
  CubicBezierCurve: fx,
  CubicBezierCurve3: cT,
  EllipseCurve: ky,
  LineCurve: hx,
  LineCurve3: fT,
  QuadraticBezierCurve: dx,
  QuadraticBezierCurve3: px,
  SplineCurve: mx,
});
class hT extends No {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new my[n](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const n = e * this.getLength(),
      i = this.getCurveLengths();
    let a = 0;
    for (; a < i.length; ) {
      if (i[a] >= n) {
        const l = i[a] - n,
          u = this.curves[a],
          f = u.getLength(),
          d = f === 0 ? 0 : 1 - l / f;
        return u.getPointAt(d, t);
      }
      a++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      (t += this.curves[n].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, a = this.curves; i < a.length; i++) {
      const l = a[i],
        u = l.isEllipseCurve
          ? e * 2
          : l.isLineCurve || l.isLineCurve3
          ? 1
          : l.isSplineCurve
          ? e * l.points.length
          : e,
        f = l.getPoints(u);
      for (let d = 0; d < f.length; d++) {
        const m = f[d];
        (n && n.equals(m)) || (t.push(m), (n = m));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new my[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Nm extends hT {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new at()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new hx(this.currentPoint.clone(), new at(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const a = new dx(this.currentPoint.clone(), new at(e, t), new at(n, i));
    return this.curves.push(a), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, a, l) {
    const u = new fx(
      this.currentPoint.clone(),
      new at(e, t),
      new at(n, i),
      new at(a, l)
    );
    return this.curves.push(u), this.currentPoint.set(a, l), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      n = new mx(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, a, l) {
    const u = this.currentPoint.x,
      f = this.currentPoint.y;
    return this.absarc(e + u, t + f, n, i, a, l), this;
  }
  absarc(e, t, n, i, a, l) {
    return this.absellipse(e, t, n, n, i, a, l), this;
  }
  ellipse(e, t, n, i, a, l, u, f) {
    const d = this.currentPoint.x,
      m = this.currentPoint.y;
    return this.absellipse(e + d, t + m, n, i, a, l, u, f), this;
  }
  absellipse(e, t, n, i, a, l, u, f) {
    const d = new ky(e, t, n, i, a, l, u, f);
    if (this.curves.length > 0) {
      const v = d.getPoint(0);
      v.equals(this.currentPoint) || this.lineTo(v.x, v.y);
    }
    this.curves.push(d);
    const m = d.getPoint(1);
    return this.currentPoint.copy(m), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Km extends mn {
  constructor(
    e = [new at(0, -0.5), new at(0.5, 0), new at(0, 0.5)],
    t = 12,
    n = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: n, phiLength: i }),
      (t = Math.floor(t)),
      (i = dn(i, 0, Math.PI * 2));
    const a = [],
      l = [],
      u = [],
      f = [],
      d = [],
      m = 1 / t,
      v = new ie(),
      _ = new at(),
      A = new ie(),
      M = new ie(),
      T = new ie();
    let E = 0,
      b = 0;
    for (let w = 0; w <= e.length - 1; w++)
      switch (w) {
        case 0:
          (E = e[w + 1].x - e[w].x),
            (b = e[w + 1].y - e[w].y),
            (A.x = b * 1),
            (A.y = -E),
            (A.z = b * 0),
            T.copy(A),
            A.normalize(),
            f.push(A.x, A.y, A.z);
          break;
        case e.length - 1:
          f.push(T.x, T.y, T.z);
          break;
        default:
          (E = e[w + 1].x - e[w].x),
            (b = e[w + 1].y - e[w].y),
            (A.x = b * 1),
            (A.y = -E),
            (A.z = b * 0),
            M.copy(A),
            (A.x += T.x),
            (A.y += T.y),
            (A.z += T.z),
            A.normalize(),
            f.push(A.x, A.y, A.z),
            T.copy(M);
      }
    for (let w = 0; w <= t; w++) {
      const D = n + w * m * i,
        B = Math.sin(D),
        I = Math.cos(D);
      for (let N = 0; N <= e.length - 1; N++) {
        (v.x = e[N].x * B),
          (v.y = e[N].y),
          (v.z = e[N].x * I),
          l.push(v.x, v.y, v.z),
          (_.x = w / t),
          (_.y = N / (e.length - 1)),
          u.push(_.x, _.y);
        const P = f[3 * N + 0] * B,
          F = f[3 * N + 1],
          O = f[3 * N + 0] * I;
        d.push(P, F, O);
      }
    }
    for (let w = 0; w < t; w++)
      for (let D = 0; D < e.length - 1; D++) {
        const B = D + w * e.length,
          I = B,
          N = B + e.length,
          P = B + e.length + 1,
          F = B + 1;
        a.push(I, N, F), a.push(P, F, N);
      }
    this.setIndex(a),
      this.setAttribute("position", new Yt(l, 3)),
      this.setAttribute("uv", new Yt(u, 2)),
      this.setAttribute("normal", new Yt(d, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Km(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Xy extends Km {
  constructor(e = 1, t = 1, n = 4, i = 8) {
    const a = new Nm();
    a.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      a.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(a.getPoints(n), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: n,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new Xy(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Yy extends mn {
  constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: n,
        thetaLength: i,
      }),
      (t = Math.max(3, t));
    const a = [],
      l = [],
      u = [],
      f = [],
      d = new ie(),
      m = new at();
    l.push(0, 0, 0), u.push(0, 0, 1), f.push(0.5, 0.5);
    for (let v = 0, _ = 3; v <= t; v++, _ += 3) {
      const A = n + (v / t) * i;
      (d.x = e * Math.cos(A)),
        (d.y = e * Math.sin(A)),
        l.push(d.x, d.y, d.z),
        u.push(0, 0, 1),
        (m.x = (l[_] / e + 1) / 2),
        (m.y = (l[_ + 1] / e + 1) / 2),
        f.push(m.x, m.y);
    }
    for (let v = 1; v <= t; v++) a.push(v, v + 1, 0);
    this.setIndex(a),
      this.setAttribute("position", new Yt(l, 3)),
      this.setAttribute("normal", new Yt(u, 3)),
      this.setAttribute("uv", new Yt(f, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Yy(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Id extends mn {
  constructor(
    e = 1,
    t = 1,
    n = 1,
    i = 32,
    a = 1,
    l = !1,
    u = 0,
    f = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: i,
        heightSegments: a,
        openEnded: l,
        thetaStart: u,
        thetaLength: f,
      });
    const d = this;
    (i = Math.floor(i)), (a = Math.floor(a));
    const m = [],
      v = [],
      _ = [],
      A = [];
    let M = 0;
    const T = [],
      E = n / 2;
    let b = 0;
    w(),
      l === !1 && (e > 0 && D(!0), t > 0 && D(!1)),
      this.setIndex(m),
      this.setAttribute("position", new Yt(v, 3)),
      this.setAttribute("normal", new Yt(_, 3)),
      this.setAttribute("uv", new Yt(A, 2));
    function w() {
      const B = new ie(),
        I = new ie();
      let N = 0;
      const P = (t - e) / n;
      for (let F = 0; F <= a; F++) {
        const O = [],
          U = F / a,
          W = U * (t - e) + e;
        for (let J = 0; J <= i; J++) {
          const q = J / i,
            Z = q * f + u,
            ue = Math.sin(Z),
            K = Math.cos(Z);
          (I.x = W * ue),
            (I.y = -U * n + E),
            (I.z = W * K),
            v.push(I.x, I.y, I.z),
            B.set(ue, P, K).normalize(),
            _.push(B.x, B.y, B.z),
            A.push(q, 1 - U),
            O.push(M++);
        }
        T.push(O);
      }
      for (let F = 0; F < i; F++)
        for (let O = 0; O < a; O++) {
          const U = T[O][F],
            W = T[O + 1][F],
            J = T[O + 1][F + 1],
            q = T[O][F + 1];
          (e > 0 || O !== 0) && (m.push(U, W, q), (N += 3)),
            (t > 0 || O !== a - 1) && (m.push(W, J, q), (N += 3));
        }
      d.addGroup(b, N, 0), (b += N);
    }
    function D(B) {
      const I = M,
        N = new at(),
        P = new ie();
      let F = 0;
      const O = B === !0 ? e : t,
        U = B === !0 ? 1 : -1;
      for (let J = 1; J <= i; J++)
        v.push(0, E * U, 0), _.push(0, U, 0), A.push(0.5, 0.5), M++;
      const W = M;
      for (let J = 0; J <= i; J++) {
        const Z = (J / i) * f + u,
          ue = Math.cos(Z),
          K = Math.sin(Z);
        (P.x = O * K),
          (P.y = E * U),
          (P.z = O * ue),
          v.push(P.x, P.y, P.z),
          _.push(0, U, 0),
          (N.x = ue * 0.5 + 0.5),
          (N.y = K * 0.5 * U + 0.5),
          A.push(N.x, N.y),
          M++;
      }
      for (let J = 0; J < i; J++) {
        const q = I + J,
          Z = W + J;
        B === !0 ? m.push(Z, Z + 1, q) : m.push(Z + 1, Z, q), (F += 3);
      }
      d.addGroup(b, F, B === !0 ? 1 : 2), (b += F);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Id(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Wy extends Id {
  constructor(e = 1, t = 1, n = 32, i = 1, a = !1, l = 0, u = Math.PI * 2) {
    super(0, e, t, n, i, a, l, u),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: n,
        heightSegments: i,
        openEnded: a,
        thetaStart: l,
        thetaLength: u,
      });
  }
  static fromJSON(e) {
    return new Wy(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Tc extends mn {
  constructor(e = [], t = [], n = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: n, detail: i });
    const a = [],
      l = [];
    u(i),
      d(n),
      m(),
      this.setAttribute("position", new Yt(a, 3)),
      this.setAttribute("normal", new Yt(a.slice(), 3)),
      this.setAttribute("uv", new Yt(l, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function u(w) {
      const D = new ie(),
        B = new ie(),
        I = new ie();
      for (let N = 0; N < t.length; N += 3)
        A(t[N + 0], D), A(t[N + 1], B), A(t[N + 2], I), f(D, B, I, w);
    }
    function f(w, D, B, I) {
      const N = I + 1,
        P = [];
      for (let F = 0; F <= N; F++) {
        P[F] = [];
        const O = w.clone().lerp(B, F / N),
          U = D.clone().lerp(B, F / N),
          W = N - F;
        for (let J = 0; J <= W; J++)
          J === 0 && F === N
            ? (P[F][J] = O)
            : (P[F][J] = O.clone().lerp(U, J / W));
      }
      for (let F = 0; F < N; F++)
        for (let O = 0; O < 2 * (N - F) - 1; O++) {
          const U = Math.floor(O / 2);
          O % 2 === 0
            ? (_(P[F][U + 1]), _(P[F + 1][U]), _(P[F][U]))
            : (_(P[F][U + 1]), _(P[F + 1][U + 1]), _(P[F + 1][U]));
        }
    }
    function d(w) {
      const D = new ie();
      for (let B = 0; B < a.length; B += 3)
        (D.x = a[B + 0]),
          (D.y = a[B + 1]),
          (D.z = a[B + 2]),
          D.normalize().multiplyScalar(w),
          (a[B + 0] = D.x),
          (a[B + 1] = D.y),
          (a[B + 2] = D.z);
    }
    function m() {
      const w = new ie();
      for (let D = 0; D < a.length; D += 3) {
        (w.x = a[D + 0]), (w.y = a[D + 1]), (w.z = a[D + 2]);
        const B = E(w) / 2 / Math.PI + 0.5,
          I = b(w) / Math.PI + 0.5;
        l.push(B, 1 - I);
      }
      M(), v();
    }
    function v() {
      for (let w = 0; w < l.length; w += 6) {
        const D = l[w + 0],
          B = l[w + 2],
          I = l[w + 4],
          N = Math.max(D, B, I),
          P = Math.min(D, B, I);
        N > 0.9 &&
          P < 0.1 &&
          (D < 0.2 && (l[w + 0] += 1),
          B < 0.2 && (l[w + 2] += 1),
          I < 0.2 && (l[w + 4] += 1));
      }
    }
    function _(w) {
      a.push(w.x, w.y, w.z);
    }
    function A(w, D) {
      const B = w * 3;
      (D.x = e[B + 0]), (D.y = e[B + 1]), (D.z = e[B + 2]);
    }
    function M() {
      const w = new ie(),
        D = new ie(),
        B = new ie(),
        I = new ie(),
        N = new at(),
        P = new at(),
        F = new at();
      for (let O = 0, U = 0; O < a.length; O += 9, U += 6) {
        w.set(a[O + 0], a[O + 1], a[O + 2]),
          D.set(a[O + 3], a[O + 4], a[O + 5]),
          B.set(a[O + 6], a[O + 7], a[O + 8]),
          N.set(l[U + 0], l[U + 1]),
          P.set(l[U + 2], l[U + 3]),
          F.set(l[U + 4], l[U + 5]),
          I.copy(w).add(D).add(B).divideScalar(3);
        const W = E(I);
        T(N, U + 0, w, W), T(P, U + 2, D, W), T(F, U + 4, B, W);
      }
    }
    function T(w, D, B, I) {
      I < 0 && w.x === 1 && (l[D] = w.x - 1),
        B.x === 0 && B.z === 0 && (l[D] = I / 2 / Math.PI + 0.5);
    }
    function E(w) {
      return Math.atan2(w.z, -w.x);
    }
    function b(w) {
      return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Tc(e.vertices, e.indices, e.radius, e.details);
  }
}
class Jy extends Tc {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      i = 1 / n,
      a = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        0,
        -n,
        0,
        -i,
        n,
        0,
        -i,
        -n,
        0,
        i,
        n,
        0,
        i,
      ],
      l = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(a, l, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Jy(e.radius, e.detail);
  }
}
const e0 = new ie(),
  t0 = new ie(),
  C1 = new ie(),
  n0 = new Kr();
class dT extends mn {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        a = Math.cos(kf * t),
        l = e.getIndex(),
        u = e.getAttribute("position"),
        f = l ? l.count : u.count,
        d = [0, 0, 0],
        m = ["a", "b", "c"],
        v = new Array(3),
        _ = {},
        A = [];
      for (let M = 0; M < f; M += 3) {
        l
          ? ((d[0] = l.getX(M)), (d[1] = l.getX(M + 1)), (d[2] = l.getX(M + 2)))
          : ((d[0] = M), (d[1] = M + 1), (d[2] = M + 2));
        const { a: T, b: E, c: b } = n0;
        if (
          (T.fromBufferAttribute(u, d[0]),
          E.fromBufferAttribute(u, d[1]),
          b.fromBufferAttribute(u, d[2]),
          n0.getNormal(C1),
          (v[0] = `${Math.round(T.x * i)},${Math.round(T.y * i)},${Math.round(
            T.z * i
          )}`),
          (v[1] = `${Math.round(E.x * i)},${Math.round(E.y * i)},${Math.round(
            E.z * i
          )}`),
          (v[2] = `${Math.round(b.x * i)},${Math.round(b.y * i)},${Math.round(
            b.z * i
          )}`),
          !(v[0] === v[1] || v[1] === v[2] || v[2] === v[0]))
        )
          for (let w = 0; w < 3; w++) {
            const D = (w + 1) % 3,
              B = v[w],
              I = v[D],
              N = n0[m[w]],
              P = n0[m[D]],
              F = `${B}_${I}`,
              O = `${I}_${B}`;
            O in _ && _[O]
              ? (C1.dot(_[O].normal) <= a &&
                  (A.push(N.x, N.y, N.z), A.push(P.x, P.y, P.z)),
                (_[O] = null))
              : F in _ ||
                (_[F] = { index0: d[w], index1: d[D], normal: C1.clone() });
          }
      }
      for (const M in _)
        if (_[M]) {
          const { index0: T, index1: E } = _[M];
          e0.fromBufferAttribute(u, T),
            t0.fromBufferAttribute(u, E),
            A.push(e0.x, e0.y, e0.z),
            A.push(t0.x, t0.y, t0.z);
        }
      this.setAttribute("position", new Yt(A, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class yc extends Nm {
  constructor(e) {
    super(e), (this.uuid = gs()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new Nm().fromJSON(i));
    }
    return this;
  }
}
const Gw = {
  triangulate: function (s, e, t = 2) {
    const n = e && e.length,
      i = n ? e[0] * t : s.length;
    let a = pT(s, 0, i, t, !0);
    const l = [];
    if (!a || a.next === a.prev) return l;
    let u, f, d, m, v, _, A;
    if ((n && (a = Xw(s, e, a, t)), s.length > 80 * t)) {
      (u = d = s[0]), (f = m = s[1]);
      for (let M = t; M < i; M += t)
        (v = s[M]),
          (_ = s[M + 1]),
          v < u && (u = v),
          _ < f && (f = _),
          v > d && (d = v),
          _ > m && (m = _);
      (A = Math.max(d - u, m - f)), (A = A !== 0 ? 32767 / A : 0);
    }
    return Im(a, l, t, u, f, A, 0), l;
  },
};
function pT(s, e, t, n, i) {
  let a, l;
  if (i === tB(s, e, t, n) > 0)
    for (a = e; a < t; a += n) l = bM(a, s[a], s[a + 1], l);
  else for (a = t - n; a >= e; a -= n) l = bM(a, s[a], s[a + 1], l);
  return l && qy(l, l.next) && (Pm(l), (l = l.next)), l;
}
function qf(s, e) {
  if (!s) return s;
  e || (e = s);
  let t = s,
    n;
  do
    if (
      ((n = !1), !t.steiner && (qy(t, t.next) || Vi(t.prev, t, t.next) === 0))
    ) {
      if ((Pm(t), (t = e = t.prev), t === t.next)) break;
      n = !0;
    } else t = t.next;
  while (n || t !== e);
  return e;
}
function Im(s, e, t, n, i, a, l) {
  if (!s) return;
  !l && a && jw(s, n, i, a);
  let u = s,
    f,
    d;
  for (; s.prev !== s.next; ) {
    if (((f = s.prev), (d = s.next), a ? Hw(s, n, i, a) : zw(s))) {
      e.push((f.i / t) | 0),
        e.push((s.i / t) | 0),
        e.push((d.i / t) | 0),
        Pm(s),
        (s = d.next),
        (u = d.next);
      continue;
    }
    if (((s = d), s === u)) {
      l
        ? l === 1
          ? ((s = Vw(qf(s), e, t)), Im(s, e, t, n, i, a, 2))
          : l === 2 && kw(s, e, t, n, i, a)
        : Im(qf(s), e, t, n, i, a, 1);
      break;
    }
  }
}
function zw(s) {
  const e = s.prev,
    t = s,
    n = s.next;
  if (Vi(e, t, n) >= 0) return !1;
  const i = e.x,
    a = t.x,
    l = n.x,
    u = e.y,
    f = t.y,
    d = n.y,
    m = i < a ? (i < l ? i : l) : a < l ? a : l,
    v = u < f ? (u < d ? u : d) : f < d ? f : d,
    _ = i > a ? (i > l ? i : l) : a > l ? a : l,
    A = u > f ? (u > d ? u : d) : f > d ? f : d;
  let M = n.next;
  for (; M !== e; ) {
    if (
      M.x >= m &&
      M.x <= _ &&
      M.y >= v &&
      M.y <= A &&
      gd(i, u, a, f, l, d, M.x, M.y) &&
      Vi(M.prev, M, M.next) >= 0
    )
      return !1;
    M = M.next;
  }
  return !0;
}
function Hw(s, e, t, n) {
  const i = s.prev,
    a = s,
    l = s.next;
  if (Vi(i, a, l) >= 0) return !1;
  const u = i.x,
    f = a.x,
    d = l.x,
    m = i.y,
    v = a.y,
    _ = l.y,
    A = u < f ? (u < d ? u : d) : f < d ? f : d,
    M = m < v ? (m < _ ? m : _) : v < _ ? v : _,
    T = u > f ? (u > d ? u : d) : f > d ? f : d,
    E = m > v ? (m > _ ? m : _) : v > _ ? v : _,
    b = AA(A, M, e, t, n),
    w = AA(T, E, e, t, n);
  let D = s.prevZ,
    B = s.nextZ;
  for (; D && D.z >= b && B && B.z <= w; ) {
    if (
      (D.x >= A &&
        D.x <= T &&
        D.y >= M &&
        D.y <= E &&
        D !== i &&
        D !== l &&
        gd(u, m, f, v, d, _, D.x, D.y) &&
        Vi(D.prev, D, D.next) >= 0) ||
      ((D = D.prevZ),
      B.x >= A &&
        B.x <= T &&
        B.y >= M &&
        B.y <= E &&
        B !== i &&
        B !== l &&
        gd(u, m, f, v, d, _, B.x, B.y) &&
        Vi(B.prev, B, B.next) >= 0)
    )
      return !1;
    B = B.nextZ;
  }
  for (; D && D.z >= b; ) {
    if (
      D.x >= A &&
      D.x <= T &&
      D.y >= M &&
      D.y <= E &&
      D !== i &&
      D !== l &&
      gd(u, m, f, v, d, _, D.x, D.y) &&
      Vi(D.prev, D, D.next) >= 0
    )
      return !1;
    D = D.prevZ;
  }
  for (; B && B.z <= w; ) {
    if (
      B.x >= A &&
      B.x <= T &&
      B.y >= M &&
      B.y <= E &&
      B !== i &&
      B !== l &&
      gd(u, m, f, v, d, _, B.x, B.y) &&
      Vi(B.prev, B, B.next) >= 0
    )
      return !1;
    B = B.nextZ;
  }
  return !0;
}
function Vw(s, e, t) {
  let n = s;
  do {
    const i = n.prev,
      a = n.next.next;
    !qy(i, a) &&
      mT(i, n, n.next, a) &&
      Fm(i, a) &&
      Fm(a, i) &&
      (e.push((i.i / t) | 0),
      e.push((n.i / t) | 0),
      e.push((a.i / t) | 0),
      Pm(n),
      Pm(n.next),
      (n = s = a)),
      (n = n.next);
  } while (n !== s);
  return qf(n);
}
function kw(s, e, t, n, i, a) {
  let l = s;
  do {
    let u = l.next.next;
    for (; u !== l.prev; ) {
      if (l.i !== u.i && Qw(l, u)) {
        let f = gT(l, u);
        (l = qf(l, l.next)),
          (f = qf(f, f.next)),
          Im(l, e, t, n, i, a, 0),
          Im(f, e, t, n, i, a, 0);
        return;
      }
      u = u.next;
    }
    l = l.next;
  } while (l !== s);
}
function Xw(s, e, t, n) {
  const i = [];
  let a, l, u, f, d;
  for (a = 0, l = e.length; a < l; a++)
    (u = e[a] * n),
      (f = a < l - 1 ? e[a + 1] * n : s.length),
      (d = pT(s, u, f, n, !1)),
      d === d.next && (d.steiner = !0),
      i.push(Zw(d));
  for (i.sort(Yw), a = 0; a < i.length; a++) t = Ww(i[a], t);
  return t;
}
function Yw(s, e) {
  return s.x - e.x;
}
function Ww(s, e) {
  const t = Jw(s, e);
  if (!t) return e;
  const n = gT(t, s);
  return qf(n, n.next), qf(t, t.next);
}
function Jw(s, e) {
  let t = e,
    n = -1 / 0,
    i;
  const a = s.x,
    l = s.y;
  do {
    if (l <= t.y && l >= t.next.y && t.next.y !== t.y) {
      const _ = t.x + ((l - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        _ <= a &&
        _ > n &&
        ((n = _), (i = t.x < t.next.x ? t : t.next), _ === a)
      )
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const u = i,
    f = i.x,
    d = i.y;
  let m = 1 / 0,
    v;
  t = i;
  do
    a >= t.x &&
      t.x >= f &&
      a !== t.x &&
      gd(l < d ? a : n, l, f, d, l < d ? n : a, l, t.x, t.y) &&
      ((v = Math.abs(l - t.y) / (a - t.x)),
      Fm(t, s) &&
        (v < m || (v === m && (t.x > i.x || (t.x === i.x && qw(i, t))))) &&
        ((i = t), (m = v))),
      (t = t.next);
  while (t !== u);
  return i;
}
function qw(s, e) {
  return Vi(s.prev, s, e.prev) < 0 && Vi(e.next, s, s.next) < 0;
}
function jw(s, e, t, n) {
  let i = s;
  do
    i.z === 0 && (i.z = AA(i.x, i.y, e, t, n)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== s);
  (i.prevZ.nextZ = null), (i.prevZ = null), Kw(i);
}
function Kw(s) {
  let e,
    t,
    n,
    i,
    a,
    l,
    u,
    f,
    d = 1;
  do {
    for (t = s, s = null, a = null, l = 0; t; ) {
      for (l++, n = t, u = 0, e = 0; e < d && (u++, (n = n.nextZ), !!n); e++);
      for (f = d; u > 0 || (f > 0 && n); )
        u !== 0 && (f === 0 || !n || t.z <= n.z)
          ? ((i = t), (t = t.nextZ), u--)
          : ((i = n), (n = n.nextZ), f--),
          a ? (a.nextZ = i) : (s = i),
          (i.prevZ = a),
          (a = i);
      t = n;
    }
    (a.nextZ = null), (d *= 2);
  } while (l > 1);
  return s;
}
function AA(s, e, t, n, i) {
  return (
    (s = ((s - t) * i) | 0),
    (e = ((e - n) * i) | 0),
    (s = (s | (s << 8)) & 16711935),
    (s = (s | (s << 4)) & 252645135),
    (s = (s | (s << 2)) & 858993459),
    (s = (s | (s << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    s | (e << 1)
  );
}
function Zw(s) {
  let e = s,
    t = s;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== s);
  return t;
}
function gd(s, e, t, n, i, a, l, u) {
  return (
    (i - l) * (e - u) >= (s - l) * (a - u) &&
    (s - l) * (n - u) >= (t - l) * (e - u) &&
    (t - l) * (a - u) >= (i - l) * (n - u)
  );
}
function Qw(s, e) {
  return (
    s.next.i !== e.i &&
    s.prev.i !== e.i &&
    !$w(s, e) &&
    ((Fm(s, e) &&
      Fm(e, s) &&
      eB(s, e) &&
      (Vi(s.prev, s, e.prev) || Vi(s, e.prev, e))) ||
      (qy(s, e) && Vi(s.prev, s, s.next) > 0 && Vi(e.prev, e, e.next) > 0))
  );
}
function Vi(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function qy(s, e) {
  return s.x === e.x && s.y === e.y;
}
function mT(s, e, t, n) {
  const i = a0(Vi(s, e, t)),
    a = a0(Vi(s, e, n)),
    l = a0(Vi(t, n, s)),
    u = a0(Vi(t, n, e));
  return !!(
    (i !== a && l !== u) ||
    (i === 0 && i0(s, t, e)) ||
    (a === 0 && i0(s, n, e)) ||
    (l === 0 && i0(t, s, n)) ||
    (u === 0 && i0(t, e, n))
  );
}
function i0(s, e, t) {
  return (
    e.x <= Math.max(s.x, t.x) &&
    e.x >= Math.min(s.x, t.x) &&
    e.y <= Math.max(s.y, t.y) &&
    e.y >= Math.min(s.y, t.y)
  );
}
function a0(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function $w(s, e) {
  let t = s;
  do {
    if (
      t.i !== s.i &&
      t.next.i !== s.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      mT(t, t.next, s, e)
    )
      return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function Fm(s, e) {
  return Vi(s.prev, s, s.next) < 0
    ? Vi(s, e, s.next) >= 0 && Vi(s, s.prev, e) >= 0
    : Vi(s, e, s.prev) < 0 || Vi(s, s.next, e) < 0;
}
function eB(s, e) {
  let t = s,
    n = !1;
  const i = (s.x + e.x) / 2,
    a = (s.y + e.y) / 2;
  do
    t.y > a != t.next.y > a &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (a - t.y)) / (t.next.y - t.y) + t.x &&
      (n = !n),
      (t = t.next);
  while (t !== s);
  return n;
}
function gT(s, e) {
  const t = new xA(s.i, s.x, s.y),
    n = new xA(e.i, e.x, e.y),
    i = s.next,
    a = e.prev;
  return (
    (s.next = e),
    (e.prev = s),
    (t.next = i),
    (i.prev = t),
    (n.next = t),
    (t.prev = n),
    (a.next = n),
    (n.prev = a),
    n
  );
}
function bM(s, e, t, n) {
  const i = new xA(s, e, t);
  return (
    n
      ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function Pm(s) {
  (s.next.prev = s.prev),
    (s.prev.next = s.next),
    s.prevZ && (s.prevZ.nextZ = s.nextZ),
    s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function xA(s, e, t) {
  (this.i = s),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function tB(s, e, t, n) {
  let i = 0;
  for (let a = e, l = t - n; a < t; a += n)
    (i += (s[l] - s[a]) * (s[a + 1] + s[l + 1])), (l = a);
  return i;
}
class El {
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, a = 0; a < t; i = a++)
      n += e[i].x * e[a].y - e[a].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return El.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [],
      i = [],
      a = [];
    EM(e), TM(n, e);
    let l = e.length;
    t.forEach(EM);
    for (let f = 0; f < t.length; f++)
      i.push(l), (l += t[f].length), TM(n, t[f]);
    const u = Gw.triangulate(n, i);
    for (let f = 0; f < u.length; f += 3) a.push(u.slice(f, f + 3));
    return a;
  }
}
function EM(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function TM(s, e) {
  for (let t = 0; t < e.length; t++) s.push(e[t].x), s.push(e[t].y);
}
class jy extends mn {
  constructor(
    e = new yc([
      new at(0.5, 0.5),
      new at(-0.5, 0.5),
      new at(-0.5, -0.5),
      new at(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const n = this,
      i = [],
      a = [];
    for (let u = 0, f = e.length; u < f; u++) {
      const d = e[u];
      l(d);
    }
    this.setAttribute("position", new Yt(i, 3)),
      this.setAttribute("uv", new Yt(a, 2)),
      this.computeVertexNormals();
    function l(u) {
      const f = [],
        d = t.curveSegments !== void 0 ? t.curveSegments : 12,
        m = t.steps !== void 0 ? t.steps : 1,
        v = t.depth !== void 0 ? t.depth : 1;
      let _ = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        A = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        M = t.bevelSize !== void 0 ? t.bevelSize : A - 0.1,
        T = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        E = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const b = t.extrudePath,
        w = t.UVGenerator !== void 0 ? t.UVGenerator : nB;
      let D,
        B = !1,
        I,
        N,
        P,
        F;
      b &&
        ((D = b.getSpacedPoints(m)),
        (B = !0),
        (_ = !1),
        (I = b.computeFrenetFrames(m, !1)),
        (N = new ie()),
        (P = new ie()),
        (F = new ie())),
        _ || ((E = 0), (A = 0), (M = 0), (T = 0));
      const O = u.extractPoints(d);
      let U = O.shape;
      const W = O.holes;
      if (!El.isClockWise(U)) {
        U = U.reverse();
        for (let Me = 0, Ie = W.length; Me < Ie; Me++) {
          const $ = W[Me];
          El.isClockWise($) && (W[Me] = $.reverse());
        }
      }
      const q = El.triangulateShape(U, W),
        Z = U;
      for (let Me = 0, Ie = W.length; Me < Ie; Me++) {
        const $ = W[Me];
        U = U.concat($);
      }
      function ue(Me, Ie, $) {
        return (
          Ie || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          Me.clone().addScaledVector(Ie, $)
        );
      }
      const K = U.length,
        ge = q.length;
      function oe(Me, Ie, $) {
        let ft, Pe, rt;
        const Ue = Me.x - Ie.x,
          ht = Me.y - Ie.y,
          Ve = $.x - Me.x,
          X = $.y - Me.y,
          k = Ue * Ue + ht * ht,
          de = Ue * X - ht * Ve;
        if (Math.abs(de) > Number.EPSILON) {
          const Ee = Math.sqrt(k),
            we = Math.sqrt(Ve * Ve + X * X),
            He = Ie.x - ht / Ee,
            tt = Ie.y + Ue / Ee,
            Ke = $.x - X / we,
            st = $.y + Ve / we,
            Ut = ((Ke - He) * X - (st - tt) * Ve) / (Ue * X - ht * Ve);
          (ft = He + Ue * Ut - Me.x), (Pe = tt + ht * Ut - Me.y);
          const et = ft * ft + Pe * Pe;
          if (et <= 2) return new at(ft, Pe);
          rt = Math.sqrt(et / 2);
        } else {
          let Ee = !1;
          Ue > Number.EPSILON
            ? Ve > Number.EPSILON && (Ee = !0)
            : Ue < -Number.EPSILON
            ? Ve < -Number.EPSILON && (Ee = !0)
            : Math.sign(ht) === Math.sign(X) && (Ee = !0),
            Ee
              ? ((ft = -ht), (Pe = Ue), (rt = Math.sqrt(k)))
              : ((ft = Ue), (Pe = ht), (rt = Math.sqrt(k / 2)));
        }
        return new at(ft / rt, Pe / rt);
      }
      const me = [];
      for (
        let Me = 0, Ie = Z.length, $ = Ie - 1, ft = Me + 1;
        Me < Ie;
        Me++, $++, ft++
      )
        $ === Ie && ($ = 0),
          ft === Ie && (ft = 0),
          (me[Me] = oe(Z[Me], Z[$], Z[ft]));
      const V = [];
      let Y,
        ae = me.concat();
      for (let Me = 0, Ie = W.length; Me < Ie; Me++) {
        const $ = W[Me];
        Y = [];
        for (
          let ft = 0, Pe = $.length, rt = Pe - 1, Ue = ft + 1;
          ft < Pe;
          ft++, rt++, Ue++
        )
          rt === Pe && (rt = 0),
            Ue === Pe && (Ue = 0),
            (Y[ft] = oe($[ft], $[rt], $[Ue]));
        V.push(Y), (ae = ae.concat(Y));
      }
      for (let Me = 0; Me < E; Me++) {
        const Ie = Me / E,
          $ = A * Math.cos((Ie * Math.PI) / 2),
          ft = M * Math.sin((Ie * Math.PI) / 2) + T;
        for (let Pe = 0, rt = Z.length; Pe < rt; Pe++) {
          const Ue = ue(Z[Pe], me[Pe], ft);
          ye(Ue.x, Ue.y, -$);
        }
        for (let Pe = 0, rt = W.length; Pe < rt; Pe++) {
          const Ue = W[Pe];
          Y = V[Pe];
          for (let ht = 0, Ve = Ue.length; ht < Ve; ht++) {
            const X = ue(Ue[ht], Y[ht], ft);
            ye(X.x, X.y, -$);
          }
        }
      }
      const fe = M + T;
      for (let Me = 0; Me < K; Me++) {
        const Ie = _ ? ue(U[Me], ae[Me], fe) : U[Me];
        B
          ? (P.copy(I.normals[0]).multiplyScalar(Ie.x),
            N.copy(I.binormals[0]).multiplyScalar(Ie.y),
            F.copy(D[0]).add(P).add(N),
            ye(F.x, F.y, F.z))
          : ye(Ie.x, Ie.y, 0);
      }
      for (let Me = 1; Me <= m; Me++)
        for (let Ie = 0; Ie < K; Ie++) {
          const $ = _ ? ue(U[Ie], ae[Ie], fe) : U[Ie];
          B
            ? (P.copy(I.normals[Me]).multiplyScalar($.x),
              N.copy(I.binormals[Me]).multiplyScalar($.y),
              F.copy(D[Me]).add(P).add(N),
              ye(F.x, F.y, F.z))
            : ye($.x, $.y, (v / m) * Me);
        }
      for (let Me = E - 1; Me >= 0; Me--) {
        const Ie = Me / E,
          $ = A * Math.cos((Ie * Math.PI) / 2),
          ft = M * Math.sin((Ie * Math.PI) / 2) + T;
        for (let Pe = 0, rt = Z.length; Pe < rt; Pe++) {
          const Ue = ue(Z[Pe], me[Pe], ft);
          ye(Ue.x, Ue.y, v + $);
        }
        for (let Pe = 0, rt = W.length; Pe < rt; Pe++) {
          const Ue = W[Pe];
          Y = V[Pe];
          for (let ht = 0, Ve = Ue.length; ht < Ve; ht++) {
            const X = ue(Ue[ht], Y[ht], ft);
            B ? ye(X.x, X.y + D[m - 1].y, D[m - 1].x + $) : ye(X.x, X.y, v + $);
          }
        }
      }
      j(), se();
      function j() {
        const Me = i.length / 3;
        if (_) {
          let Ie = 0,
            $ = K * Ie;
          for (let ft = 0; ft < ge; ft++) {
            const Pe = q[ft];
            be(Pe[2] + $, Pe[1] + $, Pe[0] + $);
          }
          (Ie = m + E * 2), ($ = K * Ie);
          for (let ft = 0; ft < ge; ft++) {
            const Pe = q[ft];
            be(Pe[0] + $, Pe[1] + $, Pe[2] + $);
          }
        } else {
          for (let Ie = 0; Ie < ge; Ie++) {
            const $ = q[Ie];
            be($[2], $[1], $[0]);
          }
          for (let Ie = 0; Ie < ge; Ie++) {
            const $ = q[Ie];
            be($[0] + K * m, $[1] + K * m, $[2] + K * m);
          }
        }
        n.addGroup(Me, i.length / 3 - Me, 0);
      }
      function se() {
        const Me = i.length / 3;
        let Ie = 0;
        ve(Z, Ie), (Ie += Z.length);
        for (let $ = 0, ft = W.length; $ < ft; $++) {
          const Pe = W[$];
          ve(Pe, Ie), (Ie += Pe.length);
        }
        n.addGroup(Me, i.length / 3 - Me, 1);
      }
      function ve(Me, Ie) {
        let $ = Me.length;
        for (; --$ >= 0; ) {
          const ft = $;
          let Pe = $ - 1;
          Pe < 0 && (Pe = Me.length - 1);
          for (let rt = 0, Ue = m + E * 2; rt < Ue; rt++) {
            const ht = K * rt,
              Ve = K * (rt + 1),
              X = Ie + ft + ht,
              k = Ie + Pe + ht,
              de = Ie + Pe + Ve,
              Ee = Ie + ft + Ve;
            it(X, k, de, Ee);
          }
        }
      }
      function ye(Me, Ie, $) {
        f.push(Me), f.push(Ie), f.push($);
      }
      function be(Me, Ie, $) {
        We(Me), We(Ie), We($);
        const ft = i.length / 3,
          Pe = w.generateTopUV(n, i, ft - 3, ft - 2, ft - 1);
        $e(Pe[0]), $e(Pe[1]), $e(Pe[2]);
      }
      function it(Me, Ie, $, ft) {
        We(Me), We(Ie), We(ft), We(Ie), We($), We(ft);
        const Pe = i.length / 3,
          rt = w.generateSideWallUV(n, i, Pe - 6, Pe - 3, Pe - 2, Pe - 1);
        $e(rt[0]), $e(rt[1]), $e(rt[3]), $e(rt[1]), $e(rt[2]), $e(rt[3]);
      }
      function We(Me) {
        i.push(f[Me * 3 + 0]), i.push(f[Me * 3 + 1]), i.push(f[Me * 3 + 2]);
      }
      function $e(Me) {
        a.push(Me.x), a.push(Me.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      n = this.parameters.options;
    return iB(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let a = 0, l = e.shapes.length; a < l; a++) {
      const u = t[e.shapes[a]];
      n.push(u);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new my[i.type]().fromJSON(i)),
      new jy(n, e.options)
    );
  }
}
const nB = {
  generateTopUV: function (s, e, t, n, i) {
    const a = e[t * 3],
      l = e[t * 3 + 1],
      u = e[n * 3],
      f = e[n * 3 + 1],
      d = e[i * 3],
      m = e[i * 3 + 1];
    return [new at(a, l), new at(u, f), new at(d, m)];
  },
  generateSideWallUV: function (s, e, t, n, i, a) {
    const l = e[t * 3],
      u = e[t * 3 + 1],
      f = e[t * 3 + 2],
      d = e[n * 3],
      m = e[n * 3 + 1],
      v = e[n * 3 + 2],
      _ = e[i * 3],
      A = e[i * 3 + 1],
      M = e[i * 3 + 2],
      T = e[a * 3],
      E = e[a * 3 + 1],
      b = e[a * 3 + 2];
    return Math.abs(u - m) < Math.abs(l - d)
      ? [new at(l, 1 - f), new at(d, 1 - v), new at(_, 1 - M), new at(T, 1 - b)]
      : [
          new at(u, 1 - f),
          new at(m, 1 - v),
          new at(A, 1 - M),
          new at(E, 1 - b),
        ];
  },
};
function iB(s, e, t) {
  if (((t.shapes = []), Array.isArray(s)))
    for (let n = 0, i = s.length; n < i; n++) {
      const a = s[n];
      t.shapes.push(a.uuid);
    }
  else t.shapes.push(s.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class Zm extends Tc {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1,
      ],
      a = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, a, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Zm(e.radius, e.detail);
  }
}
class Qm extends Tc {
  constructor(e = 1, t = 0) {
    const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(n, i, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Qm(e.radius, e.detail);
  }
}
class zs extends mn {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i,
      });
    const a = e / 2,
      l = t / 2,
      u = Math.floor(n),
      f = Math.floor(i),
      d = u + 1,
      m = f + 1,
      v = e / u,
      _ = t / f,
      A = [],
      M = [],
      T = [],
      E = [];
    for (let b = 0; b < m; b++) {
      const w = b * _ - l;
      for (let D = 0; D < d; D++) {
        const B = D * v - a;
        M.push(B, -w, 0), T.push(0, 0, 1), E.push(D / u), E.push(1 - b / f);
      }
    }
    for (let b = 0; b < f; b++)
      for (let w = 0; w < u; w++) {
        const D = w + d * b,
          B = w + d * (b + 1),
          I = w + 1 + d * (b + 1),
          N = w + 1 + d * b;
        A.push(D, B, N), A.push(B, I, N);
      }
    this.setIndex(A),
      this.setAttribute("position", new Yt(M, 3)),
      this.setAttribute("normal", new Yt(T, 3)),
      this.setAttribute("uv", new Yt(E, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new zs(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class Ky extends mn {
  constructor(e = 0.5, t = 1, n = 32, i = 1, a = 0, l = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: a,
        thetaLength: l,
      }),
      (n = Math.max(3, n)),
      (i = Math.max(1, i));
    const u = [],
      f = [],
      d = [],
      m = [];
    let v = e;
    const _ = (t - e) / i,
      A = new ie(),
      M = new at();
    for (let T = 0; T <= i; T++) {
      for (let E = 0; E <= n; E++) {
        const b = a + (E / n) * l;
        (A.x = v * Math.cos(b)),
          (A.y = v * Math.sin(b)),
          f.push(A.x, A.y, A.z),
          d.push(0, 0, 1),
          (M.x = (A.x / t + 1) / 2),
          (M.y = (A.y / t + 1) / 2),
          m.push(M.x, M.y);
      }
      v += _;
    }
    for (let T = 0; T < i; T++) {
      const E = T * (n + 1);
      for (let b = 0; b < n; b++) {
        const w = b + E,
          D = w,
          B = w + n + 1,
          I = w + n + 2,
          N = w + 1;
        u.push(D, B, N), u.push(B, I, N);
      }
    }
    this.setIndex(u),
      this.setAttribute("position", new Yt(f, 3)),
      this.setAttribute("normal", new Yt(d, 3)),
      this.setAttribute("uv", new Yt(m, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ky(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Zy extends mn {
  constructor(
    e = new yc([new at(0, 0.5), new at(-0.5, -0.5), new at(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const n = [],
      i = [],
      a = [],
      l = [];
    let u = 0,
      f = 0;
    if (Array.isArray(e) === !1) d(e);
    else
      for (let m = 0; m < e.length; m++)
        d(e[m]), this.addGroup(u, f, m), (u += f), (f = 0);
    this.setIndex(n),
      this.setAttribute("position", new Yt(i, 3)),
      this.setAttribute("normal", new Yt(a, 3)),
      this.setAttribute("uv", new Yt(l, 2));
    function d(m) {
      const v = i.length / 3,
        _ = m.extractPoints(t);
      let A = _.shape;
      const M = _.holes;
      El.isClockWise(A) === !1 && (A = A.reverse());
      for (let E = 0, b = M.length; E < b; E++) {
        const w = M[E];
        El.isClockWise(w) === !0 && (M[E] = w.reverse());
      }
      const T = El.triangulateShape(A, M);
      for (let E = 0, b = M.length; E < b; E++) {
        const w = M[E];
        A = A.concat(w);
      }
      for (let E = 0, b = A.length; E < b; E++) {
        const w = A[E];
        i.push(w.x, w.y, 0), a.push(0, 0, 1), l.push(w.x, w.y);
      }
      for (let E = 0, b = T.length; E < b; E++) {
        const w = T[E],
          D = w[0] + v,
          B = w[1] + v,
          I = w[2] + v;
        n.push(D, B, I), (f += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return aB(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, a = e.shapes.length; i < a; i++) {
      const l = t[e.shapes[i]];
      n.push(l);
    }
    return new Zy(n, e.curveSegments);
  }
}
function aB(s, e) {
  if (((e.shapes = []), Array.isArray(s)))
    for (let t = 0, n = s.length; t < n; t++) {
      const i = s[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(s.uuid);
  return e;
}
class $m extends mn {
  constructor(
    e = 1,
    t = 32,
    n = 16,
    i = 0,
    a = Math.PI * 2,
    l = 0,
    u = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: i,
        phiLength: a,
        thetaStart: l,
        thetaLength: u,
      }),
      (t = Math.max(3, Math.floor(t))),
      (n = Math.max(2, Math.floor(n)));
    const f = Math.min(l + u, Math.PI);
    let d = 0;
    const m = [],
      v = new ie(),
      _ = new ie(),
      A = [],
      M = [],
      T = [],
      E = [];
    for (let b = 0; b <= n; b++) {
      const w = [],
        D = b / n;
      let B = 0;
      b === 0 && l === 0
        ? (B = 0.5 / t)
        : b === n && f === Math.PI && (B = -0.5 / t);
      for (let I = 0; I <= t; I++) {
        const N = I / t;
        (v.x = -e * Math.cos(i + N * a) * Math.sin(l + D * u)),
          (v.y = e * Math.cos(l + D * u)),
          (v.z = e * Math.sin(i + N * a) * Math.sin(l + D * u)),
          M.push(v.x, v.y, v.z),
          _.copy(v).normalize(),
          T.push(_.x, _.y, _.z),
          E.push(N + B, 1 - D),
          w.push(d++);
      }
      m.push(w);
    }
    for (let b = 0; b < n; b++)
      for (let w = 0; w < t; w++) {
        const D = m[b][w + 1],
          B = m[b][w],
          I = m[b + 1][w],
          N = m[b + 1][w + 1];
        (b !== 0 || l > 0) && A.push(D, B, N),
          (b !== n - 1 || f < Math.PI) && A.push(B, I, N);
      }
    this.setIndex(A),
      this.setAttribute("position", new Yt(M, 3)),
      this.setAttribute("normal", new Yt(T, 3)),
      this.setAttribute("uv", new Yt(E, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new $m(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Qy extends Tc {
  constructor(e = 1, t = 0) {
    const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(n, i, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Qy(e.radius, e.detail);
  }
}
class $y extends mn {
  constructor(e = 1, t = 0.4, n = 12, i = 48, a = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: n,
        tubularSegments: i,
        arc: a,
      }),
      (n = Math.floor(n)),
      (i = Math.floor(i));
    const l = [],
      u = [],
      f = [],
      d = [],
      m = new ie(),
      v = new ie(),
      _ = new ie();
    for (let A = 0; A <= n; A++)
      for (let M = 0; M <= i; M++) {
        const T = (M / i) * a,
          E = (A / n) * Math.PI * 2;
        (v.x = (e + t * Math.cos(E)) * Math.cos(T)),
          (v.y = (e + t * Math.cos(E)) * Math.sin(T)),
          (v.z = t * Math.sin(E)),
          u.push(v.x, v.y, v.z),
          (m.x = e * Math.cos(T)),
          (m.y = e * Math.sin(T)),
          _.subVectors(v, m).normalize(),
          f.push(_.x, _.y, _.z),
          d.push(M / i),
          d.push(A / n);
      }
    for (let A = 1; A <= n; A++)
      for (let M = 1; M <= i; M++) {
        const T = (i + 1) * A + M - 1,
          E = (i + 1) * (A - 1) + M - 1,
          b = (i + 1) * (A - 1) + M,
          w = (i + 1) * A + M;
        l.push(T, E, w), l.push(E, b, w);
      }
    this.setIndex(l),
      this.setAttribute("position", new Yt(u, 3)),
      this.setAttribute("normal", new Yt(f, 3)),
      this.setAttribute("uv", new Yt(d, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new $y(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class e_ extends mn {
  constructor(e = 1, t = 0.4, n = 64, i = 8, a = 2, l = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: n,
        radialSegments: i,
        p: a,
        q: l,
      }),
      (n = Math.floor(n)),
      (i = Math.floor(i));
    const u = [],
      f = [],
      d = [],
      m = [],
      v = new ie(),
      _ = new ie(),
      A = new ie(),
      M = new ie(),
      T = new ie(),
      E = new ie(),
      b = new ie();
    for (let D = 0; D <= n; ++D) {
      const B = (D / n) * a * Math.PI * 2;
      w(B, a, l, e, A),
        w(B + 0.01, a, l, e, M),
        E.subVectors(M, A),
        b.addVectors(M, A),
        T.crossVectors(E, b),
        b.crossVectors(T, E),
        T.normalize(),
        b.normalize();
      for (let I = 0; I <= i; ++I) {
        const N = (I / i) * Math.PI * 2,
          P = -t * Math.cos(N),
          F = t * Math.sin(N);
        (v.x = A.x + (P * b.x + F * T.x)),
          (v.y = A.y + (P * b.y + F * T.y)),
          (v.z = A.z + (P * b.z + F * T.z)),
          f.push(v.x, v.y, v.z),
          _.subVectors(v, A).normalize(),
          d.push(_.x, _.y, _.z),
          m.push(D / n),
          m.push(I / i);
      }
    }
    for (let D = 1; D <= n; D++)
      for (let B = 1; B <= i; B++) {
        const I = (i + 1) * (D - 1) + (B - 1),
          N = (i + 1) * D + (B - 1),
          P = (i + 1) * D + B,
          F = (i + 1) * (D - 1) + B;
        u.push(I, N, F), u.push(N, P, F);
      }
    this.setIndex(u),
      this.setAttribute("position", new Yt(f, 3)),
      this.setAttribute("normal", new Yt(d, 3)),
      this.setAttribute("uv", new Yt(m, 2));
    function w(D, B, I, N, P) {
      const F = Math.cos(D),
        O = Math.sin(D),
        U = (I / B) * D,
        W = Math.cos(U);
      (P.x = N * (2 + W) * 0.5 * F),
        (P.y = N * (2 + W) * O * 0.5),
        (P.z = N * Math.sin(U) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new e_(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class t_ extends mn {
  constructor(
    e = new px(new ie(-1, -1, 0), new ie(-1, 1, 0), new ie(1, 1, 0)),
    t = 64,
    n = 1,
    i = 8,
    a = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: n,
        radialSegments: i,
        closed: a,
      });
    const l = e.computeFrenetFrames(t, a);
    (this.tangents = l.tangents),
      (this.normals = l.normals),
      (this.binormals = l.binormals);
    const u = new ie(),
      f = new ie(),
      d = new at();
    let m = new ie();
    const v = [],
      _ = [],
      A = [],
      M = [];
    T(),
      this.setIndex(M),
      this.setAttribute("position", new Yt(v, 3)),
      this.setAttribute("normal", new Yt(_, 3)),
      this.setAttribute("uv", new Yt(A, 2));
    function T() {
      for (let D = 0; D < t; D++) E(D);
      E(a === !1 ? t : 0), w(), b();
    }
    function E(D) {
      m = e.getPointAt(D / t, m);
      const B = l.normals[D],
        I = l.binormals[D];
      for (let N = 0; N <= i; N++) {
        const P = (N / i) * Math.PI * 2,
          F = Math.sin(P),
          O = -Math.cos(P);
        (f.x = O * B.x + F * I.x),
          (f.y = O * B.y + F * I.y),
          (f.z = O * B.z + F * I.z),
          f.normalize(),
          _.push(f.x, f.y, f.z),
          (u.x = m.x + n * f.x),
          (u.y = m.y + n * f.y),
          (u.z = m.z + n * f.z),
          v.push(u.x, u.y, u.z);
      }
    }
    function b() {
      for (let D = 1; D <= t; D++)
        for (let B = 1; B <= i; B++) {
          const I = (i + 1) * (D - 1) + (B - 1),
            N = (i + 1) * D + (B - 1),
            P = (i + 1) * D + B,
            F = (i + 1) * (D - 1) + B;
          M.push(I, N, F), M.push(N, P, F);
        }
    }
    function w() {
      for (let D = 0; D <= t; D++)
        for (let B = 0; B <= i; B++)
          (d.x = D / t), (d.y = B / i), A.push(d.x, d.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new t_(
      new my[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class vT extends mn {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        n = new Set(),
        i = new ie(),
        a = new ie();
      if (e.index !== null) {
        const l = e.attributes.position,
          u = e.index;
        let f = e.groups;
        f.length === 0 &&
          (f = [{ start: 0, count: u.count, materialIndex: 0 }]);
        for (let d = 0, m = f.length; d < m; ++d) {
          const v = f[d],
            _ = v.start,
            A = v.count;
          for (let M = _, T = _ + A; M < T; M += 3)
            for (let E = 0; E < 3; E++) {
              const b = u.getX(M + E),
                w = u.getX(M + ((E + 1) % 3));
              i.fromBufferAttribute(l, b),
                a.fromBufferAttribute(l, w),
                CM(i, a, n) === !0 &&
                  (t.push(i.x, i.y, i.z), t.push(a.x, a.y, a.z));
            }
        }
      } else {
        const l = e.attributes.position;
        for (let u = 0, f = l.count / 3; u < f; u++)
          for (let d = 0; d < 3; d++) {
            const m = 3 * u + d,
              v = 3 * u + ((d + 1) % 3);
            i.fromBufferAttribute(l, m),
              a.fromBufferAttribute(l, v),
              CM(i, a, n) === !0 &&
                (t.push(i.x, i.y, i.z), t.push(a.x, a.y, a.z));
          }
      }
      this.setAttribute("position", new Yt(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function CM(s, e, t) {
  const n = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
  return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
}
var RM = Object.freeze({
  __proto__: null,
  BoxGeometry: eh,
  CapsuleGeometry: Xy,
  CircleGeometry: Yy,
  ConeGeometry: Wy,
  CylinderGeometry: Id,
  DodecahedronGeometry: Jy,
  EdgesGeometry: dT,
  ExtrudeGeometry: jy,
  IcosahedronGeometry: Zm,
  LatheGeometry: Km,
  OctahedronGeometry: Qm,
  PlaneGeometry: zs,
  PolyhedronGeometry: Tc,
  RingGeometry: Ky,
  ShapeGeometry: Zy,
  SphereGeometry: $m,
  TetrahedronGeometry: Qy,
  TorusGeometry: $y,
  TorusKnotGeometry: e_,
  TubeGeometry: t_,
  WireframeGeometry: vT,
});
class yT extends _a {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Dt(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class _T extends ra {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class eg extends _a {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = "MeshStandardMaterial"),
      (this.defines = { STANDARD: "" }),
      (this.color = new Dt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ec),
      (this.normalScale = new at(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new vs()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Hs extends eg {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new at(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return dn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Dt(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Dt(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Dt(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class AT extends _a {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Dt(16777215)),
      (this.specular = new Dt(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ec),
      (this.normalScale = new at(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new vs()),
      (this.combine = Vm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class xT extends _a {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Dt(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ec),
      (this.normalScale = new at(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class ST extends _a {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ec),
      (this.normalScale = new at(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class MT extends _a {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Dt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ec),
      (this.normalScale = new at(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new vs()),
      (this.combine = Vm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class n_ extends _a {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = VE),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class i_ extends _a {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
class bT extends _a {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Dt(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ec),
      (this.normalScale = new at(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class ET extends dr {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function Pf(s, e, t) {
  return !s || (!t && s.constructor === e)
    ? s
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(s)
    : Array.prototype.slice.call(s);
}
function TT(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function CT(s) {
  function e(i, a) {
    return s[i] - s[a];
  }
  const t = s.length,
    n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function SA(s, e, t) {
  const n = s.length,
    i = new s.constructor(n);
  for (let a = 0, l = 0; l !== n; ++a) {
    const u = t[a] * e;
    for (let f = 0; f !== e; ++f) i[l++] = s[u + f];
  }
  return i;
}
function gx(s, e, t, n) {
  let i = 1,
    a = s[0];
  for (; a !== void 0 && a[n] === void 0; ) a = s[i++];
  if (a === void 0) return;
  let l = a[n];
  if (l !== void 0)
    if (Array.isArray(l))
      do
        (l = a[n]),
          l !== void 0 && (e.push(a.time), t.push.apply(t, l)),
          (a = s[i++]);
      while (a !== void 0);
    else if (l.toArray !== void 0)
      do
        (l = a[n]),
          l !== void 0 && (e.push(a.time), l.toArray(t, t.length)),
          (a = s[i++]);
      while (a !== void 0);
    else
      do (l = a[n]), l !== void 0 && (e.push(a.time), t.push(l)), (a = s[i++]);
      while (a !== void 0);
}
function rB(s, e, t, n, i = 30) {
  const a = s.clone();
  a.name = e;
  const l = [];
  for (let f = 0; f < a.tracks.length; ++f) {
    const d = a.tracks[f],
      m = d.getValueSize(),
      v = [],
      _ = [];
    for (let A = 0; A < d.times.length; ++A) {
      const M = d.times[A] * i;
      if (!(M < t || M >= n)) {
        v.push(d.times[A]);
        for (let T = 0; T < m; ++T) _.push(d.values[A * m + T]);
      }
    }
    v.length !== 0 &&
      ((d.times = Pf(v, d.times.constructor)),
      (d.values = Pf(_, d.values.constructor)),
      l.push(d));
  }
  a.tracks = l;
  let u = 1 / 0;
  for (let f = 0; f < a.tracks.length; ++f)
    u > a.tracks[f].times[0] && (u = a.tracks[f].times[0]);
  for (let f = 0; f < a.tracks.length; ++f) a.tracks[f].shift(-1 * u);
  return a.resetDuration(), a;
}
function sB(s, e = 0, t = s, n = 30) {
  n <= 0 && (n = 30);
  const i = t.tracks.length,
    a = e / n;
  for (let l = 0; l < i; ++l) {
    const u = t.tracks[l],
      f = u.ValueTypeName;
    if (f === "bool" || f === "string") continue;
    const d = s.tracks.find(function (b) {
      return b.name === u.name && b.ValueTypeName === f;
    });
    if (d === void 0) continue;
    let m = 0;
    const v = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (m = v / 3);
    let _ = 0;
    const A = d.getValueSize();
    d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (_ = A / 3);
    const M = u.times.length - 1;
    let T;
    if (a <= u.times[0]) {
      const b = m,
        w = v - m;
      T = u.values.slice(b, w);
    } else if (a >= u.times[M]) {
      const b = M * v + m,
        w = b + v - m;
      T = u.values.slice(b, w);
    } else {
      const b = u.createInterpolant(),
        w = m,
        D = v - m;
      b.evaluate(a), (T = b.resultBuffer.slice(w, D));
    }
    f === "quaternion" &&
      new La().fromArray(T).normalize().conjugate().toArray(T);
    const E = d.times.length;
    for (let b = 0; b < E; ++b) {
      const w = b * A + _;
      if (f === "quaternion")
        La.multiplyQuaternionsFlat(d.values, w, T, 0, d.values, w);
      else {
        const D = A - _ * 2;
        for (let B = 0; B < D; ++B) d.values[w + B] -= T[B];
      }
    }
  }
  return (s.blendMode = KA), s;
}
const oB = {
  convertArray: Pf,
  isTypedArray: TT,
  getKeyframeOrder: CT,
  sortedArray: SA,
  flattenJSON: gx,
  subclip: rB,
  makeClipAdditive: sB,
};
class Fd {
  constructor(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      i = t[n],
      a = t[n - 1];
    e: {
      t: {
        let l;
        n: {
          i: if (!(e < i)) {
            for (let u = n + 2; ; ) {
              if (i === void 0) {
                if (e < a) break i;
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
              }
              if (n === u) break;
              if (((a = i), (i = t[++n]), e < i)) break t;
            }
            l = t.length;
            break n;
          }
          if (!(e >= a)) {
            const u = t[1];
            e < u && ((n = 2), (a = u));
            for (let f = n - 2; ; ) {
              if (a === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (n === f) break;
              if (((i = a), (a = t[--n - 1]), e >= a)) break t;
            }
            (l = n), (n = 0);
            break n;
          }
          break e;
        }
        for (; n < l; ) {
          const u = (n + l) >>> 1;
          e < t[u] ? (l = u) : (n = u + 1);
        }
        if (((i = t[n]), (a = t[n - 1]), a === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (n = t.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, a, i);
    }
    return this.interpolate_(n, a, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      a = e * i;
    for (let l = 0; l !== i; ++l) t[l] = n[a + l];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class RT extends Fd {
  constructor(e, t, n, i) {
    super(e, t, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Lf, endingEnd: Lf });
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let a = e - 2,
      l = e + 1,
      u = i[a],
      f = i[l];
    if (u === void 0)
      switch (this.getSettings_().endingStart) {
        case Nf:
          (a = e), (u = 2 * t - n);
          break;
        case Bm:
          (a = i.length - 2), (u = t + i[a] - i[a + 1]);
          break;
        default:
          (a = e), (u = n);
      }
    if (f === void 0)
      switch (this.getSettings_().endingEnd) {
        case Nf:
          (l = e), (f = 2 * n - t);
          break;
        case Bm:
          (l = 1), (f = n + i[1] - i[0]);
          break;
        default:
          (l = e - 1), (f = t);
      }
    const d = (n - t) * 0.5,
      m = this.valueSize;
    (this._weightPrev = d / (t - u)),
      (this._weightNext = d / (f - n)),
      (this._offsetPrev = a * m),
      (this._offsetNext = l * m);
  }
  interpolate_(e, t, n, i) {
    const a = this.resultBuffer,
      l = this.sampleValues,
      u = this.valueSize,
      f = e * u,
      d = f - u,
      m = this._offsetPrev,
      v = this._offsetNext,
      _ = this._weightPrev,
      A = this._weightNext,
      M = (n - t) / (i - t),
      T = M * M,
      E = T * M,
      b = -_ * E + 2 * _ * T - _ * M,
      w = (1 + _) * E + (-1.5 - 2 * _) * T + (-0.5 + _) * M + 1,
      D = (-1 - A) * E + (1.5 + A) * T + 0.5 * M,
      B = A * E - A * T;
    for (let I = 0; I !== u; ++I)
      a[I] = b * l[m + I] + w * l[d + I] + D * l[f + I] + B * l[v + I];
    return a;
  }
}
class vx extends Fd {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const a = this.resultBuffer,
      l = this.sampleValues,
      u = this.valueSize,
      f = e * u,
      d = f - u,
      m = (n - t) / (i - t),
      v = 1 - m;
    for (let _ = 0; _ !== u; ++_) a[_] = l[d + _] * v + l[f + _] * m;
    return a;
  }
}
class wT extends Fd {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Io {
  constructor(e, t, n, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = Pf(t, this.TimeBufferType)),
      (this.values = Pf(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: Pf(e.times, Array),
        values: Pf(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = e.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new wT(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new vx(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new RT(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Ed:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Td:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case b0:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Ed;
      case this.InterpolantFactoryMethodLinear:
        return Td;
      case this.InterpolantFactoryMethodSmooth:
        return b0;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      i = n.length;
    let a = 0,
      l = i - 1;
    for (; a !== i && n[a] < e; ) ++a;
    for (; l !== -1 && n[l] > t; ) --l;
    if ((++l, a !== 0 || l !== i)) {
      a >= l && ((l = Math.max(l, 1)), (a = l - 1));
      const u = this.getValueSize();
      (this.times = n.slice(a, l)),
        (this.values = this.values.slice(a * u, l * u));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const n = this.times,
      i = this.values,
      a = n.length;
    a === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let l = null;
    for (let u = 0; u !== a; u++) {
      const f = n[u];
      if (typeof f == "number" && isNaN(f)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          u,
          f
        ),
          (e = !1);
        break;
      }
      if (l !== null && l > f) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, u, f, l),
          (e = !1);
        break;
      }
      l = f;
    }
    if (i !== void 0 && TT(i))
      for (let u = 0, f = i.length; u !== f; ++u) {
        const d = i[u];
        if (isNaN(d)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            u,
            d
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      n = this.getValueSize(),
      i = this.getInterpolation() === b0,
      a = e.length - 1;
    let l = 1;
    for (let u = 1; u < a; ++u) {
      let f = !1;
      const d = e[u],
        m = e[u + 1];
      if (d !== m && (u !== 1 || d !== e[0]))
        if (i) f = !0;
        else {
          const v = u * n,
            _ = v - n,
            A = v + n;
          for (let M = 0; M !== n; ++M) {
            const T = t[v + M];
            if (T !== t[_ + M] || T !== t[A + M]) {
              f = !0;
              break;
            }
          }
        }
      if (f) {
        if (u !== l) {
          e[l] = e[u];
          const v = u * n,
            _ = l * n;
          for (let A = 0; A !== n; ++A) t[_ + A] = t[v + A];
        }
        ++l;
      }
    }
    if (a > 0) {
      e[l] = e[a];
      for (let u = a * n, f = l * n, d = 0; d !== n; ++d) t[f + d] = t[u + d];
      ++l;
    }
    return (
      l !== e.length
        ? ((this.times = e.slice(0, l)), (this.values = t.slice(0, l * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      n = this.constructor,
      i = new n(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
Io.prototype.TimeBufferType = Float32Array;
Io.prototype.ValueBufferType = Float32Array;
Io.prototype.DefaultInterpolation = Td;
class th extends Io {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
th.prototype.ValueTypeName = "bool";
th.prototype.ValueBufferType = Array;
th.prototype.DefaultInterpolation = Ed;
th.prototype.InterpolantFactoryMethodLinear = void 0;
th.prototype.InterpolantFactoryMethodSmooth = void 0;
class yx extends Io {}
yx.prototype.ValueTypeName = "color";
class jf extends Io {}
jf.prototype.ValueTypeName = "number";
class BT extends Fd {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const a = this.resultBuffer,
      l = this.sampleValues,
      u = this.valueSize,
      f = (n - t) / (i - t);
    let d = e * u;
    for (let m = d + u; d !== m; d += 4) La.slerpFlat(a, 0, l, d - u, l, d, f);
    return a;
  }
}
class Kf extends Io {
  InterpolantFactoryMethodLinear(e) {
    return new BT(this.times, this.values, this.getValueSize(), e);
  }
}
Kf.prototype.ValueTypeName = "quaternion";
Kf.prototype.InterpolantFactoryMethodSmooth = void 0;
class nh extends Io {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
nh.prototype.ValueTypeName = "string";
nh.prototype.ValueBufferType = Array;
nh.prototype.DefaultInterpolation = Ed;
nh.prototype.InterpolantFactoryMethodLinear = void 0;
nh.prototype.InterpolantFactoryMethodSmooth = void 0;
class Zf extends Io {}
Zf.prototype.ValueTypeName = "vector";
class Bd {
  constructor(e = "", t = -1, n = [], i = Uy) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = gs()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      i = 1 / (e.fps || 1);
    for (let l = 0, u = n.length; l !== u; ++l) t.push(uB(n[l]).scale(i));
    const a = new this(e.name, e.duration, t, e.blendMode);
    return (a.uuid = e.uuid), a;
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let a = 0, l = n.length; a !== l; ++a) t.push(Io.toJSON(n[a]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const a = t.length,
      l = [];
    for (let u = 0; u < a; u++) {
      let f = [],
        d = [];
      f.push((u + a - 1) % a, u, (u + 1) % a), d.push(0, 1, 0);
      const m = CT(f);
      (f = SA(f, 1, m)),
        (d = SA(d, 1, m)),
        !i && f[0] === 0 && (f.push(a), d.push(d[0])),
        l.push(
          new jf(".morphTargetInfluences[" + t[u].name + "]", f, d).scale(1 / n)
        );
    }
    return new this(e, -1, l);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {},
      a = /^([\w-]*?)([\d]+)$/;
    for (let u = 0, f = e.length; u < f; u++) {
      const d = e[u],
        m = d.name.match(a);
      if (m && m.length > 1) {
        const v = m[1];
        let _ = i[v];
        _ || (i[v] = _ = []), _.push(d);
      }
    }
    const l = [];
    for (const u in i)
      l.push(this.CreateFromMorphTargetSequence(u, i[u], t, n));
    return l;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const n = function (v, _, A, M, T) {
        if (A.length !== 0) {
          const E = [],
            b = [];
          gx(A, E, b, M), E.length !== 0 && T.push(new v(_, E, b));
        }
      },
      i = [],
      a = e.name || "default",
      l = e.fps || 30,
      u = e.blendMode;
    let f = e.length || -1;
    const d = e.hierarchy || [];
    for (let v = 0; v < d.length; v++) {
      const _ = d[v].keys;
      if (!(!_ || _.length === 0))
        if (_[0].morphTargets) {
          const A = {};
          let M;
          for (M = 0; M < _.length; M++)
            if (_[M].morphTargets)
              for (let T = 0; T < _[M].morphTargets.length; T++)
                A[_[M].morphTargets[T]] = -1;
          for (const T in A) {
            const E = [],
              b = [];
            for (let w = 0; w !== _[M].morphTargets.length; ++w) {
              const D = _[M];
              E.push(D.time), b.push(D.morphTarget === T ? 1 : 0);
            }
            i.push(new jf(".morphTargetInfluence[" + T + "]", E, b));
          }
          f = A.length * l;
        } else {
          const A = ".bones[" + t[v].name + "]";
          n(Zf, A + ".position", _, "pos", i),
            n(Kf, A + ".quaternion", _, "rot", i),
            n(Zf, A + ".scale", _, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(a, f, i, u);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const a = this.tracks[n];
      t = Math.max(t, a.times[a.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function lB(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return jf;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Zf;
    case "color":
      return yx;
    case "quaternion":
      return Kf;
    case "bool":
    case "boolean":
      return th;
    case "string":
      return nh;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function uB(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = lB(s.type);
  if (s.times === void 0) {
    const t = [],
      n = [];
    gx(s.keys, t, n, "value"), (s.times = t), (s.values = n);
  }
  return e.parse !== void 0
    ? e.parse(s)
    : new e(s.name, s.times, s.values, s.interpolation);
}
const _u = {
  enabled: !1,
  files: {},
  add: function (s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function (s) {
    if (this.enabled !== !1) return this.files[s];
  },
  remove: function (s) {
    delete this.files[s];
  },
  clear: function () {
    this.files = {};
  },
};
class a_ {
  constructor(e, t, n) {
    const i = this;
    let a = !1,
      l = 0,
      u = 0,
      f;
    const d = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (m) {
        u++, a === !1 && i.onStart !== void 0 && i.onStart(m, l, u), (a = !0);
      }),
      (this.itemEnd = function (m) {
        l++,
          i.onProgress !== void 0 && i.onProgress(m, l, u),
          l === u && ((a = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (m) {
        i.onError !== void 0 && i.onError(m);
      }),
      (this.resolveURL = function (m) {
        return f ? f(m) : m;
      }),
      (this.setURLModifier = function (m) {
        return (f = m), this;
      }),
      (this.addHandler = function (m, v) {
        return d.push(m, v), this;
      }),
      (this.removeHandler = function (m) {
        const v = d.indexOf(m);
        return v !== -1 && d.splice(v, 2), this;
      }),
      (this.getHandler = function (m) {
        for (let v = 0, _ = d.length; v < _; v += 2) {
          const A = d[v],
            M = d[v + 1];
          if ((A.global && (A.lastIndex = 0), A.test(m))) return M;
        }
        return null;
      });
  }
}
const DT = new a_();
class qa {
  constructor(e) {
    (this.manager = e !== void 0 ? e : DT),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (i, a) {
      n.load(e, i, t, a);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
qa.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const hu = {};
class cB extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class Ja extends qa {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const a = _u.get(e);
    if (a !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(a), this.manager.itemEnd(e);
        }, 0),
        a
      );
    if (hu[e] !== void 0) {
      hu[e].push({ onLoad: t, onProgress: n, onError: i });
      return;
    }
    (hu[e] = []), hu[e].push({ onLoad: t, onProgress: n, onError: i });
    const l = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      u = this.mimeType,
      f = this.responseType;
    fetch(l)
      .then((d) => {
        if (d.status === 200 || d.status === 0) {
          if (
            (d.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              d.body === void 0 ||
              d.body.getReader === void 0)
          )
            return d;
          const m = hu[e],
            v = d.body.getReader(),
            _ = d.headers.get("X-File-Size") || d.headers.get("Content-Length"),
            A = _ ? parseInt(_) : 0,
            M = A !== 0;
          let T = 0;
          const E = new ReadableStream({
            start(b) {
              w();
              function w() {
                v.read().then(
                  ({ done: D, value: B }) => {
                    if (D) b.close();
                    else {
                      T += B.byteLength;
                      const I = new ProgressEvent("progress", {
                        lengthComputable: M,
                        loaded: T,
                        total: A,
                      });
                      for (let N = 0, P = m.length; N < P; N++) {
                        const F = m[N];
                        F.onProgress && F.onProgress(I);
                      }
                      b.enqueue(B), w();
                    }
                  },
                  (D) => {
                    b.error(D);
                  }
                );
              }
            },
          });
          return new Response(E);
        } else
          throw new cB(
            `fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`,
            d
          );
      })
      .then((d) => {
        switch (f) {
          case "arraybuffer":
            return d.arrayBuffer();
          case "blob":
            return d.blob();
          case "document":
            return d.text().then((m) => new DOMParser().parseFromString(m, u));
          case "json":
            return d.json();
          default:
            if (u === void 0) return d.text();
            {
              const v = /charset="?([^;"\s]*)"?/i.exec(u),
                _ = v && v[1] ? v[1].toLowerCase() : void 0,
                A = new TextDecoder(_);
              return d.arrayBuffer().then((M) => A.decode(M));
            }
        }
      })
      .then((d) => {
        _u.add(e, d);
        const m = hu[e];
        delete hu[e];
        for (let v = 0, _ = m.length; v < _; v++) {
          const A = m[v];
          A.onLoad && A.onLoad(d);
        }
      })
      .catch((d) => {
        const m = hu[e];
        if (m === void 0) throw (this.manager.itemError(e), d);
        delete hu[e];
        for (let v = 0, _ = m.length; v < _; v++) {
          const A = m[v];
          A.onError && A.onError(d);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class fB extends qa {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const a = this,
      l = new Ja(this.manager);
    l.setPath(this.path),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (u) {
          try {
            t(a.parse(JSON.parse(u)));
          } catch (f) {
            i ? i(f) : console.error(f), a.manager.itemError(e);
          }
        },
        n,
        i
      );
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const i = Bd.parse(e[n]);
      t.push(i);
    }
    return t;
  }
}
class hB extends qa {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const a = this,
      l = [],
      u = new Hy(),
      f = new Ja(this.manager);
    f.setPath(this.path),
      f.setResponseType("arraybuffer"),
      f.setRequestHeader(this.requestHeader),
      f.setWithCredentials(a.withCredentials);
    let d = 0;
    function m(v) {
      f.load(
        e[v],
        function (_) {
          const A = a.parse(_, !0);
          (l[v] = {
            width: A.width,
            height: A.height,
            format: A.format,
            mipmaps: A.mipmaps,
          }),
            (d += 1),
            d === 6 &&
              (A.mipmapCount === 1 && (u.minFilter = In),
              (u.image = l),
              (u.format = A.format),
              (u.needsUpdate = !0),
              t && t(u));
        },
        n,
        i
      );
    }
    if (Array.isArray(e)) for (let v = 0, _ = e.length; v < _; ++v) m(v);
    else
      f.load(
        e,
        function (v) {
          const _ = a.parse(v, !0);
          if (_.isCubemap) {
            const A = _.mipmaps.length / _.mipmapCount;
            for (let M = 0; M < A; M++) {
              l[M] = { mipmaps: [] };
              for (let T = 0; T < _.mipmapCount; T++)
                l[M].mipmaps.push(_.mipmaps[M * _.mipmapCount + T]),
                  (l[M].format = _.format),
                  (l[M].width = _.width),
                  (l[M].height = _.height);
            }
            u.image = l;
          } else
            (u.image.width = _.width),
              (u.image.height = _.height),
              (u.mipmaps = _.mipmaps);
          _.mipmapCount === 1 && (u.minFilter = In),
            (u.format = _.format),
            (u.needsUpdate = !0),
            t && t(u);
        },
        n,
        i
      );
    return u;
  }
}
class Gm extends qa {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const a = this,
      l = _u.get(e);
    if (l !== void 0)
      return (
        a.manager.itemStart(e),
        setTimeout(function () {
          t && t(l), a.manager.itemEnd(e);
        }, 0),
        l
      );
    const u = Lm("img");
    function f() {
      m(), _u.add(e, this), t && t(this), a.manager.itemEnd(e);
    }
    function d(v) {
      m(), i && i(v), a.manager.itemError(e), a.manager.itemEnd(e);
    }
    function m() {
      u.removeEventListener("load", f, !1),
        u.removeEventListener("error", d, !1);
    }
    return (
      u.addEventListener("load", f, !1),
      u.addEventListener("error", d, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (u.crossOrigin = this.crossOrigin),
      a.manager.itemStart(e),
      (u.src = e),
      u
    );
  }
}
class UT extends qa {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const a = new Wm();
    a.colorSpace = Wa;
    const l = new Gm(this.manager);
    l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
    let u = 0;
    function f(d) {
      l.load(
        e[d],
        function (m) {
          (a.images[d] = m), u++, u === 6 && ((a.needsUpdate = !0), t && t(a));
        },
        void 0,
        i
      );
    }
    for (let d = 0; d < e.length; ++d) f(d);
    return a;
  }
}
class _x extends qa {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const a = this,
      l = new Uo(),
      u = new Ja(this.manager);
    return (
      u.setResponseType("arraybuffer"),
      u.setRequestHeader(this.requestHeader),
      u.setPath(this.path),
      u.setWithCredentials(a.withCredentials),
      u.load(
        e,
        function (f) {
          let d;
          try {
            d = a.parse(f);
          } catch (m) {
            if (i !== void 0) i(m);
            else {
              console.error(m);
              return;
            }
          }
          d.image !== void 0
            ? (l.image = d.image)
            : d.data !== void 0 &&
              ((l.image.width = d.width),
              (l.image.height = d.height),
              (l.image.data = d.data)),
            (l.wrapS = d.wrapS !== void 0 ? d.wrapS : sa),
            (l.wrapT = d.wrapT !== void 0 ? d.wrapT : sa),
            (l.magFilter = d.magFilter !== void 0 ? d.magFilter : In),
            (l.minFilter = d.minFilter !== void 0 ? d.minFilter : In),
            (l.anisotropy = d.anisotropy !== void 0 ? d.anisotropy : 1),
            d.colorSpace !== void 0 && (l.colorSpace = d.colorSpace),
            d.flipY !== void 0 && (l.flipY = d.flipY),
            d.format !== void 0 && (l.format = d.format),
            d.type !== void 0 && (l.type = d.type),
            d.mipmaps !== void 0 &&
              ((l.mipmaps = d.mipmaps), (l.minFilter = ms)),
            d.mipmapCount === 1 && (l.minFilter = In),
            d.generateMipmaps !== void 0 &&
              (l.generateMipmaps = d.generateMipmaps),
            (l.needsUpdate = !0),
            t && t(l, d);
        },
        n,
        i
      ),
      l
    );
  }
}
class tg extends qa {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const a = new Wn(),
      l = new Gm(this.manager);
    return (
      l.setCrossOrigin(this.crossOrigin),
      l.setPath(this.path),
      l.load(
        e,
        function (u) {
          (a.image = u), (a.needsUpdate = !0), t !== void 0 && t(a);
        },
        n,
        i
      ),
      a
    );
  }
}
class Cc extends On {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Dt(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
class OT extends Cc {
  constructor(e, t, n) {
    super(e, n),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(On.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Dt(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const R1 = new Qt(),
  wM = new ie(),
  BM = new ie();
class Ax {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new at(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Qt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new jm()),
      (this._frameExtents = new at(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Hn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    wM.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(wM),
      BM.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(BM),
      t.updateMatrixWorld(),
      R1.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(R1),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(R1);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class dB extends Ax {
  constructor() {
    super(new $i(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      n = Cd * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      a = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || a !== t.far) &&
      ((t.fov = n), (t.aspect = i), (t.far = a), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class xx extends Cc {
  constructor(e, t, n = 0, i = Math.PI / 3, a = 0, l = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(On.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new On()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = a),
      (this.decay = l),
      (this.map = null),
      (this.shadow = new dB());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const DM = new Qt(),
  lm = new ie(),
  w1 = new ie();
class pB extends Ax {
  constructor() {
    super(new $i(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new at(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Hn(2, 1, 1, 1),
        new Hn(0, 1, 1, 1),
        new Hn(3, 1, 1, 1),
        new Hn(1, 1, 1, 1),
        new Hn(3, 0, 1, 1),
        new Hn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new ie(1, 0, 0),
        new ie(-1, 0, 0),
        new ie(0, 0, 1),
        new ie(0, 0, -1),
        new ie(0, 1, 0),
        new ie(0, -1, 0),
      ]),
      (this._cubeUps = [
        new ie(0, 1, 0),
        new ie(0, 1, 0),
        new ie(0, 1, 0),
        new ie(0, 1, 0),
        new ie(0, 0, 1),
        new ie(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      i = this.matrix,
      a = e.distance || n.far;
    a !== n.far && ((n.far = a), n.updateProjectionMatrix()),
      lm.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(lm),
      w1.copy(n.position),
      w1.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(w1),
      n.updateMatrixWorld(),
      i.makeTranslation(-lm.x, -lm.y, -lm.z),
      DM.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(DM);
  }
}
class Sx extends Cc {
  constructor(e, t, n = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new pB());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class Ps extends Iy {
  constructor(e = -1, t = 1, n = 1, i = -1, a = 0.1, l = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = a),
      (this.far = l),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, i, a, l) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = a),
      (this.view.height = l),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let a = n - e,
      l = n + e,
      u = i + t,
      f = i - t;
    if (this.view !== null && this.view.enabled) {
      const d = (this.right - this.left) / this.view.fullWidth / this.zoom,
        m = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (a += d * this.view.offsetX),
        (l = a + d * this.view.width),
        (u -= m * this.view.offsetY),
        (f = u - m * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      a,
      l,
      u,
      f,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
class mB extends Ax {
  constructor() {
    super(new Ps(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class Mx extends Cc {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(On.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new On()),
      (this.shadow = new mB());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class LT extends Cc {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class NT extends Cc {
  constructor(e, t, n = 10, i = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = n),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class IT {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new ie());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const n = e.x,
      i = e.y,
      a = e.z,
      l = this.coefficients;
    return (
      t.copy(l[0]).multiplyScalar(0.282095),
      t.addScaledVector(l[1], 0.488603 * i),
      t.addScaledVector(l[2], 0.488603 * a),
      t.addScaledVector(l[3], 0.488603 * n),
      t.addScaledVector(l[4], 1.092548 * (n * i)),
      t.addScaledVector(l[5], 1.092548 * (i * a)),
      t.addScaledVector(l[6], 0.315392 * (3 * a * a - 1)),
      t.addScaledVector(l[7], 1.092548 * (n * a)),
      t.addScaledVector(l[8], 0.546274 * (n * n - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const n = e.x,
      i = e.y,
      a = e.z,
      l = this.coefficients;
    return (
      t.copy(l[0]).multiplyScalar(0.886227),
      t.addScaledVector(l[1], 2 * 0.511664 * i),
      t.addScaledVector(l[2], 2 * 0.511664 * a),
      t.addScaledVector(l[3], 2 * 0.511664 * n),
      t.addScaledVector(l[4], 2 * 0.429043 * n * i),
      t.addScaledVector(l[5], 2 * 0.429043 * i * a),
      t.addScaledVector(l[6], 0.743125 * a * a - 0.247708),
      t.addScaledVector(l[7], 2 * 0.429043 * n * a),
      t.addScaledVector(l[8], 0.429043 * (n * n - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const n = e.x,
      i = e.y,
      a = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * a),
      (t[3] = 0.488603 * n),
      (t[4] = 1.092548 * n * i),
      (t[5] = 1.092548 * i * a),
      (t[6] = 0.315392 * (3 * a * a - 1)),
      (t[7] = 1.092548 * n * a),
      (t[8] = 0.546274 * (n * n - i * i));
  }
}
class FT extends Cc {
  constructor(e = new IT(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class r_ extends qa {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, n, i) {
    const a = this,
      l = new Ja(a.manager);
    l.setPath(a.path),
      l.setRequestHeader(a.requestHeader),
      l.setWithCredentials(a.withCredentials),
      l.load(
        e,
        function (u) {
          try {
            t(a.parse(JSON.parse(u)));
          } catch (f) {
            i ? i(f) : console.error(f), a.manager.itemError(e);
          }
        },
        n,
        i
      );
  }
  parse(e) {
    const t = this.textures;
    function n(a) {
      return (
        t[a] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", a),
        t[a]
      );
    }
    const i = this.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new Dt().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (i.dispersion = e.dispersion),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        i.blendColor !== void 0 &&
        i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const a in e.uniforms) {
        const l = e.uniforms[a];
        switch (((i.uniforms[a] = {}), l.type)) {
          case "t":
            i.uniforms[a].value = n(l.value);
            break;
          case "c":
            i.uniforms[a].value = new Dt().setHex(l.value);
            break;
          case "v2":
            i.uniforms[a].value = new at().fromArray(l.value);
            break;
          case "v3":
            i.uniforms[a].value = new ie().fromArray(l.value);
            break;
          case "v4":
            i.uniforms[a].value = new Hn().fromArray(l.value);
            break;
          case "m3":
            i.uniforms[a].value = new hn().fromArray(l.value);
            break;
          case "m4":
            i.uniforms[a].value = new Qt().fromArray(l.value);
            break;
          default:
            i.uniforms[a].value = l.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const a in e.extensions) i.extensions[a] = e.extensions[a];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = n(e.map)),
      e.matcap !== void 0 && (i.matcap = n(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let a = e.normalScale;
      Array.isArray(a) === !1 && (a = [a, a]),
        (i.normalScale = new at().fromArray(a));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = n(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = n(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = n(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = n(e.envMap)),
      e.envMapRotation !== void 0 &&
        i.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new at().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = n(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = n(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  createMaterialFromType(e) {
    return r_.createMaterialFromType(e);
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: yT,
      SpriteMaterial: rx,
      RawShaderMaterial: _T,
      ShaderMaterial: ra,
      PointsMaterial: zy,
      MeshPhysicalMaterial: Hs,
      MeshStandardMaterial: eg,
      MeshPhongMaterial: AT,
      MeshToonMaterial: xT,
      MeshNormalMaterial: ST,
      MeshLambertMaterial: MT,
      MeshDepthMaterial: n_,
      MeshDistanceMaterial: i_,
      MeshBasicMaterial: fr,
      MeshMatcapMaterial: bT,
      LineDashedMaterial: ET,
      LineBasicMaterial: dr,
      Material: _a,
    };
    return new t[e]();
  }
}
class _c {
  static decodeText(e) {
    if (
      (console.warn(
        "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
      ),
      typeof TextDecoder < "u")
    )
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class bx extends mn {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class PT extends qa {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const a = this,
      l = new Ja(a.manager);
    l.setPath(a.path),
      l.setRequestHeader(a.requestHeader),
      l.setWithCredentials(a.withCredentials),
      l.load(
        e,
        function (u) {
          try {
            t(a.parse(JSON.parse(u)));
          } catch (f) {
            i ? i(f) : console.error(f), a.manager.itemError(e);
          }
        },
        n,
        i
      );
  }
  parse(e) {
    const t = {},
      n = {};
    function i(A, M) {
      if (t[M] !== void 0) return t[M];
      const E = A.interleavedBuffers[M],
        b = a(A, E.buffer),
        w = md(E.type, b),
        D = new Jm(w, E.stride);
      return (D.uuid = E.uuid), (t[M] = D), D;
    }
    function a(A, M) {
      if (n[M] !== void 0) return n[M];
      const E = A.arrayBuffers[M],
        b = new Uint32Array(E).buffer;
      return (n[M] = b), b;
    }
    const l = e.isInstancedBufferGeometry ? new bx() : new mn(),
      u = e.data.index;
    if (u !== void 0) {
      const A = md(u.type, u.array);
      l.setIndex(new Yn(A, 1));
    }
    const f = e.data.attributes;
    for (const A in f) {
      const M = f[A];
      let T;
      if (M.isInterleavedBufferAttribute) {
        const E = i(e.data, M.data);
        T = new Mc(E, M.itemSize, M.offset, M.normalized);
      } else {
        const E = md(M.type, M.array),
          b = M.isInstancedBufferAttribute ? bc : Yn;
        T = new b(E, M.itemSize, M.normalized);
      }
      M.name !== void 0 && (T.name = M.name),
        M.usage !== void 0 && T.setUsage(M.usage),
        l.setAttribute(A, T);
    }
    const d = e.data.morphAttributes;
    if (d)
      for (const A in d) {
        const M = d[A],
          T = [];
        for (let E = 0, b = M.length; E < b; E++) {
          const w = M[E];
          let D;
          if (w.isInterleavedBufferAttribute) {
            const B = i(e.data, w.data);
            D = new Mc(B, w.itemSize, w.offset, w.normalized);
          } else {
            const B = md(w.type, w.array);
            D = new Yn(B, w.itemSize, w.normalized);
          }
          w.name !== void 0 && (D.name = w.name), T.push(D);
        }
        l.morphAttributes[A] = T;
      }
    e.data.morphTargetsRelative && (l.morphTargetsRelative = !0);
    const v = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (v !== void 0)
      for (let A = 0, M = v.length; A !== M; ++A) {
        const T = v[A];
        l.addGroup(T.start, T.count, T.materialIndex);
      }
    const _ = e.data.boundingSphere;
    if (_ !== void 0) {
      const A = new ie();
      _.center !== void 0 && A.fromArray(_.center),
        (l.boundingSphere = new Na(A, _.radius));
    }
    return (
      e.name && (l.name = e.name), e.userData && (l.userData = e.userData), l
    );
  }
}
class gB extends qa {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const a = this,
      l = this.path === "" ? _c.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || l;
    const u = new Ja(this.manager);
    u.setPath(this.path),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(this.withCredentials),
      u.load(
        e,
        function (f) {
          let d = null;
          try {
            d = JSON.parse(f);
          } catch (v) {
            i !== void 0 && i(v),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                v.message
              );
            return;
          }
          const m = d.metadata;
          if (
            m === void 0 ||
            m.type === void 0 ||
            m.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          a.parse(d, t);
        },
        n,
        i
      );
  }
  async loadAsync(e, t) {
    const n = this,
      i = this.path === "" ? _c.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const a = new Ja(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials);
    const l = await a.loadAsync(e, t),
      u = JSON.parse(l),
      f = u.metadata;
    if (
      f === void 0 ||
      f.type === void 0 ||
      f.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(u);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      a = this.parseGeometries(e.geometries, i),
      l = this.parseImages(e.images, function () {
        t !== void 0 && t(d);
      }),
      u = this.parseTextures(e.textures, l),
      f = this.parseMaterials(e.materials, u),
      d = this.parseObject(e.object, a, f, u, n),
      m = this.parseSkeletons(e.skeletons, d);
    if ((this.bindSkeletons(d, m), this.bindLightTargets(d), t !== void 0)) {
      let v = !1;
      for (const _ in l)
        if (l[_].data instanceof HTMLImageElement) {
          v = !0;
          break;
        }
      v === !1 && t(d);
    }
    return d;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      n = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, n),
      a = await this.parseImagesAsync(e.images),
      l = this.parseTextures(e.textures, a),
      u = this.parseMaterials(e.materials, l),
      f = this.parseObject(e.object, i, u, l, t),
      d = this.parseSkeletons(e.skeletons, f);
    return this.bindSkeletons(f, d), this.bindLightTargets(f), f;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, i = e.length; n < i; n++) {
        const a = new yc().fromJSON(e[n]);
        t[a.uuid] = a;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {},
      i = {};
    if (
      (t.traverse(function (a) {
        a.isBone && (i[a.uuid] = a);
      }),
      e !== void 0)
    )
      for (let a = 0, l = e.length; a < l; a++) {
        const u = new qm().fromJSON(e[a], i);
        n[u.uuid] = u;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const i = new PT();
      for (let a = 0, l = e.length; a < l; a++) {
        let u;
        const f = e[a];
        switch (f.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            u = i.parse(f);
            break;
          default:
            f.type in RM
              ? (u = RM[f.type].fromJSON(f, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${f.type}"`
                );
        }
        (u.uuid = f.uuid),
          f.name !== void 0 && (u.name = f.name),
          f.userData !== void 0 && (u.userData = f.userData),
          (n[f.uuid] = u);
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {},
      i = {};
    if (e !== void 0) {
      const a = new r_();
      a.setTextures(t);
      for (let l = 0, u = e.length; l < u; l++) {
        const f = e[l];
        n[f.uuid] === void 0 && (n[f.uuid] = a.parse(f)),
          (i[f.uuid] = n[f.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const i = e[n],
          a = Bd.parse(i);
        t[a.uuid] = a;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this,
      i = {};
    let a;
    function l(f) {
      return (
        n.manager.itemStart(f),
        a.load(
          f,
          function () {
            n.manager.itemEnd(f);
          },
          void 0,
          function () {
            n.manager.itemError(f), n.manager.itemEnd(f);
          }
        )
      );
    }
    function u(f) {
      if (typeof f == "string") {
        const d = f,
          m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
        return l(m);
      } else
        return f.data
          ? { data: md(f.type, f.data), width: f.width, height: f.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const f = new a_(t);
      (a = new Gm(f)), a.setCrossOrigin(this.crossOrigin);
      for (let d = 0, m = e.length; d < m; d++) {
        const v = e[d],
          _ = v.url;
        if (Array.isArray(_)) {
          const A = [];
          for (let M = 0, T = _.length; M < T; M++) {
            const E = _[M],
              b = u(E);
            b !== null &&
              (b instanceof HTMLImageElement
                ? A.push(b)
                : A.push(new Uo(b.data, b.width, b.height)));
          }
          i[v.uuid] = new If(A);
        } else {
          const A = u(v.url);
          i[v.uuid] = new If(A);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this,
      n = {};
    let i;
    async function a(l) {
      if (typeof l == "string") {
        const u = l,
          f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : t.resourcePath + u;
        return await i.loadAsync(f);
      } else
        return l.data
          ? { data: md(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new Gm(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let l = 0, u = e.length; l < u; l++) {
        const f = e[l],
          d = f.url;
        if (Array.isArray(d)) {
          const m = [];
          for (let v = 0, _ = d.length; v < _; v++) {
            const A = d[v],
              M = await a(A);
            M !== null &&
              (M instanceof HTMLImageElement
                ? m.push(M)
                : m.push(new Uo(M.data, M.width, M.height)));
          }
          n[f.uuid] = new If(m);
        } else {
          const m = await a(f.url);
          n[f.uuid] = new If(m);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(a, l) {
      return typeof a == "number"
        ? a
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            a
          ),
          l[a]);
    }
    const i = {};
    if (e !== void 0)
      for (let a = 0, l = e.length; a < l; a++) {
        const u = e[a];
        u.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', u.uuid),
          t[u.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", u.image);
        const f = t[u.image],
          d = f.data;
        let m;
        Array.isArray(d)
          ? ((m = new Wm()), d.length === 6 && (m.needsUpdate = !0))
          : (d && d.data ? (m = new Uo()) : (m = new Wn()),
            d && (m.needsUpdate = !0)),
          (m.source = f),
          (m.uuid = u.uuid),
          u.name !== void 0 && (m.name = u.name),
          u.mapping !== void 0 && (m.mapping = n(u.mapping, vB)),
          u.channel !== void 0 && (m.channel = u.channel),
          u.offset !== void 0 && m.offset.fromArray(u.offset),
          u.repeat !== void 0 && m.repeat.fromArray(u.repeat),
          u.center !== void 0 && m.center.fromArray(u.center),
          u.rotation !== void 0 && (m.rotation = u.rotation),
          u.wrap !== void 0 &&
            ((m.wrapS = n(u.wrap[0], UM)), (m.wrapT = n(u.wrap[1], UM))),
          u.format !== void 0 && (m.format = u.format),
          u.internalFormat !== void 0 && (m.internalFormat = u.internalFormat),
          u.type !== void 0 && (m.type = u.type),
          u.colorSpace !== void 0 && (m.colorSpace = u.colorSpace),
          u.minFilter !== void 0 && (m.minFilter = n(u.minFilter, OM)),
          u.magFilter !== void 0 && (m.magFilter = n(u.magFilter, OM)),
          u.anisotropy !== void 0 && (m.anisotropy = u.anisotropy),
          u.flipY !== void 0 && (m.flipY = u.flipY),
          u.generateMipmaps !== void 0 &&
            (m.generateMipmaps = u.generateMipmaps),
          u.premultiplyAlpha !== void 0 &&
            (m.premultiplyAlpha = u.premultiplyAlpha),
          u.unpackAlignment !== void 0 &&
            (m.unpackAlignment = u.unpackAlignment),
          u.compareFunction !== void 0 &&
            (m.compareFunction = u.compareFunction),
          u.userData !== void 0 && (m.userData = u.userData),
          (i[u.uuid] = m);
      }
    return i;
  }
  parseObject(e, t, n, i, a) {
    let l;
    function u(_) {
      return (
        t[_] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", _),
        t[_]
      );
    }
    function f(_) {
      if (_ !== void 0) {
        if (Array.isArray(_)) {
          const A = [];
          for (let M = 0, T = _.length; M < T; M++) {
            const E = _[M];
            n[E] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", E),
              A.push(n[E]);
          }
          return A;
        }
        return (
          n[_] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", _),
          n[_]
        );
      }
    }
    function d(_) {
      return (
        i[_] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", _),
        i[_]
      );
    }
    let m, v;
    switch (e.type) {
      case "Scene":
        (l = new Nd()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (l.background = new Dt(e.background))
              : (l.background = d(e.background))),
          e.environment !== void 0 && (l.environment = d(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (l.fog = new Py(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (l.fog = new Fy(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (l.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (l.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (l.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            l.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (l.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            l.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (l = new $i(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (l.focus = e.focus),
          e.zoom !== void 0 && (l.zoom = e.zoom),
          e.filmGauge !== void 0 && (l.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (l.filmOffset = e.filmOffset),
          e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (l = new Ps(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (l.zoom = e.zoom),
          e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        l = new LT(e.color, e.intensity);
        break;
      case "DirectionalLight":
        (l = new Mx(e.color, e.intensity)), (l.target = e.target || "");
        break;
      case "PointLight":
        l = new Sx(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        l = new NT(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        (l = new xx(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )),
          (l.target = e.target || "");
        break;
      case "HemisphereLight":
        l = new OT(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        l = new FT().fromJSON(e);
        break;
      case "SkinnedMesh":
        (m = u(e.geometry)),
          (v = f(e.material)),
          (l = new sx(m, v)),
          e.bindMode !== void 0 && (l.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && l.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (l.skeleton = e.skeleton);
        break;
      case "Mesh":
        (m = u(e.geometry)), (v = f(e.material)), (l = new li(m, v));
        break;
      case "InstancedMesh":
        (m = u(e.geometry)), (v = f(e.material));
        const _ = e.count,
          A = e.instanceMatrix,
          M = e.instanceColor;
        (l = new ox(m, v, _)),
          (l.instanceMatrix = new bc(new Float32Array(A.array), 16)),
          M !== void 0 &&
            (l.instanceColor = new bc(new Float32Array(M.array), M.itemSize));
        break;
      case "BatchedMesh":
        (m = u(e.geometry)),
          (v = f(e.material)),
          (l = new sT(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            v
          )),
          (l.geometry = m),
          (l.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (l.sortObjects = e.sortObjects),
          (l._drawRanges = e.drawRanges),
          (l._reservedRanges = e.reservedRanges),
          (l._visibility = e.visibility),
          (l._active = e.active),
          (l._bounds = e.bounds.map((T) => {
            const E = new ya();
            E.min.fromArray(T.boxMin), E.max.fromArray(T.boxMax);
            const b = new Na();
            return (
              (b.radius = T.sphereRadius),
              b.center.fromArray(T.sphereCenter),
              {
                boxInitialized: T.boxInitialized,
                box: E,
                sphereInitialized: T.sphereInitialized,
                sphere: b,
              }
            );
          })),
          (l._maxInstanceCount = e.maxInstanceCount),
          (l._maxVertexCount = e.maxVertexCount),
          (l._maxIndexCount = e.maxIndexCount),
          (l._geometryInitialized = e.geometryInitialized),
          (l._geometryCount = e.geometryCount),
          (l._matricesTexture = d(e.matricesTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (l._colorsTexture = d(e.colorsTexture.uuid));
        break;
      case "LOD":
        l = new rT();
        break;
      case "Line":
        l = new Su(u(e.geometry), f(e.material));
        break;
      case "LineLoop":
        l = new lx(u(e.geometry), f(e.material));
        break;
      case "LineSegments":
        l = new Lo(u(e.geometry), f(e.material));
        break;
      case "PointCloud":
      case "Points":
        l = new ux(u(e.geometry), f(e.material));
        break;
      case "Sprite":
        l = new aT(f(e.material));
        break;
      case "Group":
        l = new yu();
        break;
      case "Bone":
        l = new Gy();
        break;
      default:
        l = new On();
    }
    if (
      ((l.uuid = e.uuid),
      e.name !== void 0 && (l.name = e.name),
      e.matrix !== void 0
        ? (l.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (l.matrixAutoUpdate = e.matrixAutoUpdate),
          l.matrixAutoUpdate &&
            l.matrix.decompose(l.position, l.quaternion, l.scale))
        : (e.position !== void 0 && l.position.fromArray(e.position),
          e.rotation !== void 0 && l.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && l.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && l.scale.fromArray(e.scale)),
      e.up !== void 0 && l.up.fromArray(e.up),
      e.castShadow !== void 0 && (l.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (l.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (l.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (l.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (l.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (l.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          l.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (l.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (l.visible = e.visible),
      e.frustumCulled !== void 0 && (l.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (l.renderOrder = e.renderOrder),
      e.userData !== void 0 && (l.userData = e.userData),
      e.layers !== void 0 && (l.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const _ = e.children;
      for (let A = 0; A < _.length; A++)
        l.add(this.parseObject(_[A], t, n, i, a));
    }
    if (e.animations !== void 0) {
      const _ = e.animations;
      for (let A = 0; A < _.length; A++) {
        const M = _[A];
        l.animations.push(a[M]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (l.autoUpdate = e.autoUpdate);
      const _ = e.levels;
      for (let A = 0; A < _.length; A++) {
        const M = _[A],
          T = l.getObjectByProperty("uuid", M.object);
        T !== void 0 && l.addLevel(T, M.distance, M.hysteresis);
      }
    }
    return l;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (n) {
        if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
          const i = t[n.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                n.skeleton
              )
            : n.bind(i, n.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const n = t.target,
          i = e.getObjectByProperty("uuid", n);
        i !== void 0 ? (t.target = i) : (t.target = new On());
      }
    });
  }
}
const vB = {
    UVMapping: Ac,
    CubeReflectionMapping: Cl,
    CubeRefractionMapping: xc,
    EquirectangularReflectionMapping: Sd,
    EquirectangularRefractionMapping: wm,
    CubeUVReflectionMapping: Ld,
  },
  UM = {
    RepeatWrapping: Sc,
    ClampToEdgeWrapping: sa,
    MirroredRepeatWrapping: Md,
  },
  OM = {
    NearestFilter: Kn,
    NearestMipmapNearestFilter: Ey,
    NearestMipmapLinearFilter: Of,
    LinearFilter: In,
    LinearMipmapNearestFilter: yd,
    LinearMipmapLinearFilter: ms,
  };
class GT extends qa {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const a = this,
      l = _u.get(e);
    if (l !== void 0) {
      if ((a.manager.itemStart(e), l.then)) {
        l.then((d) => {
          t && t(d), a.manager.itemEnd(e);
        }).catch((d) => {
          i && i(d);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(l), a.manager.itemEnd(e);
        }, 0),
        l
      );
    }
    const u = {};
    (u.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (u.headers = this.requestHeader);
    const f = fetch(e, u)
      .then(function (d) {
        return d.blob();
      })
      .then(function (d) {
        return createImageBitmap(
          d,
          Object.assign(a.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (d) {
        return _u.add(e, d), t && t(d), a.manager.itemEnd(e), d;
      })
      .catch(function (d) {
        i && i(d), _u.remove(e), a.manager.itemError(e), a.manager.itemEnd(e);
      });
    _u.add(e, f), a.manager.itemStart(e);
  }
}
let r0;
class Ex {
  static getContext() {
    return (
      r0 === void 0 &&
        (r0 = new (window.AudioContext || window.webkitAudioContext)()),
      r0
    );
  }
  static setContext(e) {
    r0 = e;
  }
}
class yB extends qa {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const a = this,
      l = new Ja(this.manager);
    l.setResponseType("arraybuffer"),
      l.setPath(this.path),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (f) {
          try {
            const d = f.slice(0);
            Ex.getContext()
              .decodeAudioData(d, function (v) {
                t(v);
              })
              .catch(u);
          } catch (d) {
            u(d);
          }
        },
        n,
        i
      );
    function u(f) {
      i ? i(f) : console.error(f), a.manager.itemError(e);
    }
  }
}
const LM = new Qt(),
  NM = new Qt(),
  _f = new Qt();
class _B {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new $i()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new $i()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        _f.copy(e.projectionMatrix);
      const i = t.eyeSep / 2,
        a = (i * t.near) / t.focus,
        l = (t.near * Math.tan(kf * t.fov * 0.5)) / t.zoom;
      let u, f;
      (NM.elements[12] = -i),
        (LM.elements[12] = i),
        (u = -l * t.aspect + a),
        (f = l * t.aspect + a),
        (_f.elements[0] = (2 * t.near) / (f - u)),
        (_f.elements[8] = (f + u) / (f - u)),
        this.cameraL.projectionMatrix.copy(_f),
        (u = -l * t.aspect - a),
        (f = l * t.aspect - a),
        (_f.elements[0] = (2 * t.near) / (f - u)),
        (_f.elements[8] = (f + u) / (f - u)),
        this.cameraR.projectionMatrix.copy(_f);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(NM),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(LM);
  }
}
class zT extends $i {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e), (this.index = 0);
  }
}
class Tx {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = IM()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = IM();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function IM() {
  return performance.now();
}
const Af = new ie(),
  FM = new La(),
  AB = new ie(),
  xf = new ie();
class xB extends On {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = Ex.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new Tx());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      n = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Af, FM, AB),
      xf.set(0, 0, -1).applyQuaternion(FM),
      t.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Af.x, i),
        t.positionY.linearRampToValueAtTime(Af.y, i),
        t.positionZ.linearRampToValueAtTime(Af.z, i),
        t.forwardX.linearRampToValueAtTime(xf.x, i),
        t.forwardY.linearRampToValueAtTime(xf.y, i),
        t.forwardZ.linearRampToValueAtTime(xf.z, i),
        t.upX.linearRampToValueAtTime(n.x, i),
        t.upY.linearRampToValueAtTime(n.y, i),
        t.upZ.linearRampToValueAtTime(n.z, i);
    } else
      t.setPosition(Af.x, Af.y, Af.z),
        t.setOrientation(xf.x, xf.y, xf.z, n.x, n.y, n.z);
  }
}
class HT extends On {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(this.context.currentTime + e),
        (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    (this.isPlaying = !1), (this._progress = 0);
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.sourceType !== "buffer"
        ? (console.warn("THREE.Audio: Audio source type cannot be copied."),
          this)
        : ((this.autoplay = e.autoplay),
          (this.buffer = e.buffer),
          (this.detune = e.detune),
          (this.loop = e.loop),
          (this.loopStart = e.loopStart),
          (this.loopEnd = e.loopEnd),
          (this.offset = e.offset),
          (this.duration = e.duration),
          (this.playbackRate = e.playbackRate),
          (this.hasPlaybackControl = e.hasPlaybackControl),
          (this.sourceType = e.sourceType),
          (this.filters = e.filters.slice()),
          this)
    );
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
const Sf = new ie(),
  PM = new La(),
  SB = new ie(),
  Mf = new ie();
class MB extends HT {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, n) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = n),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(Sf, PM, SB), Mf.set(0, 0, 1).applyQuaternion(PM);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Sf.x, n),
        t.positionY.linearRampToValueAtTime(Sf.y, n),
        t.positionZ.linearRampToValueAtTime(Sf.z, n),
        t.orientationX.linearRampToValueAtTime(Mf.x, n),
        t.orientationY.linearRampToValueAtTime(Mf.y, n),
        t.orientationZ.linearRampToValueAtTime(Mf.z, n);
    } else t.setPosition(Sf.x, Sf.y, Sf.z), t.setOrientation(Mf.x, Mf.y, Mf.z);
  }
}
class bB {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++) e += t[n];
    return e / t.length;
  }
}
class VT {
  constructor(e, t, n) {
    (this.binding = e), (this.valueSize = n);
    let i, a, l;
    switch (t) {
      case "quaternion":
        (i = this._slerp),
          (a = this._slerpAdditive),
          (l = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(n * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (a = this._select),
          (l = this._setAdditiveIdentityOther),
          (this.buffer = new Array(n * 5));
        break;
      default:
        (i = this._lerp),
          (a = this._lerpAdditive),
          (l = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(n * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = a),
      (this._setIdentity = l),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const n = this.buffer,
      i = this.valueSize,
      a = e * i + i;
    let l = this.cumulativeWeight;
    if (l === 0) {
      for (let u = 0; u !== i; ++u) n[a + u] = n[u];
      l = t;
    } else {
      l += t;
      const u = t / l;
      this._mixBufferRegion(n, a, 0, u, i);
    }
    this.cumulativeWeight = l;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      n = this.valueSize,
      i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, n),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      n = this.buffer,
      i = e * t + t,
      a = this.cumulativeWeight,
      l = this.cumulativeWeightAdditive,
      u = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), a < 1)
    ) {
      const f = t * this._origIndex;
      this._mixBufferRegion(n, i, f, 1 - a, t);
    }
    l > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let f = t, d = t + t; f !== d; ++f)
      if (n[f] !== n[f + t]) {
        u.setValue(n, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      n = this.valueSize,
      i = n * this._origIndex;
    e.getValue(t, i);
    for (let a = n, l = i; a !== l; ++a) t[a] = t[i + (a % n)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let n = e; n < t; n++) this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  _select(e, t, n, i, a) {
    if (i >= 0.5) for (let l = 0; l !== a; ++l) e[t + l] = e[n + l];
  }
  _slerp(e, t, n, i) {
    La.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, a) {
    const l = this._workIndex * a;
    La.multiplyQuaternionsFlat(e, l, e, t, e, n),
      La.slerpFlat(e, t, e, t, e, l, i);
  }
  _lerp(e, t, n, i, a) {
    const l = 1 - i;
    for (let u = 0; u !== a; ++u) {
      const f = t + u;
      e[f] = e[f] * l + e[n + u] * i;
    }
  }
  _lerpAdditive(e, t, n, i, a) {
    for (let l = 0; l !== a; ++l) {
      const u = t + l;
      e[u] = e[u] + e[n + l] * i;
    }
  }
}
const Cx = "\\[\\]\\.:\\/",
  EB = new RegExp("[" + Cx + "]", "g"),
  Rx = "[^" + Cx + "]",
  TB = "[^" + Cx.replace("\\.", "") + "]",
  CB = /((?:WC+[\/:])*)/.source.replace("WC", Rx),
  RB = /(WCOD+)?/.source.replace("WCOD", TB),
  wB = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Rx),
  BB = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Rx),
  DB = new RegExp("^" + CB + RB + wB + BB + "$"),
  UB = ["material", "materials", "bones", "map"];
class OB {
  constructor(e, t, n) {
    const i = n || Xn.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, a = n.length; i !== a; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Xn {
  constructor(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || Xn.parseTrackName(t)),
      (this.node = Xn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup
      ? new Xn.Composite(e, t, n)
      : new Xn(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(EB, "");
  }
  static parseTrackName(e) {
    const t = DB.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const a = n.nodeName.substring(i + 1);
      UB.indexOf(a) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = a));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return n;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0) return n;
    }
    if (e.children) {
      const n = function (a) {
          for (let l = 0; l < a.length; l++) {
            const u = a[l];
            if (u.name === t || u.uuid === t) return u;
            const f = n(u.children);
            if (f) return f;
          }
          return null;
        },
        i = n(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, a = n.length; i !== a; ++i) e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, a = n.length; i !== a; ++i) n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, a = n.length; i !== a; ++i) n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, a = n.length; i !== a; ++i) n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      i = t.propertyName;
    let a = t.propertyIndex;
    if (
      (e || ((e = Xn.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (n) {
      let d = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let m = 0; m < e.length; m++)
            if (e[m].name === d) {
              d = m;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[n];
      }
      if (d !== void 0) {
        if (e[d] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[d];
      }
    }
    const l = e[i];
    if (l === void 0) {
      const d = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          d +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let u = this.Versioning.None;
    (this.targetObject = e),
      e.isMaterial === !0
        ? (u = this.Versioning.NeedsUpdate)
        : e.isObject3D === !0 && (u = this.Versioning.MatrixWorldNeedsUpdate);
    let f = this.BindingType.Direct;
    if (a !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[a] !== void 0 &&
          (a = e.morphTargetDictionary[a]);
      }
      (f = this.BindingType.ArrayElement),
        (this.resolvedProperty = l),
        (this.propertyIndex = a);
    } else
      l.fromArray !== void 0 && l.toArray !== void 0
        ? ((f = this.BindingType.HasFromToArray), (this.resolvedProperty = l))
        : Array.isArray(l)
        ? ((f = this.BindingType.EntireArray), (this.resolvedProperty = l))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[f]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[f][u]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Xn.Composite = OB;
Xn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Xn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Xn.prototype.GetterByBindingType = [
  Xn.prototype._getValue_direct,
  Xn.prototype._getValue_array,
  Xn.prototype._getValue_arrayElement,
  Xn.prototype._getValue_toArray,
];
Xn.prototype.SetterByBindingTypeAndVersioning = [
  [
    Xn.prototype._setValue_direct,
    Xn.prototype._setValue_direct_setNeedsUpdate,
    Xn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Xn.prototype._setValue_array,
    Xn.prototype._setValue_array_setNeedsUpdate,
    Xn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Xn.prototype._setValue_arrayElement,
    Xn.prototype._setValue_arrayElement_setNeedsUpdate,
    Xn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Xn.prototype._setValue_fromArray,
    Xn.prototype._setValue_fromArray_setNeedsUpdate,
    Xn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class LB {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = gs()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, i = arguments.length; n !== i; ++n)
      e[arguments[n].uuid] = n;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._paths,
      i = this._parsedPaths,
      a = this._bindings,
      l = a.length;
    let u,
      f = e.length,
      d = this.nCachedObjects_;
    for (let m = 0, v = arguments.length; m !== v; ++m) {
      const _ = arguments[m],
        A = _.uuid;
      let M = t[A];
      if (M === void 0) {
        (M = f++), (t[A] = M), e.push(_);
        for (let T = 0, E = l; T !== E; ++T) a[T].push(new Xn(_, n[T], i[T]));
      } else if (M < d) {
        u = e[M];
        const T = --d,
          E = e[T];
        (t[E.uuid] = M), (e[M] = E), (t[A] = T), (e[T] = _);
        for (let b = 0, w = l; b !== w; ++b) {
          const D = a[b],
            B = D[T];
          let I = D[M];
          (D[M] = B), I === void 0 && (I = new Xn(_, n[b], i[b])), (D[T] = I);
        }
      } else
        e[M] !== u &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = d;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._bindings,
      i = n.length;
    let a = this.nCachedObjects_;
    for (let l = 0, u = arguments.length; l !== u; ++l) {
      const f = arguments[l],
        d = f.uuid,
        m = t[d];
      if (m !== void 0 && m >= a) {
        const v = a++,
          _ = e[v];
        (t[_.uuid] = m), (e[m] = _), (t[d] = v), (e[v] = f);
        for (let A = 0, M = i; A !== M; ++A) {
          const T = n[A],
            E = T[v],
            b = T[m];
          (T[m] = E), (T[v] = b);
        }
      }
    }
    this.nCachedObjects_ = a;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._bindings,
      i = n.length;
    let a = this.nCachedObjects_,
      l = e.length;
    for (let u = 0, f = arguments.length; u !== f; ++u) {
      const d = arguments[u],
        m = d.uuid,
        v = t[m];
      if (v !== void 0)
        if ((delete t[m], v < a)) {
          const _ = --a,
            A = e[_],
            M = --l,
            T = e[M];
          (t[A.uuid] = v), (e[v] = A), (t[T.uuid] = _), (e[_] = T), e.pop();
          for (let E = 0, b = i; E !== b; ++E) {
            const w = n[E],
              D = w[_],
              B = w[M];
            (w[v] = D), (w[_] = B), w.pop();
          }
        } else {
          const _ = --l,
            A = e[_];
          _ > 0 && (t[A.uuid] = v), (e[v] = A), e.pop();
          for (let M = 0, T = i; M !== T; ++M) {
            const E = n[M];
            (E[v] = E[_]), E.pop();
          }
        }
    }
    this.nCachedObjects_ = a;
  }
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let i = n[e];
    const a = this._bindings;
    if (i !== void 0) return a[i];
    const l = this._paths,
      u = this._parsedPaths,
      f = this._objects,
      d = f.length,
      m = this.nCachedObjects_,
      v = new Array(d);
    (i = a.length), (n[e] = i), l.push(e), u.push(t), a.push(v);
    for (let _ = m, A = f.length; _ !== A; ++_) {
      const M = f[_];
      v[_] = new Xn(M, e, t);
    }
    return v;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      n = t[e];
    if (n !== void 0) {
      const i = this._paths,
        a = this._parsedPaths,
        l = this._bindings,
        u = l.length - 1,
        f = l[u],
        d = e[u];
      (t[d] = n),
        (l[n] = f),
        l.pop(),
        (a[n] = a[u]),
        a.pop(),
        (i[n] = i[u]),
        i.pop();
    }
  }
}
class kT {
  constructor(e, t, n = null, i = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = n),
      (this.blendMode = i);
    const a = t.tracks,
      l = a.length,
      u = new Array(l),
      f = { endingStart: Lf, endingEnd: Lf };
    for (let d = 0; d !== l; ++d) {
      const m = a[d].createInterpolant(null);
      (u[d] = m), (m.settings = f);
    }
    (this._interpolantSettings = f),
      (this._interpolants = u),
      (this._propertyBindings = new Array(l)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = GE),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if ((e.fadeOut(t), this.fadeIn(t), n)) {
      const i = this._clip.duration,
        a = e._clip.duration,
        l = a / i,
        u = i / a;
      e.warp(1, l, t), this.warp(u, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer,
      a = i.time,
      l = this.timeScale;
    let u = this._timeScaleInterpolant;
    u === null &&
      ((u = i._lendControlInterpolant()), (this._timeScaleInterpolant = u));
    const f = u.parameterPositions,
      d = u.sampleValues;
    return (f[0] = a), (f[1] = a + n), (d[0] = e / l), (d[1] = t / l), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const a = this._startTime;
    if (a !== null) {
      const f = (e - a) * n;
      f < 0 || n === 0 ? (t = 0) : ((this._startTime = null), (t = n * f));
    }
    t *= this._updateTimeScale(e);
    const l = this._updateTime(t),
      u = this._updateWeight(e);
    if (u > 0) {
      const f = this._interpolants,
        d = this._propertyBindings;
      switch (this.blendMode) {
        case KA:
          for (let m = 0, v = f.length; m !== v; ++m)
            f[m].evaluate(l), d[m].accumulateAdditive(u);
          break;
        case Uy:
        default:
          for (let m = 0, v = f.length; m !== v; ++m)
            f[m].evaluate(l), d[m].accumulate(i, u);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        (t *= i),
          e > n.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        (t *= i),
          e > n.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      n = this.loop;
    let i = this.time + e,
      a = this._loopCount;
    const l = n === zE;
    if (e === 0) return a === -1 ? i : l && (a & 1) === 1 ? t - i : i;
    if (n === PE) {
      a === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (a === -1 &&
          (e >= 0
            ? ((a = 0), this._setEndings(!0, this.repetitions === 0, l))
            : this._setEndings(this.repetitions === 0, !0, l)),
        i >= t || i < 0)
      ) {
        const u = Math.floor(i / t);
        (i -= t * u), (a += Math.abs(u));
        const f = this.repetitions - a;
        if (f <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (f === 1) {
            const d = e < 0;
            this._setEndings(d, !d, l);
          } else this._setEndings(!1, !1, l);
          (this._loopCount = a),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: u,
            });
        }
      } else this.time = i;
      if (l && (a & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n
      ? ((i.endingStart = Nf), (i.endingEnd = Nf))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? Nf : Lf)
          : (i.endingStart = Bm),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? Nf : Lf) : (i.endingEnd = Bm));
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer,
      a = i.time;
    let l = this._weightInterpolant;
    l === null &&
      ((l = i._lendControlInterpolant()), (this._weightInterpolant = l));
    const u = l.parameterPositions,
      f = l.sampleValues;
    return (u[0] = a), (f[0] = t), (u[1] = a + e), (f[1] = n), this;
  }
}
const NB = new Float32Array(1);
class IB extends wl {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root,
      i = e._clip.tracks,
      a = i.length,
      l = e._propertyBindings,
      u = e._interpolants,
      f = n.uuid,
      d = this._bindingsByRootAndName;
    let m = d[f];
    m === void 0 && ((m = {}), (d[f] = m));
    for (let v = 0; v !== a; ++v) {
      const _ = i[v],
        A = _.name;
      let M = m[A];
      if (M !== void 0) ++M.referenceCount, (l[v] = M);
      else {
        if (((M = l[v]), M !== void 0)) {
          M._cacheIndex === null &&
            (++M.referenceCount, this._addInactiveBinding(M, f, A));
          continue;
        }
        const T = t && t._propertyBindings[v].binding.parsedPath;
        (M = new VT(Xn.create(n, A, T), _.ValueTypeName, _.getValueSize())),
          ++M.referenceCount,
          this._addInactiveBinding(M, f, A),
          (l[v] = M);
      }
      u[v].resultBuffer = M.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          a = this._actionsByClip[i];
        this._bindAction(e, a && a.knownActions[0]),
          this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const a = t[n];
        a.useCount++ === 0 && (this._lendBinding(a), a.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const a = t[n];
        --a.useCount === 0 &&
          (a.restoreOriginalState(), this._takeBackBinding(a));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions,
      a = this._actionsByClip;
    let l = a[t];
    if (l === void 0)
      (l = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (a[t] = l);
    else {
      const u = l.knownActions;
      (e._byClipCacheIndex = u.length), u.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (l.actionByRoot[n] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      n = t[t.length - 1],
      i = e._cacheIndex;
    (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
    const a = e._clip.uuid,
      l = this._actionsByClip,
      u = l[a],
      f = u.knownActions,
      d = f[f.length - 1],
      m = e._byClipCacheIndex;
    (d._byClipCacheIndex = m),
      (f[m] = d),
      f.pop(),
      (e._byClipCacheIndex = null);
    const v = u.actionByRoot,
      _ = (e._localRoot || this._root).uuid;
    delete v[_],
      f.length === 0 && delete l[a],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const a = t[n];
      --a.referenceCount === 0 && this._removeInactiveBinding(a);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      i = this._nActiveActions++,
      a = t[i];
    (e._cacheIndex = i), (t[i] = e), (a._cacheIndex = n), (t[n] = a);
  }
  _takeBackAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      i = --this._nActiveActions,
      a = t[i];
    (e._cacheIndex = i), (t[i] = e), (a._cacheIndex = n), (t[n] = a);
  }
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName,
      a = this._bindings;
    let l = i[t];
    l === void 0 && ((l = {}), (i[t] = l)),
      (l[n] = e),
      (e._cacheIndex = a.length),
      a.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      n = e.binding,
      i = n.rootNode.uuid,
      a = n.path,
      l = this._bindingsByRootAndName,
      u = l[i],
      f = t[t.length - 1],
      d = e._cacheIndex;
    (f._cacheIndex = d),
      (t[d] = f),
      t.pop(),
      delete u[a],
      Object.keys(u).length === 0 && delete l[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      i = this._nActiveBindings++,
      a = t[i];
    (e._cacheIndex = i), (t[i] = e), (a._cacheIndex = n), (t[n] = a);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      i = --this._nActiveBindings,
      a = t[i];
    (e._cacheIndex = i), (t[i] = e), (a._cacheIndex = n), (t[n] = a);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let n = e[t];
    return (
      n === void 0 &&
        ((n = new vx(new Float32Array(2), new Float32Array(2), 1, NB)),
        (n.__cacheIndex = t),
        (e[t] = n)),
      n
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      n = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      a = t[i];
    (e.__cacheIndex = i), (t[i] = e), (a.__cacheIndex = n), (t[n] = a);
  }
  clipAction(e, t, n) {
    const i = t || this._root,
      a = i.uuid;
    let l = typeof e == "string" ? Bd.findByName(i, e) : e;
    const u = l !== null ? l.uuid : e,
      f = this._actionsByClip[u];
    let d = null;
    if (
      (n === void 0 && (l !== null ? (n = l.blendMode) : (n = Uy)),
      f !== void 0)
    ) {
      const v = f.actionByRoot[a];
      if (v !== void 0 && v.blendMode === n) return v;
      (d = f.knownActions[0]), l === null && (l = d._clip);
    }
    if (l === null) return null;
    const m = new kT(this, l, t, n);
    return this._bindAction(m, d), this._addInactiveAction(m, u, a), m;
  }
  existingAction(e, t) {
    const n = t || this._root,
      i = n.uuid,
      a = typeof e == "string" ? Bd.findByName(n, e) : e,
      l = a ? a.uuid : e,
      u = this._actionsByClip[l];
    return (u !== void 0 && u.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n) e[n].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      n = this._nActiveActions,
      i = (this.time += e),
      a = Math.sign(e),
      l = (this._accuIndex ^= 1);
    for (let d = 0; d !== n; ++d) t[d]._update(i, e, a, l);
    const u = this._bindings,
      f = this._nActiveBindings;
    for (let d = 0; d !== f; ++d) u[d].apply(l);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      n = e.uuid,
      i = this._actionsByClip,
      a = i[n];
    if (a !== void 0) {
      const l = a.knownActions;
      for (let u = 0, f = l.length; u !== f; ++u) {
        const d = l[u];
        this._deactivateAction(d);
        const m = d._cacheIndex,
          v = t[t.length - 1];
        (d._cacheIndex = null),
          (d._byClipCacheIndex = null),
          (v._cacheIndex = m),
          (t[m] = v),
          t.pop(),
          this._removeInactiveBindingsForAction(d);
      }
      delete i[n];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      n = this._actionsByClip;
    for (const l in n) {
      const u = n[l].actionByRoot,
        f = u[t];
      f !== void 0 &&
        (this._deactivateAction(f), this._removeInactiveAction(f));
    }
    const i = this._bindingsByRootAndName,
      a = i[t];
    if (a !== void 0)
      for (const l in a) {
        const u = a[l];
        u.restoreOriginalState(), this._removeInactiveBinding(u);
      }
  }
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class FB extends Oy {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i),
      (this.isRenderTarget3D = !0),
      (this.depth = n),
      (this.texture = new Ly(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class PB extends Oy {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i),
      (this.isRenderTargetArray = !0),
      (this.depth = n),
      (this.texture = new Ym(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class s_ {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new s_(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let GB = 0;
class zB extends wl {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: GB++ }),
      (this.name = ""),
      (this.usage = Um),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, i = t.length; n < i; n++) {
      const a = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let l = 0; l < a.length; l++) this.uniforms.push(a[l].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class HB extends Jm {
  constructor(e, t, n = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = n);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class VB {
  constructor(e, t, n, i, a) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = n),
      (this.elementSize = i),
      (this.count = a),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const GM = new Qt();
class wx {
  constructor(e, t, n = 0, i = 1 / 0) {
    (this.ray = new $f(e, t)),
      (this.near = n),
      (this.far = i),
      (this.camera = null),
      (this.layers = new Rd()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      GM.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(GM),
      this
    );
  }
  intersectObject(e, t = !0, n = []) {
    return MA(e, this, n, t), n.sort(zM), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, a = e.length; i < a; i++) MA(e[i], this, n, t);
    return n.sort(zM), n;
  }
}
function zM(s, e) {
  return s.distance - e.distance;
}
function MA(s, e, t, n) {
  let i = !0;
  if (
    (s.layers.test(e.layers) && s.raycast(e, t) === !1 && (i = !1),
    i === !0 && n === !0)
  ) {
    const a = s.children;
    for (let l = 0, u = a.length; l < u; l++) MA(a[l], e, t, !0);
  }
}
class bA {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (this.phi = dn(this.phi, 1e-6, Math.PI - 1e-6)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, n)),
          (this.phi = Math.acos(dn(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class kB {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.theta = t), (this.y = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.theta = t), (this.y = n), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + n * n)),
      (this.theta = Math.atan2(e, n)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Bx {
  constructor(e, t, n, i) {
    (Bx.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 4; n++) this.elements[n] = e[n + t];
    return this;
  }
  set(e, t, n, i) {
    const a = this.elements;
    return (a[0] = e), (a[2] = t), (a[1] = n), (a[3] = i), this;
  }
}
const HM = new at();
class XB {
  constructor(e = new at(1 / 0, 1 / 0), t = new at(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = HM.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, HM).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const VM = new ie(),
  s0 = new ie();
class YB {
  constructor(e = new ie(), t = new ie()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    VM.subVectors(e, this.start), s0.subVectors(this.end, this.start);
    const n = s0.dot(s0);
    let a = s0.dot(VM) / n;
    return t && (a = dn(a, 0, 1)), a;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const kM = new ie();
class WB extends On {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const n = new mn(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let l = 0, u = 1, f = 32; l < f; l++, u++) {
      const d = (l / f) * Math.PI * 2,
        m = (u / f) * Math.PI * 2;
      i.push(Math.cos(d), Math.sin(d), 1, Math.cos(m), Math.sin(m), 1);
    }
    n.setAttribute("position", new Yt(i, 3));
    const a = new dr({ fog: !1, toneMapped: !1 });
    (this.cone = new Lo(n, a)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      kM.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(kM),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const hc = new ie(),
  o0 = new Qt(),
  B1 = new Qt();
class JB extends Lo {
  constructor(e) {
    const t = XT(e),
      n = new mn(),
      i = [],
      a = [],
      l = new Dt(0, 0, 1),
      u = new Dt(0, 1, 0);
    for (let d = 0; d < t.length; d++) {
      const m = t[d];
      m.parent &&
        m.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        a.push(l.r, l.g, l.b),
        a.push(u.r, u.g, u.b));
    }
    n.setAttribute("position", new Yt(i, 3)),
      n.setAttribute("color", new Yt(a, 3));
    const f = new dr({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(n, f),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      n = this.geometry,
      i = n.getAttribute("position");
    B1.copy(this.root.matrixWorld).invert();
    for (let a = 0, l = 0; a < t.length; a++) {
      const u = t[a];
      u.parent &&
        u.parent.isBone &&
        (o0.multiplyMatrices(B1, u.matrixWorld),
        hc.setFromMatrixPosition(o0),
        i.setXYZ(l, hc.x, hc.y, hc.z),
        o0.multiplyMatrices(B1, u.parent.matrixWorld),
        hc.setFromMatrixPosition(o0),
        i.setXYZ(l + 1, hc.x, hc.y, hc.z),
        (l += 2));
    }
    (n.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function XT(s) {
  const e = [];
  s.isBone === !0 && e.push(s);
  for (let t = 0; t < s.children.length; t++)
    e.push.apply(e, XT(s.children[t]));
  return e;
}
class qB extends li {
  constructor(e, t, n) {
    const i = new $m(t, 4, 2),
      a = new fr({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, a),
      (this.light = e),
      (this.color = n),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const jB = new ie(),
  XM = new Dt(),
  YM = new Dt();
class KB extends On {
  constructor(e, t, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "HemisphereLightHelper");
    const i = new Qm(t);
    i.rotateY(Math.PI * 0.5),
      (this.material = new fr({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const a = i.getAttribute("position"),
      l = new Float32Array(a.count * 3);
    i.setAttribute("color", new Yn(l, 3)),
      this.add(new li(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      XM.copy(this.light.color), YM.copy(this.light.groundColor);
      for (let n = 0, i = t.count; n < i; n++) {
        const a = n < i / 2 ? XM : YM;
        t.setXYZ(n, a.r, a.g, a.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(jB.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class ZB extends Lo {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    (n = new Dt(n)), (i = new Dt(i));
    const a = t / 2,
      l = e / t,
      u = e / 2,
      f = [],
      d = [];
    for (let _ = 0, A = 0, M = -u; _ <= t; _++, M += l) {
      f.push(-u, 0, M, u, 0, M), f.push(M, 0, -u, M, 0, u);
      const T = _ === a ? n : i;
      T.toArray(d, A),
        (A += 3),
        T.toArray(d, A),
        (A += 3),
        T.toArray(d, A),
        (A += 3),
        T.toArray(d, A),
        (A += 3);
    }
    const m = new mn();
    m.setAttribute("position", new Yt(f, 3)),
      m.setAttribute("color", new Yt(d, 3));
    const v = new dr({ vertexColors: !0, toneMapped: !1 });
    super(m, v), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class QB extends Lo {
  constructor(e = 10, t = 16, n = 8, i = 64, a = 4473924, l = 8947848) {
    (a = new Dt(a)), (l = new Dt(l));
    const u = [],
      f = [];
    if (t > 1)
      for (let v = 0; v < t; v++) {
        const _ = (v / t) * (Math.PI * 2),
          A = Math.sin(_) * e,
          M = Math.cos(_) * e;
        u.push(0, 0, 0), u.push(A, 0, M);
        const T = v & 1 ? a : l;
        f.push(T.r, T.g, T.b), f.push(T.r, T.g, T.b);
      }
    for (let v = 0; v < n; v++) {
      const _ = v & 1 ? a : l,
        A = e - (e / n) * v;
      for (let M = 0; M < i; M++) {
        let T = (M / i) * (Math.PI * 2),
          E = Math.sin(T) * A,
          b = Math.cos(T) * A;
        u.push(E, 0, b),
          f.push(_.r, _.g, _.b),
          (T = ((M + 1) / i) * (Math.PI * 2)),
          (E = Math.sin(T) * A),
          (b = Math.cos(T) * A),
          u.push(E, 0, b),
          f.push(_.r, _.g, _.b);
      }
    }
    const d = new mn();
    d.setAttribute("position", new Yt(u, 3)),
      d.setAttribute("color", new Yt(f, 3));
    const m = new dr({ vertexColors: !0, toneMapped: !1 });
    super(d, m), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const WM = new ie(),
  l0 = new ie(),
  JM = new ie();
class $B extends On {
  constructor(e, t, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let i = new mn();
    i.setAttribute(
      "position",
      new Yt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const a = new dr({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Su(i, a)),
      this.add(this.lightPlane),
      (i = new mn()),
      i.setAttribute("position", new Yt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Su(i, a)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      WM.setFromMatrixPosition(this.light.matrixWorld),
      l0.setFromMatrixPosition(this.light.target.matrixWorld),
      JM.subVectors(l0, WM),
      this.lightPlane.lookAt(l0),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(l0),
      (this.targetLine.scale.z = JM.length());
  }
}
const u0 = new ie(),
  Qi = new Iy();
class eD extends Lo {
  constructor(e) {
    const t = new mn(),
      n = new dr({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      a = [],
      l = {};
    u("n1", "n2"),
      u("n2", "n4"),
      u("n4", "n3"),
      u("n3", "n1"),
      u("f1", "f2"),
      u("f2", "f4"),
      u("f4", "f3"),
      u("f3", "f1"),
      u("n1", "f1"),
      u("n2", "f2"),
      u("n3", "f3"),
      u("n4", "f4"),
      u("p", "n1"),
      u("p", "n2"),
      u("p", "n3"),
      u("p", "n4"),
      u("u1", "u2"),
      u("u2", "u3"),
      u("u3", "u1"),
      u("c", "t"),
      u("p", "c"),
      u("cn1", "cn2"),
      u("cn3", "cn4"),
      u("cf1", "cf2"),
      u("cf3", "cf4");
    function u(M, T) {
      f(M), f(T);
    }
    function f(M) {
      i.push(0, 0, 0),
        a.push(0, 0, 0),
        l[M] === void 0 && (l[M] = []),
        l[M].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Yt(i, 3)),
      t.setAttribute("color", new Yt(a, 3)),
      super(t, n),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = l),
      this.update();
    const d = new Dt(16755200),
      m = new Dt(16711680),
      v = new Dt(43775),
      _ = new Dt(16777215),
      A = new Dt(3355443);
    this.setColors(d, m, v, _, A);
  }
  setColors(e, t, n, i, a) {
    const u = this.geometry.getAttribute("color");
    u.setXYZ(0, e.r, e.g, e.b),
      u.setXYZ(1, e.r, e.g, e.b),
      u.setXYZ(2, e.r, e.g, e.b),
      u.setXYZ(3, e.r, e.g, e.b),
      u.setXYZ(4, e.r, e.g, e.b),
      u.setXYZ(5, e.r, e.g, e.b),
      u.setXYZ(6, e.r, e.g, e.b),
      u.setXYZ(7, e.r, e.g, e.b),
      u.setXYZ(8, e.r, e.g, e.b),
      u.setXYZ(9, e.r, e.g, e.b),
      u.setXYZ(10, e.r, e.g, e.b),
      u.setXYZ(11, e.r, e.g, e.b),
      u.setXYZ(12, e.r, e.g, e.b),
      u.setXYZ(13, e.r, e.g, e.b),
      u.setXYZ(14, e.r, e.g, e.b),
      u.setXYZ(15, e.r, e.g, e.b),
      u.setXYZ(16, e.r, e.g, e.b),
      u.setXYZ(17, e.r, e.g, e.b),
      u.setXYZ(18, e.r, e.g, e.b),
      u.setXYZ(19, e.r, e.g, e.b),
      u.setXYZ(20, e.r, e.g, e.b),
      u.setXYZ(21, e.r, e.g, e.b),
      u.setXYZ(22, e.r, e.g, e.b),
      u.setXYZ(23, e.r, e.g, e.b),
      u.setXYZ(24, t.r, t.g, t.b),
      u.setXYZ(25, t.r, t.g, t.b),
      u.setXYZ(26, t.r, t.g, t.b),
      u.setXYZ(27, t.r, t.g, t.b),
      u.setXYZ(28, t.r, t.g, t.b),
      u.setXYZ(29, t.r, t.g, t.b),
      u.setXYZ(30, t.r, t.g, t.b),
      u.setXYZ(31, t.r, t.g, t.b),
      u.setXYZ(32, n.r, n.g, n.b),
      u.setXYZ(33, n.r, n.g, n.b),
      u.setXYZ(34, n.r, n.g, n.b),
      u.setXYZ(35, n.r, n.g, n.b),
      u.setXYZ(36, n.r, n.g, n.b),
      u.setXYZ(37, n.r, n.g, n.b),
      u.setXYZ(38, i.r, i.g, i.b),
      u.setXYZ(39, i.r, i.g, i.b),
      u.setXYZ(40, a.r, a.g, a.b),
      u.setXYZ(41, a.r, a.g, a.b),
      u.setXYZ(42, a.r, a.g, a.b),
      u.setXYZ(43, a.r, a.g, a.b),
      u.setXYZ(44, a.r, a.g, a.b),
      u.setXYZ(45, a.r, a.g, a.b),
      u.setXYZ(46, a.r, a.g, a.b),
      u.setXYZ(47, a.r, a.g, a.b),
      u.setXYZ(48, a.r, a.g, a.b),
      u.setXYZ(49, a.r, a.g, a.b),
      (u.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      n = 1,
      i = 1;
    Qi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    const a = this.camera.coordinateSystem === Do ? -1 : 0;
    ia("c", t, e, Qi, 0, 0, a),
      ia("t", t, e, Qi, 0, 0, 1),
      ia("n1", t, e, Qi, -1, -1, a),
      ia("n2", t, e, Qi, n, -1, a),
      ia("n3", t, e, Qi, -1, i, a),
      ia("n4", t, e, Qi, n, i, a),
      ia("f1", t, e, Qi, -1, -1, 1),
      ia("f2", t, e, Qi, n, -1, 1),
      ia("f3", t, e, Qi, -1, i, 1),
      ia("f4", t, e, Qi, n, i, 1),
      ia("u1", t, e, Qi, n * 0.7, i * 1.1, a),
      ia("u2", t, e, Qi, -1 * 0.7, i * 1.1, a),
      ia("u3", t, e, Qi, 0, i * 2, a),
      ia("cf1", t, e, Qi, -1, 0, 1),
      ia("cf2", t, e, Qi, n, 0, 1),
      ia("cf3", t, e, Qi, 0, -1, 1),
      ia("cf4", t, e, Qi, 0, i, 1),
      ia("cn1", t, e, Qi, -1, 0, a),
      ia("cn2", t, e, Qi, n, 0, a),
      ia("cn3", t, e, Qi, 0, -1, a),
      ia("cn4", t, e, Qi, 0, i, a),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function ia(s, e, t, n, i, a, l) {
  u0.set(i, a, l).unproject(n);
  const u = e[s];
  if (u !== void 0) {
    const f = t.getAttribute("position");
    for (let d = 0, m = u.length; d < m; d++) f.setXYZ(u[d], u0.x, u0.y, u0.z);
  }
}
const c0 = new ya();
class tD extends Lo {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      a = new mn();
    a.setIndex(new Yn(n, 1)),
      a.setAttribute("position", new Yn(i, 3)),
      super(a, new dr({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && c0.setFromObject(this.object),
      c0.isEmpty())
    )
      return;
    const t = c0.min,
      n = c0.max,
      i = this.geometry.attributes.position,
      a = i.array;
    (a[0] = n.x),
      (a[1] = n.y),
      (a[2] = n.z),
      (a[3] = t.x),
      (a[4] = n.y),
      (a[5] = n.z),
      (a[6] = t.x),
      (a[7] = t.y),
      (a[8] = n.z),
      (a[9] = n.x),
      (a[10] = t.y),
      (a[11] = n.z),
      (a[12] = n.x),
      (a[13] = n.y),
      (a[14] = t.z),
      (a[15] = t.x),
      (a[16] = n.y),
      (a[17] = t.z),
      (a[18] = t.x),
      (a[19] = t.y),
      (a[20] = t.z),
      (a[21] = n.x),
      (a[22] = t.y),
      (a[23] = t.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class nD extends Lo {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      a = new mn();
    a.setIndex(new Yn(n, 1)),
      a.setAttribute("position", new Yt(i, 3)),
      super(a, new dr({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class iD extends Su {
  constructor(e, t = 1, n = 16776960) {
    const i = n,
      a = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      l = new mn();
    l.setAttribute("position", new Yt(a, 3)),
      l.computeBoundingSphere(),
      super(l, new dr({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const u = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      f = new mn();
    f.setAttribute("position", new Yt(u, 3)),
      f.computeBoundingSphere(),
      this.add(
        new li(
          f,
          new fr({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const qM = new ie();
let f0, D1;
class aD extends On {
  constructor(
    e = new ie(0, 0, 1),
    t = new ie(0, 0, 0),
    n = 1,
    i = 16776960,
    a = n * 0.2,
    l = a * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      f0 === void 0 &&
        ((f0 = new mn()),
        f0.setAttribute("position", new Yt([0, 0, 0, 0, 1, 0], 3)),
        (D1 = new Id(0, 0.5, 1, 5, 1)),
        D1.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Su(f0, new dr({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new li(D1, new fr({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(n, a, l);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      qM.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(qM, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(n, t, n),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class rD extends Lo {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new mn();
    i.setAttribute("position", new Yt(t, 3)),
      i.setAttribute("color", new Yt(n, 3));
    const a = new dr({ vertexColors: !0, toneMapped: !1 });
    super(i, a), (this.type = "AxesHelper");
  }
  setColors(e, t, n) {
    const i = new Dt(),
      a = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(a, 0),
      i.toArray(a, 3),
      i.set(t),
      i.toArray(a, 6),
      i.toArray(a, 9),
      i.set(n),
      i.toArray(a, 12),
      i.toArray(a, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class sD {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Dt()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Nm()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
  }
  bezierCurveTo(e, t, n, i, a, l) {
    return this.currentPath.bezierCurveTo(e, t, n, i, a, l), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(b) {
      const w = [];
      for (let D = 0, B = b.length; D < B; D++) {
        const I = b[D],
          N = new yc();
        (N.curves = I.curves), w.push(N);
      }
      return w;
    }
    function n(b, w) {
      const D = w.length;
      let B = !1;
      for (let I = D - 1, N = 0; N < D; I = N++) {
        let P = w[I],
          F = w[N],
          O = F.x - P.x,
          U = F.y - P.y;
        if (Math.abs(U) > Number.EPSILON) {
          if (
            (U < 0 && ((P = w[N]), (O = -O), (F = w[I]), (U = -U)),
            b.y < P.y || b.y > F.y)
          )
            continue;
          if (b.y === P.y) {
            if (b.x === P.x) return !0;
          } else {
            const W = U * (b.x - P.x) - O * (b.y - P.y);
            if (W === 0) return !0;
            if (W < 0) continue;
            B = !B;
          }
        } else {
          if (b.y !== P.y) continue;
          if ((F.x <= b.x && b.x <= P.x) || (P.x <= b.x && b.x <= F.x))
            return !0;
        }
      }
      return B;
    }
    const i = El.isClockWise,
      a = this.subPaths;
    if (a.length === 0) return [];
    let l, u, f;
    const d = [];
    if (a.length === 1)
      return (u = a[0]), (f = new yc()), (f.curves = u.curves), d.push(f), d;
    let m = !i(a[0].getPoints());
    m = e ? !m : m;
    const v = [],
      _ = [];
    let A = [],
      M = 0,
      T;
    (_[M] = void 0), (A[M] = []);
    for (let b = 0, w = a.length; b < w; b++)
      (u = a[b]),
        (T = u.getPoints()),
        (l = i(T)),
        (l = e ? !l : l),
        l
          ? (!m && _[M] && M++,
            (_[M] = { s: new yc(), p: T }),
            (_[M].s.curves = u.curves),
            m && M++,
            (A[M] = []))
          : A[M].push({ h: u, p: T[0] });
    if (!_[0]) return t(a);
    if (_.length > 1) {
      let b = !1,
        w = 0;
      for (let D = 0, B = _.length; D < B; D++) v[D] = [];
      for (let D = 0, B = _.length; D < B; D++) {
        const I = A[D];
        for (let N = 0; N < I.length; N++) {
          const P = I[N];
          let F = !0;
          for (let O = 0; O < _.length; O++)
            n(P.p, _[O].p) &&
              (D !== O && w++, F ? ((F = !1), v[O].push(P)) : (b = !0));
          F && v[D].push(P);
        }
      }
      w > 0 && b === !1 && (A = v);
    }
    let E;
    for (let b = 0, w = _.length; b < w; b++) {
      (f = _[b].s), d.push(f), (E = A[b]);
      for (let D = 0, B = E.length; D < B; D++) f.holes.push(E[D].h);
    }
    return d;
  }
}
class oD extends wl {
  constructor(e, t = null) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect() {}
  disconnect() {}
  dispose() {}
  update() {}
}
function lD(s, e) {
  const t = s.image && s.image.width ? s.image.width / s.image.height : 1;
  return (
    t > e
      ? ((s.repeat.x = 1),
        (s.repeat.y = t / e),
        (s.offset.x = 0),
        (s.offset.y = (1 - s.repeat.y) / 2))
      : ((s.repeat.x = e / t),
        (s.repeat.y = 1),
        (s.offset.x = (1 - s.repeat.x) / 2),
        (s.offset.y = 0)),
    s
  );
}
function uD(s, e) {
  const t = s.image && s.image.width ? s.image.width / s.image.height : 1;
  return (
    t > e
      ? ((s.repeat.x = e / t),
        (s.repeat.y = 1),
        (s.offset.x = (1 - s.repeat.x) / 2),
        (s.offset.y = 0))
      : ((s.repeat.x = 1),
        (s.repeat.y = t / e),
        (s.offset.x = 0),
        (s.offset.y = (1 - s.repeat.y) / 2)),
    s
  );
}
function cD(s) {
  return (
    (s.repeat.x = 1), (s.repeat.y = 1), (s.offset.x = 0), (s.offset.y = 0), s
  );
}
function EA(s, e, t, n) {
  const i = fD(n);
  switch (t) {
    case XA:
      return s * e;
    case WA:
      return s * e;
    case JA:
      return s * e * 2;
    case vc:
      return ((s * e) / i.components) * i.byteLength;
    case Xm:
      return ((s * e) / i.components) * i.byteLength;
    case qA:
      return ((s * e * 2) / i.components) * i.byteLength;
    case By:
      return ((s * e * 2) / i.components) * i.byteLength;
    case YA:
      return ((s * e * 3) / i.components) * i.byteLength;
    case oa:
      return ((s * e * 4) / i.components) * i.byteLength;
    case Dy:
      return ((s * e * 4) / i.components) * i.byteLength;
    case vm:
    case ym:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case _m:
    case Am:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case H0:
    case k0:
      return (Math.max(s, 16) * Math.max(e, 8)) / 4;
    case z0:
    case V0:
      return (Math.max(s, 8) * Math.max(e, 8)) / 2;
    case X0:
    case Y0:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case W0:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case J0:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case q0:
      return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case j0:
      return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case K0:
      return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Z0:
      return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Q0:
      return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case $0:
      return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case ey:
      return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case ty:
      return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case ny:
      return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case iy:
      return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case ay:
      return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case ry:
      return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case sy:
      return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case xm:
    case oy:
    case ly:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case jA:
    case uy:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case cy:
    case fy:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function fD(s) {
  switch (s) {
    case Zr:
    case Ty:
      return { byteLength: 1, components: 1 };
    case bd:
    case Cy:
    case va:
      return { byteLength: 2, components: 1 };
    case Ry:
    case wy:
      return { byteLength: 2, components: 4 };
    case Rl:
    case km:
    case yi:
      return { byteLength: 4, components: 1 };
    case kA:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${s}.`);
}
const hD = { contain: lD, cover: uD, fill: cD, getByteLength: EA };
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Od } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Od));
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function YT() {
  let s = null,
    e = !1,
    t = null,
    n = null;
  function i(a, l) {
    t(a, l), (n = s.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = s.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      s.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (a) {
      t = a;
    },
    setContext: function (a) {
      s = a;
    },
  };
}
function dD(s) {
  const e = new WeakMap();
  function t(u, f) {
    const d = u.array,
      m = u.usage,
      v = d.byteLength,
      _ = s.createBuffer();
    s.bindBuffer(f, _), s.bufferData(f, d, m), u.onUploadCallback();
    let A;
    if (d instanceof Float32Array) A = s.FLOAT;
    else if (d instanceof Uint16Array)
      u.isFloat16BufferAttribute ? (A = s.HALF_FLOAT) : (A = s.UNSIGNED_SHORT);
    else if (d instanceof Int16Array) A = s.SHORT;
    else if (d instanceof Uint32Array) A = s.UNSIGNED_INT;
    else if (d instanceof Int32Array) A = s.INT;
    else if (d instanceof Int8Array) A = s.BYTE;
    else if (d instanceof Uint8Array) A = s.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray) A = s.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d
      );
    return {
      buffer: _,
      type: A,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: u.version,
      size: v,
    };
  }
  function n(u, f, d) {
    const m = f.array,
      v = f.updateRanges;
    if ((s.bindBuffer(d, u), v.length === 0)) s.bufferSubData(d, 0, m);
    else {
      v.sort((A, M) => A.start - M.start);
      let _ = 0;
      for (let A = 1; A < v.length; A++) {
        const M = v[_],
          T = v[A];
        T.start <= M.start + M.count + 1
          ? (M.count = Math.max(M.count, T.start + T.count - M.start))
          : (++_, (v[_] = T));
      }
      v.length = _ + 1;
      for (let A = 0, M = v.length; A < M; A++) {
        const T = v[A];
        s.bufferSubData(d, T.start * m.BYTES_PER_ELEMENT, m, T.start, T.count);
      }
      f.clearUpdateRanges();
    }
    f.onUploadCallback();
  }
  function i(u) {
    return u.isInterleavedBufferAttribute && (u = u.data), e.get(u);
  }
  function a(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const f = e.get(u);
    f && (s.deleteBuffer(f.buffer), e.delete(u));
  }
  function l(u, f) {
    if (
      (u.isInterleavedBufferAttribute && (u = u.data), u.isGLBufferAttribute)
    ) {
      const m = e.get(u);
      (!m || m.version < u.version) &&
        e.set(u, {
          buffer: u.buffer,
          type: u.type,
          bytesPerElement: u.elementSize,
          version: u.version,
        });
      return;
    }
    const d = e.get(u);
    if (d === void 0) e.set(u, t(u, f));
    else if (d.version < u.version) {
      if (d.size !== u.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      n(d.buffer, u, f), (d.version = u.version);
    }
  }
  return { get: i, remove: a, update: l };
}
var pD = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  mD = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  gD = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  vD = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  yD = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  _D = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  AD = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  xD = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  SD = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  MD = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  bD = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  ED = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  TD = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  CD = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  RD = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  wD = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  BD = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  DD = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  UD = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  OD = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  LD = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  ND = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  ID = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  FD = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  PD = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  GD = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  zD = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  HD = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  VD = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  kD = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  XD = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  YD = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  WD = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  JD = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  qD = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  jD = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  KD = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  ZD = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  QD = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  $D = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  e3 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  t3 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  n3 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  i3 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  a3 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  r3 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  s3 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  o3 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  l3 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  u3 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  c3 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  f3 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  h3 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  d3 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  p3 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  m3 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  g3 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  v3 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  y3 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  _3 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  A3 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  x3 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  S3 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  M3 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  b3 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  E3 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  T3 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  C3 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  R3 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  w3 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  B3 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  D3 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  U3 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  O3 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  L3 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  N3 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  I3 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  F3 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  P3 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  G3 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  z3 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  H3 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  V3 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  k3 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  X3 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  Y3 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  W3 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  J3 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  q3 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  j3 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  K3 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  Z3 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  Q3 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  $3 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  eU = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  tU = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  nU = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  iU = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  aU = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  rU = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  sU = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  oU = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  lU = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  uU = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  cU = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  fU = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  hU = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const dU = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  pU = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  mU = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  gU = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vU = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  yU = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  _U = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  AU = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  xU = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  SU = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  MU = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  bU = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  EU = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  TU = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  CU = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  RU = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  wU = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  BU = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  DU = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  UU = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  OU = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  LU = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  NU = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  IU = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  FU = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  PU = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  GU = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  zU = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  HU = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  VU = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  kU = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  XU = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  YU = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  WU = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  _n = {
    alphahash_fragment: pD,
    alphahash_pars_fragment: mD,
    alphamap_fragment: gD,
    alphamap_pars_fragment: vD,
    alphatest_fragment: yD,
    alphatest_pars_fragment: _D,
    aomap_fragment: AD,
    aomap_pars_fragment: xD,
    batching_pars_vertex: SD,
    batching_vertex: MD,
    begin_vertex: bD,
    beginnormal_vertex: ED,
    bsdfs: TD,
    iridescence_fragment: CD,
    bumpmap_pars_fragment: RD,
    clipping_planes_fragment: wD,
    clipping_planes_pars_fragment: BD,
    clipping_planes_pars_vertex: DD,
    clipping_planes_vertex: UD,
    color_fragment: OD,
    color_pars_fragment: LD,
    color_pars_vertex: ND,
    color_vertex: ID,
    common: FD,
    cube_uv_reflection_fragment: PD,
    defaultnormal_vertex: GD,
    displacementmap_pars_vertex: zD,
    displacementmap_vertex: HD,
    emissivemap_fragment: VD,
    emissivemap_pars_fragment: kD,
    colorspace_fragment: XD,
    colorspace_pars_fragment: YD,
    envmap_fragment: WD,
    envmap_common_pars_fragment: JD,
    envmap_pars_fragment: qD,
    envmap_pars_vertex: jD,
    envmap_physical_pars_fragment: s3,
    envmap_vertex: KD,
    fog_vertex: ZD,
    fog_pars_vertex: QD,
    fog_fragment: $D,
    fog_pars_fragment: e3,
    gradientmap_pars_fragment: t3,
    lightmap_pars_fragment: n3,
    lights_lambert_fragment: i3,
    lights_lambert_pars_fragment: a3,
    lights_pars_begin: r3,
    lights_toon_fragment: o3,
    lights_toon_pars_fragment: l3,
    lights_phong_fragment: u3,
    lights_phong_pars_fragment: c3,
    lights_physical_fragment: f3,
    lights_physical_pars_fragment: h3,
    lights_fragment_begin: d3,
    lights_fragment_maps: p3,
    lights_fragment_end: m3,
    logdepthbuf_fragment: g3,
    logdepthbuf_pars_fragment: v3,
    logdepthbuf_pars_vertex: y3,
    logdepthbuf_vertex: _3,
    map_fragment: A3,
    map_pars_fragment: x3,
    map_particle_fragment: S3,
    map_particle_pars_fragment: M3,
    metalnessmap_fragment: b3,
    metalnessmap_pars_fragment: E3,
    morphinstance_vertex: T3,
    morphcolor_vertex: C3,
    morphnormal_vertex: R3,
    morphtarget_pars_vertex: w3,
    morphtarget_vertex: B3,
    normal_fragment_begin: D3,
    normal_fragment_maps: U3,
    normal_pars_fragment: O3,
    normal_pars_vertex: L3,
    normal_vertex: N3,
    normalmap_pars_fragment: I3,
    clearcoat_normal_fragment_begin: F3,
    clearcoat_normal_fragment_maps: P3,
    clearcoat_pars_fragment: G3,
    iridescence_pars_fragment: z3,
    opaque_fragment: H3,
    packing: V3,
    premultiplied_alpha_fragment: k3,
    project_vertex: X3,
    dithering_fragment: Y3,
    dithering_pars_fragment: W3,
    roughnessmap_fragment: J3,
    roughnessmap_pars_fragment: q3,
    shadowmap_pars_fragment: j3,
    shadowmap_pars_vertex: K3,
    shadowmap_vertex: Z3,
    shadowmask_pars_fragment: Q3,
    skinbase_vertex: $3,
    skinning_pars_vertex: eU,
    skinning_vertex: tU,
    skinnormal_vertex: nU,
    specularmap_fragment: iU,
    specularmap_pars_fragment: aU,
    tonemapping_fragment: rU,
    tonemapping_pars_fragment: sU,
    transmission_fragment: oU,
    transmission_pars_fragment: lU,
    uv_pars_fragment: uU,
    uv_pars_vertex: cU,
    uv_vertex: fU,
    worldpos_vertex: hU,
    background_vert: dU,
    background_frag: pU,
    backgroundCube_vert: mU,
    backgroundCube_frag: gU,
    cube_vert: vU,
    cube_frag: yU,
    depth_vert: _U,
    depth_frag: AU,
    distanceRGBA_vert: xU,
    distanceRGBA_frag: SU,
    equirect_vert: MU,
    equirect_frag: bU,
    linedashed_vert: EU,
    linedashed_frag: TU,
    meshbasic_vert: CU,
    meshbasic_frag: RU,
    meshlambert_vert: wU,
    meshlambert_frag: BU,
    meshmatcap_vert: DU,
    meshmatcap_frag: UU,
    meshnormal_vert: OU,
    meshnormal_frag: LU,
    meshphong_vert: NU,
    meshphong_frag: IU,
    meshphysical_vert: FU,
    meshphysical_frag: PU,
    meshtoon_vert: GU,
    meshtoon_frag: zU,
    points_vert: HU,
    points_frag: VU,
    shadow_vert: kU,
    shadow_frag: XU,
    sprite_vert: YU,
    sprite_frag: WU,
  },
  Lt = {
    common: {
      diffuse: { value: new Dt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new hn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new hn() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new hn() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new hn() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new hn() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new hn() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new hn() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new hn() },
      normalScale: { value: new at(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new hn() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new hn() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new hn() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new hn() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Dt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Dt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new hn() },
      alphaTest: { value: 0 },
      uvTransform: { value: new hn() },
    },
    sprite: {
      diffuse: { value: new Dt(16777215) },
      opacity: { value: 1 },
      center: { value: new at(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new hn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new hn() },
      alphaTest: { value: 0 },
    },
  },
  Bo = {
    basic: {
      uniforms: Tr([
        Lt.common,
        Lt.specularmap,
        Lt.envmap,
        Lt.aomap,
        Lt.lightmap,
        Lt.fog,
      ]),
      vertexShader: _n.meshbasic_vert,
      fragmentShader: _n.meshbasic_frag,
    },
    lambert: {
      uniforms: Tr([
        Lt.common,
        Lt.specularmap,
        Lt.envmap,
        Lt.aomap,
        Lt.lightmap,
        Lt.emissivemap,
        Lt.bumpmap,
        Lt.normalmap,
        Lt.displacementmap,
        Lt.fog,
        Lt.lights,
        { emissive: { value: new Dt(0) } },
      ]),
      vertexShader: _n.meshlambert_vert,
      fragmentShader: _n.meshlambert_frag,
    },
    phong: {
      uniforms: Tr([
        Lt.common,
        Lt.specularmap,
        Lt.envmap,
        Lt.aomap,
        Lt.lightmap,
        Lt.emissivemap,
        Lt.bumpmap,
        Lt.normalmap,
        Lt.displacementmap,
        Lt.fog,
        Lt.lights,
        {
          emissive: { value: new Dt(0) },
          specular: { value: new Dt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: _n.meshphong_vert,
      fragmentShader: _n.meshphong_frag,
    },
    standard: {
      uniforms: Tr([
        Lt.common,
        Lt.envmap,
        Lt.aomap,
        Lt.lightmap,
        Lt.emissivemap,
        Lt.bumpmap,
        Lt.normalmap,
        Lt.displacementmap,
        Lt.roughnessmap,
        Lt.metalnessmap,
        Lt.fog,
        Lt.lights,
        {
          emissive: { value: new Dt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: _n.meshphysical_vert,
      fragmentShader: _n.meshphysical_frag,
    },
    toon: {
      uniforms: Tr([
        Lt.common,
        Lt.aomap,
        Lt.lightmap,
        Lt.emissivemap,
        Lt.bumpmap,
        Lt.normalmap,
        Lt.displacementmap,
        Lt.gradientmap,
        Lt.fog,
        Lt.lights,
        { emissive: { value: new Dt(0) } },
      ]),
      vertexShader: _n.meshtoon_vert,
      fragmentShader: _n.meshtoon_frag,
    },
    matcap: {
      uniforms: Tr([
        Lt.common,
        Lt.bumpmap,
        Lt.normalmap,
        Lt.displacementmap,
        Lt.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: _n.meshmatcap_vert,
      fragmentShader: _n.meshmatcap_frag,
    },
    points: {
      uniforms: Tr([Lt.points, Lt.fog]),
      vertexShader: _n.points_vert,
      fragmentShader: _n.points_frag,
    },
    dashed: {
      uniforms: Tr([
        Lt.common,
        Lt.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: _n.linedashed_vert,
      fragmentShader: _n.linedashed_frag,
    },
    depth: {
      uniforms: Tr([Lt.common, Lt.displacementmap]),
      vertexShader: _n.depth_vert,
      fragmentShader: _n.depth_frag,
    },
    normal: {
      uniforms: Tr([
        Lt.common,
        Lt.bumpmap,
        Lt.normalmap,
        Lt.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: _n.meshnormal_vert,
      fragmentShader: _n.meshnormal_frag,
    },
    sprite: {
      uniforms: Tr([Lt.sprite, Lt.fog]),
      vertexShader: _n.sprite_vert,
      fragmentShader: _n.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new hn() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: _n.background_vert,
      fragmentShader: _n.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new hn() },
      },
      vertexShader: _n.backgroundCube_vert,
      fragmentShader: _n.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: _n.cube_vert,
      fragmentShader: _n.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: _n.equirect_vert,
      fragmentShader: _n.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Tr([
        Lt.common,
        Lt.displacementmap,
        {
          referencePosition: { value: new ie() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: _n.distanceRGBA_vert,
      fragmentShader: _n.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Tr([
        Lt.lights,
        Lt.fog,
        { color: { value: new Dt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: _n.shadow_vert,
      fragmentShader: _n.shadow_frag,
    },
  };
Bo.physical = {
  uniforms: Tr([
    Bo.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new hn() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new hn() },
      clearcoatNormalScale: { value: new at(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new hn() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new hn() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new hn() },
      sheen: { value: 0 },
      sheenColor: { value: new Dt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new hn() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new hn() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new hn() },
      transmissionSamplerSize: { value: new at() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new hn() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Dt(0) },
      specularColor: { value: new Dt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new hn() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new hn() },
      anisotropyVector: { value: new at() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new hn() },
    },
  ]),
  vertexShader: _n.meshphysical_vert,
  fragmentShader: _n.meshphysical_frag,
};
const h0 = { r: 0, b: 0, g: 0 },
  bf = new vs(),
  JU = new Qt();
function qU(s, e, t, n, i, a, l) {
  const u = new Dt(0);
  let f = a === !0 ? 0 : 1,
    d,
    m,
    v = null,
    _ = 0,
    A = null;
  function M(D) {
    let B = D.isScene === !0 ? D.background : null;
    return (
      B && B.isTexture && (B = (D.backgroundBlurriness > 0 ? t : e).get(B)), B
    );
  }
  function T(D) {
    let B = !1;
    const I = M(D);
    I === null ? b(u, f) : I && I.isColor && (b(I, 1), (B = !0));
    const N = s.xr.getEnvironmentBlendMode();
    N === "additive"
      ? n.buffers.color.setClear(0, 0, 0, 1, l)
      : N === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, l),
      (s.autoClear || B) &&
        (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
  }
  function E(D, B) {
    const I = M(B);
    I && (I.isCubeTexture || I.mapping === Ld)
      ? (m === void 0 &&
          ((m = new li(
            new eh(1, 1, 1),
            new ra({
              name: "BackgroundCubeMaterial",
              uniforms: wd(Bo.backgroundCube.uniforms),
              vertexShader: Bo.backgroundCube.vertexShader,
              fragmentShader: Bo.backgroundCube.fragmentShader,
              side: hr,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          m.geometry.deleteAttribute("normal"),
          m.geometry.deleteAttribute("uv"),
          (m.onBeforeRender = function (N, P, F) {
            this.matrixWorld.copyPosition(F.matrixWorld);
          }),
          Object.defineProperty(m.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          i.update(m)),
        bf.copy(B.backgroundRotation),
        (bf.x *= -1),
        (bf.y *= -1),
        (bf.z *= -1),
        I.isCubeTexture &&
          I.isRenderTargetTexture === !1 &&
          ((bf.y *= -1), (bf.z *= -1)),
        (m.material.uniforms.envMap.value = I),
        (m.material.uniforms.flipEnvMap.value =
          I.isCubeTexture && I.isRenderTargetTexture === !1 ? -1 : 1),
        (m.material.uniforms.backgroundBlurriness.value =
          B.backgroundBlurriness),
        (m.material.uniforms.backgroundIntensity.value = B.backgroundIntensity),
        m.material.uniforms.backgroundRotation.value.setFromMatrix4(
          JU.makeRotationFromEuler(bf)
        ),
        (m.material.toneMapped = zn.getTransfer(I.colorSpace) !== oi),
        (v !== I || _ !== I.version || A !== s.toneMapping) &&
          ((m.material.needsUpdate = !0),
          (v = I),
          (_ = I.version),
          (A = s.toneMapping)),
        m.layers.enableAll(),
        D.unshift(m, m.geometry, m.material, 0, 0, null))
      : I &&
        I.isTexture &&
        (d === void 0 &&
          ((d = new li(
            new zs(2, 2),
            new ra({
              name: "BackgroundMaterial",
              uniforms: wd(Bo.background.uniforms),
              vertexShader: Bo.background.vertexShader,
              fragmentShader: Bo.background.fragmentShader,
              side: Tl,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          d.geometry.deleteAttribute("normal"),
          Object.defineProperty(d.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          i.update(d)),
        (d.material.uniforms.t2D.value = I),
        (d.material.uniforms.backgroundIntensity.value = B.backgroundIntensity),
        (d.material.toneMapped = zn.getTransfer(I.colorSpace) !== oi),
        I.matrixAutoUpdate === !0 && I.updateMatrix(),
        d.material.uniforms.uvTransform.value.copy(I.matrix),
        (v !== I || _ !== I.version || A !== s.toneMapping) &&
          ((d.material.needsUpdate = !0),
          (v = I),
          (_ = I.version),
          (A = s.toneMapping)),
        d.layers.enableAll(),
        D.unshift(d, d.geometry, d.material, 0, 0, null));
  }
  function b(D, B) {
    D.getRGB(h0, tT(s)), n.buffers.color.setClear(h0.r, h0.g, h0.b, B, l);
  }
  function w() {
    m !== void 0 && (m.geometry.dispose(), m.material.dispose(), (m = void 0)),
      d !== void 0 &&
        (d.geometry.dispose(), d.material.dispose(), (d = void 0));
  }
  return {
    getClearColor: function () {
      return u;
    },
    setClearColor: function (D, B = 1) {
      u.set(D), (f = B), b(u, f);
    },
    getClearAlpha: function () {
      return f;
    },
    setClearAlpha: function (D) {
      (f = D), b(u, f);
    },
    render: T,
    addToRenderList: E,
    dispose: w,
  };
}
function jU(s, e) {
  const t = s.getParameter(s.MAX_VERTEX_ATTRIBS),
    n = {},
    i = _(null);
  let a = i,
    l = !1;
  function u(U, W, J, q, Z) {
    let ue = !1;
    const K = v(q, J, W);
    a !== K && ((a = K), d(a.object)),
      (ue = A(U, q, J, Z)),
      ue && M(U, q, J, Z),
      Z !== null && e.update(Z, s.ELEMENT_ARRAY_BUFFER),
      (ue || l) &&
        ((l = !1),
        B(U, W, J, q),
        Z !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(Z).buffer));
  }
  function f() {
    return s.createVertexArray();
  }
  function d(U) {
    return s.bindVertexArray(U);
  }
  function m(U) {
    return s.deleteVertexArray(U);
  }
  function v(U, W, J) {
    const q = J.wireframe === !0;
    let Z = n[U.id];
    Z === void 0 && ((Z = {}), (n[U.id] = Z));
    let ue = Z[W.id];
    ue === void 0 && ((ue = {}), (Z[W.id] = ue));
    let K = ue[q];
    return K === void 0 && ((K = _(f())), (ue[q] = K)), K;
  }
  function _(U) {
    const W = [],
      J = [],
      q = [];
    for (let Z = 0; Z < t; Z++) (W[Z] = 0), (J[Z] = 0), (q[Z] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: W,
      enabledAttributes: J,
      attributeDivisors: q,
      object: U,
      attributes: {},
      index: null,
    };
  }
  function A(U, W, J, q) {
    const Z = a.attributes,
      ue = W.attributes;
    let K = 0;
    const ge = J.getAttributes();
    for (const oe in ge)
      if (ge[oe].location >= 0) {
        const V = Z[oe];
        let Y = ue[oe];
        if (
          (Y === void 0 &&
            (oe === "instanceMatrix" &&
              U.instanceMatrix &&
              (Y = U.instanceMatrix),
            oe === "instanceColor" && U.instanceColor && (Y = U.instanceColor)),
          V === void 0 || V.attribute !== Y || (Y && V.data !== Y.data))
        )
          return !0;
        K++;
      }
    return a.attributesNum !== K || a.index !== q;
  }
  function M(U, W, J, q) {
    const Z = {},
      ue = W.attributes;
    let K = 0;
    const ge = J.getAttributes();
    for (const oe in ge)
      if (ge[oe].location >= 0) {
        let V = ue[oe];
        V === void 0 &&
          (oe === "instanceMatrix" &&
            U.instanceMatrix &&
            (V = U.instanceMatrix),
          oe === "instanceColor" && U.instanceColor && (V = U.instanceColor));
        const Y = {};
        (Y.attribute = V), V && V.data && (Y.data = V.data), (Z[oe] = Y), K++;
      }
    (a.attributes = Z), (a.attributesNum = K), (a.index = q);
  }
  function T() {
    const U = a.newAttributes;
    for (let W = 0, J = U.length; W < J; W++) U[W] = 0;
  }
  function E(U) {
    b(U, 0);
  }
  function b(U, W) {
    const J = a.newAttributes,
      q = a.enabledAttributes,
      Z = a.attributeDivisors;
    (J[U] = 1),
      q[U] === 0 && (s.enableVertexAttribArray(U), (q[U] = 1)),
      Z[U] !== W && (s.vertexAttribDivisor(U, W), (Z[U] = W));
  }
  function w() {
    const U = a.newAttributes,
      W = a.enabledAttributes;
    for (let J = 0, q = W.length; J < q; J++)
      W[J] !== U[J] && (s.disableVertexAttribArray(J), (W[J] = 0));
  }
  function D(U, W, J, q, Z, ue, K) {
    K === !0
      ? s.vertexAttribIPointer(U, W, J, Z, ue)
      : s.vertexAttribPointer(U, W, J, q, Z, ue);
  }
  function B(U, W, J, q) {
    T();
    const Z = q.attributes,
      ue = J.getAttributes(),
      K = W.defaultAttributeValues;
    for (const ge in ue) {
      const oe = ue[ge];
      if (oe.location >= 0) {
        let me = Z[ge];
        if (
          (me === void 0 &&
            (ge === "instanceMatrix" &&
              U.instanceMatrix &&
              (me = U.instanceMatrix),
            ge === "instanceColor" &&
              U.instanceColor &&
              (me = U.instanceColor)),
          me !== void 0)
        ) {
          const V = me.normalized,
            Y = me.itemSize,
            ae = e.get(me);
          if (ae === void 0) continue;
          const fe = ae.buffer,
            j = ae.type,
            se = ae.bytesPerElement,
            ve = j === s.INT || j === s.UNSIGNED_INT || me.gpuType === km;
          if (me.isInterleavedBufferAttribute) {
            const ye = me.data,
              be = ye.stride,
              it = me.offset;
            if (ye.isInstancedInterleavedBuffer) {
              for (let We = 0; We < oe.locationSize; We++)
                b(oe.location + We, ye.meshPerAttribute);
              U.isInstancedMesh !== !0 &&
                q._maxInstanceCount === void 0 &&
                (q._maxInstanceCount = ye.meshPerAttribute * ye.count);
            } else
              for (let We = 0; We < oe.locationSize; We++) E(oe.location + We);
            s.bindBuffer(s.ARRAY_BUFFER, fe);
            for (let We = 0; We < oe.locationSize; We++)
              D(
                oe.location + We,
                Y / oe.locationSize,
                j,
                V,
                be * se,
                (it + (Y / oe.locationSize) * We) * se,
                ve
              );
          } else {
            if (me.isInstancedBufferAttribute) {
              for (let ye = 0; ye < oe.locationSize; ye++)
                b(oe.location + ye, me.meshPerAttribute);
              U.isInstancedMesh !== !0 &&
                q._maxInstanceCount === void 0 &&
                (q._maxInstanceCount = me.meshPerAttribute * me.count);
            } else
              for (let ye = 0; ye < oe.locationSize; ye++) E(oe.location + ye);
            s.bindBuffer(s.ARRAY_BUFFER, fe);
            for (let ye = 0; ye < oe.locationSize; ye++)
              D(
                oe.location + ye,
                Y / oe.locationSize,
                j,
                V,
                Y * se,
                (Y / oe.locationSize) * ye * se,
                ve
              );
          }
        } else if (K !== void 0) {
          const V = K[ge];
          if (V !== void 0)
            switch (V.length) {
              case 2:
                s.vertexAttrib2fv(oe.location, V);
                break;
              case 3:
                s.vertexAttrib3fv(oe.location, V);
                break;
              case 4:
                s.vertexAttrib4fv(oe.location, V);
                break;
              default:
                s.vertexAttrib1fv(oe.location, V);
            }
        }
      }
    }
    w();
  }
  function I() {
    F();
    for (const U in n) {
      const W = n[U];
      for (const J in W) {
        const q = W[J];
        for (const Z in q) m(q[Z].object), delete q[Z];
        delete W[J];
      }
      delete n[U];
    }
  }
  function N(U) {
    if (n[U.id] === void 0) return;
    const W = n[U.id];
    for (const J in W) {
      const q = W[J];
      for (const Z in q) m(q[Z].object), delete q[Z];
      delete W[J];
    }
    delete n[U.id];
  }
  function P(U) {
    for (const W in n) {
      const J = n[W];
      if (J[U.id] === void 0) continue;
      const q = J[U.id];
      for (const Z in q) m(q[Z].object), delete q[Z];
      delete J[U.id];
    }
  }
  function F() {
    O(), (l = !0), a !== i && ((a = i), d(a.object));
  }
  function O() {
    (i.geometry = null), (i.program = null), (i.wireframe = !1);
  }
  return {
    setup: u,
    reset: F,
    resetDefaultState: O,
    dispose: I,
    releaseStatesOfGeometry: N,
    releaseStatesOfProgram: P,
    initAttributes: T,
    enableAttribute: E,
    disableUnusedAttributes: w,
  };
}
function KU(s, e, t) {
  let n;
  function i(d) {
    n = d;
  }
  function a(d, m) {
    s.drawArrays(n, d, m), t.update(m, n, 1);
  }
  function l(d, m, v) {
    v !== 0 && (s.drawArraysInstanced(n, d, m, v), t.update(m, n, v));
  }
  function u(d, m, v) {
    if (v === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, d, 0, m, 0, v);
    let A = 0;
    for (let M = 0; M < v; M++) A += m[M];
    t.update(A, n, 1);
  }
  function f(d, m, v, _) {
    if (v === 0) return;
    const A = e.get("WEBGL_multi_draw");
    if (A === null) for (let M = 0; M < d.length; M++) l(d[M], m[M], _[M]);
    else {
      A.multiDrawArraysInstancedWEBGL(n, d, 0, m, 0, _, 0, v);
      let M = 0;
      for (let T = 0; T < v; T++) M += m[T] * _[T];
      t.update(M, n, 1);
    }
  }
  (this.setMode = i),
    (this.render = a),
    (this.renderInstances = l),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = f);
}
function ZU(s, e, t, n) {
  let i;
  function a() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const P = e.get("EXT_texture_filter_anisotropic");
      i = s.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function l(P) {
    return !(
      P !== oa &&
      n.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function u(P) {
    const F =
      P === va &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      P !== Zr &&
      n.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) &&
      P !== yi &&
      !F
    );
  }
  function f(P) {
    if (P === "highp") {
      if (
        s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision >
          0 &&
        s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      P = "mediump";
    }
    return P === "mediump" &&
      s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision >
        0 &&
      s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let d = t.precision !== void 0 ? t.precision : "highp";
  const m = f(d);
  m !== d &&
    (console.warn(
      "THREE.WebGLRenderer:",
      d,
      "not supported, using",
      m,
      "instead."
    ),
    (d = m));
  const v = t.logarithmicDepthBuffer === !0,
    _ = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
    A = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),
    M = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    T = s.getParameter(s.MAX_TEXTURE_SIZE),
    E = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE),
    b = s.getParameter(s.MAX_VERTEX_ATTRIBS),
    w = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS),
    D = s.getParameter(s.MAX_VARYING_VECTORS),
    B = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS),
    I = M > 0,
    N = s.getParameter(s.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: a,
    getMaxPrecision: f,
    textureFormatReadable: l,
    textureTypeReadable: u,
    precision: d,
    logarithmicDepthBuffer: v,
    reverseDepthBuffer: _,
    maxTextures: A,
    maxVertexTextures: M,
    maxTextureSize: T,
    maxCubemapSize: E,
    maxAttributes: b,
    maxVertexUniforms: w,
    maxVaryings: D,
    maxFragmentUniforms: B,
    vertexTextures: I,
    maxSamples: N,
  };
}
function QU(s) {
  const e = this;
  let t = null,
    n = 0,
    i = !1,
    a = !1;
  const l = new mu(),
    u = new hn(),
    f = { value: null, needsUpdate: !1 };
  (this.uniform = f),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (v, _) {
      const A = v.length !== 0 || _ || n !== 0 || i;
      return (i = _), (n = v.length), A;
    }),
    (this.beginShadows = function () {
      (a = !0), m(null);
    }),
    (this.endShadows = function () {
      a = !1;
    }),
    (this.setGlobalState = function (v, _) {
      t = m(v, _, 0);
    }),
    (this.setState = function (v, _, A) {
      const M = v.clippingPlanes,
        T = v.clipIntersection,
        E = v.clipShadows,
        b = s.get(v);
      if (!i || M === null || M.length === 0 || (a && !E)) a ? m(null) : d();
      else {
        const w = a ? 0 : n,
          D = w * 4;
        let B = b.clippingState || null;
        (f.value = B), (B = m(M, _, D, A));
        for (let I = 0; I !== D; ++I) B[I] = t[I];
        (b.clippingState = B),
          (this.numIntersection = T ? this.numPlanes : 0),
          (this.numPlanes += w);
      }
    });
  function d() {
    f.value !== t && ((f.value = t), (f.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function m(v, _, A, M) {
    const T = v !== null ? v.length : 0;
    let E = null;
    if (T !== 0) {
      if (((E = f.value), M !== !0 || E === null)) {
        const b = A + T * 4,
          w = _.matrixWorldInverse;
        u.getNormalMatrix(w),
          (E === null || E.length < b) && (E = new Float32Array(b));
        for (let D = 0, B = A; D !== T; ++D, B += 4)
          l.copy(v[D]).applyMatrix4(w, u),
            l.normal.toArray(E, B),
            (E[B + 3] = l.constant);
      }
      (f.value = E), (f.needsUpdate = !0);
    }
    return (e.numPlanes = T), (e.numIntersection = 0), E;
  }
}
function $U(s) {
  let e = new WeakMap();
  function t(l, u) {
    return u === Sd ? (l.mapping = Cl) : u === wm && (l.mapping = xc), l;
  }
  function n(l) {
    if (l && l.isTexture) {
      const u = l.mapping;
      if (u === Sd || u === wm)
        if (e.has(l)) {
          const f = e.get(l).texture;
          return t(f, l.mapping);
        } else {
          const f = l.image;
          if (f && f.height > 0) {
            const d = new ax(f.height);
            return (
              d.fromEquirectangularTexture(s, l),
              e.set(l, d),
              l.addEventListener("dispose", i),
              t(d.texture, l.mapping)
            );
          } else return null;
        }
    }
    return l;
  }
  function i(l) {
    const u = l.target;
    u.removeEventListener("dispose", i);
    const f = e.get(u);
    f !== void 0 && (e.delete(u), f.dispose());
  }
  function a() {
    e = new WeakMap();
  }
  return { get: n, dispose: a };
}
const vd = 4,
  jM = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Uf = 20,
  U1 = new Ps(),
  KM = new Dt();
let O1 = null,
  L1 = 0,
  N1 = 0,
  I1 = !1;
const Df = (1 + Math.sqrt(5)) / 2,
  ld = 1 / Df,
  ZM = [
    new ie(-Df, ld, 0),
    new ie(Df, ld, 0),
    new ie(-ld, 0, Df),
    new ie(ld, 0, Df),
    new ie(0, Df, -ld),
    new ie(0, Df, ld),
    new ie(-1, 1, -1),
    new ie(1, 1, -1),
    new ie(-1, 1, 1),
    new ie(1, 1, 1),
  ];
class TA {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    (O1 = this._renderer.getRenderTarget()),
      (L1 = this._renderer.getActiveCubeFace()),
      (N1 = this._renderer.getActiveMipmapLevel()),
      (I1 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const a = this._allocateTargets();
    return (
      (a.depthBuffer = !0),
      this._sceneToCubeUV(e, n, i, a),
      t > 0 && this._blur(a, 0, 0, t),
      this._applyPMREM(a),
      this._cleanup(a),
      a
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = eb()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = $M()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(O1, L1, N1),
      (this._renderer.xr.enabled = I1),
      (e.scissorTest = !1),
      d0(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Cl || e.mapping === xc
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (O1 = this._renderer.getRenderTarget()),
      (L1 = this._renderer.getActiveCubeFace()),
      (N1 = this._renderer.getActiveMipmapLevel()),
      (I1 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const n = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      n = {
        magFilter: In,
        minFilter: In,
        generateMipmaps: !1,
        type: va,
        format: oa,
        colorSpace: Oo,
        depthBuffer: !1,
      },
      i = QM(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = QM(e, t, n));
      const { _lodMax: a } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = eO(a)),
        (this._blurMaterial = tO(a, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new li(this._lodPlanes[0], e);
    this._renderer.compile(t, U1);
  }
  _sceneToCubeUV(e, t, n, i) {
    const u = new $i(90, 1, t, n),
      f = [1, -1, 1, 1, 1, 1],
      d = [1, 1, 1, -1, -1, -1],
      m = this._renderer,
      v = m.autoClear,
      _ = m.toneMapping;
    m.getClearColor(KM), (m.toneMapping = bl), (m.autoClear = !1);
    const A = new fr({
        name: "PMREM.Background",
        side: hr,
        depthWrite: !1,
        depthTest: !1,
      }),
      M = new li(new eh(), A);
    let T = !1;
    const E = e.background;
    E
      ? E.isColor && (A.color.copy(E), (e.background = null), (T = !0))
      : (A.color.copy(KM), (T = !0));
    for (let b = 0; b < 6; b++) {
      const w = b % 3;
      w === 0
        ? (u.up.set(0, f[b], 0), u.lookAt(d[b], 0, 0))
        : w === 1
        ? (u.up.set(0, 0, f[b]), u.lookAt(0, d[b], 0))
        : (u.up.set(0, f[b], 0), u.lookAt(0, 0, d[b]));
      const D = this._cubeSize;
      d0(i, w * D, b > 2 ? D : 0, D, D),
        m.setRenderTarget(i),
        T && m.render(M, u),
        m.render(e, u);
    }
    M.geometry.dispose(),
      M.material.dispose(),
      (m.toneMapping = _),
      (m.autoClear = v),
      (e.background = E);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      i = e.mapping === Cl || e.mapping === xc;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = eb()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = $M());
    const a = i ? this._cubemapMaterial : this._equirectMaterial,
      l = new li(this._lodPlanes[0], a),
      u = a.uniforms;
    u.envMap.value = e;
    const f = this._cubeSize;
    d0(t, 0, 0, 3 * f, 2 * f), n.setRenderTarget(t), n.render(l, U1);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let a = 1; a < i; a++) {
      const l = Math.sqrt(
          this._sigmas[a] * this._sigmas[a] -
            this._sigmas[a - 1] * this._sigmas[a - 1]
        ),
        u = ZM[(i - a - 1) % ZM.length];
      this._blur(e, a - 1, a, l, u);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, a) {
    const l = this._pingPongRenderTarget;
    this._halfBlur(e, l, t, n, i, "latitudinal", a),
      this._halfBlur(l, e, n, n, i, "longitudinal", a);
  }
  _halfBlur(e, t, n, i, a, l, u) {
    const f = this._renderer,
      d = this._blurMaterial;
    l !== "latitudinal" &&
      l !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const m = 3,
      v = new li(this._lodPlanes[i], d),
      _ = d.uniforms,
      A = this._sizeLods[n] - 1,
      M = isFinite(a) ? Math.PI / (2 * A) : (2 * Math.PI) / (2 * Uf - 1),
      T = a / M,
      E = isFinite(a) ? 1 + Math.floor(m * T) : Uf;
    E > Uf &&
      console.warn(
        `sigmaRadians, ${a}, is too large and will clip, as it requested ${E} samples when the maximum is set to ${Uf}`
      );
    const b = [];
    let w = 0;
    for (let P = 0; P < Uf; ++P) {
      const F = P / T,
        O = Math.exp((-F * F) / 2);
      b.push(O), P === 0 ? (w += O) : P < E && (w += 2 * O);
    }
    for (let P = 0; P < b.length; P++) b[P] = b[P] / w;
    (_.envMap.value = e.texture),
      (_.samples.value = E),
      (_.weights.value = b),
      (_.latitudinal.value = l === "latitudinal"),
      u && (_.poleAxis.value = u);
    const { _lodMax: D } = this;
    (_.dTheta.value = M), (_.mipInt.value = D - n);
    const B = this._sizeLods[i],
      I = 3 * B * (i > D - vd ? i - D + vd : 0),
      N = 4 * (this._cubeSize - B);
    d0(t, I, N, 3 * B, 2 * B), f.setRenderTarget(t), f.render(v, U1);
  }
}
function eO(s) {
  const e = [],
    t = [],
    n = [];
  let i = s;
  const a = s - vd + 1 + jM.length;
  for (let l = 0; l < a; l++) {
    const u = Math.pow(2, i);
    t.push(u);
    let f = 1 / u;
    l > s - vd ? (f = jM[l - s + vd - 1]) : l === 0 && (f = 0), n.push(f);
    const d = 1 / (u - 2),
      m = -d,
      v = 1 + d,
      _ = [m, m, v, m, v, v, m, m, v, v, m, v],
      A = 6,
      M = 6,
      T = 3,
      E = 2,
      b = 1,
      w = new Float32Array(T * M * A),
      D = new Float32Array(E * M * A),
      B = new Float32Array(b * M * A);
    for (let N = 0; N < A; N++) {
      const P = ((N % 3) * 2) / 3 - 1,
        F = N > 2 ? 0 : -1,
        O = [
          P,
          F,
          0,
          P + 2 / 3,
          F,
          0,
          P + 2 / 3,
          F + 1,
          0,
          P,
          F,
          0,
          P + 2 / 3,
          F + 1,
          0,
          P,
          F + 1,
          0,
        ];
      w.set(O, T * M * N), D.set(_, E * M * N);
      const U = [N, N, N, N, N, N];
      B.set(U, b * M * N);
    }
    const I = new mn();
    I.setAttribute("position", new Yn(w, T)),
      I.setAttribute("uv", new Yn(D, E)),
      I.setAttribute("faceIndex", new Yn(B, b)),
      e.push(I),
      i > vd && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function QM(s, e, t) {
  const n = new ha(s, e, t);
  return (
    (n.texture.mapping = Ld),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function d0(s, e, t, n, i) {
  s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
}
function tO(s, e, t) {
  const n = new Float32Array(Uf),
    i = new ie(0, 1, 0);
  return new ra({
    name: "SphericalGaussianBlur",
    defines: {
      n: Uf,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${s}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: Dx(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Ml,
    depthTest: !1,
    depthWrite: !1,
  });
}
function $M() {
  return new ra({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Dx(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Ml,
    depthTest: !1,
    depthWrite: !1,
  });
}
function eb() {
  return new ra({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Dx(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Ml,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Dx() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function nO(s) {
  let e = new WeakMap(),
    t = null;
  function n(u) {
    if (u && u.isTexture) {
      const f = u.mapping,
        d = f === Sd || f === wm,
        m = f === Cl || f === xc;
      if (d || m) {
        let v = e.get(u);
        const _ = v !== void 0 ? v.texture.pmremVersion : 0;
        if (u.isRenderTargetTexture && u.pmremVersion !== _)
          return (
            t === null && (t = new TA(s)),
            (v = d ? t.fromEquirectangular(u, v) : t.fromCubemap(u, v)),
            (v.texture.pmremVersion = u.pmremVersion),
            e.set(u, v),
            v.texture
          );
        if (v !== void 0) return v.texture;
        {
          const A = u.image;
          return (d && A && A.height > 0) || (m && A && i(A))
            ? (t === null && (t = new TA(s)),
              (v = d ? t.fromEquirectangular(u) : t.fromCubemap(u)),
              (v.texture.pmremVersion = u.pmremVersion),
              e.set(u, v),
              u.addEventListener("dispose", a),
              v.texture)
            : null;
        }
      }
    }
    return u;
  }
  function i(u) {
    let f = 0;
    const d = 6;
    for (let m = 0; m < d; m++) u[m] !== void 0 && f++;
    return f === d;
  }
  function a(u) {
    const f = u.target;
    f.removeEventListener("dispose", a);
    const d = e.get(f);
    d !== void 0 && (e.delete(f), d.dispose());
  }
  function l() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: n, dispose: l };
}
function iO(s) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i =
          s.getExtension("WEBGL_depth_texture") ||
          s.getExtension("MOZ_WEBGL_depth_texture") ||
          s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          s.getExtension("EXT_texture_filter_anisotropic") ||
          s.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          s.getExtension("WEBGL_compressed_texture_s3tc") ||
          s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          s.getExtension("WEBGL_compressed_texture_pvrtc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = s.getExtension(n);
    }
    return (e[n] = i), i;
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (n) {
      const i = t(n);
      return (
        i === null &&
          dd("THREE.WebGLRenderer: " + n + " extension not supported."),
        i
      );
    },
  };
}
function aO(s, e, t, n) {
  const i = {},
    a = new WeakMap();
  function l(v) {
    const _ = v.target;
    _.index !== null && e.remove(_.index);
    for (const M in _.attributes) e.remove(_.attributes[M]);
    _.removeEventListener("dispose", l), delete i[_.id];
    const A = a.get(_);
    A && (e.remove(A), a.delete(_)),
      n.releaseStatesOfGeometry(_),
      _.isInstancedBufferGeometry === !0 && delete _._maxInstanceCount,
      t.memory.geometries--;
  }
  function u(v, _) {
    return (
      i[_.id] === !0 ||
        (_.addEventListener("dispose", l),
        (i[_.id] = !0),
        t.memory.geometries++),
      _
    );
  }
  function f(v) {
    const _ = v.attributes;
    for (const A in _) e.update(_[A], s.ARRAY_BUFFER);
  }
  function d(v) {
    const _ = [],
      A = v.index,
      M = v.attributes.position;
    let T = 0;
    if (A !== null) {
      const w = A.array;
      T = A.version;
      for (let D = 0, B = w.length; D < B; D += 3) {
        const I = w[D + 0],
          N = w[D + 1],
          P = w[D + 2];
        _.push(I, N, N, P, P, I);
      }
    } else if (M !== void 0) {
      const w = M.array;
      T = M.version;
      for (let D = 0, B = w.length / 3 - 1; D < B; D += 3) {
        const I = D + 0,
          N = D + 1,
          P = D + 2;
        _.push(I, N, N, P, P, I);
      }
    } else return;
    const E = new (ZE(_) ? ix : nx)(_, 1);
    E.version = T;
    const b = a.get(v);
    b && e.remove(b), a.set(v, E);
  }
  function m(v) {
    const _ = a.get(v);
    if (_) {
      const A = v.index;
      A !== null && _.version < A.version && d(v);
    } else d(v);
    return a.get(v);
  }
  return { get: u, update: f, getWireframeAttribute: m };
}
function rO(s, e, t) {
  let n;
  function i(_) {
    n = _;
  }
  let a, l;
  function u(_) {
    (a = _.type), (l = _.bytesPerElement);
  }
  function f(_, A) {
    s.drawElements(n, A, a, _ * l), t.update(A, n, 1);
  }
  function d(_, A, M) {
    M !== 0 && (s.drawElementsInstanced(n, A, a, _ * l, M), t.update(A, n, M));
  }
  function m(_, A, M) {
    if (M === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, A, 0, a, _, 0, M);
    let E = 0;
    for (let b = 0; b < M; b++) E += A[b];
    t.update(E, n, 1);
  }
  function v(_, A, M, T) {
    if (M === 0) return;
    const E = e.get("WEBGL_multi_draw");
    if (E === null) for (let b = 0; b < _.length; b++) d(_[b] / l, A[b], T[b]);
    else {
      E.multiDrawElementsInstancedWEBGL(n, A, 0, a, _, 0, T, 0, M);
      let b = 0;
      for (let w = 0; w < M; w++) b += A[w] * T[w];
      t.update(b, n, 1);
    }
  }
  (this.setMode = i),
    (this.setIndex = u),
    (this.render = f),
    (this.renderInstances = d),
    (this.renderMultiDraw = m),
    (this.renderMultiDrawInstances = v);
}
function sO(s) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(a, l, u) {
    switch ((t.calls++, l)) {
      case s.TRIANGLES:
        t.triangles += u * (a / 3);
        break;
      case s.LINES:
        t.lines += u * (a / 2);
        break;
      case s.LINE_STRIP:
        t.lines += u * (a - 1);
        break;
      case s.LINE_LOOP:
        t.lines += u * a;
        break;
      case s.POINTS:
        t.points += u * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", l);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n,
  };
}
function oO(s, e, t) {
  const n = new WeakMap(),
    i = new Hn();
  function a(l, u, f) {
    const d = l.morphTargetInfluences,
      m =
        u.morphAttributes.position ||
        u.morphAttributes.normal ||
        u.morphAttributes.color,
      v = m !== void 0 ? m.length : 0;
    let _ = n.get(u);
    if (_ === void 0 || _.count !== v) {
      let U = function () {
        F.dispose(), n.delete(u), u.removeEventListener("dispose", U);
      };
      var A = U;
      _ !== void 0 && _.texture.dispose();
      const M = u.morphAttributes.position !== void 0,
        T = u.morphAttributes.normal !== void 0,
        E = u.morphAttributes.color !== void 0,
        b = u.morphAttributes.position || [],
        w = u.morphAttributes.normal || [],
        D = u.morphAttributes.color || [];
      let B = 0;
      M === !0 && (B = 1), T === !0 && (B = 2), E === !0 && (B = 3);
      let I = u.attributes.position.count * B,
        N = 1;
      I > e.maxTextureSize &&
        ((N = Math.ceil(I / e.maxTextureSize)), (I = e.maxTextureSize));
      const P = new Float32Array(I * N * 4 * v),
        F = new Ym(P, I, N, v);
      (F.type = yi), (F.needsUpdate = !0);
      const O = B * 4;
      for (let W = 0; W < v; W++) {
        const J = b[W],
          q = w[W],
          Z = D[W],
          ue = I * N * 4 * W;
        for (let K = 0; K < J.count; K++) {
          const ge = K * O;
          M === !0 &&
            (i.fromBufferAttribute(J, K),
            (P[ue + ge + 0] = i.x),
            (P[ue + ge + 1] = i.y),
            (P[ue + ge + 2] = i.z),
            (P[ue + ge + 3] = 0)),
            T === !0 &&
              (i.fromBufferAttribute(q, K),
              (P[ue + ge + 4] = i.x),
              (P[ue + ge + 5] = i.y),
              (P[ue + ge + 6] = i.z),
              (P[ue + ge + 7] = 0)),
            E === !0 &&
              (i.fromBufferAttribute(Z, K),
              (P[ue + ge + 8] = i.x),
              (P[ue + ge + 9] = i.y),
              (P[ue + ge + 10] = i.z),
              (P[ue + ge + 11] = Z.itemSize === 4 ? i.w : 1));
        }
      }
      (_ = { count: v, texture: F, size: new at(I, N) }),
        n.set(u, _),
        u.addEventListener("dispose", U);
    }
    if (l.isInstancedMesh === !0 && l.morphTexture !== null)
      f.getUniforms().setValue(s, "morphTexture", l.morphTexture, t);
    else {
      let M = 0;
      for (let E = 0; E < d.length; E++) M += d[E];
      const T = u.morphTargetsRelative ? 1 : 1 - M;
      f.getUniforms().setValue(s, "morphTargetBaseInfluence", T),
        f.getUniforms().setValue(s, "morphTargetInfluences", d);
    }
    f.getUniforms().setValue(s, "morphTargetsTexture", _.texture, t),
      f.getUniforms().setValue(s, "morphTargetsTextureSize", _.size);
  }
  return { update: a };
}
function lO(s, e, t, n) {
  let i = new WeakMap();
  function a(f) {
    const d = n.render.frame,
      m = f.geometry,
      v = e.get(f, m);
    if (
      (i.get(v) !== d && (e.update(v), i.set(v, d)),
      f.isInstancedMesh &&
        (f.hasEventListener("dispose", u) === !1 &&
          f.addEventListener("dispose", u),
        i.get(f) !== d &&
          (t.update(f.instanceMatrix, s.ARRAY_BUFFER),
          f.instanceColor !== null && t.update(f.instanceColor, s.ARRAY_BUFFER),
          i.set(f, d))),
      f.isSkinnedMesh)
    ) {
      const _ = f.skeleton;
      i.get(_) !== d && (_.update(), i.set(_, d));
    }
    return v;
  }
  function l() {
    i = new WeakMap();
  }
  function u(f) {
    const d = f.target;
    d.removeEventListener("dispose", u),
      t.remove(d.instanceMatrix),
      d.instanceColor !== null && t.remove(d.instanceColor);
  }
  return { update: a, dispose: l };
}
const WT = new Wn(),
  tb = new Vy(1, 1),
  JT = new Ym(),
  qT = new Ly(),
  jT = new Wm(),
  nb = [],
  ib = [],
  ab = new Float32Array(16),
  rb = new Float32Array(9),
  sb = new Float32Array(4);
function Pd(s, e, t) {
  const n = s[0];
  if (n <= 0 || n > 0) return s;
  const i = e * t;
  let a = nb[i];
  if ((a === void 0 && ((a = new Float32Array(i)), (nb[i] = a)), e !== 0)) {
    n.toArray(a, 0);
    for (let l = 1, u = 0; l !== e; ++l) (u += t), s[l].toArray(a, u);
  }
  return a;
}
function Aa(s, e) {
  if (s.length !== e.length) return !1;
  for (let t = 0, n = s.length; t < n; t++) if (s[t] !== e[t]) return !1;
  return !0;
}
function xa(s, e) {
  for (let t = 0, n = e.length; t < n; t++) s[t] = e[t];
}
function o_(s, e) {
  let t = ib[e];
  t === void 0 && ((t = new Int32Array(e)), (ib[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = s.allocateTextureUnit();
  return t;
}
function uO(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), (t[0] = e));
}
function cO(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (s.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Aa(t, e)) return;
    s.uniform2fv(this.addr, e), xa(t, e);
  }
}
function fO(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (s.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (s.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Aa(t, e)) return;
    s.uniform3fv(this.addr, e), xa(t, e);
  }
}
function hO(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Aa(t, e)) return;
    s.uniform4fv(this.addr, e), xa(t, e);
  }
}
function dO(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Aa(t, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), xa(t, e);
  } else {
    if (Aa(t, n)) return;
    sb.set(n), s.uniformMatrix2fv(this.addr, !1, sb), xa(t, n);
  }
}
function pO(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Aa(t, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), xa(t, e);
  } else {
    if (Aa(t, n)) return;
    rb.set(n), s.uniformMatrix3fv(this.addr, !1, rb), xa(t, n);
  }
}
function mO(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Aa(t, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), xa(t, e);
  } else {
    if (Aa(t, n)) return;
    ab.set(n), s.uniformMatrix4fv(this.addr, !1, ab), xa(t, n);
  }
}
function gO(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), (t[0] = e));
}
function vO(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (s.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Aa(t, e)) return;
    s.uniform2iv(this.addr, e), xa(t, e);
  }
}
function yO(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (s.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Aa(t, e)) return;
    s.uniform3iv(this.addr, e), xa(t, e);
  }
}
function _O(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (s.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Aa(t, e)) return;
    s.uniform4iv(this.addr, e), xa(t, e);
  }
}
function AO(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), (t[0] = e));
}
function xO(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (s.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Aa(t, e)) return;
    s.uniform2uiv(this.addr, e), xa(t, e);
  }
}
function SO(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (s.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Aa(t, e)) return;
    s.uniform3uiv(this.addr, e), xa(t, e);
  }
}
function MO(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Aa(t, e)) return;
    s.uniform4uiv(this.addr, e), xa(t, e);
  }
}
function bO(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i));
  let a;
  this.type === s.SAMPLER_2D_SHADOW
    ? ((tb.compareFunction = $A), (a = tb))
    : (a = WT),
    t.setTexture2D(e || a, i);
}
function EO(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture3D(e || qT, i);
}
function TO(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTextureCube(e || jT, i);
}
function CO(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2DArray(e || JT, i);
}
function RO(s) {
  switch (s) {
    case 5126:
      return uO;
    case 35664:
      return cO;
    case 35665:
      return fO;
    case 35666:
      return hO;
    case 35674:
      return dO;
    case 35675:
      return pO;
    case 35676:
      return mO;
    case 5124:
    case 35670:
      return gO;
    case 35667:
    case 35671:
      return vO;
    case 35668:
    case 35672:
      return yO;
    case 35669:
    case 35673:
      return _O;
    case 5125:
      return AO;
    case 36294:
      return xO;
    case 36295:
      return SO;
    case 36296:
      return MO;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return bO;
    case 35679:
    case 36299:
    case 36307:
      return EO;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return TO;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return CO;
  }
}
function wO(s, e) {
  s.uniform1fv(this.addr, e);
}
function BO(s, e) {
  const t = Pd(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function DO(s, e) {
  const t = Pd(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function UO(s, e) {
  const t = Pd(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function OO(s, e) {
  const t = Pd(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, t);
}
function LO(s, e) {
  const t = Pd(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, t);
}
function NO(s, e) {
  const t = Pd(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, t);
}
function IO(s, e) {
  s.uniform1iv(this.addr, e);
}
function FO(s, e) {
  s.uniform2iv(this.addr, e);
}
function PO(s, e) {
  s.uniform3iv(this.addr, e);
}
function GO(s, e) {
  s.uniform4iv(this.addr, e);
}
function zO(s, e) {
  s.uniform1uiv(this.addr, e);
}
function HO(s, e) {
  s.uniform2uiv(this.addr, e);
}
function VO(s, e) {
  s.uniform3uiv(this.addr, e);
}
function kO(s, e) {
  s.uniform4uiv(this.addr, e);
}
function XO(s, e, t) {
  const n = this.cache,
    i = e.length,
    a = o_(t, i);
  Aa(n, a) || (s.uniform1iv(this.addr, a), xa(n, a));
  for (let l = 0; l !== i; ++l) t.setTexture2D(e[l] || WT, a[l]);
}
function YO(s, e, t) {
  const n = this.cache,
    i = e.length,
    a = o_(t, i);
  Aa(n, a) || (s.uniform1iv(this.addr, a), xa(n, a));
  for (let l = 0; l !== i; ++l) t.setTexture3D(e[l] || qT, a[l]);
}
function WO(s, e, t) {
  const n = this.cache,
    i = e.length,
    a = o_(t, i);
  Aa(n, a) || (s.uniform1iv(this.addr, a), xa(n, a));
  for (let l = 0; l !== i; ++l) t.setTextureCube(e[l] || jT, a[l]);
}
function JO(s, e, t) {
  const n = this.cache,
    i = e.length,
    a = o_(t, i);
  Aa(n, a) || (s.uniform1iv(this.addr, a), xa(n, a));
  for (let l = 0; l !== i; ++l) t.setTexture2DArray(e[l] || JT, a[l]);
}
function qO(s) {
  switch (s) {
    case 5126:
      return wO;
    case 35664:
      return BO;
    case 35665:
      return DO;
    case 35666:
      return UO;
    case 35674:
      return OO;
    case 35675:
      return LO;
    case 35676:
      return NO;
    case 5124:
    case 35670:
      return IO;
    case 35667:
    case 35671:
      return FO;
    case 35668:
    case 35672:
      return PO;
    case 35669:
    case 35673:
      return GO;
    case 5125:
      return zO;
    case 36294:
      return HO;
    case 36295:
      return VO;
    case 36296:
      return kO;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return XO;
    case 35679:
    case 36299:
    case 36307:
      return YO;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return WO;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return JO;
  }
}
class jO {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = RO(t.type));
  }
}
class KO {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = qO(t.type));
  }
}
class ZO {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let a = 0, l = i.length; a !== l; ++a) {
      const u = i[a];
      u.setValue(e, t[u.id], n);
    }
  }
}
const F1 = /(\w+)(\])?(\[|\.)?/g;
function ob(s, e) {
  s.seq.push(e), (s.map[e.id] = e);
}
function QO(s, e, t) {
  const n = s.name,
    i = n.length;
  for (F1.lastIndex = 0; ; ) {
    const a = F1.exec(n),
      l = F1.lastIndex;
    let u = a[1];
    const f = a[2] === "]",
      d = a[3];
    if ((f && (u = u | 0), d === void 0 || (d === "[" && l + 2 === i))) {
      ob(t, d === void 0 ? new jO(u, s, e) : new KO(u, s, e));
      break;
    } else {
      let v = t.map[u];
      v === void 0 && ((v = new ZO(u)), ob(t, v)), (t = v);
    }
  }
}
class T0 {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const a = e.getActiveUniform(t, i),
        l = e.getUniformLocation(t, a.name);
      QO(a, l, this);
    }
  }
  setValue(e, t, n, i) {
    const a = this.map[t];
    a !== void 0 && a.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let a = 0, l = t.length; a !== l; ++a) {
      const u = t[a],
        f = n[u.id];
      f.needsUpdate !== !1 && u.setValue(e, f.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, a = e.length; i !== a; ++i) {
      const l = e[i];
      l.id in t && n.push(l);
    }
    return n;
  }
}
function lb(s, e, t) {
  const n = s.createShader(e);
  return s.shaderSource(n, t), s.compileShader(n), n;
}
const $O = 37297;
let eL = 0;
function tL(s, e) {
  const t = s.split(`
`),
    n = [],
    i = Math.max(e - 6, 0),
    a = Math.min(e + 6, t.length);
  for (let l = i; l < a; l++) {
    const u = l + 1;
    n.push(`${u === e ? ">" : " "} ${u}: ${t[l]}`);
  }
  return n.join(`
`);
}
const ub = new hn();
function nL(s) {
  zn._getMatrix(ub, zn.workingColorSpace, s);
  const e = `mat3( ${ub.elements.map((t) => t.toFixed(4))} )`;
  switch (zn.getTransfer(s)) {
    case Dm:
      return [e, "LinearTransferOETF"];
    case oi:
      return [e, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space: ", s),
        [e, "LinearTransferOETF"]
      );
  }
}
function cb(s, e, t) {
  const n = s.getShaderParameter(e, s.COMPILE_STATUS),
    i = s.getShaderInfoLog(e).trim();
  if (n && i === "") return "";
  const a = /ERROR: 0:(\d+)/.exec(i);
  if (a) {
    const l = parseInt(a[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      tL(s.getShaderSource(e), l)
    );
  } else return i;
}
function iL(s, e) {
  const t = nL(e);
  return [
    `vec4 ${s}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
function aL(s, e) {
  let t;
  switch (e) {
    case DE:
      t = "Linear";
      break;
    case UE:
      t = "Reinhard";
      break;
    case OE:
      t = "Cineon";
      break;
    case VA:
      t = "ACESFilmic";
      break;
    case NE:
      t = "AgX";
      break;
    case IE:
      t = "Neutral";
      break;
    case LE:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const p0 = new ie();
function rL() {
  zn.getLuminanceCoefficients(p0);
  const s = p0.x.toFixed(4),
    e = p0.y.toFixed(4),
    t = p0.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${s}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function sL(s) {
  return [
    s.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(pm).join(`
`);
}
function oL(s) {
  const e = [];
  for (const t in s) {
    const n = s[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function lL(s, e) {
  const t = {},
    n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const a = s.getActiveAttrib(e, i),
      l = a.name;
    let u = 1;
    a.type === s.FLOAT_MAT2 && (u = 2),
      a.type === s.FLOAT_MAT3 && (u = 3),
      a.type === s.FLOAT_MAT4 && (u = 4),
      (t[l] = {
        type: a.type,
        location: s.getAttribLocation(e, l),
        locationSize: u,
      });
  }
  return t;
}
function pm(s) {
  return s !== "";
}
function fb(s, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function hb(s, e) {
  return s
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const uL = /^[ \t]*#include +<([\w\d./]+)>/gm;
function CA(s) {
  return s.replace(uL, fL);
}
const cL = new Map();
function fL(s, e) {
  let t = _n[e];
  if (t === void 0) {
    const n = cL.get(e);
    if (n !== void 0)
      (t = _n[n]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          n
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return CA(t);
}
const hL =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function db(s) {
  return s.replace(hL, dL);
}
function dL(s, e, t, n) {
  let i = "";
  for (let a = parseInt(e); a < parseInt(t); a++)
    i += n
      .replace(/\[\s*i\s*\]/g, "[ " + a + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, a);
  return i;
}
function pb(s) {
  let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
  return (
    s.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : s.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : s.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function pL(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    s.shadowMapType === by
      ? (e = "SHADOWMAP_TYPE_PCF")
      : s.shadowMapType === gm
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : s.shadowMapType === wo && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function mL(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case Cl:
      case xc:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Ld:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function gL(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case xc:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function vL(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case Vm:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case wE:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case BE:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function yL(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: n,
    maxMip: t,
  };
}
function _L(s, e, t, n) {
  const i = s.getContext(),
    a = t.defines;
  let l = t.vertexShader,
    u = t.fragmentShader;
  const f = pL(t),
    d = mL(t),
    m = gL(t),
    v = vL(t),
    _ = yL(t),
    A = sL(t),
    M = oL(a),
    T = i.createProgram();
  let E,
    b,
    w = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((E = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        M,
      ].filter(pm).join(`
`)),
      E.length > 0 &&
        (E += `
`),
      (b = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        M,
      ].filter(pm).join(`
`)),
      b.length > 0 &&
        (b += `
`))
    : ((E = [
        pb(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        M,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + m : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + f : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(pm).join(`
`)),
      (b = [
        pb(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        M,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + d : "",
        t.envMap ? "#define " + m : "",
        t.envMap ? "#define " + v : "",
        _ ? "#define CUBEUV_TEXEL_WIDTH " + _.texelWidth : "",
        _ ? "#define CUBEUV_TEXEL_HEIGHT " + _.texelHeight : "",
        _ ? "#define CUBEUV_MAX_MIP " + _.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + f : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== bl ? "#define TONE_MAPPING" : "",
        t.toneMapping !== bl ? _n.tonemapping_pars_fragment : "",
        t.toneMapping !== bl ? aL("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        _n.colorspace_pars_fragment,
        iL("linearToOutputTexel", t.outputColorSpace),
        rL(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(pm).join(`
`))),
    (l = CA(l)),
    (l = fb(l, t)),
    (l = hb(l, t)),
    (u = CA(u)),
    (u = fb(u, t)),
    (u = hb(u, t)),
    (l = db(l)),
    (u = db(u)),
    t.isRawShaderMaterial !== !0 &&
      ((w = `#version 300 es
`),
      (E =
        [
          A,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        E),
      (b =
        [
          "#define varying in",
          t.glslVersion === yA
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === yA ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        b));
  const D = w + E + l,
    B = w + b + u,
    I = lb(i, i.VERTEX_SHADER, D),
    N = lb(i, i.FRAGMENT_SHADER, B);
  i.attachShader(T, I),
    i.attachShader(T, N),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(T, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(T, 0, "position"),
    i.linkProgram(T);
  function P(W) {
    if (s.debug.checkShaderErrors) {
      const J = i.getProgramInfoLog(T).trim(),
        q = i.getShaderInfoLog(I).trim(),
        Z = i.getShaderInfoLog(N).trim();
      let ue = !0,
        K = !0;
      if (i.getProgramParameter(T, i.LINK_STATUS) === !1)
        if (((ue = !1), typeof s.debug.onShaderError == "function"))
          s.debug.onShaderError(i, T, I, N);
        else {
          const ge = cb(i, I, "vertex"),
            oe = cb(i, N, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(T, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              W.name +
              `
Material Type: ` +
              W.type +
              `

Program Info Log: ` +
              J +
              `
` +
              ge +
              `
` +
              oe
          );
        }
      else
        J !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", J)
          : (q === "" || Z === "") && (K = !1);
      K &&
        (W.diagnostics = {
          runnable: ue,
          programLog: J,
          vertexShader: { log: q, prefix: E },
          fragmentShader: { log: Z, prefix: b },
        });
    }
    i.deleteShader(I), i.deleteShader(N), (F = new T0(i, T)), (O = lL(i, T));
  }
  let F;
  this.getUniforms = function () {
    return F === void 0 && P(this), F;
  };
  let O;
  this.getAttributes = function () {
    return O === void 0 && P(this), O;
  };
  let U = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return U === !1 && (U = i.getProgramParameter(T, $O)), U;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        i.deleteProgram(T),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = eL++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = T),
    (this.vertexShader = I),
    (this.fragmentShader = N),
    this
  );
}
let AL = 0;
class xL {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      i = this._getShaderStage(t),
      a = this._getShaderStage(n),
      l = this._getShaderCacheForMaterial(e);
    return (
      l.has(i) === !1 && (l.add(i), i.usedTimes++),
      l.has(a) === !1 && (l.add(a), a.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && ((n = new Set()), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && ((n = new SL(e)), t.set(e, n)), n;
  }
}
class SL {
  constructor(e) {
    (this.id = AL++), (this.code = e), (this.usedTimes = 0);
  }
}
function ML(s, e, t, n, i, a, l) {
  const u = new Rd(),
    f = new xL(),
    d = new Set(),
    m = [],
    v = i.logarithmicDepthBuffer,
    _ = i.vertexTextures;
  let A = i.precision;
  const M = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function T(O) {
    return d.add(O), O === 0 ? "uv" : `uv${O}`;
  }
  function E(O, U, W, J, q) {
    const Z = J.fog,
      ue = q.geometry,
      K = O.isMeshStandardMaterial ? J.environment : null,
      ge = (O.isMeshStandardMaterial ? t : e).get(O.envMap || K),
      oe = ge && ge.mapping === Ld ? ge.image.height : null,
      me = M[O.type];
    O.precision !== null &&
      ((A = i.getMaxPrecision(O.precision)),
      A !== O.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          O.precision,
          "not supported, using",
          A,
          "instead."
        ));
    const V =
        ue.morphAttributes.position ||
        ue.morphAttributes.normal ||
        ue.morphAttributes.color,
      Y = V !== void 0 ? V.length : 0;
    let ae = 0;
    ue.morphAttributes.position !== void 0 && (ae = 1),
      ue.morphAttributes.normal !== void 0 && (ae = 2),
      ue.morphAttributes.color !== void 0 && (ae = 3);
    let fe, j, se, ve;
    if (me) {
      const Ft = Bo[me];
      (fe = Ft.vertexShader), (j = Ft.fragmentShader);
    } else
      (fe = O.vertexShader),
        (j = O.fragmentShader),
        f.update(O),
        (se = f.getVertexShaderID(O)),
        (ve = f.getFragmentShaderID(O));
    const ye = s.getRenderTarget(),
      be = s.state.buffers.depth.getReversed(),
      it = q.isInstancedMesh === !0,
      We = q.isBatchedMesh === !0,
      $e = !!O.map,
      Me = !!O.matcap,
      Ie = !!ge,
      $ = !!O.aoMap,
      ft = !!O.lightMap,
      Pe = !!O.bumpMap,
      rt = !!O.normalMap,
      Ue = !!O.displacementMap,
      ht = !!O.emissiveMap,
      Ve = !!O.metalnessMap,
      X = !!O.roughnessMap,
      k = O.anisotropy > 0,
      de = O.clearcoat > 0,
      Ee = O.dispersion > 0,
      we = O.iridescence > 0,
      He = O.sheen > 0,
      tt = O.transmission > 0,
      Ke = k && !!O.anisotropyMap,
      st = de && !!O.clearcoatMap,
      Ut = de && !!O.clearcoatNormalMap,
      et = de && !!O.clearcoatRoughnessMap,
      At = we && !!O.iridescenceMap,
      mt = we && !!O.iridescenceThicknessMap,
      nt = He && !!O.sheenColorMap,
      Ze = He && !!O.sheenRoughnessMap,
      le = !!O.specularMap,
      Be = !!O.specularColorMap,
      vt = !!O.specularIntensityMap,
      ce = tt && !!O.transmissionMap,
      xe = tt && !!O.thicknessMap,
      Re = !!O.gradientMap,
      Qe = !!O.alphaMap,
      gt = O.alphaTest > 0,
      dt = !!O.alphaHash,
      Ct = !!O.extensions;
    let Ht = bl;
    O.toneMapped &&
      (ye === null || ye.isXRRenderTarget === !0) &&
      (Ht = s.toneMapping);
    const Nt = {
      shaderID: me,
      shaderType: O.type,
      shaderName: O.name,
      vertexShader: fe,
      fragmentShader: j,
      defines: O.defines,
      customVertexShaderID: se,
      customFragmentShaderID: ve,
      isRawShaderMaterial: O.isRawShaderMaterial === !0,
      glslVersion: O.glslVersion,
      precision: A,
      batching: We,
      batchingColor: We && q._colorsTexture !== null,
      instancing: it,
      instancingColor: it && q.instanceColor !== null,
      instancingMorph: it && q.morphTexture !== null,
      supportsVertexTextures: _,
      outputColorSpace:
        ye === null
          ? s.outputColorSpace
          : ye.isXRRenderTarget === !0
          ? ye.texture.colorSpace
          : Oo,
      alphaToCoverage: !!O.alphaToCoverage,
      map: $e,
      matcap: Me,
      envMap: Ie,
      envMapMode: Ie && ge.mapping,
      envMapCubeUVHeight: oe,
      aoMap: $,
      lightMap: ft,
      bumpMap: Pe,
      normalMap: rt,
      displacementMap: _ && Ue,
      emissiveMap: ht,
      normalMapObjectSpace: rt && O.normalMapType === kE,
      normalMapTangentSpace: rt && O.normalMapType === Ec,
      metalnessMap: Ve,
      roughnessMap: X,
      anisotropy: k,
      anisotropyMap: Ke,
      clearcoat: de,
      clearcoatMap: st,
      clearcoatNormalMap: Ut,
      clearcoatRoughnessMap: et,
      dispersion: Ee,
      iridescence: we,
      iridescenceMap: At,
      iridescenceThicknessMap: mt,
      sheen: He,
      sheenColorMap: nt,
      sheenRoughnessMap: Ze,
      specularMap: le,
      specularColorMap: Be,
      specularIntensityMap: vt,
      transmission: tt,
      transmissionMap: ce,
      thicknessMap: xe,
      gradientMap: Re,
      opaque:
        O.transparent === !1 && O.blending === Hf && O.alphaToCoverage === !1,
      alphaMap: Qe,
      alphaTest: gt,
      alphaHash: dt,
      combine: O.combine,
      mapUv: $e && T(O.map.channel),
      aoMapUv: $ && T(O.aoMap.channel),
      lightMapUv: ft && T(O.lightMap.channel),
      bumpMapUv: Pe && T(O.bumpMap.channel),
      normalMapUv: rt && T(O.normalMap.channel),
      displacementMapUv: Ue && T(O.displacementMap.channel),
      emissiveMapUv: ht && T(O.emissiveMap.channel),
      metalnessMapUv: Ve && T(O.metalnessMap.channel),
      roughnessMapUv: X && T(O.roughnessMap.channel),
      anisotropyMapUv: Ke && T(O.anisotropyMap.channel),
      clearcoatMapUv: st && T(O.clearcoatMap.channel),
      clearcoatNormalMapUv: Ut && T(O.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: et && T(O.clearcoatRoughnessMap.channel),
      iridescenceMapUv: At && T(O.iridescenceMap.channel),
      iridescenceThicknessMapUv: mt && T(O.iridescenceThicknessMap.channel),
      sheenColorMapUv: nt && T(O.sheenColorMap.channel),
      sheenRoughnessMapUv: Ze && T(O.sheenRoughnessMap.channel),
      specularMapUv: le && T(O.specularMap.channel),
      specularColorMapUv: Be && T(O.specularColorMap.channel),
      specularIntensityMapUv: vt && T(O.specularIntensityMap.channel),
      transmissionMapUv: ce && T(O.transmissionMap.channel),
      thicknessMapUv: xe && T(O.thicknessMap.channel),
      alphaMapUv: Qe && T(O.alphaMap.channel),
      vertexTangents: !!ue.attributes.tangent && (rt || k),
      vertexColors: O.vertexColors,
      vertexAlphas:
        O.vertexColors === !0 &&
        !!ue.attributes.color &&
        ue.attributes.color.itemSize === 4,
      pointsUvs: q.isPoints === !0 && !!ue.attributes.uv && ($e || Qe),
      fog: !!Z,
      useFog: O.fog === !0,
      fogExp2: !!Z && Z.isFogExp2,
      flatShading: O.flatShading === !0,
      sizeAttenuation: O.sizeAttenuation === !0,
      logarithmicDepthBuffer: v,
      reverseDepthBuffer: be,
      skinning: q.isSkinnedMesh === !0,
      morphTargets: ue.morphAttributes.position !== void 0,
      morphNormals: ue.morphAttributes.normal !== void 0,
      morphColors: ue.morphAttributes.color !== void 0,
      morphTargetsCount: Y,
      morphTextureStride: ae,
      numDirLights: U.directional.length,
      numPointLights: U.point.length,
      numSpotLights: U.spot.length,
      numSpotLightMaps: U.spotLightMap.length,
      numRectAreaLights: U.rectArea.length,
      numHemiLights: U.hemi.length,
      numDirLightShadows: U.directionalShadowMap.length,
      numPointLightShadows: U.pointShadowMap.length,
      numSpotLightShadows: U.spotShadowMap.length,
      numSpotLightShadowsWithMaps: U.numSpotLightShadowsWithMaps,
      numLightProbes: U.numLightProbes,
      numClippingPlanes: l.numPlanes,
      numClipIntersection: l.numIntersection,
      dithering: O.dithering,
      shadowMapEnabled: s.shadowMap.enabled && W.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: Ht,
      decodeVideoTexture:
        $e &&
        O.map.isVideoTexture === !0 &&
        zn.getTransfer(O.map.colorSpace) === oi,
      decodeVideoTextureEmissive:
        ht &&
        O.emissiveMap.isVideoTexture === !0 &&
        zn.getTransfer(O.emissiveMap.colorSpace) === oi,
      premultipliedAlpha: O.premultipliedAlpha,
      doubleSided: O.side === jr,
      flipSided: O.side === hr,
      useDepthPacking: O.depthPacking >= 0,
      depthPacking: O.depthPacking || 0,
      index0AttributeName: O.index0AttributeName,
      extensionClipCullDistance:
        Ct &&
        O.extensions.clipCullDistance === !0 &&
        n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((Ct && O.extensions.multiDraw === !0) || We) &&
        n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: O.customProgramCacheKey(),
    };
    return (
      (Nt.vertexUv1s = d.has(1)),
      (Nt.vertexUv2s = d.has(2)),
      (Nt.vertexUv3s = d.has(3)),
      d.clear(),
      Nt
    );
  }
  function b(O) {
    const U = [];
    if (
      (O.shaderID
        ? U.push(O.shaderID)
        : (U.push(O.customVertexShaderID), U.push(O.customFragmentShaderID)),
      O.defines !== void 0)
    )
      for (const W in O.defines) U.push(W), U.push(O.defines[W]);
    return (
      O.isRawShaderMaterial === !1 &&
        (w(U, O), D(U, O), U.push(s.outputColorSpace)),
      U.push(O.customProgramCacheKey),
      U.join()
    );
  }
  function w(O, U) {
    O.push(U.precision),
      O.push(U.outputColorSpace),
      O.push(U.envMapMode),
      O.push(U.envMapCubeUVHeight),
      O.push(U.mapUv),
      O.push(U.alphaMapUv),
      O.push(U.lightMapUv),
      O.push(U.aoMapUv),
      O.push(U.bumpMapUv),
      O.push(U.normalMapUv),
      O.push(U.displacementMapUv),
      O.push(U.emissiveMapUv),
      O.push(U.metalnessMapUv),
      O.push(U.roughnessMapUv),
      O.push(U.anisotropyMapUv),
      O.push(U.clearcoatMapUv),
      O.push(U.clearcoatNormalMapUv),
      O.push(U.clearcoatRoughnessMapUv),
      O.push(U.iridescenceMapUv),
      O.push(U.iridescenceThicknessMapUv),
      O.push(U.sheenColorMapUv),
      O.push(U.sheenRoughnessMapUv),
      O.push(U.specularMapUv),
      O.push(U.specularColorMapUv),
      O.push(U.specularIntensityMapUv),
      O.push(U.transmissionMapUv),
      O.push(U.thicknessMapUv),
      O.push(U.combine),
      O.push(U.fogExp2),
      O.push(U.sizeAttenuation),
      O.push(U.morphTargetsCount),
      O.push(U.morphAttributeCount),
      O.push(U.numDirLights),
      O.push(U.numPointLights),
      O.push(U.numSpotLights),
      O.push(U.numSpotLightMaps),
      O.push(U.numHemiLights),
      O.push(U.numRectAreaLights),
      O.push(U.numDirLightShadows),
      O.push(U.numPointLightShadows),
      O.push(U.numSpotLightShadows),
      O.push(U.numSpotLightShadowsWithMaps),
      O.push(U.numLightProbes),
      O.push(U.shadowMapType),
      O.push(U.toneMapping),
      O.push(U.numClippingPlanes),
      O.push(U.numClipIntersection),
      O.push(U.depthPacking);
  }
  function D(O, U) {
    u.disableAll(),
      U.supportsVertexTextures && u.enable(0),
      U.instancing && u.enable(1),
      U.instancingColor && u.enable(2),
      U.instancingMorph && u.enable(3),
      U.matcap && u.enable(4),
      U.envMap && u.enable(5),
      U.normalMapObjectSpace && u.enable(6),
      U.normalMapTangentSpace && u.enable(7),
      U.clearcoat && u.enable(8),
      U.iridescence && u.enable(9),
      U.alphaTest && u.enable(10),
      U.vertexColors && u.enable(11),
      U.vertexAlphas && u.enable(12),
      U.vertexUv1s && u.enable(13),
      U.vertexUv2s && u.enable(14),
      U.vertexUv3s && u.enable(15),
      U.vertexTangents && u.enable(16),
      U.anisotropy && u.enable(17),
      U.alphaHash && u.enable(18),
      U.batching && u.enable(19),
      U.dispersion && u.enable(20),
      U.batchingColor && u.enable(21),
      O.push(u.mask),
      u.disableAll(),
      U.fog && u.enable(0),
      U.useFog && u.enable(1),
      U.flatShading && u.enable(2),
      U.logarithmicDepthBuffer && u.enable(3),
      U.reverseDepthBuffer && u.enable(4),
      U.skinning && u.enable(5),
      U.morphTargets && u.enable(6),
      U.morphNormals && u.enable(7),
      U.morphColors && u.enable(8),
      U.premultipliedAlpha && u.enable(9),
      U.shadowMapEnabled && u.enable(10),
      U.doubleSided && u.enable(11),
      U.flipSided && u.enable(12),
      U.useDepthPacking && u.enable(13),
      U.dithering && u.enable(14),
      U.transmission && u.enable(15),
      U.sheen && u.enable(16),
      U.opaque && u.enable(17),
      U.pointsUvs && u.enable(18),
      U.decodeVideoTexture && u.enable(19),
      U.decodeVideoTextureEmissive && u.enable(20),
      U.alphaToCoverage && u.enable(21),
      O.push(u.mask);
  }
  function B(O) {
    const U = M[O.type];
    let W;
    if (U) {
      const J = Bo[U];
      W = Ny.clone(J.uniforms);
    } else W = O.uniforms;
    return W;
  }
  function I(O, U) {
    let W;
    for (let J = 0, q = m.length; J < q; J++) {
      const Z = m[J];
      if (Z.cacheKey === U) {
        (W = Z), ++W.usedTimes;
        break;
      }
    }
    return W === void 0 && ((W = new _L(s, U, O, a)), m.push(W)), W;
  }
  function N(O) {
    if (--O.usedTimes === 0) {
      const U = m.indexOf(O);
      (m[U] = m[m.length - 1]), m.pop(), O.destroy();
    }
  }
  function P(O) {
    f.remove(O);
  }
  function F() {
    f.dispose();
  }
  return {
    getParameters: E,
    getProgramCacheKey: b,
    getUniforms: B,
    acquireProgram: I,
    releaseProgram: N,
    releaseShaderCache: P,
    programs: m,
    dispose: F,
  };
}
function bL() {
  let s = new WeakMap();
  function e(l) {
    return s.has(l);
  }
  function t(l) {
    let u = s.get(l);
    return u === void 0 && ((u = {}), s.set(l, u)), u;
  }
  function n(l) {
    s.delete(l);
  }
  function i(l, u, f) {
    s.get(l)[u] = f;
  }
  function a() {
    s = new WeakMap();
  }
  return { has: e, get: t, remove: n, update: i, dispose: a };
}
function EL(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.material.id !== e.material.id
    ? s.material.id - e.material.id
    : s.z !== e.z
    ? s.z - e.z
    : s.id - e.id;
}
function mb(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.z !== e.z
    ? e.z - s.z
    : s.id - e.id;
}
function gb() {
  const s = [];
  let e = 0;
  const t = [],
    n = [],
    i = [];
  function a() {
    (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
  }
  function l(v, _, A, M, T, E) {
    let b = s[e];
    return (
      b === void 0
        ? ((b = {
            id: v.id,
            object: v,
            geometry: _,
            material: A,
            groupOrder: M,
            renderOrder: v.renderOrder,
            z: T,
            group: E,
          }),
          (s[e] = b))
        : ((b.id = v.id),
          (b.object = v),
          (b.geometry = _),
          (b.material = A),
          (b.groupOrder = M),
          (b.renderOrder = v.renderOrder),
          (b.z = T),
          (b.group = E)),
      e++,
      b
    );
  }
  function u(v, _, A, M, T, E) {
    const b = l(v, _, A, M, T, E);
    A.transmission > 0
      ? n.push(b)
      : A.transparent === !0
      ? i.push(b)
      : t.push(b);
  }
  function f(v, _, A, M, T, E) {
    const b = l(v, _, A, M, T, E);
    A.transmission > 0
      ? n.unshift(b)
      : A.transparent === !0
      ? i.unshift(b)
      : t.unshift(b);
  }
  function d(v, _) {
    t.length > 1 && t.sort(v || EL),
      n.length > 1 && n.sort(_ || mb),
      i.length > 1 && i.sort(_ || mb);
  }
  function m() {
    for (let v = e, _ = s.length; v < _; v++) {
      const A = s[v];
      if (A.id === null) break;
      (A.id = null),
        (A.object = null),
        (A.geometry = null),
        (A.material = null),
        (A.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: a,
    push: u,
    unshift: f,
    finish: m,
    sort: d,
  };
}
function TL() {
  let s = new WeakMap();
  function e(n, i) {
    const a = s.get(n);
    let l;
    return (
      a === void 0
        ? ((l = new gb()), s.set(n, [l]))
        : i >= a.length
        ? ((l = new gb()), a.push(l))
        : (l = a[i]),
      l
    );
  }
  function t() {
    s = new WeakMap();
  }
  return { get: e, dispose: t };
}
function CL() {
  const s = {};
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new ie(), color: new Dt() };
          break;
        case "SpotLight":
          t = {
            position: new ie(),
            direction: new ie(),
            color: new Dt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new ie(), color: new Dt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = {
            direction: new ie(),
            skyColor: new Dt(),
            groundColor: new Dt(),
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Dt(),
            position: new ie(),
            halfWidth: new ie(),
            halfHeight: new ie(),
          };
          break;
      }
      return (s[e.id] = t), t;
    },
  };
}
function RL() {
  const s = {};
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new at(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new at(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new at(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (s[e.id] = t), t;
    },
  };
}
let wL = 0;
function BL(s, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (s.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (s.map ? 1 : 0)
  );
}
function DL(s) {
  const e = new CL(),
    t = RL(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let d = 0; d < 9; d++) n.probe.push(new ie());
  const i = new ie(),
    a = new Qt(),
    l = new Qt();
  function u(d) {
    let m = 0,
      v = 0,
      _ = 0;
    for (let O = 0; O < 9; O++) n.probe[O].set(0, 0, 0);
    let A = 0,
      M = 0,
      T = 0,
      E = 0,
      b = 0,
      w = 0,
      D = 0,
      B = 0,
      I = 0,
      N = 0,
      P = 0;
    d.sort(BL);
    for (let O = 0, U = d.length; O < U; O++) {
      const W = d[O],
        J = W.color,
        q = W.intensity,
        Z = W.distance,
        ue = W.shadow && W.shadow.map ? W.shadow.map.texture : null;
      if (W.isAmbientLight) (m += J.r * q), (v += J.g * q), (_ += J.b * q);
      else if (W.isLightProbe) {
        for (let K = 0; K < 9; K++)
          n.probe[K].addScaledVector(W.sh.coefficients[K], q);
        P++;
      } else if (W.isDirectionalLight) {
        const K = e.get(W);
        if ((K.color.copy(W.color).multiplyScalar(W.intensity), W.castShadow)) {
          const ge = W.shadow,
            oe = t.get(W);
          (oe.shadowIntensity = ge.intensity),
            (oe.shadowBias = ge.bias),
            (oe.shadowNormalBias = ge.normalBias),
            (oe.shadowRadius = ge.radius),
            (oe.shadowMapSize = ge.mapSize),
            (n.directionalShadow[A] = oe),
            (n.directionalShadowMap[A] = ue),
            (n.directionalShadowMatrix[A] = W.shadow.matrix),
            w++;
        }
        (n.directional[A] = K), A++;
      } else if (W.isSpotLight) {
        const K = e.get(W);
        K.position.setFromMatrixPosition(W.matrixWorld),
          K.color.copy(J).multiplyScalar(q),
          (K.distance = Z),
          (K.coneCos = Math.cos(W.angle)),
          (K.penumbraCos = Math.cos(W.angle * (1 - W.penumbra))),
          (K.decay = W.decay),
          (n.spot[T] = K);
        const ge = W.shadow;
        if (
          (W.map &&
            ((n.spotLightMap[I] = W.map),
            I++,
            ge.updateMatrices(W),
            W.castShadow && N++),
          (n.spotLightMatrix[T] = ge.matrix),
          W.castShadow)
        ) {
          const oe = t.get(W);
          (oe.shadowIntensity = ge.intensity),
            (oe.shadowBias = ge.bias),
            (oe.shadowNormalBias = ge.normalBias),
            (oe.shadowRadius = ge.radius),
            (oe.shadowMapSize = ge.mapSize),
            (n.spotShadow[T] = oe),
            (n.spotShadowMap[T] = ue),
            B++;
        }
        T++;
      } else if (W.isRectAreaLight) {
        const K = e.get(W);
        K.color.copy(J).multiplyScalar(q),
          K.halfWidth.set(W.width * 0.5, 0, 0),
          K.halfHeight.set(0, W.height * 0.5, 0),
          (n.rectArea[E] = K),
          E++;
      } else if (W.isPointLight) {
        const K = e.get(W);
        if (
          (K.color.copy(W.color).multiplyScalar(W.intensity),
          (K.distance = W.distance),
          (K.decay = W.decay),
          W.castShadow)
        ) {
          const ge = W.shadow,
            oe = t.get(W);
          (oe.shadowIntensity = ge.intensity),
            (oe.shadowBias = ge.bias),
            (oe.shadowNormalBias = ge.normalBias),
            (oe.shadowRadius = ge.radius),
            (oe.shadowMapSize = ge.mapSize),
            (oe.shadowCameraNear = ge.camera.near),
            (oe.shadowCameraFar = ge.camera.far),
            (n.pointShadow[M] = oe),
            (n.pointShadowMap[M] = ue),
            (n.pointShadowMatrix[M] = W.shadow.matrix),
            D++;
        }
        (n.point[M] = K), M++;
      } else if (W.isHemisphereLight) {
        const K = e.get(W);
        K.skyColor.copy(W.color).multiplyScalar(q),
          K.groundColor.copy(W.groundColor).multiplyScalar(q),
          (n.hemi[b] = K),
          b++;
      }
    }
    E > 0 &&
      (s.has("OES_texture_float_linear") === !0
        ? ((n.rectAreaLTC1 = Lt.LTC_FLOAT_1), (n.rectAreaLTC2 = Lt.LTC_FLOAT_2))
        : ((n.rectAreaLTC1 = Lt.LTC_HALF_1), (n.rectAreaLTC2 = Lt.LTC_HALF_2))),
      (n.ambient[0] = m),
      (n.ambient[1] = v),
      (n.ambient[2] = _);
    const F = n.hash;
    (F.directionalLength !== A ||
      F.pointLength !== M ||
      F.spotLength !== T ||
      F.rectAreaLength !== E ||
      F.hemiLength !== b ||
      F.numDirectionalShadows !== w ||
      F.numPointShadows !== D ||
      F.numSpotShadows !== B ||
      F.numSpotMaps !== I ||
      F.numLightProbes !== P) &&
      ((n.directional.length = A),
      (n.spot.length = T),
      (n.rectArea.length = E),
      (n.point.length = M),
      (n.hemi.length = b),
      (n.directionalShadow.length = w),
      (n.directionalShadowMap.length = w),
      (n.pointShadow.length = D),
      (n.pointShadowMap.length = D),
      (n.spotShadow.length = B),
      (n.spotShadowMap.length = B),
      (n.directionalShadowMatrix.length = w),
      (n.pointShadowMatrix.length = D),
      (n.spotLightMatrix.length = B + I - N),
      (n.spotLightMap.length = I),
      (n.numSpotLightShadowsWithMaps = N),
      (n.numLightProbes = P),
      (F.directionalLength = A),
      (F.pointLength = M),
      (F.spotLength = T),
      (F.rectAreaLength = E),
      (F.hemiLength = b),
      (F.numDirectionalShadows = w),
      (F.numPointShadows = D),
      (F.numSpotShadows = B),
      (F.numSpotMaps = I),
      (F.numLightProbes = P),
      (n.version = wL++));
  }
  function f(d, m) {
    let v = 0,
      _ = 0,
      A = 0,
      M = 0,
      T = 0;
    const E = m.matrixWorldInverse;
    for (let b = 0, w = d.length; b < w; b++) {
      const D = d[b];
      if (D.isDirectionalLight) {
        const B = n.directional[v];
        B.direction.setFromMatrixPosition(D.matrixWorld),
          i.setFromMatrixPosition(D.target.matrixWorld),
          B.direction.sub(i),
          B.direction.transformDirection(E),
          v++;
      } else if (D.isSpotLight) {
        const B = n.spot[A];
        B.position.setFromMatrixPosition(D.matrixWorld),
          B.position.applyMatrix4(E),
          B.direction.setFromMatrixPosition(D.matrixWorld),
          i.setFromMatrixPosition(D.target.matrixWorld),
          B.direction.sub(i),
          B.direction.transformDirection(E),
          A++;
      } else if (D.isRectAreaLight) {
        const B = n.rectArea[M];
        B.position.setFromMatrixPosition(D.matrixWorld),
          B.position.applyMatrix4(E),
          l.identity(),
          a.copy(D.matrixWorld),
          a.premultiply(E),
          l.extractRotation(a),
          B.halfWidth.set(D.width * 0.5, 0, 0),
          B.halfHeight.set(0, D.height * 0.5, 0),
          B.halfWidth.applyMatrix4(l),
          B.halfHeight.applyMatrix4(l),
          M++;
      } else if (D.isPointLight) {
        const B = n.point[_];
        B.position.setFromMatrixPosition(D.matrixWorld),
          B.position.applyMatrix4(E),
          _++;
      } else if (D.isHemisphereLight) {
        const B = n.hemi[T];
        B.direction.setFromMatrixPosition(D.matrixWorld),
          B.direction.transformDirection(E),
          T++;
      }
    }
  }
  return { setup: u, setupView: f, state: n };
}
function vb(s) {
  const e = new DL(s),
    t = [],
    n = [];
  function i(m) {
    (d.camera = m), (t.length = 0), (n.length = 0);
  }
  function a(m) {
    t.push(m);
  }
  function l(m) {
    n.push(m);
  }
  function u() {
    e.setup(t);
  }
  function f(m) {
    e.setupView(t, m);
  }
  const d = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: i,
    state: d,
    setupLights: u,
    setupLightsView: f,
    pushLight: a,
    pushShadow: l,
  };
}
function UL(s) {
  let e = new WeakMap();
  function t(i, a = 0) {
    const l = e.get(i);
    let u;
    return (
      l === void 0
        ? ((u = new vb(s)), e.set(i, [u]))
        : a >= l.length
        ? ((u = new vb(s)), l.push(u))
        : (u = l[a]),
      u
    );
  }
  function n() {
    e = new WeakMap();
  }
  return { get: t, dispose: n };
}
const OL = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  LL = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function NL(s, e, t) {
  let n = new jm();
  const i = new at(),
    a = new at(),
    l = new Hn(),
    u = new n_({ depthPacking: QA }),
    f = new i_(),
    d = {},
    m = t.maxTextureSize,
    v = { [Tl]: hr, [hr]: Tl, [jr]: jr },
    _ = new ra({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new at() },
        radius: { value: 4 },
      },
      vertexShader: OL,
      fragmentShader: LL,
    }),
    A = _.clone();
  A.defines.HORIZONTAL_PASS = 1;
  const M = new mn();
  M.setAttribute(
    "position",
    new Yn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const T = new li(M, _),
    E = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = by);
  let b = this.type;
  this.render = function (N, P, F) {
    if (
      E.enabled === !1 ||
      (E.autoUpdate === !1 && E.needsUpdate === !1) ||
      N.length === 0
    )
      return;
    const O = s.getRenderTarget(),
      U = s.getActiveCubeFace(),
      W = s.getActiveMipmapLevel(),
      J = s.state;
    J.setBlending(Ml),
      J.buffers.color.setClear(1, 1, 1, 1),
      J.buffers.depth.setTest(!0),
      J.setScissorTest(!1);
    const q = b !== wo && this.type === wo,
      Z = b === wo && this.type !== wo;
    for (let ue = 0, K = N.length; ue < K; ue++) {
      const ge = N[ue],
        oe = ge.shadow;
      if (oe === void 0) {
        console.warn("THREE.WebGLShadowMap:", ge, "has no shadow.");
        continue;
      }
      if (oe.autoUpdate === !1 && oe.needsUpdate === !1) continue;
      i.copy(oe.mapSize);
      const me = oe.getFrameExtents();
      if (
        (i.multiply(me),
        a.copy(oe.mapSize),
        (i.x > m || i.y > m) &&
          (i.x > m &&
            ((a.x = Math.floor(m / me.x)),
            (i.x = a.x * me.x),
            (oe.mapSize.x = a.x)),
          i.y > m &&
            ((a.y = Math.floor(m / me.y)),
            (i.y = a.y * me.y),
            (oe.mapSize.y = a.y))),
        oe.map === null || q === !0 || Z === !0)
      ) {
        const Y = this.type !== wo ? { minFilter: Kn, magFilter: Kn } : {};
        oe.map !== null && oe.map.dispose(),
          (oe.map = new ha(i.x, i.y, Y)),
          (oe.map.texture.name = ge.name + ".shadowMap"),
          oe.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(oe.map), s.clear();
      const V = oe.getViewportCount();
      for (let Y = 0; Y < V; Y++) {
        const ae = oe.getViewport(Y);
        l.set(a.x * ae.x, a.y * ae.y, a.x * ae.z, a.y * ae.w),
          J.viewport(l),
          oe.updateMatrices(ge, Y),
          (n = oe.getFrustum()),
          B(P, F, oe.camera, ge, this.type);
      }
      oe.isPointLightShadow !== !0 && this.type === wo && w(oe, F),
        (oe.needsUpdate = !1);
    }
    (b = this.type), (E.needsUpdate = !1), s.setRenderTarget(O, U, W);
  };
  function w(N, P) {
    const F = e.update(T);
    _.defines.VSM_SAMPLES !== N.blurSamples &&
      ((_.defines.VSM_SAMPLES = N.blurSamples),
      (A.defines.VSM_SAMPLES = N.blurSamples),
      (_.needsUpdate = !0),
      (A.needsUpdate = !0)),
      N.mapPass === null && (N.mapPass = new ha(i.x, i.y)),
      (_.uniforms.shadow_pass.value = N.map.texture),
      (_.uniforms.resolution.value = N.mapSize),
      (_.uniforms.radius.value = N.radius),
      s.setRenderTarget(N.mapPass),
      s.clear(),
      s.renderBufferDirect(P, null, F, _, T, null),
      (A.uniforms.shadow_pass.value = N.mapPass.texture),
      (A.uniforms.resolution.value = N.mapSize),
      (A.uniforms.radius.value = N.radius),
      s.setRenderTarget(N.map),
      s.clear(),
      s.renderBufferDirect(P, null, F, A, T, null);
  }
  function D(N, P, F, O) {
    let U = null;
    const W =
      F.isPointLight === !0 ? N.customDistanceMaterial : N.customDepthMaterial;
    if (W !== void 0) U = W;
    else if (
      ((U = F.isPointLight === !0 ? f : u),
      (s.localClippingEnabled &&
        P.clipShadows === !0 &&
        Array.isArray(P.clippingPlanes) &&
        P.clippingPlanes.length !== 0) ||
        (P.displacementMap && P.displacementScale !== 0) ||
        (P.alphaMap && P.alphaTest > 0) ||
        (P.map && P.alphaTest > 0))
    ) {
      const J = U.uuid,
        q = P.uuid;
      let Z = d[J];
      Z === void 0 && ((Z = {}), (d[J] = Z));
      let ue = Z[q];
      ue === void 0 &&
        ((ue = U.clone()), (Z[q] = ue), P.addEventListener("dispose", I)),
        (U = ue);
    }
    if (
      ((U.visible = P.visible),
      (U.wireframe = P.wireframe),
      O === wo
        ? (U.side = P.shadowSide !== null ? P.shadowSide : P.side)
        : (U.side = P.shadowSide !== null ? P.shadowSide : v[P.side]),
      (U.alphaMap = P.alphaMap),
      (U.alphaTest = P.alphaTest),
      (U.map = P.map),
      (U.clipShadows = P.clipShadows),
      (U.clippingPlanes = P.clippingPlanes),
      (U.clipIntersection = P.clipIntersection),
      (U.displacementMap = P.displacementMap),
      (U.displacementScale = P.displacementScale),
      (U.displacementBias = P.displacementBias),
      (U.wireframeLinewidth = P.wireframeLinewidth),
      (U.linewidth = P.linewidth),
      F.isPointLight === !0 && U.isMeshDistanceMaterial === !0)
    ) {
      const J = s.properties.get(U);
      J.light = F;
    }
    return U;
  }
  function B(N, P, F, O, U) {
    if (N.visible === !1) return;
    if (
      N.layers.test(P.layers) &&
      (N.isMesh || N.isLine || N.isPoints) &&
      (N.castShadow || (N.receiveShadow && U === wo)) &&
      (!N.frustumCulled || n.intersectsObject(N))
    ) {
      N.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse, N.matrixWorld);
      const q = e.update(N),
        Z = N.material;
      if (Array.isArray(Z)) {
        const ue = q.groups;
        for (let K = 0, ge = ue.length; K < ge; K++) {
          const oe = ue[K],
            me = Z[oe.materialIndex];
          if (me && me.visible) {
            const V = D(N, me, O, U);
            N.onBeforeShadow(s, N, P, F, q, V, oe),
              s.renderBufferDirect(F, null, q, V, N, oe),
              N.onAfterShadow(s, N, P, F, q, V, oe);
          }
        }
      } else if (Z.visible) {
        const ue = D(N, Z, O, U);
        N.onBeforeShadow(s, N, P, F, q, ue, null),
          s.renderBufferDirect(F, null, q, ue, N, null),
          N.onAfterShadow(s, N, P, F, q, ue, null);
      }
    }
    const J = N.children;
    for (let q = 0, Z = J.length; q < Z; q++) B(J[q], P, F, O, U);
  }
  function I(N) {
    N.target.removeEventListener("dispose", I);
    for (const F in d) {
      const O = d[F],
        U = N.target.uuid;
      U in O && (O[U].dispose(), delete O[U]);
    }
  }
}
const IL = {
  [O0]: L0,
  [N0]: P0,
  [I0]: G0,
  [Yf]: F0,
  [L0]: O0,
  [P0]: N0,
  [G0]: I0,
  [F0]: Yf,
};
function FL(s, e) {
  function t() {
    let ce = !1;
    const xe = new Hn();
    let Re = null;
    const Qe = new Hn(0, 0, 0, 0);
    return {
      setMask: function (gt) {
        Re !== gt && !ce && (s.colorMask(gt, gt, gt, gt), (Re = gt));
      },
      setLocked: function (gt) {
        ce = gt;
      },
      setClear: function (gt, dt, Ct, Ht, Nt) {
        Nt === !0 && ((gt *= Ht), (dt *= Ht), (Ct *= Ht)),
          xe.set(gt, dt, Ct, Ht),
          Qe.equals(xe) === !1 && (s.clearColor(gt, dt, Ct, Ht), Qe.copy(xe));
      },
      reset: function () {
        (ce = !1), (Re = null), Qe.set(-1, 0, 0, 0);
      },
    };
  }
  function n() {
    let ce = !1,
      xe = !1,
      Re = null,
      Qe = null,
      gt = null;
    return {
      setReversed: function (dt) {
        if (xe !== dt) {
          const Ct = e.get("EXT_clip_control");
          xe
            ? Ct.clipControlEXT(Ct.LOWER_LEFT_EXT, Ct.ZERO_TO_ONE_EXT)
            : Ct.clipControlEXT(Ct.LOWER_LEFT_EXT, Ct.NEGATIVE_ONE_TO_ONE_EXT);
          const Ht = gt;
          (gt = null), this.setClear(Ht);
        }
        xe = dt;
      },
      getReversed: function () {
        return xe;
      },
      setTest: function (dt) {
        dt ? ye(s.DEPTH_TEST) : be(s.DEPTH_TEST);
      },
      setMask: function (dt) {
        Re !== dt && !ce && (s.depthMask(dt), (Re = dt));
      },
      setFunc: function (dt) {
        if ((xe && (dt = IL[dt]), Qe !== dt)) {
          switch (dt) {
            case O0:
              s.depthFunc(s.NEVER);
              break;
            case L0:
              s.depthFunc(s.ALWAYS);
              break;
            case N0:
              s.depthFunc(s.LESS);
              break;
            case Yf:
              s.depthFunc(s.LEQUAL);
              break;
            case I0:
              s.depthFunc(s.EQUAL);
              break;
            case F0:
              s.depthFunc(s.GEQUAL);
              break;
            case P0:
              s.depthFunc(s.GREATER);
              break;
            case G0:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          Qe = dt;
        }
      },
      setLocked: function (dt) {
        ce = dt;
      },
      setClear: function (dt) {
        gt !== dt && (xe && (dt = 1 - dt), s.clearDepth(dt), (gt = dt));
      },
      reset: function () {
        (ce = !1), (Re = null), (Qe = null), (gt = null), (xe = !1);
      },
    };
  }
  function i() {
    let ce = !1,
      xe = null,
      Re = null,
      Qe = null,
      gt = null,
      dt = null,
      Ct = null,
      Ht = null,
      Nt = null;
    return {
      setTest: function (Ft) {
        ce || (Ft ? ye(s.STENCIL_TEST) : be(s.STENCIL_TEST));
      },
      setMask: function (Ft) {
        xe !== Ft && !ce && (s.stencilMask(Ft), (xe = Ft));
      },
      setFunc: function (Ft, gn, vn) {
        (Re !== Ft || Qe !== gn || gt !== vn) &&
          (s.stencilFunc(Ft, gn, vn), (Re = Ft), (Qe = gn), (gt = vn));
      },
      setOp: function (Ft, gn, vn) {
        (dt !== Ft || Ct !== gn || Ht !== vn) &&
          (s.stencilOp(Ft, gn, vn), (dt = Ft), (Ct = gn), (Ht = vn));
      },
      setLocked: function (Ft) {
        ce = Ft;
      },
      setClear: function (Ft) {
        Nt !== Ft && (s.clearStencil(Ft), (Nt = Ft));
      },
      reset: function () {
        (ce = !1),
          (xe = null),
          (Re = null),
          (Qe = null),
          (gt = null),
          (dt = null),
          (Ct = null),
          (Ht = null),
          (Nt = null);
      },
    };
  }
  const a = new t(),
    l = new n(),
    u = new i(),
    f = new WeakMap(),
    d = new WeakMap();
  let m = {},
    v = {},
    _ = new WeakMap(),
    A = [],
    M = null,
    T = !1,
    E = null,
    b = null,
    w = null,
    D = null,
    B = null,
    I = null,
    N = null,
    P = new Dt(0, 0, 0),
    F = 0,
    O = !1,
    U = null,
    W = null,
    J = null,
    q = null,
    Z = null;
  const ue = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let K = !1,
    ge = 0;
  const oe = s.getParameter(s.VERSION);
  oe.indexOf("WebGL") !== -1
    ? ((ge = parseFloat(/^WebGL (\d)/.exec(oe)[1])), (K = ge >= 1))
    : oe.indexOf("OpenGL ES") !== -1 &&
      ((ge = parseFloat(/^OpenGL ES (\d)/.exec(oe)[1])), (K = ge >= 2));
  let me = null,
    V = {};
  const Y = s.getParameter(s.SCISSOR_BOX),
    ae = s.getParameter(s.VIEWPORT),
    fe = new Hn().fromArray(Y),
    j = new Hn().fromArray(ae);
  function se(ce, xe, Re, Qe) {
    const gt = new Uint8Array(4),
      dt = s.createTexture();
    s.bindTexture(ce, dt),
      s.texParameteri(ce, s.TEXTURE_MIN_FILTER, s.NEAREST),
      s.texParameteri(ce, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let Ct = 0; Ct < Re; Ct++)
      ce === s.TEXTURE_3D || ce === s.TEXTURE_2D_ARRAY
        ? s.texImage3D(xe, 0, s.RGBA, 1, 1, Qe, 0, s.RGBA, s.UNSIGNED_BYTE, gt)
        : s.texImage2D(
            xe + Ct,
            0,
            s.RGBA,
            1,
            1,
            0,
            s.RGBA,
            s.UNSIGNED_BYTE,
            gt
          );
    return dt;
  }
  const ve = {};
  (ve[s.TEXTURE_2D] = se(s.TEXTURE_2D, s.TEXTURE_2D, 1)),
    (ve[s.TEXTURE_CUBE_MAP] = se(
      s.TEXTURE_CUBE_MAP,
      s.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (ve[s.TEXTURE_2D_ARRAY] = se(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1)),
    (ve[s.TEXTURE_3D] = se(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1)),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    u.setClear(0),
    ye(s.DEPTH_TEST),
    l.setFunc(Yf),
    Pe(!1),
    rt(fA),
    ye(s.CULL_FACE),
    $(Ml);
  function ye(ce) {
    m[ce] !== !0 && (s.enable(ce), (m[ce] = !0));
  }
  function be(ce) {
    m[ce] !== !1 && (s.disable(ce), (m[ce] = !1));
  }
  function it(ce, xe) {
    return v[ce] !== xe
      ? (s.bindFramebuffer(ce, xe),
        (v[ce] = xe),
        ce === s.DRAW_FRAMEBUFFER && (v[s.FRAMEBUFFER] = xe),
        ce === s.FRAMEBUFFER && (v[s.DRAW_FRAMEBUFFER] = xe),
        !0)
      : !1;
  }
  function We(ce, xe) {
    let Re = A,
      Qe = !1;
    if (ce) {
      (Re = _.get(xe)), Re === void 0 && ((Re = []), _.set(xe, Re));
      const gt = ce.textures;
      if (Re.length !== gt.length || Re[0] !== s.COLOR_ATTACHMENT0) {
        for (let dt = 0, Ct = gt.length; dt < Ct; dt++)
          Re[dt] = s.COLOR_ATTACHMENT0 + dt;
        (Re.length = gt.length), (Qe = !0);
      }
    } else Re[0] !== s.BACK && ((Re[0] = s.BACK), (Qe = !0));
    Qe && s.drawBuffers(Re);
  }
  function $e(ce) {
    return M !== ce ? (s.useProgram(ce), (M = ce), !0) : !1;
  }
  const Me = {
    [mc]: s.FUNC_ADD,
    [hE]: s.FUNC_SUBTRACT,
    [dE]: s.FUNC_REVERSE_SUBTRACT,
  };
  (Me[pE] = s.MIN), (Me[mE] = s.MAX);
  const Ie = {
    [gE]: s.ZERO,
    [vE]: s.ONE,
    [yE]: s.SRC_COLOR,
    [D0]: s.SRC_ALPHA,
    [bE]: s.SRC_ALPHA_SATURATE,
    [SE]: s.DST_COLOR,
    [AE]: s.DST_ALPHA,
    [_E]: s.ONE_MINUS_SRC_COLOR,
    [U0]: s.ONE_MINUS_SRC_ALPHA,
    [ME]: s.ONE_MINUS_DST_COLOR,
    [xE]: s.ONE_MINUS_DST_ALPHA,
    [EE]: s.CONSTANT_COLOR,
    [TE]: s.ONE_MINUS_CONSTANT_COLOR,
    [CE]: s.CONSTANT_ALPHA,
    [RE]: s.ONE_MINUS_CONSTANT_ALPHA,
  };
  function $(ce, xe, Re, Qe, gt, dt, Ct, Ht, Nt, Ft) {
    if (ce === Ml) {
      T === !0 && (be(s.BLEND), (T = !1));
      return;
    }
    if ((T === !1 && (ye(s.BLEND), (T = !0)), ce !== fE)) {
      if (ce !== E || Ft !== O) {
        if (
          ((b !== mc || B !== mc) &&
            (s.blendEquation(s.FUNC_ADD), (b = mc), (B = mc)),
          Ft)
        )
          switch (ce) {
            case Hf:
              s.blendFuncSeparate(
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA,
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA
              );
              break;
            case hA:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case dA:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case pA:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ce);
              break;
          }
        else
          switch (ce) {
            case Hf:
              s.blendFuncSeparate(
                s.SRC_ALPHA,
                s.ONE_MINUS_SRC_ALPHA,
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA
              );
              break;
            case hA:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case dA:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case pA:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ce);
              break;
          }
        (w = null),
          (D = null),
          (I = null),
          (N = null),
          P.set(0, 0, 0),
          (F = 0),
          (E = ce),
          (O = Ft);
      }
      return;
    }
    (gt = gt || xe),
      (dt = dt || Re),
      (Ct = Ct || Qe),
      (xe !== b || gt !== B) &&
        (s.blendEquationSeparate(Me[xe], Me[gt]), (b = xe), (B = gt)),
      (Re !== w || Qe !== D || dt !== I || Ct !== N) &&
        (s.blendFuncSeparate(Ie[Re], Ie[Qe], Ie[dt], Ie[Ct]),
        (w = Re),
        (D = Qe),
        (I = dt),
        (N = Ct)),
      (Ht.equals(P) === !1 || Nt !== F) &&
        (s.blendColor(Ht.r, Ht.g, Ht.b, Nt), P.copy(Ht), (F = Nt)),
      (E = ce),
      (O = !1);
  }
  function ft(ce, xe) {
    ce.side === jr ? be(s.CULL_FACE) : ye(s.CULL_FACE);
    let Re = ce.side === hr;
    xe && (Re = !Re),
      Pe(Re),
      ce.blending === Hf && ce.transparent === !1
        ? $(Ml)
        : $(
            ce.blending,
            ce.blendEquation,
            ce.blendSrc,
            ce.blendDst,
            ce.blendEquationAlpha,
            ce.blendSrcAlpha,
            ce.blendDstAlpha,
            ce.blendColor,
            ce.blendAlpha,
            ce.premultipliedAlpha
          ),
      l.setFunc(ce.depthFunc),
      l.setTest(ce.depthTest),
      l.setMask(ce.depthWrite),
      a.setMask(ce.colorWrite);
    const Qe = ce.stencilWrite;
    u.setTest(Qe),
      Qe &&
        (u.setMask(ce.stencilWriteMask),
        u.setFunc(ce.stencilFunc, ce.stencilRef, ce.stencilFuncMask),
        u.setOp(ce.stencilFail, ce.stencilZFail, ce.stencilZPass)),
      ht(ce.polygonOffset, ce.polygonOffsetFactor, ce.polygonOffsetUnits),
      ce.alphaToCoverage === !0
        ? ye(s.SAMPLE_ALPHA_TO_COVERAGE)
        : be(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Pe(ce) {
    U !== ce && (ce ? s.frontFace(s.CW) : s.frontFace(s.CCW), (U = ce));
  }
  function rt(ce) {
    ce !== lE
      ? (ye(s.CULL_FACE),
        ce !== W &&
          (ce === fA
            ? s.cullFace(s.BACK)
            : ce === uE
            ? s.cullFace(s.FRONT)
            : s.cullFace(s.FRONT_AND_BACK)))
      : be(s.CULL_FACE),
      (W = ce);
  }
  function Ue(ce) {
    ce !== J && (K && s.lineWidth(ce), (J = ce));
  }
  function ht(ce, xe, Re) {
    ce
      ? (ye(s.POLYGON_OFFSET_FILL),
        (q !== xe || Z !== Re) && (s.polygonOffset(xe, Re), (q = xe), (Z = Re)))
      : be(s.POLYGON_OFFSET_FILL);
  }
  function Ve(ce) {
    ce ? ye(s.SCISSOR_TEST) : be(s.SCISSOR_TEST);
  }
  function X(ce) {
    ce === void 0 && (ce = s.TEXTURE0 + ue - 1),
      me !== ce && (s.activeTexture(ce), (me = ce));
  }
  function k(ce, xe, Re) {
    Re === void 0 && (me === null ? (Re = s.TEXTURE0 + ue - 1) : (Re = me));
    let Qe = V[Re];
    Qe === void 0 && ((Qe = { type: void 0, texture: void 0 }), (V[Re] = Qe)),
      (Qe.type !== ce || Qe.texture !== xe) &&
        (me !== Re && (s.activeTexture(Re), (me = Re)),
        s.bindTexture(ce, xe || ve[ce]),
        (Qe.type = ce),
        (Qe.texture = xe));
  }
  function de() {
    const ce = V[me];
    ce !== void 0 &&
      ce.type !== void 0 &&
      (s.bindTexture(ce.type, null), (ce.type = void 0), (ce.texture = void 0));
  }
  function Ee() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (ce) {
      console.error("THREE.WebGLState:", ce);
    }
  }
  function we() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (ce) {
      console.error("THREE.WebGLState:", ce);
    }
  }
  function He() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (ce) {
      console.error("THREE.WebGLState:", ce);
    }
  }
  function tt() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (ce) {
      console.error("THREE.WebGLState:", ce);
    }
  }
  function Ke() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (ce) {
      console.error("THREE.WebGLState:", ce);
    }
  }
  function st() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (ce) {
      console.error("THREE.WebGLState:", ce);
    }
  }
  function Ut() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (ce) {
      console.error("THREE.WebGLState:", ce);
    }
  }
  function et() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (ce) {
      console.error("THREE.WebGLState:", ce);
    }
  }
  function At() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (ce) {
      console.error("THREE.WebGLState:", ce);
    }
  }
  function mt() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (ce) {
      console.error("THREE.WebGLState:", ce);
    }
  }
  function nt(ce) {
    fe.equals(ce) === !1 && (s.scissor(ce.x, ce.y, ce.z, ce.w), fe.copy(ce));
  }
  function Ze(ce) {
    j.equals(ce) === !1 && (s.viewport(ce.x, ce.y, ce.z, ce.w), j.copy(ce));
  }
  function le(ce, xe) {
    let Re = d.get(xe);
    Re === void 0 && ((Re = new WeakMap()), d.set(xe, Re));
    let Qe = Re.get(ce);
    Qe === void 0 &&
      ((Qe = s.getUniformBlockIndex(xe, ce.name)), Re.set(ce, Qe));
  }
  function Be(ce, xe) {
    const Qe = d.get(xe).get(ce);
    f.get(xe) !== Qe &&
      (s.uniformBlockBinding(xe, Qe, ce.__bindingPointIndex), f.set(xe, Qe));
  }
  function vt() {
    s.disable(s.BLEND),
      s.disable(s.CULL_FACE),
      s.disable(s.DEPTH_TEST),
      s.disable(s.POLYGON_OFFSET_FILL),
      s.disable(s.SCISSOR_TEST),
      s.disable(s.STENCIL_TEST),
      s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),
      s.blendEquation(s.FUNC_ADD),
      s.blendFunc(s.ONE, s.ZERO),
      s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO),
      s.blendColor(0, 0, 0, 0),
      s.colorMask(!0, !0, !0, !0),
      s.clearColor(0, 0, 0, 0),
      s.depthMask(!0),
      s.depthFunc(s.LESS),
      l.setReversed(!1),
      s.clearDepth(1),
      s.stencilMask(4294967295),
      s.stencilFunc(s.ALWAYS, 0, 4294967295),
      s.stencilOp(s.KEEP, s.KEEP, s.KEEP),
      s.clearStencil(0),
      s.cullFace(s.BACK),
      s.frontFace(s.CCW),
      s.polygonOffset(0, 0),
      s.activeTexture(s.TEXTURE0),
      s.bindFramebuffer(s.FRAMEBUFFER, null),
      s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
      s.bindFramebuffer(s.READ_FRAMEBUFFER, null),
      s.useProgram(null),
      s.lineWidth(1),
      s.scissor(0, 0, s.canvas.width, s.canvas.height),
      s.viewport(0, 0, s.canvas.width, s.canvas.height),
      (m = {}),
      (me = null),
      (V = {}),
      (v = {}),
      (_ = new WeakMap()),
      (A = []),
      (M = null),
      (T = !1),
      (E = null),
      (b = null),
      (w = null),
      (D = null),
      (B = null),
      (I = null),
      (N = null),
      (P = new Dt(0, 0, 0)),
      (F = 0),
      (O = !1),
      (U = null),
      (W = null),
      (J = null),
      (q = null),
      (Z = null),
      fe.set(0, 0, s.canvas.width, s.canvas.height),
      j.set(0, 0, s.canvas.width, s.canvas.height),
      a.reset(),
      l.reset(),
      u.reset();
  }
  return {
    buffers: { color: a, depth: l, stencil: u },
    enable: ye,
    disable: be,
    bindFramebuffer: it,
    drawBuffers: We,
    useProgram: $e,
    setBlending: $,
    setMaterial: ft,
    setFlipSided: Pe,
    setCullFace: rt,
    setLineWidth: Ue,
    setPolygonOffset: ht,
    setScissorTest: Ve,
    activeTexture: X,
    bindTexture: k,
    unbindTexture: de,
    compressedTexImage2D: Ee,
    compressedTexImage3D: we,
    texImage2D: At,
    texImage3D: mt,
    updateUBOMapping: le,
    uniformBlockBinding: Be,
    texStorage2D: Ut,
    texStorage3D: et,
    texSubImage2D: He,
    texSubImage3D: tt,
    compressedTexSubImage2D: Ke,
    compressedTexSubImage3D: st,
    scissor: nt,
    viewport: Ze,
    reset: vt,
  };
}
function PL(s, e, t, n, i, a, l) {
  const u = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    f =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    d = new at(),
    m = new WeakMap();
  let v;
  const _ = new WeakMap();
  let A = !1;
  try {
    A =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function M(X, k) {
    return A ? new OffscreenCanvas(X, k) : Lm("canvas");
  }
  function T(X, k, de) {
    let Ee = 1;
    const we = Ve(X);
    if (
      ((we.width > de || we.height > de) &&
        (Ee = de / Math.max(we.width, we.height)),
      Ee < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && X instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && X instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && X instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && X instanceof VideoFrame)
      ) {
        const He = Math.floor(Ee * we.width),
          tt = Math.floor(Ee * we.height);
        v === void 0 && (v = M(He, tt));
        const Ke = k ? M(He, tt) : v;
        return (
          (Ke.width = He),
          (Ke.height = tt),
          Ke.getContext("2d").drawImage(X, 0, 0, He, tt),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              we.width +
              "x" +
              we.height +
              ") to (" +
              He +
              "x" +
              tt +
              ")."
          ),
          Ke
        );
      } else
        return (
          "data" in X &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                we.width +
                "x" +
                we.height +
                ")."
            ),
          X
        );
    return X;
  }
  function E(X) {
    return X.generateMipmaps;
  }
  function b(X) {
    s.generateMipmap(X);
  }
  function w(X) {
    return X.isWebGLCubeRenderTarget
      ? s.TEXTURE_CUBE_MAP
      : X.isWebGL3DRenderTarget
      ? s.TEXTURE_3D
      : X.isWebGLArrayRenderTarget || X.isCompressedArrayTexture
      ? s.TEXTURE_2D_ARRAY
      : s.TEXTURE_2D;
  }
  function D(X, k, de, Ee, we = !1) {
    if (X !== null) {
      if (s[X] !== void 0) return s[X];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          X +
          "'"
      );
    }
    let He = k;
    if (
      (k === s.RED &&
        (de === s.FLOAT && (He = s.R32F),
        de === s.HALF_FLOAT && (He = s.R16F),
        de === s.UNSIGNED_BYTE && (He = s.R8)),
      k === s.RED_INTEGER &&
        (de === s.UNSIGNED_BYTE && (He = s.R8UI),
        de === s.UNSIGNED_SHORT && (He = s.R16UI),
        de === s.UNSIGNED_INT && (He = s.R32UI),
        de === s.BYTE && (He = s.R8I),
        de === s.SHORT && (He = s.R16I),
        de === s.INT && (He = s.R32I)),
      k === s.RG &&
        (de === s.FLOAT && (He = s.RG32F),
        de === s.HALF_FLOAT && (He = s.RG16F),
        de === s.UNSIGNED_BYTE && (He = s.RG8)),
      k === s.RG_INTEGER &&
        (de === s.UNSIGNED_BYTE && (He = s.RG8UI),
        de === s.UNSIGNED_SHORT && (He = s.RG16UI),
        de === s.UNSIGNED_INT && (He = s.RG32UI),
        de === s.BYTE && (He = s.RG8I),
        de === s.SHORT && (He = s.RG16I),
        de === s.INT && (He = s.RG32I)),
      k === s.RGB_INTEGER &&
        (de === s.UNSIGNED_BYTE && (He = s.RGB8UI),
        de === s.UNSIGNED_SHORT && (He = s.RGB16UI),
        de === s.UNSIGNED_INT && (He = s.RGB32UI),
        de === s.BYTE && (He = s.RGB8I),
        de === s.SHORT && (He = s.RGB16I),
        de === s.INT && (He = s.RGB32I)),
      k === s.RGBA_INTEGER &&
        (de === s.UNSIGNED_BYTE && (He = s.RGBA8UI),
        de === s.UNSIGNED_SHORT && (He = s.RGBA16UI),
        de === s.UNSIGNED_INT && (He = s.RGBA32UI),
        de === s.BYTE && (He = s.RGBA8I),
        de === s.SHORT && (He = s.RGBA16I),
        de === s.INT && (He = s.RGBA32I)),
      k === s.RGB && de === s.UNSIGNED_INT_5_9_9_9_REV && (He = s.RGB9_E5),
      k === s.RGBA)
    ) {
      const tt = we ? Dm : zn.getTransfer(Ee);
      de === s.FLOAT && (He = s.RGBA32F),
        de === s.HALF_FLOAT && (He = s.RGBA16F),
        de === s.UNSIGNED_BYTE && (He = tt === oi ? s.SRGB8_ALPHA8 : s.RGBA8),
        de === s.UNSIGNED_SHORT_4_4_4_4 && (He = s.RGBA4),
        de === s.UNSIGNED_SHORT_5_5_5_1 && (He = s.RGB5_A1);
    }
    return (
      (He === s.R16F ||
        He === s.R32F ||
        He === s.RG16F ||
        He === s.RG32F ||
        He === s.RGBA16F ||
        He === s.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      He
    );
  }
  function B(X, k) {
    let de;
    return (
      X
        ? k === null || k === Rl || k === Wf
          ? (de = s.DEPTH24_STENCIL8)
          : k === yi
          ? (de = s.DEPTH32F_STENCIL8)
          : k === bd &&
            ((de = s.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : k === null || k === Rl || k === Wf
        ? (de = s.DEPTH_COMPONENT24)
        : k === yi
        ? (de = s.DEPTH_COMPONENT32F)
        : k === bd && (de = s.DEPTH_COMPONENT16),
      de
    );
  }
  function I(X, k) {
    return E(X) === !0 ||
      (X.isFramebufferTexture && X.minFilter !== Kn && X.minFilter !== In)
      ? Math.log2(Math.max(k.width, k.height)) + 1
      : X.mipmaps !== void 0 && X.mipmaps.length > 0
      ? X.mipmaps.length
      : X.isCompressedTexture && Array.isArray(X.image)
      ? k.mipmaps.length
      : 1;
  }
  function N(X) {
    const k = X.target;
    k.removeEventListener("dispose", N), F(k), k.isVideoTexture && m.delete(k);
  }
  function P(X) {
    const k = X.target;
    k.removeEventListener("dispose", P), U(k);
  }
  function F(X) {
    const k = n.get(X);
    if (k.__webglInit === void 0) return;
    const de = X.source,
      Ee = _.get(de);
    if (Ee) {
      const we = Ee[k.__cacheKey];
      we.usedTimes--,
        we.usedTimes === 0 && O(X),
        Object.keys(Ee).length === 0 && _.delete(de);
    }
    n.remove(X);
  }
  function O(X) {
    const k = n.get(X);
    s.deleteTexture(k.__webglTexture);
    const de = X.source,
      Ee = _.get(de);
    delete Ee[k.__cacheKey], l.memory.textures--;
  }
  function U(X) {
    const k = n.get(X);
    if (
      (X.depthTexture && (X.depthTexture.dispose(), n.remove(X.depthTexture)),
      X.isWebGLCubeRenderTarget)
    )
      for (let Ee = 0; Ee < 6; Ee++) {
        if (Array.isArray(k.__webglFramebuffer[Ee]))
          for (let we = 0; we < k.__webglFramebuffer[Ee].length; we++)
            s.deleteFramebuffer(k.__webglFramebuffer[Ee][we]);
        else s.deleteFramebuffer(k.__webglFramebuffer[Ee]);
        k.__webglDepthbuffer && s.deleteRenderbuffer(k.__webglDepthbuffer[Ee]);
      }
    else {
      if (Array.isArray(k.__webglFramebuffer))
        for (let Ee = 0; Ee < k.__webglFramebuffer.length; Ee++)
          s.deleteFramebuffer(k.__webglFramebuffer[Ee]);
      else s.deleteFramebuffer(k.__webglFramebuffer);
      if (
        (k.__webglDepthbuffer && s.deleteRenderbuffer(k.__webglDepthbuffer),
        k.__webglMultisampledFramebuffer &&
          s.deleteFramebuffer(k.__webglMultisampledFramebuffer),
        k.__webglColorRenderbuffer)
      )
        for (let Ee = 0; Ee < k.__webglColorRenderbuffer.length; Ee++)
          k.__webglColorRenderbuffer[Ee] &&
            s.deleteRenderbuffer(k.__webglColorRenderbuffer[Ee]);
      k.__webglDepthRenderbuffer &&
        s.deleteRenderbuffer(k.__webglDepthRenderbuffer);
    }
    const de = X.textures;
    for (let Ee = 0, we = de.length; Ee < we; Ee++) {
      const He = n.get(de[Ee]);
      He.__webglTexture &&
        (s.deleteTexture(He.__webglTexture), l.memory.textures--),
        n.remove(de[Ee]);
    }
    n.remove(X);
  }
  let W = 0;
  function J() {
    W = 0;
  }
  function q() {
    const X = W;
    return (
      X >= i.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            X +
            " texture units while this GPU supports only " +
            i.maxTextures
        ),
      (W += 1),
      X
    );
  }
  function Z(X) {
    const k = [];
    return (
      k.push(X.wrapS),
      k.push(X.wrapT),
      k.push(X.wrapR || 0),
      k.push(X.magFilter),
      k.push(X.minFilter),
      k.push(X.anisotropy),
      k.push(X.internalFormat),
      k.push(X.format),
      k.push(X.type),
      k.push(X.generateMipmaps),
      k.push(X.premultiplyAlpha),
      k.push(X.flipY),
      k.push(X.unpackAlignment),
      k.push(X.colorSpace),
      k.join()
    );
  }
  function ue(X, k) {
    const de = n.get(X);
    if (
      (X.isVideoTexture && Ue(X),
      X.isRenderTargetTexture === !1 &&
        X.version > 0 &&
        de.__version !== X.version)
    ) {
      const Ee = X.image;
      if (Ee === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Ee.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        j(de, X, k);
        return;
      }
    }
    t.bindTexture(s.TEXTURE_2D, de.__webglTexture, s.TEXTURE0 + k);
  }
  function K(X, k) {
    const de = n.get(X);
    if (X.version > 0 && de.__version !== X.version) {
      j(de, X, k);
      return;
    }
    t.bindTexture(s.TEXTURE_2D_ARRAY, de.__webglTexture, s.TEXTURE0 + k);
  }
  function ge(X, k) {
    const de = n.get(X);
    if (X.version > 0 && de.__version !== X.version) {
      j(de, X, k);
      return;
    }
    t.bindTexture(s.TEXTURE_3D, de.__webglTexture, s.TEXTURE0 + k);
  }
  function oe(X, k) {
    const de = n.get(X);
    if (X.version > 0 && de.__version !== X.version) {
      se(de, X, k);
      return;
    }
    t.bindTexture(s.TEXTURE_CUBE_MAP, de.__webglTexture, s.TEXTURE0 + k);
  }
  const me = { [Sc]: s.REPEAT, [sa]: s.CLAMP_TO_EDGE, [Md]: s.MIRRORED_REPEAT },
    V = {
      [Kn]: s.NEAREST,
      [Ey]: s.NEAREST_MIPMAP_NEAREST,
      [Of]: s.NEAREST_MIPMAP_LINEAR,
      [In]: s.LINEAR,
      [yd]: s.LINEAR_MIPMAP_NEAREST,
      [ms]: s.LINEAR_MIPMAP_LINEAR,
    },
    Y = {
      [XE]: s.NEVER,
      [KE]: s.ALWAYS,
      [YE]: s.LESS,
      [$A]: s.LEQUAL,
      [WE]: s.EQUAL,
      [jE]: s.GEQUAL,
      [JE]: s.GREATER,
      [qE]: s.NOTEQUAL,
    };
  function ae(X, k) {
    if (
      (k.type === yi &&
        e.has("OES_texture_float_linear") === !1 &&
        (k.magFilter === In ||
          k.magFilter === yd ||
          k.magFilter === Of ||
          k.magFilter === ms ||
          k.minFilter === In ||
          k.minFilter === yd ||
          k.minFilter === Of ||
          k.minFilter === ms) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      s.texParameteri(X, s.TEXTURE_WRAP_S, me[k.wrapS]),
      s.texParameteri(X, s.TEXTURE_WRAP_T, me[k.wrapT]),
      (X === s.TEXTURE_3D || X === s.TEXTURE_2D_ARRAY) &&
        s.texParameteri(X, s.TEXTURE_WRAP_R, me[k.wrapR]),
      s.texParameteri(X, s.TEXTURE_MAG_FILTER, V[k.magFilter]),
      s.texParameteri(X, s.TEXTURE_MIN_FILTER, V[k.minFilter]),
      k.compareFunction &&
        (s.texParameteri(X, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE),
        s.texParameteri(X, s.TEXTURE_COMPARE_FUNC, Y[k.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        k.magFilter === Kn ||
        (k.minFilter !== Of && k.minFilter !== ms) ||
        (k.type === yi && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (k.anisotropy > 1 || n.get(k).__currentAnisotropy) {
        const de = e.get("EXT_texture_filter_anisotropic");
        s.texParameterf(
          X,
          de.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(k.anisotropy, i.getMaxAnisotropy())
        ),
          (n.get(k).__currentAnisotropy = k.anisotropy);
      }
    }
  }
  function fe(X, k) {
    let de = !1;
    X.__webglInit === void 0 &&
      ((X.__webglInit = !0), k.addEventListener("dispose", N));
    const Ee = k.source;
    let we = _.get(Ee);
    we === void 0 && ((we = {}), _.set(Ee, we));
    const He = Z(k);
    if (He !== X.__cacheKey) {
      we[He] === void 0 &&
        ((we[He] = { texture: s.createTexture(), usedTimes: 0 }),
        l.memory.textures++,
        (de = !0)),
        we[He].usedTimes++;
      const tt = we[X.__cacheKey];
      tt !== void 0 &&
        (we[X.__cacheKey].usedTimes--, tt.usedTimes === 0 && O(k)),
        (X.__cacheKey = He),
        (X.__webglTexture = we[He].texture);
    }
    return de;
  }
  function j(X, k, de) {
    let Ee = s.TEXTURE_2D;
    (k.isDataArrayTexture || k.isCompressedArrayTexture) &&
      (Ee = s.TEXTURE_2D_ARRAY),
      k.isData3DTexture && (Ee = s.TEXTURE_3D);
    const we = fe(X, k),
      He = k.source;
    t.bindTexture(Ee, X.__webglTexture, s.TEXTURE0 + de);
    const tt = n.get(He);
    if (He.version !== tt.__version || we === !0) {
      t.activeTexture(s.TEXTURE0 + de);
      const Ke = zn.getPrimaries(zn.workingColorSpace),
        st = k.colorSpace === gu ? null : zn.getPrimaries(k.colorSpace),
        Ut =
          k.colorSpace === gu || Ke === st ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, k.flipY),
        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
        s.pixelStorei(s.UNPACK_ALIGNMENT, k.unpackAlignment),
        s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ut);
      let et = T(k.image, !1, i.maxTextureSize);
      et = ht(k, et);
      const At = a.convert(k.format, k.colorSpace),
        mt = a.convert(k.type);
      let nt = D(k.internalFormat, At, mt, k.colorSpace, k.isVideoTexture);
      ae(Ee, k);
      let Ze;
      const le = k.mipmaps,
        Be = k.isVideoTexture !== !0,
        vt = tt.__version === void 0 || we === !0,
        ce = He.dataReady,
        xe = I(k, et);
      if (k.isDepthTexture)
        (nt = B(k.format === Jf, k.type)),
          vt &&
            (Be
              ? t.texStorage2D(s.TEXTURE_2D, 1, nt, et.width, et.height)
              : t.texImage2D(
                  s.TEXTURE_2D,
                  0,
                  nt,
                  et.width,
                  et.height,
                  0,
                  At,
                  mt,
                  null
                ));
      else if (k.isDataTexture)
        if (le.length > 0) {
          Be &&
            vt &&
            t.texStorage2D(s.TEXTURE_2D, xe, nt, le[0].width, le[0].height);
          for (let Re = 0, Qe = le.length; Re < Qe; Re++)
            (Ze = le[Re]),
              Be
                ? ce &&
                  t.texSubImage2D(
                    s.TEXTURE_2D,
                    Re,
                    0,
                    0,
                    Ze.width,
                    Ze.height,
                    At,
                    mt,
                    Ze.data
                  )
                : t.texImage2D(
                    s.TEXTURE_2D,
                    Re,
                    nt,
                    Ze.width,
                    Ze.height,
                    0,
                    At,
                    mt,
                    Ze.data
                  );
          k.generateMipmaps = !1;
        } else
          Be
            ? (vt && t.texStorage2D(s.TEXTURE_2D, xe, nt, et.width, et.height),
              ce &&
                t.texSubImage2D(
                  s.TEXTURE_2D,
                  0,
                  0,
                  0,
                  et.width,
                  et.height,
                  At,
                  mt,
                  et.data
                ))
            : t.texImage2D(
                s.TEXTURE_2D,
                0,
                nt,
                et.width,
                et.height,
                0,
                At,
                mt,
                et.data
              );
      else if (k.isCompressedTexture)
        if (k.isCompressedArrayTexture) {
          Be &&
            vt &&
            t.texStorage3D(
              s.TEXTURE_2D_ARRAY,
              xe,
              nt,
              le[0].width,
              le[0].height,
              et.depth
            );
          for (let Re = 0, Qe = le.length; Re < Qe; Re++)
            if (((Ze = le[Re]), k.format !== oa))
              if (At !== null)
                if (Be) {
                  if (ce)
                    if (k.layerUpdates.size > 0) {
                      const gt = EA(Ze.width, Ze.height, k.format, k.type);
                      for (const dt of k.layerUpdates) {
                        const Ct = Ze.data.subarray(
                          (dt * gt) / Ze.data.BYTES_PER_ELEMENT,
                          ((dt + 1) * gt) / Ze.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(
                          s.TEXTURE_2D_ARRAY,
                          Re,
                          0,
                          0,
                          dt,
                          Ze.width,
                          Ze.height,
                          1,
                          At,
                          Ct
                        );
                      }
                      k.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        s.TEXTURE_2D_ARRAY,
                        Re,
                        0,
                        0,
                        0,
                        Ze.width,
                        Ze.height,
                        et.depth,
                        At,
                        Ze.data
                      );
                } else
                  t.compressedTexImage3D(
                    s.TEXTURE_2D_ARRAY,
                    Re,
                    nt,
                    Ze.width,
                    Ze.height,
                    et.depth,
                    0,
                    Ze.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              Be
                ? ce &&
                  t.texSubImage3D(
                    s.TEXTURE_2D_ARRAY,
                    Re,
                    0,
                    0,
                    0,
                    Ze.width,
                    Ze.height,
                    et.depth,
                    At,
                    mt,
                    Ze.data
                  )
                : t.texImage3D(
                    s.TEXTURE_2D_ARRAY,
                    Re,
                    nt,
                    Ze.width,
                    Ze.height,
                    et.depth,
                    0,
                    At,
                    mt,
                    Ze.data
                  );
        } else {
          Be &&
            vt &&
            t.texStorage2D(s.TEXTURE_2D, xe, nt, le[0].width, le[0].height);
          for (let Re = 0, Qe = le.length; Re < Qe; Re++)
            (Ze = le[Re]),
              k.format !== oa
                ? At !== null
                  ? Be
                    ? ce &&
                      t.compressedTexSubImage2D(
                        s.TEXTURE_2D,
                        Re,
                        0,
                        0,
                        Ze.width,
                        Ze.height,
                        At,
                        Ze.data
                      )
                    : t.compressedTexImage2D(
                        s.TEXTURE_2D,
                        Re,
                        nt,
                        Ze.width,
                        Ze.height,
                        0,
                        Ze.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Be
                ? ce &&
                  t.texSubImage2D(
                    s.TEXTURE_2D,
                    Re,
                    0,
                    0,
                    Ze.width,
                    Ze.height,
                    At,
                    mt,
                    Ze.data
                  )
                : t.texImage2D(
                    s.TEXTURE_2D,
                    Re,
                    nt,
                    Ze.width,
                    Ze.height,
                    0,
                    At,
                    mt,
                    Ze.data
                  );
        }
      else if (k.isDataArrayTexture)
        if (Be) {
          if (
            (vt &&
              t.texStorage3D(
                s.TEXTURE_2D_ARRAY,
                xe,
                nt,
                et.width,
                et.height,
                et.depth
              ),
            ce)
          )
            if (k.layerUpdates.size > 0) {
              const Re = EA(et.width, et.height, k.format, k.type);
              for (const Qe of k.layerUpdates) {
                const gt = et.data.subarray(
                  (Qe * Re) / et.data.BYTES_PER_ELEMENT,
                  ((Qe + 1) * Re) / et.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(
                  s.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Qe,
                  et.width,
                  et.height,
                  1,
                  At,
                  mt,
                  gt
                );
              }
              k.clearLayerUpdates();
            } else
              t.texSubImage3D(
                s.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                et.width,
                et.height,
                et.depth,
                At,
                mt,
                et.data
              );
        } else
          t.texImage3D(
            s.TEXTURE_2D_ARRAY,
            0,
            nt,
            et.width,
            et.height,
            et.depth,
            0,
            At,
            mt,
            et.data
          );
      else if (k.isData3DTexture)
        Be
          ? (vt &&
              t.texStorage3D(
                s.TEXTURE_3D,
                xe,
                nt,
                et.width,
                et.height,
                et.depth
              ),
            ce &&
              t.texSubImage3D(
                s.TEXTURE_3D,
                0,
                0,
                0,
                0,
                et.width,
                et.height,
                et.depth,
                At,
                mt,
                et.data
              ))
          : t.texImage3D(
              s.TEXTURE_3D,
              0,
              nt,
              et.width,
              et.height,
              et.depth,
              0,
              At,
              mt,
              et.data
            );
      else if (k.isFramebufferTexture) {
        if (vt)
          if (Be) t.texStorage2D(s.TEXTURE_2D, xe, nt, et.width, et.height);
          else {
            let Re = et.width,
              Qe = et.height;
            for (let gt = 0; gt < xe; gt++)
              t.texImage2D(s.TEXTURE_2D, gt, nt, Re, Qe, 0, At, mt, null),
                (Re >>= 1),
                (Qe >>= 1);
          }
      } else if (le.length > 0) {
        if (Be && vt) {
          const Re = Ve(le[0]);
          t.texStorage2D(s.TEXTURE_2D, xe, nt, Re.width, Re.height);
        }
        for (let Re = 0, Qe = le.length; Re < Qe; Re++)
          (Ze = le[Re]),
            Be
              ? ce && t.texSubImage2D(s.TEXTURE_2D, Re, 0, 0, At, mt, Ze)
              : t.texImage2D(s.TEXTURE_2D, Re, nt, At, mt, Ze);
        k.generateMipmaps = !1;
      } else if (Be) {
        if (vt) {
          const Re = Ve(et);
          t.texStorage2D(s.TEXTURE_2D, xe, nt, Re.width, Re.height);
        }
        ce && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, At, mt, et);
      } else t.texImage2D(s.TEXTURE_2D, 0, nt, At, mt, et);
      E(k) && b(Ee), (tt.__version = He.version), k.onUpdate && k.onUpdate(k);
    }
    X.__version = k.version;
  }
  function se(X, k, de) {
    if (k.image.length !== 6) return;
    const Ee = fe(X, k),
      we = k.source;
    t.bindTexture(s.TEXTURE_CUBE_MAP, X.__webglTexture, s.TEXTURE0 + de);
    const He = n.get(we);
    if (we.version !== He.__version || Ee === !0) {
      t.activeTexture(s.TEXTURE0 + de);
      const tt = zn.getPrimaries(zn.workingColorSpace),
        Ke = k.colorSpace === gu ? null : zn.getPrimaries(k.colorSpace),
        st =
          k.colorSpace === gu || tt === Ke ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, k.flipY),
        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
        s.pixelStorei(s.UNPACK_ALIGNMENT, k.unpackAlignment),
        s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, st);
      const Ut = k.isCompressedTexture || k.image[0].isCompressedTexture,
        et = k.image[0] && k.image[0].isDataTexture,
        At = [];
      for (let Qe = 0; Qe < 6; Qe++)
        !Ut && !et
          ? (At[Qe] = T(k.image[Qe], !0, i.maxCubemapSize))
          : (At[Qe] = et ? k.image[Qe].image : k.image[Qe]),
          (At[Qe] = ht(k, At[Qe]));
      const mt = At[0],
        nt = a.convert(k.format, k.colorSpace),
        Ze = a.convert(k.type),
        le = D(k.internalFormat, nt, Ze, k.colorSpace),
        Be = k.isVideoTexture !== !0,
        vt = He.__version === void 0 || Ee === !0,
        ce = we.dataReady;
      let xe = I(k, mt);
      ae(s.TEXTURE_CUBE_MAP, k);
      let Re;
      if (Ut) {
        Be &&
          vt &&
          t.texStorage2D(s.TEXTURE_CUBE_MAP, xe, le, mt.width, mt.height);
        for (let Qe = 0; Qe < 6; Qe++) {
          Re = At[Qe].mipmaps;
          for (let gt = 0; gt < Re.length; gt++) {
            const dt = Re[gt];
            k.format !== oa
              ? nt !== null
                ? Be
                  ? ce &&
                    t.compressedTexSubImage2D(
                      s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                      gt,
                      0,
                      0,
                      dt.width,
                      dt.height,
                      nt,
                      dt.data
                    )
                  : t.compressedTexImage2D(
                      s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                      gt,
                      le,
                      dt.width,
                      dt.height,
                      0,
                      dt.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : Be
              ? ce &&
                t.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                  gt,
                  0,
                  0,
                  dt.width,
                  dt.height,
                  nt,
                  Ze,
                  dt.data
                )
              : t.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                  gt,
                  le,
                  dt.width,
                  dt.height,
                  0,
                  nt,
                  Ze,
                  dt.data
                );
          }
        }
      } else {
        if (((Re = k.mipmaps), Be && vt)) {
          Re.length > 0 && xe++;
          const Qe = Ve(At[0]);
          t.texStorage2D(s.TEXTURE_CUBE_MAP, xe, le, Qe.width, Qe.height);
        }
        for (let Qe = 0; Qe < 6; Qe++)
          if (et) {
            Be
              ? ce &&
                t.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                  0,
                  0,
                  0,
                  At[Qe].width,
                  At[Qe].height,
                  nt,
                  Ze,
                  At[Qe].data
                )
              : t.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                  0,
                  le,
                  At[Qe].width,
                  At[Qe].height,
                  0,
                  nt,
                  Ze,
                  At[Qe].data
                );
            for (let gt = 0; gt < Re.length; gt++) {
              const Ct = Re[gt].image[Qe].image;
              Be
                ? ce &&
                  t.texSubImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                    gt + 1,
                    0,
                    0,
                    Ct.width,
                    Ct.height,
                    nt,
                    Ze,
                    Ct.data
                  )
                : t.texImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                    gt + 1,
                    le,
                    Ct.width,
                    Ct.height,
                    0,
                    nt,
                    Ze,
                    Ct.data
                  );
            }
          } else {
            Be
              ? ce &&
                t.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                  0,
                  0,
                  0,
                  nt,
                  Ze,
                  At[Qe]
                )
              : t.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                  0,
                  le,
                  nt,
                  Ze,
                  At[Qe]
                );
            for (let gt = 0; gt < Re.length; gt++) {
              const dt = Re[gt];
              Be
                ? ce &&
                  t.texSubImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                    gt + 1,
                    0,
                    0,
                    nt,
                    Ze,
                    dt.image[Qe]
                  )
                : t.texImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + Qe,
                    gt + 1,
                    le,
                    nt,
                    Ze,
                    dt.image[Qe]
                  );
            }
          }
      }
      E(k) && b(s.TEXTURE_CUBE_MAP),
        (He.__version = we.version),
        k.onUpdate && k.onUpdate(k);
    }
    X.__version = k.version;
  }
  function ve(X, k, de, Ee, we, He) {
    const tt = a.convert(de.format, de.colorSpace),
      Ke = a.convert(de.type),
      st = D(de.internalFormat, tt, Ke, de.colorSpace),
      Ut = n.get(k),
      et = n.get(de);
    if (((et.__renderTarget = k), !Ut.__hasExternalTextures)) {
      const At = Math.max(1, k.width >> He),
        mt = Math.max(1, k.height >> He);
      we === s.TEXTURE_3D || we === s.TEXTURE_2D_ARRAY
        ? t.texImage3D(we, He, st, At, mt, k.depth, 0, tt, Ke, null)
        : t.texImage2D(we, He, st, At, mt, 0, tt, Ke, null);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, X),
      rt(k)
        ? u.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            Ee,
            we,
            et.__webglTexture,
            0,
            Pe(k)
          )
        : (we === s.TEXTURE_2D ||
            (we >= s.TEXTURE_CUBE_MAP_POSITIVE_X &&
              we <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          s.framebufferTexture2D(s.FRAMEBUFFER, Ee, we, et.__webglTexture, He),
      t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function ye(X, k, de) {
    if ((s.bindRenderbuffer(s.RENDERBUFFER, X), k.depthBuffer)) {
      const Ee = k.depthTexture,
        we = Ee && Ee.isDepthTexture ? Ee.type : null,
        He = B(k.stencilBuffer, we),
        tt = k.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT,
        Ke = Pe(k);
      rt(k)
        ? u.renderbufferStorageMultisampleEXT(
            s.RENDERBUFFER,
            Ke,
            He,
            k.width,
            k.height
          )
        : de
        ? s.renderbufferStorageMultisample(
            s.RENDERBUFFER,
            Ke,
            He,
            k.width,
            k.height
          )
        : s.renderbufferStorage(s.RENDERBUFFER, He, k.width, k.height),
        s.framebufferRenderbuffer(s.FRAMEBUFFER, tt, s.RENDERBUFFER, X);
    } else {
      const Ee = k.textures;
      for (let we = 0; we < Ee.length; we++) {
        const He = Ee[we],
          tt = a.convert(He.format, He.colorSpace),
          Ke = a.convert(He.type),
          st = D(He.internalFormat, tt, Ke, He.colorSpace),
          Ut = Pe(k);
        de && rt(k) === !1
          ? s.renderbufferStorageMultisample(
              s.RENDERBUFFER,
              Ut,
              st,
              k.width,
              k.height
            )
          : rt(k)
          ? u.renderbufferStorageMultisampleEXT(
              s.RENDERBUFFER,
              Ut,
              st,
              k.width,
              k.height
            )
          : s.renderbufferStorage(s.RENDERBUFFER, st, k.width, k.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function be(X, k) {
    if (k && k.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(s.FRAMEBUFFER, X),
      !(k.depthTexture && k.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    const Ee = n.get(k.depthTexture);
    (Ee.__renderTarget = k),
      (!Ee.__webglTexture ||
        k.depthTexture.image.width !== k.width ||
        k.depthTexture.image.height !== k.height) &&
        ((k.depthTexture.image.width = k.width),
        (k.depthTexture.image.height = k.height),
        (k.depthTexture.needsUpdate = !0)),
      ue(k.depthTexture, 0);
    const we = Ee.__webglTexture,
      He = Pe(k);
    if (k.depthTexture.format === Vf)
      rt(k)
        ? u.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            s.DEPTH_ATTACHMENT,
            s.TEXTURE_2D,
            we,
            0,
            He
          )
        : s.framebufferTexture2D(
            s.FRAMEBUFFER,
            s.DEPTH_ATTACHMENT,
            s.TEXTURE_2D,
            we,
            0
          );
    else if (k.depthTexture.format === Jf)
      rt(k)
        ? u.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            s.DEPTH_STENCIL_ATTACHMENT,
            s.TEXTURE_2D,
            we,
            0,
            He
          )
        : s.framebufferTexture2D(
            s.FRAMEBUFFER,
            s.DEPTH_STENCIL_ATTACHMENT,
            s.TEXTURE_2D,
            we,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function it(X) {
    const k = n.get(X),
      de = X.isWebGLCubeRenderTarget === !0;
    if (k.__boundDepthTexture !== X.depthTexture) {
      const Ee = X.depthTexture;
      if ((k.__depthDisposeCallback && k.__depthDisposeCallback(), Ee)) {
        const we = () => {
          delete k.__boundDepthTexture,
            delete k.__depthDisposeCallback,
            Ee.removeEventListener("dispose", we);
        };
        Ee.addEventListener("dispose", we), (k.__depthDisposeCallback = we);
      }
      k.__boundDepthTexture = Ee;
    }
    if (X.depthTexture && !k.__autoAllocateDepthBuffer) {
      if (de)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      be(k.__webglFramebuffer, X);
    } else if (de) {
      k.__webglDepthbuffer = [];
      for (let Ee = 0; Ee < 6; Ee++)
        if (
          (t.bindFramebuffer(s.FRAMEBUFFER, k.__webglFramebuffer[Ee]),
          k.__webglDepthbuffer[Ee] === void 0)
        )
          (k.__webglDepthbuffer[Ee] = s.createRenderbuffer()),
            ye(k.__webglDepthbuffer[Ee], X, !1);
        else {
          const we = X.stencilBuffer
              ? s.DEPTH_STENCIL_ATTACHMENT
              : s.DEPTH_ATTACHMENT,
            He = k.__webglDepthbuffer[Ee];
          s.bindRenderbuffer(s.RENDERBUFFER, He),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, we, s.RENDERBUFFER, He);
        }
    } else if (
      (t.bindFramebuffer(s.FRAMEBUFFER, k.__webglFramebuffer),
      k.__webglDepthbuffer === void 0)
    )
      (k.__webglDepthbuffer = s.createRenderbuffer()),
        ye(k.__webglDepthbuffer, X, !1);
    else {
      const Ee = X.stencilBuffer
          ? s.DEPTH_STENCIL_ATTACHMENT
          : s.DEPTH_ATTACHMENT,
        we = k.__webglDepthbuffer;
      s.bindRenderbuffer(s.RENDERBUFFER, we),
        s.framebufferRenderbuffer(s.FRAMEBUFFER, Ee, s.RENDERBUFFER, we);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function We(X, k, de) {
    const Ee = n.get(X);
    k !== void 0 &&
      ve(
        Ee.__webglFramebuffer,
        X,
        X.texture,
        s.COLOR_ATTACHMENT0,
        s.TEXTURE_2D,
        0
      ),
      de !== void 0 && it(X);
  }
  function $e(X) {
    const k = X.texture,
      de = n.get(X),
      Ee = n.get(k);
    X.addEventListener("dispose", P);
    const we = X.textures,
      He = X.isWebGLCubeRenderTarget === !0,
      tt = we.length > 1;
    if (
      (tt ||
        (Ee.__webglTexture === void 0 &&
          (Ee.__webglTexture = s.createTexture()),
        (Ee.__version = k.version),
        l.memory.textures++),
      He)
    ) {
      de.__webglFramebuffer = [];
      for (let Ke = 0; Ke < 6; Ke++)
        if (k.mipmaps && k.mipmaps.length > 0) {
          de.__webglFramebuffer[Ke] = [];
          for (let st = 0; st < k.mipmaps.length; st++)
            de.__webglFramebuffer[Ke][st] = s.createFramebuffer();
        } else de.__webglFramebuffer[Ke] = s.createFramebuffer();
    } else {
      if (k.mipmaps && k.mipmaps.length > 0) {
        de.__webglFramebuffer = [];
        for (let Ke = 0; Ke < k.mipmaps.length; Ke++)
          de.__webglFramebuffer[Ke] = s.createFramebuffer();
      } else de.__webglFramebuffer = s.createFramebuffer();
      if (tt)
        for (let Ke = 0, st = we.length; Ke < st; Ke++) {
          const Ut = n.get(we[Ke]);
          Ut.__webglTexture === void 0 &&
            ((Ut.__webglTexture = s.createTexture()), l.memory.textures++);
        }
      if (X.samples > 0 && rt(X) === !1) {
        (de.__webglMultisampledFramebuffer = s.createFramebuffer()),
          (de.__webglColorRenderbuffer = []),
          t.bindFramebuffer(s.FRAMEBUFFER, de.__webglMultisampledFramebuffer);
        for (let Ke = 0; Ke < we.length; Ke++) {
          const st = we[Ke];
          (de.__webglColorRenderbuffer[Ke] = s.createRenderbuffer()),
            s.bindRenderbuffer(s.RENDERBUFFER, de.__webglColorRenderbuffer[Ke]);
          const Ut = a.convert(st.format, st.colorSpace),
            et = a.convert(st.type),
            At = D(
              st.internalFormat,
              Ut,
              et,
              st.colorSpace,
              X.isXRRenderTarget === !0
            ),
            mt = Pe(X);
          s.renderbufferStorageMultisample(
            s.RENDERBUFFER,
            mt,
            At,
            X.width,
            X.height
          ),
            s.framebufferRenderbuffer(
              s.FRAMEBUFFER,
              s.COLOR_ATTACHMENT0 + Ke,
              s.RENDERBUFFER,
              de.__webglColorRenderbuffer[Ke]
            );
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null),
          X.depthBuffer &&
            ((de.__webglDepthRenderbuffer = s.createRenderbuffer()),
            ye(de.__webglDepthRenderbuffer, X, !0)),
          t.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (He) {
      t.bindTexture(s.TEXTURE_CUBE_MAP, Ee.__webglTexture),
        ae(s.TEXTURE_CUBE_MAP, k);
      for (let Ke = 0; Ke < 6; Ke++)
        if (k.mipmaps && k.mipmaps.length > 0)
          for (let st = 0; st < k.mipmaps.length; st++)
            ve(
              de.__webglFramebuffer[Ke][st],
              X,
              k,
              s.COLOR_ATTACHMENT0,
              s.TEXTURE_CUBE_MAP_POSITIVE_X + Ke,
              st
            );
        else
          ve(
            de.__webglFramebuffer[Ke],
            X,
            k,
            s.COLOR_ATTACHMENT0,
            s.TEXTURE_CUBE_MAP_POSITIVE_X + Ke,
            0
          );
      E(k) && b(s.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (tt) {
      for (let Ke = 0, st = we.length; Ke < st; Ke++) {
        const Ut = we[Ke],
          et = n.get(Ut);
        t.bindTexture(s.TEXTURE_2D, et.__webglTexture),
          ae(s.TEXTURE_2D, Ut),
          ve(
            de.__webglFramebuffer,
            X,
            Ut,
            s.COLOR_ATTACHMENT0 + Ke,
            s.TEXTURE_2D,
            0
          ),
          E(Ut) && b(s.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Ke = s.TEXTURE_2D;
      if (
        ((X.isWebGL3DRenderTarget || X.isWebGLArrayRenderTarget) &&
          (Ke = X.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY),
        t.bindTexture(Ke, Ee.__webglTexture),
        ae(Ke, k),
        k.mipmaps && k.mipmaps.length > 0)
      )
        for (let st = 0; st < k.mipmaps.length; st++)
          ve(de.__webglFramebuffer[st], X, k, s.COLOR_ATTACHMENT0, Ke, st);
      else ve(de.__webglFramebuffer, X, k, s.COLOR_ATTACHMENT0, Ke, 0);
      E(k) && b(Ke), t.unbindTexture();
    }
    X.depthBuffer && it(X);
  }
  function Me(X) {
    const k = X.textures;
    for (let de = 0, Ee = k.length; de < Ee; de++) {
      const we = k[de];
      if (E(we)) {
        const He = w(X),
          tt = n.get(we).__webglTexture;
        t.bindTexture(He, tt), b(He), t.unbindTexture();
      }
    }
  }
  const Ie = [],
    $ = [];
  function ft(X) {
    if (X.samples > 0) {
      if (rt(X) === !1) {
        const k = X.textures,
          de = X.width,
          Ee = X.height;
        let we = s.COLOR_BUFFER_BIT;
        const He = X.stencilBuffer
            ? s.DEPTH_STENCIL_ATTACHMENT
            : s.DEPTH_ATTACHMENT,
          tt = n.get(X),
          Ke = k.length > 1;
        if (Ke)
          for (let st = 0; st < k.length; st++)
            t.bindFramebuffer(s.FRAMEBUFFER, tt.__webglMultisampledFramebuffer),
              s.framebufferRenderbuffer(
                s.FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + st,
                s.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(s.FRAMEBUFFER, tt.__webglFramebuffer),
              s.framebufferTexture2D(
                s.DRAW_FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + st,
                s.TEXTURE_2D,
                null,
                0
              );
        t.bindFramebuffer(
          s.READ_FRAMEBUFFER,
          tt.__webglMultisampledFramebuffer
        ),
          t.bindFramebuffer(s.DRAW_FRAMEBUFFER, tt.__webglFramebuffer);
        for (let st = 0; st < k.length; st++) {
          if (
            (X.resolveDepthBuffer &&
              (X.depthBuffer && (we |= s.DEPTH_BUFFER_BIT),
              X.stencilBuffer &&
                X.resolveStencilBuffer &&
                (we |= s.STENCIL_BUFFER_BIT)),
            Ke)
          ) {
            s.framebufferRenderbuffer(
              s.READ_FRAMEBUFFER,
              s.COLOR_ATTACHMENT0,
              s.RENDERBUFFER,
              tt.__webglColorRenderbuffer[st]
            );
            const Ut = n.get(k[st]).__webglTexture;
            s.framebufferTexture2D(
              s.DRAW_FRAMEBUFFER,
              s.COLOR_ATTACHMENT0,
              s.TEXTURE_2D,
              Ut,
              0
            );
          }
          s.blitFramebuffer(0, 0, de, Ee, 0, 0, de, Ee, we, s.NEAREST),
            f === !0 &&
              ((Ie.length = 0),
              ($.length = 0),
              Ie.push(s.COLOR_ATTACHMENT0 + st),
              X.depthBuffer &&
                X.resolveDepthBuffer === !1 &&
                (Ie.push(He),
                $.push(He),
                s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, $)),
              s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Ie));
        }
        if (
          (t.bindFramebuffer(s.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
          Ke)
        )
          for (let st = 0; st < k.length; st++) {
            t.bindFramebuffer(s.FRAMEBUFFER, tt.__webglMultisampledFramebuffer),
              s.framebufferRenderbuffer(
                s.FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + st,
                s.RENDERBUFFER,
                tt.__webglColorRenderbuffer[st]
              );
            const Ut = n.get(k[st]).__webglTexture;
            t.bindFramebuffer(s.FRAMEBUFFER, tt.__webglFramebuffer),
              s.framebufferTexture2D(
                s.DRAW_FRAMEBUFFER,
                s.COLOR_ATTACHMENT0 + st,
                s.TEXTURE_2D,
                Ut,
                0
              );
          }
        t.bindFramebuffer(
          s.DRAW_FRAMEBUFFER,
          tt.__webglMultisampledFramebuffer
        );
      } else if (X.depthBuffer && X.resolveDepthBuffer === !1 && f) {
        const k = X.stencilBuffer
          ? s.DEPTH_STENCIL_ATTACHMENT
          : s.DEPTH_ATTACHMENT;
        s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [k]);
      }
    }
  }
  function Pe(X) {
    return Math.min(i.maxSamples, X.samples);
  }
  function rt(X) {
    const k = n.get(X);
    return (
      X.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      k.__useRenderToTexture !== !1
    );
  }
  function Ue(X) {
    const k = l.render.frame;
    m.get(X) !== k && (m.set(X, k), X.update());
  }
  function ht(X, k) {
    const de = X.colorSpace,
      Ee = X.format,
      we = X.type;
    return (
      X.isCompressedTexture === !0 ||
        X.isVideoTexture === !0 ||
        (de !== Oo &&
          de !== gu &&
          (zn.getTransfer(de) === oi
            ? (Ee !== oa || we !== Zr) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                de
              ))),
      k
    );
  }
  function Ve(X) {
    return (
      typeof HTMLImageElement < "u" && X instanceof HTMLImageElement
        ? ((d.width = X.naturalWidth || X.width),
          (d.height = X.naturalHeight || X.height))
        : typeof VideoFrame < "u" && X instanceof VideoFrame
        ? ((d.width = X.displayWidth), (d.height = X.displayHeight))
        : ((d.width = X.width), (d.height = X.height)),
      d
    );
  }
  (this.allocateTextureUnit = q),
    (this.resetTextureUnits = J),
    (this.setTexture2D = ue),
    (this.setTexture2DArray = K),
    (this.setTexture3D = ge),
    (this.setTextureCube = oe),
    (this.rebindTextures = We),
    (this.setupRenderTarget = $e),
    (this.updateRenderTargetMipmap = Me),
    (this.updateMultisampleRenderTarget = ft),
    (this.setupDepthRenderbuffer = it),
    (this.setupFrameBufferTexture = ve),
    (this.useMultisampledRTT = rt);
}
function KT(s, e) {
  function t(n, i = gu) {
    let a;
    const l = zn.getTransfer(i);
    if (n === Zr) return s.UNSIGNED_BYTE;
    if (n === Ry) return s.UNSIGNED_SHORT_4_4_4_4;
    if (n === wy) return s.UNSIGNED_SHORT_5_5_5_1;
    if (n === kA) return s.UNSIGNED_INT_5_9_9_9_REV;
    if (n === Ty) return s.BYTE;
    if (n === Cy) return s.SHORT;
    if (n === bd) return s.UNSIGNED_SHORT;
    if (n === km) return s.INT;
    if (n === Rl) return s.UNSIGNED_INT;
    if (n === yi) return s.FLOAT;
    if (n === va) return s.HALF_FLOAT;
    if (n === XA) return s.ALPHA;
    if (n === YA) return s.RGB;
    if (n === oa) return s.RGBA;
    if (n === WA) return s.LUMINANCE;
    if (n === JA) return s.LUMINANCE_ALPHA;
    if (n === Vf) return s.DEPTH_COMPONENT;
    if (n === Jf) return s.DEPTH_STENCIL;
    if (n === vc) return s.RED;
    if (n === Xm) return s.RED_INTEGER;
    if (n === qA) return s.RG;
    if (n === By) return s.RG_INTEGER;
    if (n === Dy) return s.RGBA_INTEGER;
    if (n === vm || n === ym || n === _m || n === Am)
      if (l === oi)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (n === vm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === ym) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === _m) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === Am) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (n === vm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === ym) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === _m) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Am) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (n === z0 || n === H0 || n === V0 || n === k0)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (n === z0) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === H0) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === V0) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === k0) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (n === X0 || n === Y0 || n === W0)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (n === X0 || n === Y0)
          return l === oi ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (n === W0)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      n === J0 ||
      n === q0 ||
      n === j0 ||
      n === K0 ||
      n === Z0 ||
      n === Q0 ||
      n === $0 ||
      n === ey ||
      n === ty ||
      n === ny ||
      n === iy ||
      n === ay ||
      n === ry ||
      n === sy
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (n === J0)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === q0)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === j0)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === K0)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === Z0)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === Q0)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === $0)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === ey)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === ty)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === ny)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === iy)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === ay)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === ry)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === sy)
          return l === oi
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (n === xm || n === oy || n === ly)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (n === xm)
          return l === oi
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === oy) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === ly) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (n === jA || n === uy || n === cy || n === fy)
      if (((a = e.get("EXT_texture_compression_rgtc")), a !== null)) {
        if (n === xm) return a.COMPRESSED_RED_RGTC1_EXT;
        if (n === uy) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === cy) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === fy) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return n === Wf ? s.UNSIGNED_INT_24_8 : s[n] !== void 0 ? s[n] : null;
  }
  return { convert: t };
}
const GL = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  zL = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class HL {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, n) {
    if (this.texture === null) {
      const i = new Wn(),
        a = e.properties.get(i);
      (a.__webglTexture = t.texture),
        (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = i);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        n = new ra({
          vertexShader: GL,
          fragmentShader: zL,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new li(new zs(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class VL extends wl {
  constructor(e, t) {
    super();
    const n = this;
    let i = null,
      a = 1,
      l = null,
      u = "local-floor",
      f = 1,
      d = null,
      m = null,
      v = null,
      _ = null,
      A = null,
      M = null;
    const T = new HL(),
      E = t.getContextAttributes();
    let b = null,
      w = null;
    const D = [],
      B = [],
      I = new at();
    let N = null;
    const P = new $i();
    P.viewport = new Hn();
    const F = new $i();
    F.viewport = new Hn();
    const O = [P, F],
      U = new zT();
    let W = null,
      J = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (j) {
        let se = D[j];
        return (
          se === void 0 && ((se = new E0()), (D[j] = se)),
          se.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (j) {
        let se = D[j];
        return (
          se === void 0 && ((se = new E0()), (D[j] = se)), se.getGripSpace()
        );
      }),
      (this.getHand = function (j) {
        let se = D[j];
        return (
          se === void 0 && ((se = new E0()), (D[j] = se)), se.getHandSpace()
        );
      });
    function q(j) {
      const se = B.indexOf(j.inputSource);
      if (se === -1) return;
      const ve = D[se];
      ve !== void 0 &&
        (ve.update(j.inputSource, j.frame, d || l),
        ve.dispatchEvent({ type: j.type, data: j.inputSource }));
    }
    function Z() {
      i.removeEventListener("select", q),
        i.removeEventListener("selectstart", q),
        i.removeEventListener("selectend", q),
        i.removeEventListener("squeeze", q),
        i.removeEventListener("squeezestart", q),
        i.removeEventListener("squeezeend", q),
        i.removeEventListener("end", Z),
        i.removeEventListener("inputsourceschange", ue);
      for (let j = 0; j < D.length; j++) {
        const se = B[j];
        se !== null && ((B[j] = null), D[j].disconnect(se));
      }
      (W = null),
        (J = null),
        T.reset(),
        e.setRenderTarget(b),
        (A = null),
        (_ = null),
        (v = null),
        (i = null),
        (w = null),
        fe.stop(),
        (n.isPresenting = !1),
        e.setPixelRatio(N),
        e.setSize(I.width, I.height, !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (j) {
      (a = j),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (j) {
        (u = j),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return d || l;
      }),
      (this.setReferenceSpace = function (j) {
        d = j;
      }),
      (this.getBaseLayer = function () {
        return _ !== null ? _ : A;
      }),
      (this.getBinding = function () {
        return v;
      }),
      (this.getFrame = function () {
        return M;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (j) {
        if (((i = j), i !== null)) {
          if (
            ((b = e.getRenderTarget()),
            i.addEventListener("select", q),
            i.addEventListener("selectstart", q),
            i.addEventListener("selectend", q),
            i.addEventListener("squeeze", q),
            i.addEventListener("squeezestart", q),
            i.addEventListener("squeezeend", q),
            i.addEventListener("end", Z),
            i.addEventListener("inputsourceschange", ue),
            E.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (N = e.getPixelRatio()),
            e.getSize(I),
            typeof XRWebGLBinding < "u" &&
              "createProjectionLayer" in XRWebGLBinding.prototype)
          ) {
            let ve = null,
              ye = null,
              be = null;
            E.depth &&
              ((be = E.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (ve = E.stencil ? Jf : Vf),
              (ye = E.stencil ? Wf : Rl));
            const it = {
              colorFormat: t.RGBA8,
              depthFormat: be,
              scaleFactor: a,
            };
            (v = new XRWebGLBinding(i, t)),
              (_ = v.createProjectionLayer(it)),
              i.updateRenderState({ layers: [_] }),
              e.setPixelRatio(1),
              e.setSize(_.textureWidth, _.textureHeight, !1),
              (w = new ha(_.textureWidth, _.textureHeight, {
                format: oa,
                type: Zr,
                depthTexture: new Vy(
                  _.textureWidth,
                  _.textureHeight,
                  ye,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  ve
                ),
                stencilBuffer: E.stencil,
                colorSpace: e.outputColorSpace,
                samples: E.antialias ? 4 : 0,
                resolveDepthBuffer: _.ignoreDepthValues === !1,
              }));
          } else {
            const ve = {
              antialias: E.antialias,
              alpha: !0,
              depth: E.depth,
              stencil: E.stencil,
              framebufferScaleFactor: a,
            };
            (A = new XRWebGLLayer(i, t, ve)),
              i.updateRenderState({ baseLayer: A }),
              e.setPixelRatio(1),
              e.setSize(A.framebufferWidth, A.framebufferHeight, !1),
              (w = new ha(A.framebufferWidth, A.framebufferHeight, {
                format: oa,
                type: Zr,
                colorSpace: e.outputColorSpace,
                stencilBuffer: E.stencil,
              }));
          }
          (w.isXRRenderTarget = !0),
            this.setFoveation(f),
            (d = null),
            (l = await i.requestReferenceSpace(u)),
            fe.setContext(i),
            fe.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return T.getDepthTexture();
      });
    function ue(j) {
      for (let se = 0; se < j.removed.length; se++) {
        const ve = j.removed[se],
          ye = B.indexOf(ve);
        ye >= 0 && ((B[ye] = null), D[ye].disconnect(ve));
      }
      for (let se = 0; se < j.added.length; se++) {
        const ve = j.added[se];
        let ye = B.indexOf(ve);
        if (ye === -1) {
          for (let it = 0; it < D.length; it++)
            if (it >= B.length) {
              B.push(ve), (ye = it);
              break;
            } else if (B[it] === null) {
              (B[it] = ve), (ye = it);
              break;
            }
          if (ye === -1) break;
        }
        const be = D[ye];
        be && be.connect(ve);
      }
    }
    const K = new ie(),
      ge = new ie();
    function oe(j, se, ve) {
      K.setFromMatrixPosition(se.matrixWorld),
        ge.setFromMatrixPosition(ve.matrixWorld);
      const ye = K.distanceTo(ge),
        be = se.projectionMatrix.elements,
        it = ve.projectionMatrix.elements,
        We = be[14] / (be[10] - 1),
        $e = be[14] / (be[10] + 1),
        Me = (be[9] + 1) / be[5],
        Ie = (be[9] - 1) / be[5],
        $ = (be[8] - 1) / be[0],
        ft = (it[8] + 1) / it[0],
        Pe = We * $,
        rt = We * ft,
        Ue = ye / (-$ + ft),
        ht = Ue * -$;
      if (
        (se.matrixWorld.decompose(j.position, j.quaternion, j.scale),
        j.translateX(ht),
        j.translateZ(Ue),
        j.matrixWorld.compose(j.position, j.quaternion, j.scale),
        j.matrixWorldInverse.copy(j.matrixWorld).invert(),
        be[10] === -1)
      )
        j.projectionMatrix.copy(se.projectionMatrix),
          j.projectionMatrixInverse.copy(se.projectionMatrixInverse);
      else {
        const Ve = We + Ue,
          X = $e + Ue,
          k = Pe - ht,
          de = rt + (ye - ht),
          Ee = ((Me * $e) / X) * Ve,
          we = ((Ie * $e) / X) * Ve;
        j.projectionMatrix.makePerspective(k, de, Ee, we, Ve, X),
          j.projectionMatrixInverse.copy(j.projectionMatrix).invert();
      }
    }
    function me(j, se) {
      se === null
        ? j.matrixWorld.copy(j.matrix)
        : j.matrixWorld.multiplyMatrices(se.matrixWorld, j.matrix),
        j.matrixWorldInverse.copy(j.matrixWorld).invert();
    }
    this.updateCamera = function (j) {
      if (i === null) return;
      let se = j.near,
        ve = j.far;
      T.texture !== null &&
        (T.depthNear > 0 && (se = T.depthNear),
        T.depthFar > 0 && (ve = T.depthFar)),
        (U.near = F.near = P.near = se),
        (U.far = F.far = P.far = ve),
        (W !== U.near || J !== U.far) &&
          (i.updateRenderState({ depthNear: U.near, depthFar: U.far }),
          (W = U.near),
          (J = U.far)),
        (P.layers.mask = j.layers.mask | 2),
        (F.layers.mask = j.layers.mask | 4),
        (U.layers.mask = P.layers.mask | F.layers.mask);
      const ye = j.parent,
        be = U.cameras;
      me(U, ye);
      for (let it = 0; it < be.length; it++) me(be[it], ye);
      be.length === 2
        ? oe(U, P, F)
        : U.projectionMatrix.copy(P.projectionMatrix),
        V(j, U, ye);
    };
    function V(j, se, ve) {
      ve === null
        ? j.matrix.copy(se.matrixWorld)
        : (j.matrix.copy(ve.matrixWorld),
          j.matrix.invert(),
          j.matrix.multiply(se.matrixWorld)),
        j.matrix.decompose(j.position, j.quaternion, j.scale),
        j.updateMatrixWorld(!0),
        j.projectionMatrix.copy(se.projectionMatrix),
        j.projectionMatrixInverse.copy(se.projectionMatrixInverse),
        j.isPerspectiveCamera &&
          ((j.fov = Cd * 2 * Math.atan(1 / j.projectionMatrix.elements[5])),
          (j.zoom = 1));
    }
    (this.getCamera = function () {
      return U;
    }),
      (this.getFoveation = function () {
        if (!(_ === null && A === null)) return f;
      }),
      (this.setFoveation = function (j) {
        (f = j),
          _ !== null && (_.fixedFoveation = j),
          A !== null && A.fixedFoveation !== void 0 && (A.fixedFoveation = j);
      }),
      (this.hasDepthSensing = function () {
        return T.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return T.getMesh(U);
      });
    let Y = null;
    function ae(j, se) {
      if (((m = se.getViewerPose(d || l)), (M = se), m !== null)) {
        const ve = m.views;
        A !== null &&
          (e.setRenderTargetFramebuffer(w, A.framebuffer),
          e.setRenderTarget(w));
        let ye = !1;
        ve.length !== U.cameras.length && ((U.cameras.length = 0), (ye = !0));
        for (let We = 0; We < ve.length; We++) {
          const $e = ve[We];
          let Me = null;
          if (A !== null) Me = A.getViewport($e);
          else {
            const $ = v.getViewSubImage(_, $e);
            (Me = $.viewport),
              We === 0 &&
                (e.setRenderTargetTextures(
                  w,
                  $.colorTexture,
                  _.ignoreDepthValues ? void 0 : $.depthStencilTexture
                ),
                e.setRenderTarget(w));
          }
          let Ie = O[We];
          Ie === void 0 &&
            ((Ie = new $i()),
            Ie.layers.enable(We),
            (Ie.viewport = new Hn()),
            (O[We] = Ie)),
            Ie.matrix.fromArray($e.transform.matrix),
            Ie.matrix.decompose(Ie.position, Ie.quaternion, Ie.scale),
            Ie.projectionMatrix.fromArray($e.projectionMatrix),
            Ie.projectionMatrixInverse.copy(Ie.projectionMatrix).invert(),
            Ie.viewport.set(Me.x, Me.y, Me.width, Me.height),
            We === 0 &&
              (U.matrix.copy(Ie.matrix),
              U.matrix.decompose(U.position, U.quaternion, U.scale)),
            ye === !0 && U.cameras.push(Ie);
        }
        const be = i.enabledFeatures;
        if (
          be &&
          be.includes("depth-sensing") &&
          i.depthUsage == "gpu-optimized" &&
          v
        ) {
          const We = v.getDepthInformation(ve[0]);
          We && We.isValid && We.texture && T.init(e, We, i.renderState);
        }
      }
      for (let ve = 0; ve < D.length; ve++) {
        const ye = B[ve],
          be = D[ve];
        ye !== null && be !== void 0 && be.update(ye, se, d || l);
      }
      Y && Y(j, se),
        se.detectedPlanes &&
          n.dispatchEvent({ type: "planesdetected", data: se }),
        (M = null);
    }
    const fe = new YT();
    fe.setAnimationLoop(ae),
      (this.setAnimationLoop = function (j) {
        Y = j;
      }),
      (this.dispose = function () {});
  }
}
const Ef = new vs(),
  kL = new Qt();
function XL(s, e) {
  function t(E, b) {
    E.matrixAutoUpdate === !0 && E.updateMatrix(), b.value.copy(E.matrix);
  }
  function n(E, b) {
    b.color.getRGB(E.fogColor.value, tT(s)),
      b.isFog
        ? ((E.fogNear.value = b.near), (E.fogFar.value = b.far))
        : b.isFogExp2 && (E.fogDensity.value = b.density);
  }
  function i(E, b, w, D, B) {
    b.isMeshBasicMaterial || b.isMeshLambertMaterial
      ? a(E, b)
      : b.isMeshToonMaterial
      ? (a(E, b), v(E, b))
      : b.isMeshPhongMaterial
      ? (a(E, b), m(E, b))
      : b.isMeshStandardMaterial
      ? (a(E, b), _(E, b), b.isMeshPhysicalMaterial && A(E, b, B))
      : b.isMeshMatcapMaterial
      ? (a(E, b), M(E, b))
      : b.isMeshDepthMaterial
      ? a(E, b)
      : b.isMeshDistanceMaterial
      ? (a(E, b), T(E, b))
      : b.isMeshNormalMaterial
      ? a(E, b)
      : b.isLineBasicMaterial
      ? (l(E, b), b.isLineDashedMaterial && u(E, b))
      : b.isPointsMaterial
      ? f(E, b, w, D)
      : b.isSpriteMaterial
      ? d(E, b)
      : b.isShadowMaterial
      ? (E.color.value.copy(b.color), (E.opacity.value = b.opacity))
      : b.isShaderMaterial && (b.uniformsNeedUpdate = !1);
  }
  function a(E, b) {
    (E.opacity.value = b.opacity),
      b.color && E.diffuse.value.copy(b.color),
      b.emissive &&
        E.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),
      b.map && ((E.map.value = b.map), t(b.map, E.mapTransform)),
      b.alphaMap &&
        ((E.alphaMap.value = b.alphaMap), t(b.alphaMap, E.alphaMapTransform)),
      b.bumpMap &&
        ((E.bumpMap.value = b.bumpMap),
        t(b.bumpMap, E.bumpMapTransform),
        (E.bumpScale.value = b.bumpScale),
        b.side === hr && (E.bumpScale.value *= -1)),
      b.normalMap &&
        ((E.normalMap.value = b.normalMap),
        t(b.normalMap, E.normalMapTransform),
        E.normalScale.value.copy(b.normalScale),
        b.side === hr && E.normalScale.value.negate()),
      b.displacementMap &&
        ((E.displacementMap.value = b.displacementMap),
        t(b.displacementMap, E.displacementMapTransform),
        (E.displacementScale.value = b.displacementScale),
        (E.displacementBias.value = b.displacementBias)),
      b.emissiveMap &&
        ((E.emissiveMap.value = b.emissiveMap),
        t(b.emissiveMap, E.emissiveMapTransform)),
      b.specularMap &&
        ((E.specularMap.value = b.specularMap),
        t(b.specularMap, E.specularMapTransform)),
      b.alphaTest > 0 && (E.alphaTest.value = b.alphaTest);
    const w = e.get(b),
      D = w.envMap,
      B = w.envMapRotation;
    D &&
      ((E.envMap.value = D),
      Ef.copy(B),
      (Ef.x *= -1),
      (Ef.y *= -1),
      (Ef.z *= -1),
      D.isCubeTexture &&
        D.isRenderTargetTexture === !1 &&
        ((Ef.y *= -1), (Ef.z *= -1)),
      E.envMapRotation.value.setFromMatrix4(kL.makeRotationFromEuler(Ef)),
      (E.flipEnvMap.value =
        D.isCubeTexture && D.isRenderTargetTexture === !1 ? -1 : 1),
      (E.reflectivity.value = b.reflectivity),
      (E.ior.value = b.ior),
      (E.refractionRatio.value = b.refractionRatio)),
      b.lightMap &&
        ((E.lightMap.value = b.lightMap),
        (E.lightMapIntensity.value = b.lightMapIntensity),
        t(b.lightMap, E.lightMapTransform)),
      b.aoMap &&
        ((E.aoMap.value = b.aoMap),
        (E.aoMapIntensity.value = b.aoMapIntensity),
        t(b.aoMap, E.aoMapTransform));
  }
  function l(E, b) {
    E.diffuse.value.copy(b.color),
      (E.opacity.value = b.opacity),
      b.map && ((E.map.value = b.map), t(b.map, E.mapTransform));
  }
  function u(E, b) {
    (E.dashSize.value = b.dashSize),
      (E.totalSize.value = b.dashSize + b.gapSize),
      (E.scale.value = b.scale);
  }
  function f(E, b, w, D) {
    E.diffuse.value.copy(b.color),
      (E.opacity.value = b.opacity),
      (E.size.value = b.size * w),
      (E.scale.value = D * 0.5),
      b.map && ((E.map.value = b.map), t(b.map, E.uvTransform)),
      b.alphaMap &&
        ((E.alphaMap.value = b.alphaMap), t(b.alphaMap, E.alphaMapTransform)),
      b.alphaTest > 0 && (E.alphaTest.value = b.alphaTest);
  }
  function d(E, b) {
    E.diffuse.value.copy(b.color),
      (E.opacity.value = b.opacity),
      (E.rotation.value = b.rotation),
      b.map && ((E.map.value = b.map), t(b.map, E.mapTransform)),
      b.alphaMap &&
        ((E.alphaMap.value = b.alphaMap), t(b.alphaMap, E.alphaMapTransform)),
      b.alphaTest > 0 && (E.alphaTest.value = b.alphaTest);
  }
  function m(E, b) {
    E.specular.value.copy(b.specular),
      (E.shininess.value = Math.max(b.shininess, 1e-4));
  }
  function v(E, b) {
    b.gradientMap && (E.gradientMap.value = b.gradientMap);
  }
  function _(E, b) {
    (E.metalness.value = b.metalness),
      b.metalnessMap &&
        ((E.metalnessMap.value = b.metalnessMap),
        t(b.metalnessMap, E.metalnessMapTransform)),
      (E.roughness.value = b.roughness),
      b.roughnessMap &&
        ((E.roughnessMap.value = b.roughnessMap),
        t(b.roughnessMap, E.roughnessMapTransform)),
      b.envMap && (E.envMapIntensity.value = b.envMapIntensity);
  }
  function A(E, b, w) {
    (E.ior.value = b.ior),
      b.sheen > 0 &&
        (E.sheenColor.value.copy(b.sheenColor).multiplyScalar(b.sheen),
        (E.sheenRoughness.value = b.sheenRoughness),
        b.sheenColorMap &&
          ((E.sheenColorMap.value = b.sheenColorMap),
          t(b.sheenColorMap, E.sheenColorMapTransform)),
        b.sheenRoughnessMap &&
          ((E.sheenRoughnessMap.value = b.sheenRoughnessMap),
          t(b.sheenRoughnessMap, E.sheenRoughnessMapTransform))),
      b.clearcoat > 0 &&
        ((E.clearcoat.value = b.clearcoat),
        (E.clearcoatRoughness.value = b.clearcoatRoughness),
        b.clearcoatMap &&
          ((E.clearcoatMap.value = b.clearcoatMap),
          t(b.clearcoatMap, E.clearcoatMapTransform)),
        b.clearcoatRoughnessMap &&
          ((E.clearcoatRoughnessMap.value = b.clearcoatRoughnessMap),
          t(b.clearcoatRoughnessMap, E.clearcoatRoughnessMapTransform)),
        b.clearcoatNormalMap &&
          ((E.clearcoatNormalMap.value = b.clearcoatNormalMap),
          t(b.clearcoatNormalMap, E.clearcoatNormalMapTransform),
          E.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),
          b.side === hr && E.clearcoatNormalScale.value.negate())),
      b.dispersion > 0 && (E.dispersion.value = b.dispersion),
      b.iridescence > 0 &&
        ((E.iridescence.value = b.iridescence),
        (E.iridescenceIOR.value = b.iridescenceIOR),
        (E.iridescenceThicknessMinimum.value = b.iridescenceThicknessRange[0]),
        (E.iridescenceThicknessMaximum.value = b.iridescenceThicknessRange[1]),
        b.iridescenceMap &&
          ((E.iridescenceMap.value = b.iridescenceMap),
          t(b.iridescenceMap, E.iridescenceMapTransform)),
        b.iridescenceThicknessMap &&
          ((E.iridescenceThicknessMap.value = b.iridescenceThicknessMap),
          t(b.iridescenceThicknessMap, E.iridescenceThicknessMapTransform))),
      b.transmission > 0 &&
        ((E.transmission.value = b.transmission),
        (E.transmissionSamplerMap.value = w.texture),
        E.transmissionSamplerSize.value.set(w.width, w.height),
        b.transmissionMap &&
          ((E.transmissionMap.value = b.transmissionMap),
          t(b.transmissionMap, E.transmissionMapTransform)),
        (E.thickness.value = b.thickness),
        b.thicknessMap &&
          ((E.thicknessMap.value = b.thicknessMap),
          t(b.thicknessMap, E.thicknessMapTransform)),
        (E.attenuationDistance.value = b.attenuationDistance),
        E.attenuationColor.value.copy(b.attenuationColor)),
      b.anisotropy > 0 &&
        (E.anisotropyVector.value.set(
          b.anisotropy * Math.cos(b.anisotropyRotation),
          b.anisotropy * Math.sin(b.anisotropyRotation)
        ),
        b.anisotropyMap &&
          ((E.anisotropyMap.value = b.anisotropyMap),
          t(b.anisotropyMap, E.anisotropyMapTransform))),
      (E.specularIntensity.value = b.specularIntensity),
      E.specularColor.value.copy(b.specularColor),
      b.specularColorMap &&
        ((E.specularColorMap.value = b.specularColorMap),
        t(b.specularColorMap, E.specularColorMapTransform)),
      b.specularIntensityMap &&
        ((E.specularIntensityMap.value = b.specularIntensityMap),
        t(b.specularIntensityMap, E.specularIntensityMapTransform));
  }
  function M(E, b) {
    b.matcap && (E.matcap.value = b.matcap);
  }
  function T(E, b) {
    const w = e.get(b).light;
    E.referencePosition.value.setFromMatrixPosition(w.matrixWorld),
      (E.nearDistance.value = w.shadow.camera.near),
      (E.farDistance.value = w.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: i };
}
function YL(s, e, t, n) {
  let i = {},
    a = {},
    l = [];
  const u = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
  function f(w, D) {
    const B = D.program;
    n.uniformBlockBinding(w, B);
  }
  function d(w, D) {
    let B = i[w.id];
    B === void 0 &&
      (M(w), (B = m(w)), (i[w.id] = B), w.addEventListener("dispose", E));
    const I = D.program;
    n.updateUBOMapping(w, I);
    const N = e.render.frame;
    a[w.id] !== N && (_(w), (a[w.id] = N));
  }
  function m(w) {
    const D = v();
    w.__bindingPointIndex = D;
    const B = s.createBuffer(),
      I = w.__size,
      N = w.usage;
    return (
      s.bindBuffer(s.UNIFORM_BUFFER, B),
      s.bufferData(s.UNIFORM_BUFFER, I, N),
      s.bindBuffer(s.UNIFORM_BUFFER, null),
      s.bindBufferBase(s.UNIFORM_BUFFER, D, B),
      B
    );
  }
  function v() {
    for (let w = 0; w < u; w++) if (l.indexOf(w) === -1) return l.push(w), w;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function _(w) {
    const D = i[w.id],
      B = w.uniforms,
      I = w.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, D);
    for (let N = 0, P = B.length; N < P; N++) {
      const F = Array.isArray(B[N]) ? B[N] : [B[N]];
      for (let O = 0, U = F.length; O < U; O++) {
        const W = F[O];
        if (A(W, N, O, I) === !0) {
          const J = W.__offset,
            q = Array.isArray(W.value) ? W.value : [W.value];
          let Z = 0;
          for (let ue = 0; ue < q.length; ue++) {
            const K = q[ue],
              ge = T(K);
            typeof K == "number" || typeof K == "boolean"
              ? ((W.__data[0] = K),
                s.bufferSubData(s.UNIFORM_BUFFER, J + Z, W.__data))
              : K.isMatrix3
              ? ((W.__data[0] = K.elements[0]),
                (W.__data[1] = K.elements[1]),
                (W.__data[2] = K.elements[2]),
                (W.__data[3] = 0),
                (W.__data[4] = K.elements[3]),
                (W.__data[5] = K.elements[4]),
                (W.__data[6] = K.elements[5]),
                (W.__data[7] = 0),
                (W.__data[8] = K.elements[6]),
                (W.__data[9] = K.elements[7]),
                (W.__data[10] = K.elements[8]),
                (W.__data[11] = 0))
              : (K.toArray(W.__data, Z),
                (Z += ge.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          s.bufferSubData(s.UNIFORM_BUFFER, J, W.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function A(w, D, B, I) {
    const N = w.value,
      P = D + "_" + B;
    if (I[P] === void 0)
      return (
        typeof N == "number" || typeof N == "boolean"
          ? (I[P] = N)
          : (I[P] = N.clone()),
        !0
      );
    {
      const F = I[P];
      if (typeof N == "number" || typeof N == "boolean") {
        if (F !== N) return (I[P] = N), !0;
      } else if (F.equals(N) === !1) return F.copy(N), !0;
    }
    return !1;
  }
  function M(w) {
    const D = w.uniforms;
    let B = 0;
    const I = 16;
    for (let P = 0, F = D.length; P < F; P++) {
      const O = Array.isArray(D[P]) ? D[P] : [D[P]];
      for (let U = 0, W = O.length; U < W; U++) {
        const J = O[U],
          q = Array.isArray(J.value) ? J.value : [J.value];
        for (let Z = 0, ue = q.length; Z < ue; Z++) {
          const K = q[Z],
            ge = T(K),
            oe = B % I,
            me = oe % ge.boundary,
            V = oe + me;
          (B += me),
            V !== 0 && I - V < ge.storage && (B += I - V),
            (J.__data = new Float32Array(
              ge.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (J.__offset = B),
            (B += ge.storage);
        }
      }
    }
    const N = B % I;
    return N > 0 && (B += I - N), (w.__size = B), (w.__cache = {}), this;
  }
  function T(w) {
    const D = { boundary: 0, storage: 0 };
    return (
      typeof w == "number" || typeof w == "boolean"
        ? ((D.boundary = 4), (D.storage = 4))
        : w.isVector2
        ? ((D.boundary = 8), (D.storage = 8))
        : w.isVector3 || w.isColor
        ? ((D.boundary = 16), (D.storage = 12))
        : w.isVector4
        ? ((D.boundary = 16), (D.storage = 16))
        : w.isMatrix3
        ? ((D.boundary = 48), (D.storage = 48))
        : w.isMatrix4
        ? ((D.boundary = 64), (D.storage = 64))
        : w.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            w
          ),
      D
    );
  }
  function E(w) {
    const D = w.target;
    D.removeEventListener("dispose", E);
    const B = l.indexOf(D.__bindingPointIndex);
    l.splice(B, 1), s.deleteBuffer(i[D.id]), delete i[D.id], delete a[D.id];
  }
  function b() {
    for (const w in i) s.deleteBuffer(i[w]);
    (l = []), (i = {}), (a = {});
  }
  return { bind: f, update: d, dispose: b };
}
class Ux {
  constructor(e = {}) {
    const {
      canvas: t = QE(),
      context: n = null,
      depth: i = !0,
      stencil: a = !1,
      alpha: l = !1,
      antialias: u = !1,
      premultipliedAlpha: f = !0,
      preserveDrawingBuffer: d = !1,
      powerPreference: m = "default",
      failIfMajorPerformanceCaveat: v = !1,
      reverseDepthBuffer: _ = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let A;
    if (n !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        n instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      A = n.getContextAttributes().alpha;
    } else A = l;
    const M = new Uint32Array(4),
      T = new Int32Array(4);
    let E = null,
      b = null;
    const w = [],
      D = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Wa),
      (this.toneMapping = bl),
      (this.toneMappingExposure = 1);
    const B = this;
    let I = !1,
      N = 0,
      P = 0,
      F = null,
      O = -1,
      U = null;
    const W = new Hn(),
      J = new Hn();
    let q = null;
    const Z = new Dt(0);
    let ue = 0,
      K = t.width,
      ge = t.height,
      oe = 1,
      me = null,
      V = null;
    const Y = new Hn(0, 0, K, ge),
      ae = new Hn(0, 0, K, ge);
    let fe = !1;
    const j = new jm();
    let se = !1,
      ve = !1;
    this.transmissionResolutionScale = 1;
    const ye = new Qt(),
      be = new Qt(),
      it = new ie(),
      We = new Hn(),
      $e = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let Me = !1;
    function Ie() {
      return F === null ? oe : 1;
    }
    let $ = n;
    function ft(z, re) {
      return t.getContext(z, re);
    }
    try {
      const z = {
        alpha: !0,
        depth: i,
        stencil: a,
        antialias: u,
        premultipliedAlpha: f,
        preserveDrawingBuffer: d,
        powerPreference: m,
        failIfMajorPerformanceCaveat: v,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Od}`),
        t.addEventListener("webglcontextlost", Qe, !1),
        t.addEventListener("webglcontextrestored", gt, !1),
        t.addEventListener("webglcontextcreationerror", dt, !1),
        $ === null)
      ) {
        const re = "webgl2";
        if ((($ = ft(re, z)), $ === null))
          throw ft(re)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (z) {
      throw (console.error("THREE.WebGLRenderer: " + z.message), z);
    }
    let Pe,
      rt,
      Ue,
      ht,
      Ve,
      X,
      k,
      de,
      Ee,
      we,
      He,
      tt,
      Ke,
      st,
      Ut,
      et,
      At,
      mt,
      nt,
      Ze,
      le,
      Be,
      vt,
      ce;
    function xe() {
      (Pe = new iO($)),
        Pe.init(),
        (Be = new KT($, Pe)),
        (rt = new ZU($, Pe, e, Be)),
        (Ue = new FL($, Pe)),
        rt.reverseDepthBuffer && _ && Ue.buffers.depth.setReversed(!0),
        (ht = new sO($)),
        (Ve = new bL()),
        (X = new PL($, Pe, Ue, Ve, rt, Be, ht)),
        (k = new $U(B)),
        (de = new nO(B)),
        (Ee = new dD($)),
        (vt = new jU($, Ee)),
        (we = new aO($, Ee, ht, vt)),
        (He = new lO($, we, Ee, ht)),
        (nt = new oO($, rt, X)),
        (et = new QU(Ve)),
        (tt = new ML(B, k, de, Pe, rt, vt, et)),
        (Ke = new XL(B, Ve)),
        (st = new TL()),
        (Ut = new UL(Pe)),
        (mt = new qU(B, k, de, Ue, He, A, f)),
        (At = new NL(B, He, rt)),
        (ce = new YL($, ht, rt, Ue)),
        (Ze = new KU($, Pe, ht)),
        (le = new rO($, Pe, ht)),
        (ht.programs = tt.programs),
        (B.capabilities = rt),
        (B.extensions = Pe),
        (B.properties = Ve),
        (B.renderLists = st),
        (B.shadowMap = At),
        (B.state = Ue),
        (B.info = ht);
    }
    xe();
    const Re = new VL(B, $);
    (this.xr = Re),
      (this.getContext = function () {
        return $;
      }),
      (this.getContextAttributes = function () {
        return $.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const z = Pe.get("WEBGL_lose_context");
        z && z.loseContext();
      }),
      (this.forceContextRestore = function () {
        const z = Pe.get("WEBGL_lose_context");
        z && z.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return oe;
      }),
      (this.setPixelRatio = function (z) {
        z !== void 0 && ((oe = z), this.setSize(K, ge, !1));
      }),
      (this.getSize = function (z) {
        return z.set(K, ge);
      }),
      (this.setSize = function (z, re, pe = !0) {
        if (Re.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (K = z),
          (ge = re),
          (t.width = Math.floor(z * oe)),
          (t.height = Math.floor(re * oe)),
          pe === !0 &&
            ((t.style.width = z + "px"), (t.style.height = re + "px")),
          this.setViewport(0, 0, z, re);
      }),
      (this.getDrawingBufferSize = function (z) {
        return z.set(K * oe, ge * oe).floor();
      }),
      (this.setDrawingBufferSize = function (z, re, pe) {
        (K = z),
          (ge = re),
          (oe = pe),
          (t.width = Math.floor(z * pe)),
          (t.height = Math.floor(re * pe)),
          this.setViewport(0, 0, z, re);
      }),
      (this.getCurrentViewport = function (z) {
        return z.copy(W);
      }),
      (this.getViewport = function (z) {
        return z.copy(Y);
      }),
      (this.setViewport = function (z, re, pe, ne) {
        z.isVector4 ? Y.set(z.x, z.y, z.z, z.w) : Y.set(z, re, pe, ne),
          Ue.viewport(W.copy(Y).multiplyScalar(oe).round());
      }),
      (this.getScissor = function (z) {
        return z.copy(ae);
      }),
      (this.setScissor = function (z, re, pe, ne) {
        z.isVector4 ? ae.set(z.x, z.y, z.z, z.w) : ae.set(z, re, pe, ne),
          Ue.scissor(J.copy(ae).multiplyScalar(oe).round());
      }),
      (this.getScissorTest = function () {
        return fe;
      }),
      (this.setScissorTest = function (z) {
        Ue.setScissorTest((fe = z));
      }),
      (this.setOpaqueSort = function (z) {
        me = z;
      }),
      (this.setTransparentSort = function (z) {
        V = z;
      }),
      (this.getClearColor = function (z) {
        return z.copy(mt.getClearColor());
      }),
      (this.setClearColor = function () {
        mt.setClearColor.apply(mt, arguments);
      }),
      (this.getClearAlpha = function () {
        return mt.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        mt.setClearAlpha.apply(mt, arguments);
      }),
      (this.clear = function (z = !0, re = !0, pe = !0) {
        let ne = 0;
        if (z) {
          let Se = !1;
          if (F !== null) {
            const Ne = F.texture.format;
            Se = Ne === Dy || Ne === By || Ne === Xm;
          }
          if (Se) {
            const Ne = F.texture.type,
              Ye =
                Ne === Zr ||
                Ne === Rl ||
                Ne === bd ||
                Ne === Wf ||
                Ne === Ry ||
                Ne === wy,
              lt = mt.getClearColor(),
              pt = mt.getClearAlpha(),
              wt = lt.r,
              Bt = lt.g,
              Rt = lt.b;
            Ye
              ? ((M[0] = wt),
                (M[1] = Bt),
                (M[2] = Rt),
                (M[3] = pt),
                $.clearBufferuiv($.COLOR, 0, M))
              : ((T[0] = wt),
                (T[1] = Bt),
                (T[2] = Rt),
                (T[3] = pt),
                $.clearBufferiv($.COLOR, 0, T));
          } else ne |= $.COLOR_BUFFER_BIT;
        }
        re && (ne |= $.DEPTH_BUFFER_BIT),
          pe &&
            ((ne |= $.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          $.clear(ne);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Qe, !1),
          t.removeEventListener("webglcontextrestored", gt, !1),
          t.removeEventListener("webglcontextcreationerror", dt, !1),
          mt.dispose(),
          st.dispose(),
          Ut.dispose(),
          Ve.dispose(),
          k.dispose(),
          de.dispose(),
          He.dispose(),
          vt.dispose(),
          ce.dispose(),
          tt.dispose(),
          Re.dispose(),
          Re.removeEventListener("sessionstart", ai),
          Re.removeEventListener("sessionend", Bi),
          ui.stop();
      });
    function Qe(z) {
      z.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (I = !0);
    }
    function gt() {
      console.log("THREE.WebGLRenderer: Context Restored."), (I = !1);
      const z = ht.autoReset,
        re = At.enabled,
        pe = At.autoUpdate,
        ne = At.needsUpdate,
        Se = At.type;
      xe(),
        (ht.autoReset = z),
        (At.enabled = re),
        (At.autoUpdate = pe),
        (At.needsUpdate = ne),
        (At.type = Se);
    }
    function dt(z) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        z.statusMessage
      );
    }
    function Ct(z) {
      const re = z.target;
      re.removeEventListener("dispose", Ct), Ht(re);
    }
    function Ht(z) {
      Nt(z), Ve.remove(z);
    }
    function Nt(z) {
      const re = Ve.get(z).programs;
      re !== void 0 &&
        (re.forEach(function (pe) {
          tt.releaseProgram(pe);
        }),
        z.isShaderMaterial && tt.releaseShaderCache(z));
    }
    this.renderBufferDirect = function (z, re, pe, ne, Se, Ne) {
      re === null && (re = $e);
      const Ye = Se.isMesh && Se.matrixWorld.determinant() < 0,
        lt = Ae(z, re, pe, ne, Se);
      Ue.setMaterial(ne, Ye);
      let pt = pe.index,
        wt = 1;
      if (ne.wireframe === !0) {
        if (((pt = we.getWireframeAttribute(pe)), pt === void 0)) return;
        wt = 2;
      }
      const Bt = pe.drawRange,
        Rt = pe.attributes.position;
      let jt = Bt.start * wt,
        Pt = (Bt.start + Bt.count) * wt;
      Ne !== null &&
        ((jt = Math.max(jt, Ne.start * wt)),
        (Pt = Math.min(Pt, (Ne.start + Ne.count) * wt))),
        pt !== null
          ? ((jt = Math.max(jt, 0)), (Pt = Math.min(Pt, pt.count)))
          : Rt != null &&
            ((jt = Math.max(jt, 0)), (Pt = Math.min(Pt, Rt.count)));
      const yn = Pt - jt;
      if (yn < 0 || yn === 1 / 0) return;
      vt.setup(Se, ne, lt, pe, pt);
      let Vt,
        Gt = Ze;
      if (
        (pt !== null && ((Vt = Ee.get(pt)), (Gt = le), Gt.setIndex(Vt)),
        Se.isMesh)
      )
        ne.wireframe === !0
          ? (Ue.setLineWidth(ne.wireframeLinewidth * Ie()), Gt.setMode($.LINES))
          : Gt.setMode($.TRIANGLES);
      else if (Se.isLine) {
        let It = ne.linewidth;
        It === void 0 && (It = 1),
          Ue.setLineWidth(It * Ie()),
          Se.isLineSegments
            ? Gt.setMode($.LINES)
            : Se.isLineLoop
            ? Gt.setMode($.LINE_LOOP)
            : Gt.setMode($.LINE_STRIP);
      } else
        Se.isPoints
          ? Gt.setMode($.POINTS)
          : Se.isSprite && Gt.setMode($.TRIANGLES);
      if (Se.isBatchedMesh)
        if (Se._multiDrawInstances !== null)
          Gt.renderMultiDrawInstances(
            Se._multiDrawStarts,
            Se._multiDrawCounts,
            Se._multiDrawCount,
            Se._multiDrawInstances
          );
        else if (Pe.get("WEBGL_multi_draw"))
          Gt.renderMultiDraw(
            Se._multiDrawStarts,
            Se._multiDrawCounts,
            Se._multiDrawCount
          );
        else {
          const It = Se._multiDrawStarts,
            Jn = Se._multiDrawCounts,
            qt = Se._multiDrawCount,
            rn = pt ? Ee.get(pt).bytesPerElement : 1,
            Ln = Ve.get(ne).currentProgram.getUniforms();
          for (let sn = 0; sn < qt; sn++)
            Ln.setValue($, "_gl_DrawID", sn), Gt.render(It[sn] / rn, Jn[sn]);
        }
      else if (Se.isInstancedMesh) Gt.renderInstances(jt, yn, Se.count);
      else if (pe.isInstancedBufferGeometry) {
        const It =
            pe._maxInstanceCount !== void 0 ? pe._maxInstanceCount : 1 / 0,
          Jn = Math.min(pe.instanceCount, It);
        Gt.renderInstances(jt, yn, Jn);
      } else Gt.render(jt, yn);
    };
    function Ft(z, re, pe) {
      z.transparent === !0 && z.side === jr && z.forceSinglePass === !1
        ? ((z.side = hr),
          (z.needsUpdate = !0),
          en(z, re, pe),
          (z.side = Tl),
          (z.needsUpdate = !0),
          en(z, re, pe),
          (z.side = jr))
        : en(z, re, pe);
    }
    (this.compile = function (z, re, pe = null) {
      pe === null && (pe = z),
        (b = Ut.get(pe)),
        b.init(re),
        D.push(b),
        pe.traverseVisible(function (Se) {
          Se.isLight &&
            Se.layers.test(re.layers) &&
            (b.pushLight(Se), Se.castShadow && b.pushShadow(Se));
        }),
        z !== pe &&
          z.traverseVisible(function (Se) {
            Se.isLight &&
              Se.layers.test(re.layers) &&
              (b.pushLight(Se), Se.castShadow && b.pushShadow(Se));
          }),
        b.setupLights();
      const ne = new Set();
      return (
        z.traverse(function (Se) {
          if (!(Se.isMesh || Se.isPoints || Se.isLine || Se.isSprite)) return;
          const Ne = Se.material;
          if (Ne)
            if (Array.isArray(Ne))
              for (let Ye = 0; Ye < Ne.length; Ye++) {
                const lt = Ne[Ye];
                Ft(lt, pe, Se), ne.add(lt);
              }
            else Ft(Ne, pe, Se), ne.add(Ne);
        }),
        D.pop(),
        (b = null),
        ne
      );
    }),
      (this.compileAsync = function (z, re, pe = null) {
        const ne = this.compile(z, re, pe);
        return new Promise((Se) => {
          function Ne() {
            if (
              (ne.forEach(function (Ye) {
                Ve.get(Ye).currentProgram.isReady() && ne.delete(Ye);
              }),
              ne.size === 0)
            ) {
              Se(z);
              return;
            }
            setTimeout(Ne, 10);
          }
          Pe.get("KHR_parallel_shader_compile") !== null
            ? Ne()
            : setTimeout(Ne, 10);
        });
      });
    let gn = null;
    function vn(z) {
      gn && gn(z);
    }
    function ai() {
      ui.stop();
    }
    function Bi() {
      ui.start();
    }
    const ui = new YT();
    ui.setAnimationLoop(vn),
      typeof self < "u" && ui.setContext(self),
      (this.setAnimationLoop = function (z) {
        (gn = z), Re.setAnimationLoop(z), z === null ? ui.stop() : ui.start();
      }),
      Re.addEventListener("sessionstart", ai),
      Re.addEventListener("sessionend", Bi),
      (this.render = function (z, re) {
        if (re !== void 0 && re.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (I === !0) return;
        if (
          (z.matrixWorldAutoUpdate === !0 && z.updateMatrixWorld(),
          re.parent === null &&
            re.matrixWorldAutoUpdate === !0 &&
            re.updateMatrixWorld(),
          Re.enabled === !0 &&
            Re.isPresenting === !0 &&
            (Re.cameraAutoUpdate === !0 && Re.updateCamera(re),
            (re = Re.getCamera())),
          z.isScene === !0 && z.onBeforeRender(B, z, re, F),
          (b = Ut.get(z, D.length)),
          b.init(re),
          D.push(b),
          be.multiplyMatrices(re.projectionMatrix, re.matrixWorldInverse),
          j.setFromProjectionMatrix(be),
          (ve = this.localClippingEnabled),
          (se = et.init(this.clippingPlanes, ve)),
          (E = st.get(z, w.length)),
          E.init(),
          w.push(E),
          Re.enabled === !0 && Re.isPresenting === !0)
        ) {
          const Ne = B.xr.getDepthSensingMesh();
          Ne !== null && di(Ne, re, -1 / 0, B.sortObjects);
        }
        di(z, re, 0, B.sortObjects),
          E.finish(),
          B.sortObjects === !0 && E.sort(me, V),
          (Me =
            Re.enabled === !1 ||
            Re.isPresenting === !1 ||
            Re.hasDepthSensing() === !1),
          Me && mt.addToRenderList(E, z),
          this.info.render.frame++,
          se === !0 && et.beginShadows();
        const pe = b.state.shadowsArray;
        At.render(pe, z, re),
          se === !0 && et.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const ne = E.opaque,
          Se = E.transmissive;
        if ((b.setupLights(), re.isArrayCamera)) {
          const Ne = re.cameras;
          if (Se.length > 0)
            for (let Ye = 0, lt = Ne.length; Ye < lt; Ye++) {
              const pt = Ne[Ye];
              pi(ne, Se, z, pt);
            }
          Me && mt.render(z);
          for (let Ye = 0, lt = Ne.length; Ye < lt; Ye++) {
            const pt = Ne[Ye];
            Di(E, z, pt, pt.viewport);
          }
        } else
          Se.length > 0 && pi(ne, Se, z, re), Me && mt.render(z), Di(E, z, re);
        F !== null &&
          P === 0 &&
          (X.updateMultisampleRenderTarget(F), X.updateRenderTargetMipmap(F)),
          z.isScene === !0 && z.onAfterRender(B, z, re),
          vt.resetDefaultState(),
          (O = -1),
          (U = null),
          D.pop(),
          D.length > 0
            ? ((b = D[D.length - 1]),
              se === !0 && et.setGlobalState(B.clippingPlanes, b.state.camera))
            : (b = null),
          w.pop(),
          w.length > 0 ? (E = w[w.length - 1]) : (E = null);
      });
    function di(z, re, pe, ne) {
      if (z.visible === !1) return;
      if (z.layers.test(re.layers)) {
        if (z.isGroup) pe = z.renderOrder;
        else if (z.isLOD) z.autoUpdate === !0 && z.update(re);
        else if (z.isLight) b.pushLight(z), z.castShadow && b.pushShadow(z);
        else if (z.isSprite) {
          if (!z.frustumCulled || j.intersectsSprite(z)) {
            ne && We.setFromMatrixPosition(z.matrixWorld).applyMatrix4(be);
            const Ye = He.update(z),
              lt = z.material;
            lt.visible && E.push(z, Ye, lt, pe, We.z, null);
          }
        } else if (
          (z.isMesh || z.isLine || z.isPoints) &&
          (!z.frustumCulled || j.intersectsObject(z))
        ) {
          const Ye = He.update(z),
            lt = z.material;
          if (
            (ne &&
              (z.boundingSphere !== void 0
                ? (z.boundingSphere === null && z.computeBoundingSphere(),
                  We.copy(z.boundingSphere.center))
                : (Ye.boundingSphere === null && Ye.computeBoundingSphere(),
                  We.copy(Ye.boundingSphere.center)),
              We.applyMatrix4(z.matrixWorld).applyMatrix4(be)),
            Array.isArray(lt))
          ) {
            const pt = Ye.groups;
            for (let wt = 0, Bt = pt.length; wt < Bt; wt++) {
              const Rt = pt[wt],
                jt = lt[Rt.materialIndex];
              jt && jt.visible && E.push(z, Ye, jt, pe, We.z, Rt);
            }
          } else lt.visible && E.push(z, Ye, lt, pe, We.z, null);
        }
      }
      const Ne = z.children;
      for (let Ye = 0, lt = Ne.length; Ye < lt; Ye++) di(Ne[Ye], re, pe, ne);
    }
    function Di(z, re, pe, ne) {
      const Se = z.opaque,
        Ne = z.transmissive,
        Ye = z.transparent;
      b.setupLightsView(pe),
        se === !0 && et.setGlobalState(B.clippingPlanes, pe),
        ne && Ue.viewport(W.copy(ne)),
        Se.length > 0 && zt(Se, re, pe),
        Ne.length > 0 && zt(Ne, re, pe),
        Ye.length > 0 && zt(Ye, re, pe),
        Ue.buffers.depth.setTest(!0),
        Ue.buffers.depth.setMask(!0),
        Ue.buffers.color.setMask(!0),
        Ue.setPolygonOffset(!1);
    }
    function pi(z, re, pe, ne) {
      if ((pe.isScene === !0 ? pe.overrideMaterial : null) !== null) return;
      b.state.transmissionRenderTarget[ne.id] === void 0 &&
        (b.state.transmissionRenderTarget[ne.id] = new ha(1, 1, {
          generateMipmaps: !0,
          type:
            Pe.has("EXT_color_buffer_half_float") ||
            Pe.has("EXT_color_buffer_float")
              ? va
              : Zr,
          minFilter: ms,
          samples: 4,
          stencilBuffer: a,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: zn.workingColorSpace,
        }));
      const Ne = b.state.transmissionRenderTarget[ne.id],
        Ye = ne.viewport || W;
      Ne.setSize(
        Ye.z * B.transmissionResolutionScale,
        Ye.w * B.transmissionResolutionScale
      );
      const lt = B.getRenderTarget();
      B.setRenderTarget(Ne),
        B.getClearColor(Z),
        (ue = B.getClearAlpha()),
        ue < 1 && B.setClearColor(16777215, 0.5),
        B.clear(),
        Me && mt.render(pe);
      const pt = B.toneMapping;
      B.toneMapping = bl;
      const wt = ne.viewport;
      if (
        (ne.viewport !== void 0 && (ne.viewport = void 0),
        b.setupLightsView(ne),
        se === !0 && et.setGlobalState(B.clippingPlanes, ne),
        zt(z, pe, ne),
        X.updateMultisampleRenderTarget(Ne),
        X.updateRenderTargetMipmap(Ne),
        Pe.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let Bt = !1;
        for (let Rt = 0, jt = re.length; Rt < jt; Rt++) {
          const Pt = re[Rt],
            yn = Pt.object,
            Vt = Pt.geometry,
            Gt = Pt.material,
            It = Pt.group;
          if (Gt.side === jr && yn.layers.test(ne.layers)) {
            const Jn = Gt.side;
            (Gt.side = hr),
              (Gt.needsUpdate = !0),
              pn(yn, pe, ne, Vt, Gt, It),
              (Gt.side = Jn),
              (Gt.needsUpdate = !0),
              (Bt = !0);
          }
        }
        Bt === !0 &&
          (X.updateMultisampleRenderTarget(Ne), X.updateRenderTargetMipmap(Ne));
      }
      B.setRenderTarget(lt),
        B.setClearColor(Z, ue),
        wt !== void 0 && (ne.viewport = wt),
        (B.toneMapping = pt);
    }
    function zt(z, re, pe) {
      const ne = re.isScene === !0 ? re.overrideMaterial : null;
      for (let Se = 0, Ne = z.length; Se < Ne; Se++) {
        const Ye = z[Se],
          lt = Ye.object,
          pt = Ye.geometry,
          wt = ne === null ? Ye.material : ne,
          Bt = Ye.group;
        lt.layers.test(pe.layers) && pn(lt, re, pe, pt, wt, Bt);
      }
    }
    function pn(z, re, pe, ne, Se, Ne) {
      z.onBeforeRender(B, re, pe, ne, Se, Ne),
        z.modelViewMatrix.multiplyMatrices(
          pe.matrixWorldInverse,
          z.matrixWorld
        ),
        z.normalMatrix.getNormalMatrix(z.modelViewMatrix),
        Se.onBeforeRender(B, re, pe, ne, z, Ne),
        Se.transparent === !0 && Se.side === jr && Se.forceSinglePass === !1
          ? ((Se.side = hr),
            (Se.needsUpdate = !0),
            B.renderBufferDirect(pe, re, ne, Se, z, Ne),
            (Se.side = Tl),
            (Se.needsUpdate = !0),
            B.renderBufferDirect(pe, re, ne, Se, z, Ne),
            (Se.side = jr))
          : B.renderBufferDirect(pe, re, ne, Se, z, Ne),
        z.onAfterRender(B, re, pe, ne, Se, Ne);
    }
    function en(z, re, pe) {
      re.isScene !== !0 && (re = $e);
      const ne = Ve.get(z),
        Se = b.state.lights,
        Ne = b.state.shadowsArray,
        Ye = Se.state.version,
        lt = tt.getParameters(z, Se.state, Ne, re, pe),
        pt = tt.getProgramCacheKey(lt);
      let wt = ne.programs;
      (ne.environment = z.isMeshStandardMaterial ? re.environment : null),
        (ne.fog = re.fog),
        (ne.envMap = (z.isMeshStandardMaterial ? de : k).get(
          z.envMap || ne.environment
        )),
        (ne.envMapRotation =
          ne.environment !== null && z.envMap === null
            ? re.environmentRotation
            : z.envMapRotation),
        wt === void 0 &&
          (z.addEventListener("dispose", Ct),
          (wt = new Map()),
          (ne.programs = wt));
      let Bt = wt.get(pt);
      if (Bt !== void 0) {
        if (ne.currentProgram === Bt && ne.lightsStateVersion === Ye)
          return te(z, lt), Bt;
      } else
        (lt.uniforms = tt.getUniforms(z)),
          z.onBeforeCompile(lt, B),
          (Bt = tt.acquireProgram(lt, pt)),
          wt.set(pt, Bt),
          (ne.uniforms = lt.uniforms);
      const Rt = ne.uniforms;
      return (
        ((!z.isShaderMaterial && !z.isRawShaderMaterial) ||
          z.clipping === !0) &&
          (Rt.clippingPlanes = et.uniform),
        te(z, lt),
        (ne.needsLights = qe(z)),
        (ne.lightsStateVersion = Ye),
        ne.needsLights &&
          ((Rt.ambientLightColor.value = Se.state.ambient),
          (Rt.lightProbe.value = Se.state.probe),
          (Rt.directionalLights.value = Se.state.directional),
          (Rt.directionalLightShadows.value = Se.state.directionalShadow),
          (Rt.spotLights.value = Se.state.spot),
          (Rt.spotLightShadows.value = Se.state.spotShadow),
          (Rt.rectAreaLights.value = Se.state.rectArea),
          (Rt.ltc_1.value = Se.state.rectAreaLTC1),
          (Rt.ltc_2.value = Se.state.rectAreaLTC2),
          (Rt.pointLights.value = Se.state.point),
          (Rt.pointLightShadows.value = Se.state.pointShadow),
          (Rt.hemisphereLights.value = Se.state.hemi),
          (Rt.directionalShadowMap.value = Se.state.directionalShadowMap),
          (Rt.directionalShadowMatrix.value = Se.state.directionalShadowMatrix),
          (Rt.spotShadowMap.value = Se.state.spotShadowMap),
          (Rt.spotLightMatrix.value = Se.state.spotLightMatrix),
          (Rt.spotLightMap.value = Se.state.spotLightMap),
          (Rt.pointShadowMap.value = Se.state.pointShadowMap),
          (Rt.pointShadowMatrix.value = Se.state.pointShadowMatrix)),
        (ne.currentProgram = Bt),
        (ne.uniformsList = null),
        Bt
      );
    }
    function H(z) {
      if (z.uniformsList === null) {
        const re = z.currentProgram.getUniforms();
        z.uniformsList = T0.seqWithValue(re.seq, z.uniforms);
      }
      return z.uniformsList;
    }
    function te(z, re) {
      const pe = Ve.get(z);
      (pe.outputColorSpace = re.outputColorSpace),
        (pe.batching = re.batching),
        (pe.batchingColor = re.batchingColor),
        (pe.instancing = re.instancing),
        (pe.instancingColor = re.instancingColor),
        (pe.instancingMorph = re.instancingMorph),
        (pe.skinning = re.skinning),
        (pe.morphTargets = re.morphTargets),
        (pe.morphNormals = re.morphNormals),
        (pe.morphColors = re.morphColors),
        (pe.morphTargetsCount = re.morphTargetsCount),
        (pe.numClippingPlanes = re.numClippingPlanes),
        (pe.numIntersection = re.numClipIntersection),
        (pe.vertexAlphas = re.vertexAlphas),
        (pe.vertexTangents = re.vertexTangents),
        (pe.toneMapping = re.toneMapping);
    }
    function Ae(z, re, pe, ne, Se) {
      re.isScene !== !0 && (re = $e), X.resetTextureUnits();
      const Ne = re.fog,
        Ye = ne.isMeshStandardMaterial ? re.environment : null,
        lt =
          F === null
            ? B.outputColorSpace
            : F.isXRRenderTarget === !0
            ? F.texture.colorSpace
            : Oo,
        pt = (ne.isMeshStandardMaterial ? de : k).get(ne.envMap || Ye),
        wt =
          ne.vertexColors === !0 &&
          !!pe.attributes.color &&
          pe.attributes.color.itemSize === 4,
        Bt = !!pe.attributes.tangent && (!!ne.normalMap || ne.anisotropy > 0),
        Rt = !!pe.morphAttributes.position,
        jt = !!pe.morphAttributes.normal,
        Pt = !!pe.morphAttributes.color;
      let yn = bl;
      ne.toneMapped &&
        (F === null || F.isXRRenderTarget === !0) &&
        (yn = B.toneMapping);
      const Vt =
          pe.morphAttributes.position ||
          pe.morphAttributes.normal ||
          pe.morphAttributes.color,
        Gt = Vt !== void 0 ? Vt.length : 0,
        It = Ve.get(ne),
        Jn = b.state.lights;
      if (se === !0 && (ve === !0 || z !== U)) {
        const Nn = z === U && ne.id === O;
        et.setState(ne, z, Nn);
      }
      let qt = !1;
      ne.version === It.__version
        ? ((It.needsLights && It.lightsStateVersion !== Jn.state.version) ||
            It.outputColorSpace !== lt ||
            (Se.isBatchedMesh && It.batching === !1) ||
            (!Se.isBatchedMesh && It.batching === !0) ||
            (Se.isBatchedMesh &&
              It.batchingColor === !0 &&
              Se.colorTexture === null) ||
            (Se.isBatchedMesh &&
              It.batchingColor === !1 &&
              Se.colorTexture !== null) ||
            (Se.isInstancedMesh && It.instancing === !1) ||
            (!Se.isInstancedMesh && It.instancing === !0) ||
            (Se.isSkinnedMesh && It.skinning === !1) ||
            (!Se.isSkinnedMesh && It.skinning === !0) ||
            (Se.isInstancedMesh &&
              It.instancingColor === !0 &&
              Se.instanceColor === null) ||
            (Se.isInstancedMesh &&
              It.instancingColor === !1 &&
              Se.instanceColor !== null) ||
            (Se.isInstancedMesh &&
              It.instancingMorph === !0 &&
              Se.morphTexture === null) ||
            (Se.isInstancedMesh &&
              It.instancingMorph === !1 &&
              Se.morphTexture !== null) ||
            It.envMap !== pt ||
            (ne.fog === !0 && It.fog !== Ne) ||
            (It.numClippingPlanes !== void 0 &&
              (It.numClippingPlanes !== et.numPlanes ||
                It.numIntersection !== et.numIntersection)) ||
            It.vertexAlphas !== wt ||
            It.vertexTangents !== Bt ||
            It.morphTargets !== Rt ||
            It.morphNormals !== jt ||
            It.morphColors !== Pt ||
            It.toneMapping !== yn ||
            It.morphTargetsCount !== Gt) &&
          (qt = !0)
        : ((qt = !0), (It.__version = ne.version));
      let rn = It.currentProgram;
      qt === !0 && (rn = en(ne, re, Se));
      let Ln = !1,
        sn = !1,
        Xt = !1;
      const on = rn.getUniforms(),
        Zn = It.uniforms;
      if (
        (Ue.useProgram(rn.program) && ((Ln = !0), (sn = !0), (Xt = !0)),
        ne.id !== O && ((O = ne.id), (sn = !0)),
        Ln || U !== z)
      ) {
        Ue.buffers.depth.getReversed()
          ? (ye.copy(z.projectionMatrix),
            HR(ye),
            VR(ye),
            on.setValue($, "projectionMatrix", ye))
          : on.setValue($, "projectionMatrix", z.projectionMatrix),
          on.setValue($, "viewMatrix", z.matrixWorldInverse);
        const Mi = on.map.cameraPosition;
        Mi !== void 0 &&
          Mi.setValue($, it.setFromMatrixPosition(z.matrixWorld)),
          rt.logarithmicDepthBuffer &&
            on.setValue(
              $,
              "logDepthBufFC",
              2 / (Math.log(z.far + 1) / Math.LN2)
            ),
          (ne.isMeshPhongMaterial ||
            ne.isMeshToonMaterial ||
            ne.isMeshLambertMaterial ||
            ne.isMeshBasicMaterial ||
            ne.isMeshStandardMaterial ||
            ne.isShaderMaterial) &&
            on.setValue($, "isOrthographic", z.isOrthographicCamera === !0),
          U !== z && ((U = z), (sn = !0), (Xt = !0));
      }
      if (Se.isSkinnedMesh) {
        on.setOptional($, Se, "bindMatrix"),
          on.setOptional($, Se, "bindMatrixInverse");
        const Nn = Se.skeleton;
        Nn &&
          (Nn.boneTexture === null && Nn.computeBoneTexture(),
          on.setValue($, "boneTexture", Nn.boneTexture, X));
      }
      Se.isBatchedMesh &&
        (on.setOptional($, Se, "batchingTexture"),
        on.setValue($, "batchingTexture", Se._matricesTexture, X),
        on.setOptional($, Se, "batchingIdTexture"),
        on.setValue($, "batchingIdTexture", Se._indirectTexture, X),
        on.setOptional($, Se, "batchingColorTexture"),
        Se._colorsTexture !== null &&
          on.setValue($, "batchingColorTexture", Se._colorsTexture, X));
      const Tn = pe.morphAttributes;
      if (
        ((Tn.position !== void 0 ||
          Tn.normal !== void 0 ||
          Tn.color !== void 0) &&
          nt.update(Se, pe, rn),
        (sn || It.receiveShadow !== Se.receiveShadow) &&
          ((It.receiveShadow = Se.receiveShadow),
          on.setValue($, "receiveShadow", Se.receiveShadow)),
        ne.isMeshGouraudMaterial &&
          ne.envMap !== null &&
          ((Zn.envMap.value = pt),
          (Zn.flipEnvMap.value =
            pt.isCubeTexture && pt.isRenderTargetTexture === !1 ? -1 : 1)),
        ne.isMeshStandardMaterial &&
          ne.envMap === null &&
          re.environment !== null &&
          (Zn.envMapIntensity.value = re.environmentIntensity),
        sn &&
          (on.setValue($, "toneMappingExposure", B.toneMappingExposure),
          It.needsLights && Ge(Zn, Xt),
          Ne && ne.fog === !0 && Ke.refreshFogUniforms(Zn, Ne),
          Ke.refreshMaterialUniforms(
            Zn,
            ne,
            oe,
            ge,
            b.state.transmissionRenderTarget[z.id]
          ),
          T0.upload($, H(It), Zn, X)),
        ne.isShaderMaterial &&
          ne.uniformsNeedUpdate === !0 &&
          (T0.upload($, H(It), Zn, X), (ne.uniformsNeedUpdate = !1)),
        ne.isSpriteMaterial && on.setValue($, "center", Se.center),
        on.setValue($, "modelViewMatrix", Se.modelViewMatrix),
        on.setValue($, "normalMatrix", Se.normalMatrix),
        on.setValue($, "modelMatrix", Se.matrixWorld),
        ne.isShaderMaterial || ne.isRawShaderMaterial)
      ) {
        const Nn = ne.uniformsGroups;
        for (let Mi = 0, Sa = Nn.length; Mi < Sa; Mi++) {
          const ea = Nn[Mi];
          ce.update(ea, rn), ce.bind(ea, rn);
        }
      }
      return rn;
    }
    function Ge(z, re) {
      (z.ambientLightColor.needsUpdate = re),
        (z.lightProbe.needsUpdate = re),
        (z.directionalLights.needsUpdate = re),
        (z.directionalLightShadows.needsUpdate = re),
        (z.pointLights.needsUpdate = re),
        (z.pointLightShadows.needsUpdate = re),
        (z.spotLights.needsUpdate = re),
        (z.spotLightShadows.needsUpdate = re),
        (z.rectAreaLights.needsUpdate = re),
        (z.hemisphereLights.needsUpdate = re);
    }
    function qe(z) {
      return (
        z.isMeshLambertMaterial ||
        z.isMeshToonMaterial ||
        z.isMeshPhongMaterial ||
        z.isMeshStandardMaterial ||
        z.isShadowMaterial ||
        (z.isShaderMaterial && z.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return N;
    }),
      (this.getActiveMipmapLevel = function () {
        return P;
      }),
      (this.getRenderTarget = function () {
        return F;
      }),
      (this.setRenderTargetTextures = function (z, re, pe) {
        (Ve.get(z.texture).__webglTexture = re),
          (Ve.get(z.depthTexture).__webglTexture = pe);
        const ne = Ve.get(z);
        (ne.__hasExternalTextures = !0),
          (ne.__autoAllocateDepthBuffer = pe === void 0),
          ne.__autoAllocateDepthBuffer ||
            (Pe.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (ne.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (z, re) {
        const pe = Ve.get(z);
        (pe.__webglFramebuffer = re),
          (pe.__useDefaultFramebuffer = re === void 0);
      });
    const Je = $.createFramebuffer();
    (this.setRenderTarget = function (z, re = 0, pe = 0) {
      (F = z), (N = re), (P = pe);
      let ne = !0,
        Se = null,
        Ne = !1,
        Ye = !1;
      if (z) {
        const pt = Ve.get(z);
        if (pt.__useDefaultFramebuffer !== void 0)
          Ue.bindFramebuffer($.FRAMEBUFFER, null), (ne = !1);
        else if (pt.__webglFramebuffer === void 0) X.setupRenderTarget(z);
        else if (pt.__hasExternalTextures)
          X.rebindTextures(
            z,
            Ve.get(z.texture).__webglTexture,
            Ve.get(z.depthTexture).__webglTexture
          );
        else if (z.depthBuffer) {
          const Rt = z.depthTexture;
          if (pt.__boundDepthTexture !== Rt) {
            if (
              Rt !== null &&
              Ve.has(Rt) &&
              (z.width !== Rt.image.width || z.height !== Rt.image.height)
            )
              throw new Error(
                "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
              );
            X.setupDepthRenderbuffer(z);
          }
        }
        const wt = z.texture;
        (wt.isData3DTexture ||
          wt.isDataArrayTexture ||
          wt.isCompressedArrayTexture) &&
          (Ye = !0);
        const Bt = Ve.get(z).__webglFramebuffer;
        z.isWebGLCubeRenderTarget
          ? (Array.isArray(Bt[re]) ? (Se = Bt[re][pe]) : (Se = Bt[re]),
            (Ne = !0))
          : z.samples > 0 && X.useMultisampledRTT(z) === !1
          ? (Se = Ve.get(z).__webglMultisampledFramebuffer)
          : Array.isArray(Bt)
          ? (Se = Bt[pe])
          : (Se = Bt),
          W.copy(z.viewport),
          J.copy(z.scissor),
          (q = z.scissorTest);
      } else
        W.copy(Y).multiplyScalar(oe).floor(),
          J.copy(ae).multiplyScalar(oe).floor(),
          (q = fe);
      if (
        (pe !== 0 && (Se = Je),
        Ue.bindFramebuffer($.FRAMEBUFFER, Se) && ne && Ue.drawBuffers(z, Se),
        Ue.viewport(W),
        Ue.scissor(J),
        Ue.setScissorTest(q),
        Ne)
      ) {
        const pt = Ve.get(z.texture);
        $.framebufferTexture2D(
          $.FRAMEBUFFER,
          $.COLOR_ATTACHMENT0,
          $.TEXTURE_CUBE_MAP_POSITIVE_X + re,
          pt.__webglTexture,
          pe
        );
      } else if (Ye) {
        const pt = Ve.get(z.texture),
          wt = re;
        $.framebufferTextureLayer(
          $.FRAMEBUFFER,
          $.COLOR_ATTACHMENT0,
          pt.__webglTexture,
          pe,
          wt
        );
      } else if (z !== null && pe !== 0) {
        const pt = Ve.get(z.texture);
        $.framebufferTexture2D(
          $.FRAMEBUFFER,
          $.COLOR_ATTACHMENT0,
          $.TEXTURE_2D,
          pt.__webglTexture,
          pe
        );
      }
      O = -1;
    }),
      (this.readRenderTargetPixels = function (z, re, pe, ne, Se, Ne, Ye) {
        if (!(z && z.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let lt = Ve.get(z).__webglFramebuffer;
        if ((z.isWebGLCubeRenderTarget && Ye !== void 0 && (lt = lt[Ye]), lt)) {
          Ue.bindFramebuffer($.FRAMEBUFFER, lt);
          try {
            const pt = z.texture,
              wt = pt.format,
              Bt = pt.type;
            if (!rt.textureFormatReadable(wt)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!rt.textureTypeReadable(Bt)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            re >= 0 &&
              re <= z.width - ne &&
              pe >= 0 &&
              pe <= z.height - Se &&
              $.readPixels(re, pe, ne, Se, Be.convert(wt), Be.convert(Bt), Ne);
          } finally {
            const pt = F !== null ? Ve.get(F).__webglFramebuffer : null;
            Ue.bindFramebuffer($.FRAMEBUFFER, pt);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        z,
        re,
        pe,
        ne,
        Se,
        Ne,
        Ye
      ) {
        if (!(z && z.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let lt = Ve.get(z).__webglFramebuffer;
        if ((z.isWebGLCubeRenderTarget && Ye !== void 0 && (lt = lt[Ye]), lt)) {
          const pt = z.texture,
            wt = pt.format,
            Bt = pt.type;
          if (!rt.textureFormatReadable(wt))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
            );
          if (!rt.textureTypeReadable(Bt))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
            );
          if (re >= 0 && re <= z.width - ne && pe >= 0 && pe <= z.height - Se) {
            Ue.bindFramebuffer($.FRAMEBUFFER, lt);
            const Rt = $.createBuffer();
            $.bindBuffer($.PIXEL_PACK_BUFFER, Rt),
              $.bufferData($.PIXEL_PACK_BUFFER, Ne.byteLength, $.STREAM_READ),
              $.readPixels(re, pe, ne, Se, Be.convert(wt), Be.convert(Bt), 0);
            const jt = F !== null ? Ve.get(F).__webglFramebuffer : null;
            Ue.bindFramebuffer($.FRAMEBUFFER, jt);
            const Pt = $.fenceSync($.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              $.flush(),
              await zR($, Pt, 4),
              $.bindBuffer($.PIXEL_PACK_BUFFER, Rt),
              $.getBufferSubData($.PIXEL_PACK_BUFFER, 0, Ne),
              $.deleteBuffer(Rt),
              $.deleteSync(Pt),
              Ne
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
            );
        }
      }),
      (this.copyFramebufferToTexture = function (z, re = null, pe = 0) {
        z.isTexture !== !0 &&
          (dd(
            "WebGLRenderer: copyFramebufferToTexture function signature has changed."
          ),
          (re = arguments[0] || null),
          (z = arguments[1]));
        const ne = Math.pow(2, -pe),
          Se = Math.floor(z.image.width * ne),
          Ne = Math.floor(z.image.height * ne),
          Ye = re !== null ? re.x : 0,
          lt = re !== null ? re.y : 0;
        X.setTexture2D(z, 0),
          $.copyTexSubImage2D($.TEXTURE_2D, pe, 0, 0, Ye, lt, Se, Ne),
          Ue.unbindTexture();
      });
    const St = $.createFramebuffer(),
      yt = $.createFramebuffer();
    (this.copyTextureToTexture = function (
      z,
      re,
      pe = null,
      ne = null,
      Se = 0,
      Ne = null
    ) {
      z.isTexture !== !0 &&
        (dd(
          "WebGLRenderer: copyTextureToTexture function signature has changed."
        ),
        (ne = arguments[0] || null),
        (z = arguments[1]),
        (re = arguments[2]),
        (Ne = arguments[3] || 0),
        (pe = null)),
        Ne === null &&
          (Se !== 0
            ? (dd(
                "WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."
              ),
              (Ne = Se),
              (Se = 0))
            : (Ne = 0));
      let Ye, lt, pt, wt, Bt, Rt, jt, Pt, yn;
      const Vt = z.isCompressedTexture ? z.mipmaps[Ne] : z.image;
      if (pe !== null)
        (Ye = pe.max.x - pe.min.x),
          (lt = pe.max.y - pe.min.y),
          (pt = pe.isBox3 ? pe.max.z - pe.min.z : 1),
          (wt = pe.min.x),
          (Bt = pe.min.y),
          (Rt = pe.isBox3 ? pe.min.z : 0);
      else {
        const Tn = Math.pow(2, -Se);
        (Ye = Math.floor(Vt.width * Tn)),
          (lt = Math.floor(Vt.height * Tn)),
          z.isDataArrayTexture
            ? (pt = Vt.depth)
            : z.isData3DTexture
            ? (pt = Math.floor(Vt.depth * Tn))
            : (pt = 1),
          (wt = 0),
          (Bt = 0),
          (Rt = 0);
      }
      ne !== null
        ? ((jt = ne.x), (Pt = ne.y), (yn = ne.z))
        : ((jt = 0), (Pt = 0), (yn = 0));
      const Gt = Be.convert(re.format),
        It = Be.convert(re.type);
      let Jn;
      re.isData3DTexture
        ? (X.setTexture3D(re, 0), (Jn = $.TEXTURE_3D))
        : re.isDataArrayTexture || re.isCompressedArrayTexture
        ? (X.setTexture2DArray(re, 0), (Jn = $.TEXTURE_2D_ARRAY))
        : (X.setTexture2D(re, 0), (Jn = $.TEXTURE_2D)),
        $.pixelStorei($.UNPACK_FLIP_Y_WEBGL, re.flipY),
        $.pixelStorei($.UNPACK_PREMULTIPLY_ALPHA_WEBGL, re.premultiplyAlpha),
        $.pixelStorei($.UNPACK_ALIGNMENT, re.unpackAlignment);
      const qt = $.getParameter($.UNPACK_ROW_LENGTH),
        rn = $.getParameter($.UNPACK_IMAGE_HEIGHT),
        Ln = $.getParameter($.UNPACK_SKIP_PIXELS),
        sn = $.getParameter($.UNPACK_SKIP_ROWS),
        Xt = $.getParameter($.UNPACK_SKIP_IMAGES);
      $.pixelStorei($.UNPACK_ROW_LENGTH, Vt.width),
        $.pixelStorei($.UNPACK_IMAGE_HEIGHT, Vt.height),
        $.pixelStorei($.UNPACK_SKIP_PIXELS, wt),
        $.pixelStorei($.UNPACK_SKIP_ROWS, Bt),
        $.pixelStorei($.UNPACK_SKIP_IMAGES, Rt);
      const on = z.isDataArrayTexture || z.isData3DTexture,
        Zn = re.isDataArrayTexture || re.isData3DTexture;
      if (z.isDepthTexture) {
        const Tn = Ve.get(z),
          Nn = Ve.get(re),
          Mi = Ve.get(Tn.__renderTarget),
          Sa = Ve.get(Nn.__renderTarget);
        Ue.bindFramebuffer($.READ_FRAMEBUFFER, Mi.__webglFramebuffer),
          Ue.bindFramebuffer($.DRAW_FRAMEBUFFER, Sa.__webglFramebuffer);
        for (let ea = 0; ea < pt; ea++)
          on &&
            ($.framebufferTextureLayer(
              $.READ_FRAMEBUFFER,
              $.COLOR_ATTACHMENT0,
              Ve.get(z).__webglTexture,
              Se,
              Rt + ea
            ),
            $.framebufferTextureLayer(
              $.DRAW_FRAMEBUFFER,
              $.COLOR_ATTACHMENT0,
              Ve.get(re).__webglTexture,
              Ne,
              yn + ea
            )),
            $.blitFramebuffer(
              wt,
              Bt,
              Ye,
              lt,
              jt,
              Pt,
              Ye,
              lt,
              $.DEPTH_BUFFER_BIT,
              $.NEAREST
            );
        Ue.bindFramebuffer($.READ_FRAMEBUFFER, null),
          Ue.bindFramebuffer($.DRAW_FRAMEBUFFER, null);
      } else if (Se !== 0 || z.isRenderTargetTexture || Ve.has(z)) {
        const Tn = Ve.get(z),
          Nn = Ve.get(re);
        Ue.bindFramebuffer($.READ_FRAMEBUFFER, St),
          Ue.bindFramebuffer($.DRAW_FRAMEBUFFER, yt);
        for (let Mi = 0; Mi < pt; Mi++)
          on
            ? $.framebufferTextureLayer(
                $.READ_FRAMEBUFFER,
                $.COLOR_ATTACHMENT0,
                Tn.__webglTexture,
                Se,
                Rt + Mi
              )
            : $.framebufferTexture2D(
                $.READ_FRAMEBUFFER,
                $.COLOR_ATTACHMENT0,
                $.TEXTURE_2D,
                Tn.__webglTexture,
                Se
              ),
            Zn
              ? $.framebufferTextureLayer(
                  $.DRAW_FRAMEBUFFER,
                  $.COLOR_ATTACHMENT0,
                  Nn.__webglTexture,
                  Ne,
                  yn + Mi
                )
              : $.framebufferTexture2D(
                  $.DRAW_FRAMEBUFFER,
                  $.COLOR_ATTACHMENT0,
                  $.TEXTURE_2D,
                  Nn.__webglTexture,
                  Ne
                ),
            Se !== 0
              ? $.blitFramebuffer(
                  wt,
                  Bt,
                  Ye,
                  lt,
                  jt,
                  Pt,
                  Ye,
                  lt,
                  $.COLOR_BUFFER_BIT,
                  $.NEAREST
                )
              : Zn
              ? $.copyTexSubImage3D(Jn, Ne, jt, Pt, yn + Mi, wt, Bt, Ye, lt)
              : $.copyTexSubImage2D(Jn, Ne, jt, Pt, wt, Bt, Ye, lt);
        Ue.bindFramebuffer($.READ_FRAMEBUFFER, null),
          Ue.bindFramebuffer($.DRAW_FRAMEBUFFER, null);
      } else
        Zn
          ? z.isDataTexture || z.isData3DTexture
            ? $.texSubImage3D(Jn, Ne, jt, Pt, yn, Ye, lt, pt, Gt, It, Vt.data)
            : re.isCompressedArrayTexture
            ? $.compressedTexSubImage3D(
                Jn,
                Ne,
                jt,
                Pt,
                yn,
                Ye,
                lt,
                pt,
                Gt,
                Vt.data
              )
            : $.texSubImage3D(Jn, Ne, jt, Pt, yn, Ye, lt, pt, Gt, It, Vt)
          : z.isDataTexture
          ? $.texSubImage2D($.TEXTURE_2D, Ne, jt, Pt, Ye, lt, Gt, It, Vt.data)
          : z.isCompressedTexture
          ? $.compressedTexSubImage2D(
              $.TEXTURE_2D,
              Ne,
              jt,
              Pt,
              Vt.width,
              Vt.height,
              Gt,
              Vt.data
            )
          : $.texSubImage2D($.TEXTURE_2D, Ne, jt, Pt, Ye, lt, Gt, It, Vt);
      $.pixelStorei($.UNPACK_ROW_LENGTH, qt),
        $.pixelStorei($.UNPACK_IMAGE_HEIGHT, rn),
        $.pixelStorei($.UNPACK_SKIP_PIXELS, Ln),
        $.pixelStorei($.UNPACK_SKIP_ROWS, sn),
        $.pixelStorei($.UNPACK_SKIP_IMAGES, Xt),
        Ne === 0 && re.generateMipmaps && $.generateMipmap(Jn),
        Ue.unbindTexture();
    }),
      (this.copyTextureToTexture3D = function (
        z,
        re,
        pe = null,
        ne = null,
        Se = 0
      ) {
        return (
          z.isTexture !== !0 &&
            (dd(
              "WebGLRenderer: copyTextureToTexture3D function signature has changed."
            ),
            (pe = arguments[0] || null),
            (ne = arguments[1] || null),
            (z = arguments[2]),
            (re = arguments[3]),
            (Se = arguments[4] || 0)),
          dd(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
          ),
          this.copyTextureToTexture(z, re, pe, ne, Se)
        );
      }),
      (this.initRenderTarget = function (z) {
        Ve.get(z).__webglFramebuffer === void 0 && X.setupRenderTarget(z);
      }),
      (this.initTexture = function (z) {
        z.isCubeTexture
          ? X.setTextureCube(z, 0)
          : z.isData3DTexture
          ? X.setTexture3D(z, 0)
          : z.isDataArrayTexture || z.isCompressedArrayTexture
          ? X.setTexture2DArray(z, 0)
          : X.setTexture2D(z, 0),
          Ue.unbindTexture();
      }),
      (this.resetState = function () {
        (N = 0), (P = 0), (F = null), Ue.reset(), vt.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Do;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorspace = zn._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = zn._getUnpackColorSpace());
  }
}
const WL = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: VA,
      AddEquation: mc,
      AddOperation: BE,
      AdditiveAnimationBlendMode: KA,
      AdditiveBlending: hA,
      AgXToneMapping: NE,
      AlphaFormat: XA,
      AlwaysCompare: KE,
      AlwaysDepth: L0,
      AlwaysStencilFunc: vA,
      AmbientLight: LT,
      AnimationAction: kT,
      AnimationClip: Bd,
      AnimationLoader: fB,
      AnimationMixer: IB,
      AnimationObjectGroup: LB,
      AnimationUtils: oB,
      ArcCurve: lT,
      ArrayCamera: zT,
      ArrowHelper: aD,
      AttachedBindMode: mA,
      Audio: HT,
      AudioAnalyser: bB,
      AudioContext: Ex,
      AudioListener: xB,
      AudioLoader: yB,
      AxesHelper: rD,
      BackSide: hr,
      BasicDepthPacking: VE,
      BasicShadowMap: cE,
      BatchedMesh: sT,
      Bone: Gy,
      BooleanKeyframeTrack: th,
      Box2: XB,
      Box3: ya,
      Box3Helper: nD,
      BoxGeometry: eh,
      BoxHelper: tD,
      BufferAttribute: Yn,
      BufferGeometry: mn,
      BufferGeometryLoader: PT,
      ByteType: Ty,
      Cache: _u,
      Camera: Iy,
      CameraHelper: eD,
      CanvasTexture: Dw,
      CapsuleGeometry: Xy,
      CatmullRomCurve3: uT,
      CineonToneMapping: OE,
      CircleGeometry: Yy,
      ClampToEdgeWrapping: sa,
      Clock: Tx,
      Color: Dt,
      ColorKeyframeTrack: yx,
      ColorManagement: zn,
      CompressedArrayTexture: ww,
      CompressedCubeTexture: Bw,
      CompressedTexture: Hy,
      CompressedTextureLoader: hB,
      ConeGeometry: Wy,
      ConstantAlphaFactor: CE,
      ConstantColorFactor: EE,
      Controls: oD,
      CubeCamera: nT,
      CubeReflectionMapping: Cl,
      CubeRefractionMapping: xc,
      CubeTexture: Wm,
      CubeTextureLoader: UT,
      CubeUVReflectionMapping: Ld,
      CubicBezierCurve: fx,
      CubicBezierCurve3: cT,
      CubicInterpolant: RT,
      CullFaceBack: fA,
      CullFaceFront: uE,
      CullFaceFrontBack: WC,
      CullFaceNone: lE,
      Curve: No,
      CurvePath: hT,
      CustomBlending: fE,
      CustomToneMapping: LE,
      CylinderGeometry: Id,
      Cylindrical: kB,
      Data3DTexture: Ly,
      DataArrayTexture: Ym,
      DataTexture: Uo,
      DataTextureLoader: _x,
      DataUtils: Ff,
      DecrementStencilOp: nR,
      DecrementWrapStencilOp: aR,
      DefaultLoadingManager: DT,
      DepthFormat: Vf,
      DepthStencilFormat: Jf,
      DepthTexture: Vy,
      DetachedBindMode: FE,
      DirectionalLight: Mx,
      DirectionalLightHelper: $B,
      DiscreteInterpolant: wT,
      DodecahedronGeometry: Jy,
      DoubleSide: jr,
      DstAlphaFactor: AE,
      DstColorFactor: SE,
      DynamicCopyUsage: _R,
      DynamicDrawUsage: dR,
      DynamicReadUsage: gR,
      EdgesGeometry: dT,
      EllipseCurve: ky,
      EqualCompare: WE,
      EqualDepth: I0,
      EqualStencilFunc: lR,
      EquirectangularReflectionMapping: Sd,
      EquirectangularRefractionMapping: wm,
      Euler: vs,
      EventDispatcher: wl,
      ExtrudeGeometry: jy,
      FileLoader: Ja,
      Float16BufferAttribute: uw,
      Float32BufferAttribute: Yt,
      FloatType: yi,
      Fog: Py,
      FogExp2: Fy,
      FramebufferTexture: Rw,
      FrontSide: Tl,
      Frustum: jm,
      GLBufferAttribute: VB,
      GLSL1: xR,
      GLSL3: yA,
      GreaterCompare: JE,
      GreaterDepth: P0,
      GreaterEqualCompare: jE,
      GreaterEqualDepth: F0,
      GreaterEqualStencilFunc: hR,
      GreaterStencilFunc: cR,
      GridHelper: ZB,
      Group: yu,
      HalfFloatType: va,
      HemisphereLight: OT,
      HemisphereLightHelper: KB,
      IcosahedronGeometry: Zm,
      ImageBitmapLoader: GT,
      ImageLoader: Gm,
      ImageUtils: $E,
      IncrementStencilOp: tR,
      IncrementWrapStencilOp: iR,
      InstancedBufferAttribute: bc,
      InstancedBufferGeometry: bx,
      InstancedInterleavedBuffer: HB,
      InstancedMesh: ox,
      Int16BufferAttribute: ow,
      Int32BufferAttribute: lw,
      Int8BufferAttribute: aw,
      IntType: km,
      InterleavedBuffer: Jm,
      InterleavedBufferAttribute: Mc,
      Interpolant: Fd,
      InterpolateDiscrete: Ed,
      InterpolateLinear: Td,
      InterpolateSmooth: b0,
      InvertStencilOp: rR,
      KeepStencilOp: Bf,
      KeyframeTrack: Io,
      LOD: rT,
      LatheGeometry: Km,
      Layers: Rd,
      LessCompare: YE,
      LessDepth: N0,
      LessEqualCompare: $A,
      LessEqualDepth: Yf,
      LessEqualStencilFunc: uR,
      LessStencilFunc: oR,
      Light: Cc,
      LightProbe: FT,
      Line: Su,
      Line3: YB,
      LineBasicMaterial: dr,
      LineCurve: hx,
      LineCurve3: fT,
      LineDashedMaterial: ET,
      LineLoop: lx,
      LineSegments: Lo,
      LinearFilter: In,
      LinearInterpolant: vx,
      LinearMipMapLinearFilter: gA,
      LinearMipMapNearestFilter: jC,
      LinearMipmapLinearFilter: ms,
      LinearMipmapNearestFilter: yd,
      LinearSRGBColorSpace: Oo,
      LinearToneMapping: DE,
      LinearTransfer: Dm,
      Loader: qa,
      LoaderUtils: _c,
      LoadingManager: a_,
      LoopOnce: PE,
      LoopPingPong: zE,
      LoopRepeat: GE,
      LuminanceAlphaFormat: JA,
      LuminanceFormat: WA,
      MOUSE: Rf,
      Material: _a,
      MaterialLoader: r_,
      MathUtils: tx,
      Matrix2: Bx,
      Matrix3: hn,
      Matrix4: Qt,
      MaxEquation: mE,
      Mesh: li,
      MeshBasicMaterial: fr,
      MeshDepthMaterial: n_,
      MeshDistanceMaterial: i_,
      MeshLambertMaterial: MT,
      MeshMatcapMaterial: bT,
      MeshNormalMaterial: ST,
      MeshPhongMaterial: AT,
      MeshPhysicalMaterial: Hs,
      MeshStandardMaterial: eg,
      MeshToonMaterial: xT,
      MinEquation: pE,
      MirroredRepeatWrapping: Md,
      MixOperation: wE,
      MultiplyBlending: pA,
      MultiplyOperation: Vm,
      NearestFilter: Kn,
      NearestMipMapLinearFilter: qC,
      NearestMipMapNearestFilter: JC,
      NearestMipmapLinearFilter: Of,
      NearestMipmapNearestFilter: Ey,
      NeutralToneMapping: IE,
      NeverCompare: XE,
      NeverDepth: O0,
      NeverStencilFunc: sR,
      NoBlending: Ml,
      NoColorSpace: gu,
      NoToneMapping: bl,
      NormalAnimationBlendMode: Uy,
      NormalBlending: Hf,
      NotEqualCompare: qE,
      NotEqualDepth: G0,
      NotEqualStencilFunc: fR,
      NumberKeyframeTrack: jf,
      Object3D: On,
      ObjectLoader: gB,
      ObjectSpaceNormalMap: kE,
      OctahedronGeometry: Qm,
      OneFactor: vE,
      OneMinusConstantAlphaFactor: RE,
      OneMinusConstantColorFactor: TE,
      OneMinusDstAlphaFactor: xE,
      OneMinusDstColorFactor: ME,
      OneMinusSrcAlphaFactor: U0,
      OneMinusSrcColorFactor: _E,
      OrthographicCamera: Ps,
      PCFShadowMap: by,
      PCFSoftShadowMap: gm,
      PMREMGenerator: TA,
      Path: Nm,
      PerspectiveCamera: $i,
      Plane: mu,
      PlaneGeometry: zs,
      PlaneHelper: iD,
      PointLight: Sx,
      PointLightHelper: qB,
      Points: ux,
      PointsMaterial: zy,
      PolarGridHelper: QB,
      PolyhedronGeometry: Tc,
      PositionalAudio: MB,
      PropertyBinding: Xn,
      PropertyMixer: VT,
      QuadraticBezierCurve: dx,
      QuadraticBezierCurve3: px,
      Quaternion: La,
      QuaternionKeyframeTrack: Kf,
      QuaternionLinearInterpolant: BT,
      RED_GREEN_RGTC2_Format: cy,
      RED_RGTC1_Format: jA,
      REVISION: Od,
      RGBADepthPacking: QA,
      RGBAFormat: oa,
      RGBAIntegerFormat: Dy,
      RGBA_ASTC_10x10_Format: ay,
      RGBA_ASTC_10x5_Format: ty,
      RGBA_ASTC_10x6_Format: ny,
      RGBA_ASTC_10x8_Format: iy,
      RGBA_ASTC_12x10_Format: ry,
      RGBA_ASTC_12x12_Format: sy,
      RGBA_ASTC_4x4_Format: J0,
      RGBA_ASTC_5x4_Format: q0,
      RGBA_ASTC_5x5_Format: j0,
      RGBA_ASTC_6x5_Format: K0,
      RGBA_ASTC_6x6_Format: Z0,
      RGBA_ASTC_8x5_Format: Q0,
      RGBA_ASTC_8x6_Format: $0,
      RGBA_ASTC_8x8_Format: ey,
      RGBA_BPTC_Format: xm,
      RGBA_ETC2_EAC_Format: W0,
      RGBA_PVRTC_2BPPV1_Format: k0,
      RGBA_PVRTC_4BPPV1_Format: V0,
      RGBA_S3TC_DXT1_Format: ym,
      RGBA_S3TC_DXT3_Format: _m,
      RGBA_S3TC_DXT5_Format: Am,
      RGBDepthPacking: ZC,
      RGBFormat: YA,
      RGBIntegerFormat: KC,
      RGB_BPTC_SIGNED_Format: oy,
      RGB_BPTC_UNSIGNED_Format: ly,
      RGB_ETC1_Format: X0,
      RGB_ETC2_Format: Y0,
      RGB_PVRTC_2BPPV1_Format: H0,
      RGB_PVRTC_4BPPV1_Format: z0,
      RGB_S3TC_DXT1_Format: vm,
      RGDepthPacking: QC,
      RGFormat: qA,
      RGIntegerFormat: By,
      RawShaderMaterial: _T,
      Ray: $f,
      Raycaster: wx,
      RectAreaLight: NT,
      RedFormat: vc,
      RedIntegerFormat: Xm,
      ReinhardToneMapping: UE,
      RenderTarget: Oy,
      RenderTarget3D: FB,
      RenderTargetArray: PB,
      RepeatWrapping: Sc,
      ReplaceStencilOp: eR,
      ReverseSubtractEquation: dE,
      RingGeometry: Ky,
      SIGNED_RED_GREEN_RGTC2_Format: fy,
      SIGNED_RED_RGTC1_Format: uy,
      SRGBColorSpace: Wa,
      SRGBTransfer: oi,
      Scene: Nd,
      ShaderChunk: _n,
      ShaderLib: Bo,
      ShaderMaterial: ra,
      ShadowMaterial: yT,
      Shape: yc,
      ShapeGeometry: Zy,
      ShapePath: sD,
      ShapeUtils: El,
      ShortType: Cy,
      Skeleton: qm,
      SkeletonHelper: JB,
      SkinnedMesh: sx,
      Source: If,
      Sphere: Na,
      SphereGeometry: $m,
      Spherical: bA,
      SphericalHarmonics3: IT,
      SplineCurve: mx,
      SpotLight: xx,
      SpotLightHelper: WB,
      Sprite: aT,
      SpriteMaterial: rx,
      SrcAlphaFactor: D0,
      SrcAlphaSaturateFactor: bE,
      SrcColorFactor: yE,
      StaticCopyUsage: yR,
      StaticDrawUsage: Um,
      StaticReadUsage: mR,
      StereoCamera: _B,
      StreamCopyUsage: AR,
      StreamDrawUsage: pR,
      StreamReadUsage: vR,
      StringKeyframeTrack: nh,
      SubtractEquation: hE,
      SubtractiveBlending: dA,
      TOUCH: wf,
      TangentSpaceNormalMap: Ec,
      TetrahedronGeometry: Qy,
      Texture: Wn,
      TextureLoader: tg,
      TextureUtils: hD,
      TimestampQuery: SR,
      TorusGeometry: $y,
      TorusKnotGeometry: e_,
      Triangle: Kr,
      TriangleFanDrawMode: hy,
      TriangleStripDrawMode: ZA,
      TrianglesDrawMode: HE,
      TubeGeometry: t_,
      UVMapping: Ac,
      Uint16BufferAttribute: nx,
      Uint32BufferAttribute: ix,
      Uint8BufferAttribute: rw,
      Uint8ClampedBufferAttribute: sw,
      Uniform: s_,
      UniformsGroup: zB,
      UniformsLib: Lt,
      UniformsUtils: Ny,
      UnsignedByteType: Zr,
      UnsignedInt248Type: Wf,
      UnsignedInt5999Type: kA,
      UnsignedIntType: Rl,
      UnsignedShort4444Type: Ry,
      UnsignedShort5551Type: wy,
      UnsignedShortType: bd,
      VSMShadowMap: wo,
      Vector2: at,
      Vector3: ie,
      Vector4: Hn,
      VectorKeyframeTrack: Zf,
      VideoFrameTexture: Cw,
      VideoTexture: oT,
      WebGL3DRenderTarget: JR,
      WebGLArrayRenderTarget: WR,
      WebGLCoordinateSystem: Do,
      WebGLCubeRenderTarget: ax,
      WebGLRenderTarget: ha,
      WebGLRenderer: Ux,
      WebGLUtils: KT,
      WebGPUCoordinateSystem: Om,
      WebXRController: E0,
      WireframeGeometry: vT,
      WrapAroundEnding: Bm,
      ZeroCurvatureEnding: Lf,
      ZeroFactor: gE,
      ZeroSlopeEnding: Nf,
      ZeroStencilOp: $C,
      createCanvasElement: QE,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var P1 = { exports: {} },
  du = {};
/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var yb;
function JL() {
  return (
    yb ||
      ((yb = 1),
      (du.ConcurrentRoot = 1),
      (du.ContinuousEventPriority = 8),
      (du.DefaultEventPriority = 32),
      (du.DiscreteEventPriority = 2),
      (du.IdleEventPriority = 268435456),
      (du.LegacyRoot = 0),
      (du.NoEventPriority = 0)),
    du
  );
}
var _b;
function qL() {
  return _b || ((_b = 1), (P1.exports = JL())), P1.exports;
}
var C0 = qL(),
  G1 = { exports: {} },
  z1 = {},
  H1 = { exports: {} },
  V1 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Ab;
function jL() {
  if (Ab) return V1;
  Ab = 1;
  var s = Ud();
  function e(v, _) {
    return (v === _ && (v !== 0 || 1 / v === 1 / _)) || (v !== v && _ !== _);
  }
  var t = typeof Object.is == "function" ? Object.is : e,
    n = s.useState,
    i = s.useEffect,
    a = s.useLayoutEffect,
    l = s.useDebugValue;
  function u(v, _) {
    var A = _(),
      M = n({ inst: { value: A, getSnapshot: _ } }),
      T = M[0].inst,
      E = M[1];
    return (
      a(
        function () {
          (T.value = A), (T.getSnapshot = _), f(T) && E({ inst: T });
        },
        [v, A, _]
      ),
      i(
        function () {
          return (
            f(T) && E({ inst: T }),
            v(function () {
              f(T) && E({ inst: T });
            })
          );
        },
        [v]
      ),
      l(A),
      A
    );
  }
  function f(v) {
    var _ = v.getSnapshot;
    v = v.value;
    try {
      var A = _();
      return !t(v, A);
    } catch {
      return !0;
    }
  }
  function d(v, _) {
    return _();
  }
  var m =
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
      ? d
      : u;
  return (
    (V1.useSyncExternalStore =
      s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : m),
    V1
  );
}
var xb;
function KL() {
  return xb || ((xb = 1), (H1.exports = jL())), H1.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Sb;
function ZL() {
  if (Sb) return z1;
  Sb = 1;
  var s = Ud(),
    e = KL();
  function t(d, m) {
    return (d === m && (d !== 0 || 1 / d === 1 / m)) || (d !== d && m !== m);
  }
  var n = typeof Object.is == "function" ? Object.is : t,
    i = e.useSyncExternalStore,
    a = s.useRef,
    l = s.useEffect,
    u = s.useMemo,
    f = s.useDebugValue;
  return (
    (z1.useSyncExternalStoreWithSelector = function (d, m, v, _, A) {
      var M = a(null);
      if (M.current === null) {
        var T = { hasValue: !1, value: null };
        M.current = T;
      } else T = M.current;
      M = u(
        function () {
          function b(N) {
            if (!w) {
              if (((w = !0), (D = N), (N = _(N)), A !== void 0 && T.hasValue)) {
                var P = T.value;
                if (A(P, N)) return (B = P);
              }
              return (B = N);
            }
            if (((P = B), n(D, N))) return P;
            var F = _(N);
            return A !== void 0 && A(P, F) ? ((D = N), P) : ((D = N), (B = F));
          }
          var w = !1,
            D,
            B,
            I = v === void 0 ? null : v;
          return [
            function () {
              return b(m());
            },
            I === null
              ? void 0
              : function () {
                  return b(I());
                },
          ];
        },
        [m, v, _, A]
      );
      var E = i(d, M[0], M[1]);
      return (
        l(
          function () {
            (T.hasValue = !0), (T.value = E);
          },
          [E]
        ),
        f(E),
        E
      );
    }),
    z1
  );
}
var Mb;
function QL() {
  return Mb || ((Mb = 1), (G1.exports = ZL())), G1.exports;
}
var $L = QL();
const eN = My($L),
  bb = (s) => {
    let e;
    const t = new Set(),
      n = (d, m) => {
        const v = typeof d == "function" ? d(e) : d;
        if (!Object.is(v, e)) {
          const _ = e;
          (e =
            m ?? (typeof v != "object" || v === null)
              ? v
              : Object.assign({}, e, v)),
            t.forEach((A) => A(e, _));
        }
      },
      i = () => e,
      u = {
        setState: n,
        getState: i,
        getInitialState: () => f,
        subscribe: (d) => (t.add(d), () => t.delete(d)),
      },
      f = (e = s(n, i, u));
    return u;
  },
  tN = (s) => (s ? bb(s) : bb),
  { useSyncExternalStoreWithSelector: nN } = eN,
  iN = (s) => s;
function aN(s, e = iN, t) {
  const n = nN(s.subscribe, s.getState, s.getInitialState, e, t);
  return oE.useDebugValue(n), n;
}
const Eb = (s, e) => {
    const t = tN(s),
      n = (i, a = e) => aN(t, i, a);
    return Object.assign(n, t), n;
  },
  ZT = (s, e) => (s ? Eb(s, e) : Eb);
var k1 = { exports: {} },
  X1 = { exports: {} };
/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Tb;
function rN() {
  return (
    Tb ||
      ((Tb = 1),
      (function (s) {
        (s.exports = function (e) {
          function t(c, h, y, S) {
            return new yg(c, h, y, S);
          }
          function n() {}
          function i(c) {
            var h = "https://react.dev/errors/" + c;
            if (1 < arguments.length) {
              h += "?args[]=" + encodeURIComponent(arguments[1]);
              for (var y = 2; y < arguments.length; y++)
                h += "&args[]=" + encodeURIComponent(arguments[y]);
            }
            return (
              "Minified React error #" +
              c +
              "; visit " +
              h +
              " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
            );
          }
          function a(c) {
            return c === null || typeof c != "object"
              ? null
              : ((c = (Qn && c[Qn]) || c["@@iterator"]),
                typeof c == "function" ? c : null);
          }
          function l(c) {
            if (c == null) return null;
            if (typeof c == "function")
              return c.$$typeof === Wi ? null : c.displayName || c.name || null;
            if (typeof c == "string") return c;
            switch (c) {
              case el:
                return "Fragment";
              case bs:
                return "Portal";
              case tl:
                return "Profiler";
              case Yl:
                return "StrictMode";
              case oo:
                return "Suspense";
              case Qc:
                return "SuspenseList";
            }
            if (typeof c == "object")
              switch (c.$$typeof) {
                case nl:
                  return (c.displayName || "Context") + ".Provider";
                case up:
                  return (c._context.displayName || "Context") + ".Consumer";
                case yh:
                  var h = c.render;
                  return (
                    (c = c.displayName),
                    c ||
                      ((c = h.displayName || h.name || ""),
                      (c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")),
                    c
                  );
                case Fu:
                  return (
                    (h = c.displayName || null),
                    h !== null ? h : l(c.type) || "Memo"
                  );
                case lo:
                  (h = c._payload), (c = c._init);
                  try {
                    return l(c(h));
                  } catch {}
              }
            return null;
          }
          function u(c) {
            if (il === void 0)
              try {
                throw Error();
              } catch (y) {
                var h = y.stack.trim().match(/\n( *(at )?)/);
                (il = (h && h[1]) || ""),
                  (al =
                    -1 <
                    y.stack.indexOf(`
    at`)
                      ? " (<anonymous>)"
                      : -1 < y.stack.indexOf("@")
                      ? "@unknown:0:0"
                      : "");
              }
            return (
              `
` +
              il +
              c +
              al
            );
          }
          function f(c, h) {
            if (!c || Pu) return "";
            Pu = !0;
            var y = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
              var S = {
                DetermineComponentFrameRoot: function () {
                  try {
                    if (h) {
                      var Ot = function () {
                        throw Error();
                      };
                      if (
                        (Object.defineProperty(Ot.prototype, "props", {
                          set: function () {
                            throw Error();
                          },
                        }),
                        typeof Reflect == "object" && Reflect.construct)
                      ) {
                        try {
                          Reflect.construct(Ot, []);
                        } catch (cn) {
                          var bt = cn;
                        }
                        Reflect.construct(c, [], Ot);
                      } else {
                        try {
                          Ot.call();
                        } catch (cn) {
                          bt = cn;
                        }
                        c.call(Ot.prototype);
                      }
                    } else {
                      try {
                        throw Error();
                      } catch (cn) {
                        bt = cn;
                      }
                      (Ot = c()) &&
                        typeof Ot.catch == "function" &&
                        Ot.catch(function () {});
                    }
                  } catch (cn) {
                    if (cn && bt && typeof cn.stack == "string")
                      return [cn.stack, bt.stack];
                  }
                  return [null, null];
                },
              };
              S.DetermineComponentFrameRoot.displayName =
                "DetermineComponentFrameRoot";
              var R = Object.getOwnPropertyDescriptor(
                S.DetermineComponentFrameRoot,
                "name"
              );
              R &&
                R.configurable &&
                Object.defineProperty(S.DetermineComponentFrameRoot, "name", {
                  value: "DetermineComponentFrameRoot",
                });
              var L = S.DetermineComponentFrameRoot(),
                ee = L[0],
                _e = L[1];
              if (ee && _e) {
                var Le = ee.split(`
`),
                  ut = _e.split(`
`);
                for (
                  R = S = 0;
                  S < Le.length &&
                  !Le[S].includes("DetermineComponentFrameRoot");

                )
                  S++;
                for (
                  ;
                  R < ut.length &&
                  !ut[R].includes("DetermineComponentFrameRoot");

                )
                  R++;
                if (S === Le.length || R === ut.length)
                  for (
                    S = Le.length - 1, R = ut.length - 1;
                    1 <= S && 0 <= R && Le[S] !== ut[R];

                  )
                    R--;
                for (; 1 <= S && 0 <= R; S--, R--)
                  if (Le[S] !== ut[R]) {
                    if (S !== 1 || R !== 1)
                      do
                        if ((S--, R--, 0 > R || Le[S] !== ut[R])) {
                          var Et =
                            `
` + Le[S].replace(" at new ", " at ");
                          return (
                            c.displayName &&
                              Et.includes("<anonymous>") &&
                              (Et = Et.replace("<anonymous>", c.displayName)),
                            Et
                          );
                        }
                      while (1 <= S && 0 <= R);
                    break;
                  }
              }
            } finally {
              (Pu = !1), (Error.prepareStackTrace = y);
            }
            return (y = c ? c.displayName || c.name : "") ? u(y) : "";
          }
          function d(c) {
            switch (c.tag) {
              case 26:
              case 27:
              case 5:
                return u(c.type);
              case 16:
                return u("Lazy");
              case 13:
                return u("Suspense");
              case 19:
                return u("SuspenseList");
              case 0:
              case 15:
                return (c = f(c.type, !1)), c;
              case 11:
                return (c = f(c.type.render, !1)), c;
              case 1:
                return (c = f(c.type, !0)), c;
              default:
                return "";
            }
          }
          function m(c) {
            try {
              var h = "";
              do (h += d(c)), (c = c.return);
              while (c);
              return h;
            } catch (y) {
              return (
                `
Error generating stack: ` +
                y.message +
                `
` +
                y.stack
              );
            }
          }
          function v(c) {
            var h = c,
              y = c;
            if (c.alternate) for (; h.return; ) h = h.return;
            else {
              c = h;
              do
                (h = c),
                  (h.flags & 4098) !== 0 && (y = h.return),
                  (c = h.return);
              while (c);
            }
            return h.tag === 3 ? y : null;
          }
          function _(c) {
            if (v(c) !== c) throw Error(i(188));
          }
          function A(c) {
            var h = c.alternate;
            if (!h) {
              if (((h = v(c)), h === null)) throw Error(i(188));
              return h !== c ? null : c;
            }
            for (var y = c, S = h; ; ) {
              var R = y.return;
              if (R === null) break;
              var L = R.alternate;
              if (L === null) {
                if (((S = R.return), S !== null)) {
                  y = S;
                  continue;
                }
                break;
              }
              if (R.child === L.child) {
                for (L = R.child; L; ) {
                  if (L === y) return _(R), c;
                  if (L === S) return _(R), h;
                  L = L.sibling;
                }
                throw Error(i(188));
              }
              if (y.return !== S.return) (y = R), (S = L);
              else {
                for (var ee = !1, _e = R.child; _e; ) {
                  if (_e === y) {
                    (ee = !0), (y = R), (S = L);
                    break;
                  }
                  if (_e === S) {
                    (ee = !0), (S = R), (y = L);
                    break;
                  }
                  _e = _e.sibling;
                }
                if (!ee) {
                  for (_e = L.child; _e; ) {
                    if (_e === y) {
                      (ee = !0), (y = L), (S = R);
                      break;
                    }
                    if (_e === S) {
                      (ee = !0), (S = L), (y = R);
                      break;
                    }
                    _e = _e.sibling;
                  }
                  if (!ee) throw Error(i(189));
                }
              }
              if (y.alternate !== S) throw Error(i(190));
            }
            if (y.tag !== 3) throw Error(i(188));
            return y.stateNode.current === y ? c : h;
          }
          function M(c) {
            var h = c.tag;
            if (h === 5 || h === 26 || h === 27 || h === 6) return c;
            for (c = c.child; c !== null; ) {
              if (((h = M(c)), h !== null)) return h;
              c = c.sibling;
            }
            return null;
          }
          function T(c) {
            var h = c.tag;
            if (h === 5 || h === 26 || h === 27 || h === 6) return c;
            for (c = c.child; c !== null; ) {
              if (c.tag !== 4 && ((h = T(c)), h !== null)) return h;
              c = c.sibling;
            }
            return null;
          }
          function E(c) {
            return { current: c };
          }
          function b(c) {
            0 > ll || ((c.current = Dh[ll]), (Dh[ll] = null), ll--);
          }
          function w(c, h) {
            ll++, (Dh[ll] = c.current), (c.current = h);
          }
          function D(c) {
            return (c >>>= 0), c === 0 ? 32 : (31 - ((Op(c) / x_) | 0)) | 0;
          }
          function B(c) {
            var h = c & 42;
            if (h !== 0) return h;
            switch (c & -c) {
              case 1:
                return 1;
              case 2:
                return 2;
              case 4:
                return 4;
              case 8:
                return 8;
              case 16:
                return 16;
              case 32:
                return 32;
              case 64:
                return 64;
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
                return c & 4194176;
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                return c & 62914560;
              case 67108864:
                return 67108864;
              case 134217728:
                return 134217728;
              case 268435456:
                return 268435456;
              case 536870912:
                return 536870912;
              case 1073741824:
                return 0;
              default:
                return c;
            }
          }
          function I(c, h) {
            var y = c.pendingLanes;
            if (y === 0) return 0;
            var S = 0,
              R = c.suspendedLanes,
              L = c.pingedLanes,
              ee = c.warmLanes;
            c = c.finishedLanes !== 0;
            var _e = y & 134217727;
            return (
              _e !== 0
                ? ((y = _e & ~R),
                  y !== 0
                    ? (S = B(y))
                    : ((L &= _e),
                      L !== 0
                        ? (S = B(L))
                        : c || ((ee = _e & ~ee), ee !== 0 && (S = B(ee)))))
                : ((_e = y & ~R),
                  _e !== 0
                    ? (S = B(_e))
                    : L !== 0
                    ? (S = B(L))
                    : c || ((ee = y & ~ee), ee !== 0 && (S = B(ee)))),
              S === 0
                ? 0
                : h !== 0 &&
                  h !== S &&
                  (h & R) === 0 &&
                  ((R = S & -S),
                  (ee = h & -h),
                  R >= ee || (R === 32 && (ee & 4194176) !== 0))
                ? h
                : S
            );
          }
          function N(c, h) {
            return (
              (c.pendingLanes & ~(c.suspendedLanes & ~c.pingedLanes) & h) === 0
            );
          }
          function P(c, h) {
            switch (c) {
              case 1:
              case 2:
              case 4:
              case 8:
                return h + 250;
              case 16:
              case 32:
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
                return h + 5e3;
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                return -1;
              case 67108864:
              case 134217728:
              case 268435456:
              case 536870912:
              case 1073741824:
                return -1;
              default:
                return -1;
            }
          }
          function F() {
            var c = nf;
            return (nf <<= 1), (nf & 4194176) === 0 && (nf = 128), c;
          }
          function O() {
            var c = ku;
            return (ku <<= 1), (ku & 62914560) === 0 && (ku = 4194304), c;
          }
          function U(c) {
            for (var h = [], y = 0; 31 > y; y++) h.push(c);
            return h;
          }
          function W(c, h) {
            (c.pendingLanes |= h),
              h !== 268435456 &&
                ((c.suspendedLanes = 0),
                (c.pingedLanes = 0),
                (c.warmLanes = 0));
          }
          function J(c, h, y, S, R, L) {
            var ee = c.pendingLanes;
            (c.pendingLanes = y),
              (c.suspendedLanes = 0),
              (c.pingedLanes = 0),
              (c.warmLanes = 0),
              (c.expiredLanes &= y),
              (c.entangledLanes &= y),
              (c.errorRecoveryDisabledLanes &= y),
              (c.shellSuspendCounter = 0);
            var _e = c.entanglements,
              Le = c.expirationTimes,
              ut = c.hiddenUpdates;
            for (y = ee & ~y; 0 < y; ) {
              var Et = 31 - Ii(y),
                Ot = 1 << Et;
              (_e[Et] = 0), (Le[Et] = -1);
              var bt = ut[Et];
              if (bt !== null)
                for (ut[Et] = null, Et = 0; Et < bt.length; Et++) {
                  var cn = bt[Et];
                  cn !== null && (cn.lane &= -536870913);
                }
              y &= ~Ot;
            }
            S !== 0 && q(c, S, 0),
              L !== 0 &&
                R === 0 &&
                c.tag !== 0 &&
                (c.suspendedLanes |= L & ~(ee & ~h));
          }
          function q(c, h, y) {
            (c.pendingLanes |= h), (c.suspendedLanes &= ~h);
            var S = 31 - Ii(h);
            (c.entangledLanes |= h),
              (c.entanglements[S] =
                c.entanglements[S] | 1073741824 | (y & 4194218));
          }
          function Z(c, h) {
            var y = (c.entangledLanes |= h);
            for (c = c.entanglements; y; ) {
              var S = 31 - Ii(y),
                R = 1 << S;
              (R & h) | (c[S] & h) && (c[S] |= h), (y &= ~R);
            }
          }
          function ue(c) {
            return (
              (c &= -c),
              2 < c ? (8 < c ? ((c & 134217727) !== 0 ? 32 : 268435456) : 8) : 2
            );
          }
          function K(c) {
            if (Ji && typeof Ji.onCommitFiberRoot == "function")
              try {
                Ji.onCommitFiberRoot(
                  Yu,
                  c,
                  void 0,
                  (c.current.flags & 128) === 128
                );
              } catch {}
          }
          function ge(c) {
            if (
              (typeof Ta == "function" && Oh(c),
              Ji && typeof Ji.setStrictMode == "function")
            )
              try {
                Ji.setStrictMode(Yu, c);
              } catch {}
          }
          function oe(c, h) {
            return (
              (c === h && (c !== 0 || 1 / c === 1 / h)) || (c !== c && h !== h)
            );
          }
          function me(c, h) {
            if (typeof c == "object" && c !== null) {
              var y = Lh.get(c);
              return y !== void 0
                ? y
                : ((h = { value: c, source: h, stack: m(h) }), Lh.set(c, h), h);
            }
            return { value: c, source: h, stack: m(h) };
          }
          function V(c, h) {
            (xr[Sr++] = Wu), (xr[Sr++] = cl), (cl = c), (Wu = h);
          }
          function Y(c, h, y) {
            (ar[Ca++] = Rs), (ar[Ca++] = ws), (ar[Ca++] = ss), (ss = c);
            var S = Rs;
            c = ws;
            var R = 32 - Ii(S) - 1;
            (S &= ~(1 << R)), (y += 1);
            var L = 32 - Ii(h) + R;
            if (30 < L) {
              var ee = R - (R % 5);
              (L = (S & ((1 << ee) - 1)).toString(32)),
                (S >>= ee),
                (R -= ee),
                (Rs = (1 << (32 - Ii(h) + R)) | (y << R) | S),
                (ws = L + c);
            } else (Rs = (1 << L) | (y << R) | S), (ws = c);
          }
          function ae(c) {
            c.return !== null && (V(c, 1), Y(c, 1, 0));
          }
          function fe(c) {
            for (; c === cl; )
              (cl = xr[--Sr]),
                (xr[Sr] = null),
                (Wu = xr[--Sr]),
                (xr[Sr] = null);
            for (; c === ss; )
              (ss = ar[--Ca]),
                (ar[Ca] = null),
                (ws = ar[--Ca]),
                (ar[Ca] = null),
                (Rs = ar[--Ca]),
                (ar[Ca] = null);
          }
          function j(c, h) {
            w(po, h), w(Fr, c), w(Fi, null), (c = cp(h)), b(Fi), w(Fi, c);
          }
          function se() {
            b(Fi), b(Fr), b(po);
          }
          function ve(c) {
            c.memoizedState !== null && w(rf, c);
            var h = Fi.current,
              y = _g(h, c.type);
            h !== y && (w(Fr, c), w(Fi, y));
          }
          function ye(c) {
            Fr.current === c && (b(Fi), b(Fr)),
              rf.current === c &&
                (b(rf),
                is ? (co._currentValue = Jl) : (co._currentValue2 = Jl));
          }
          function be(c) {
            var h = Error(i(418, ""));
            throw (Ie(me(h, c)), sf);
          }
          function it(c, h) {
            if (!ir) throw Error(i(175));
            Kl(c.stateNode, c.type, c.memoizedProps, h, c) || be(c);
          }
          function We(c) {
            for (Pi = c.return; Pi; )
              switch (Pi.tag) {
                case 3:
                case 27:
                  os = !0;
                  return;
                case 5:
                case 13:
                  os = !1;
                  return;
                default:
                  Pi = Pi.return;
              }
          }
          function $e(c) {
            if (!ir || c !== Pi) return !1;
            if (!Pn) return We(c), (Pn = !0), !1;
            var h = !1;
            if (
              (ua
                ? c.tag !== 3 &&
                  c.tag !== 27 &&
                  (c.tag !== 5 ||
                    (Mp(c.type) && !ga(c.type, c.memoizedProps))) &&
                  (h = !0)
                : c.tag !== 3 &&
                  (c.tag !== 5 ||
                    (Mp(c.type) && !ga(c.type, c.memoizedProps))) &&
                  (h = !0),
              h && ei && be(c),
              We(c),
              c.tag === 13)
            ) {
              if (!ir) throw Error(i(316));
              if (
                ((c = c.memoizedState),
                (c = c !== null ? c.dehydrated : null),
                !c)
              )
                throw Error(i(317));
              ei = Zg(c);
            } else ei = Pi ? ol(c.stateNode) : null;
            return !0;
          }
          function Me() {
            ir && ((ei = Pi = null), (Pn = !1));
          }
          function Ie(c) {
            Pr === null ? (Pr = [c]) : Pr.push(c);
          }
          function $() {
            for (var c = mo, h = (ls = mo = 0); h < c; ) {
              var y = rr[h];
              rr[h++] = null;
              var S = rr[h];
              rr[h++] = null;
              var R = rr[h];
              rr[h++] = null;
              var L = rr[h];
              if (((rr[h++] = null), S !== null && R !== null)) {
                var ee = S.pending;
                ee === null
                  ? (R.next = R)
                  : ((R.next = ee.next), (ee.next = R)),
                  (S.pending = R);
              }
              L !== 0 && Ue(y, R, L);
            }
          }
          function ft(c, h, y, S) {
            (rr[mo++] = c),
              (rr[mo++] = h),
              (rr[mo++] = y),
              (rr[mo++] = S),
              (ls |= S),
              (c.lanes |= S),
              (c = c.alternate),
              c !== null && (c.lanes |= S);
          }
          function Pe(c, h, y, S) {
            return ft(c, h, y, S), ht(c);
          }
          function rt(c, h) {
            return ft(c, null, null, h), ht(c);
          }
          function Ue(c, h, y) {
            c.lanes |= y;
            var S = c.alternate;
            S !== null && (S.lanes |= y);
            for (var R = !1, L = c.return; L !== null; )
              (L.childLanes |= y),
                (S = L.alternate),
                S !== null && (S.childLanes |= y),
                L.tag === 22 &&
                  ((c = L.stateNode),
                  c === null || c._visibility & 1 || (R = !0)),
                (c = L),
                (L = L.return);
            R &&
              h !== null &&
              c.tag === 3 &&
              ((L = c.stateNode),
              (R = 31 - Ii(y)),
              (L = L.hiddenUpdates),
              (c = L[R]),
              c === null ? (L[R] = [h]) : c.push(h),
              (h.lane = y | 536870912));
          }
          function ht(c) {
            if (50 < au) throw ((au = 0), (Pp = null), Error(i(185)));
            for (var h = c.return; h !== null; ) (c = h), (h = c.return);
            return c.tag === 3 ? c.stateNode : null;
          }
          function Ve(c) {
            c !== fl &&
              c.next === null &&
              (fl === null ? (mi = fl = c) : (fl = fl.next = c)),
              (Gi = !0),
              Nh || ((Nh = !0), He(k));
          }
          function X(c, h) {
            if (!Ih && Gi) {
              Ih = !0;
              do
                for (var y = !1, S = mi; S !== null; ) {
                  if (c !== 0) {
                    var R = S.pendingLanes;
                    if (R === 0) var L = 0;
                    else {
                      var ee = S.suspendedLanes,
                        _e = S.pingedLanes;
                      (L = (1 << (31 - Ii(42 | c) + 1)) - 1),
                        (L &= R & ~(ee & ~_e)),
                        (L =
                          L & 201326677 ? (L & 201326677) | 1 : L ? L | 2 : 0);
                    }
                    L !== 0 && ((y = !0), we(S, L));
                  } else
                    (L = wn),
                      (L = I(S, S === ni ? L : 0)),
                      (L & 3) === 0 || N(S, L) || ((y = !0), we(S, L));
                  S = S.next;
                }
              while (y);
              Ih = !1;
            }
          }
          function k() {
            Gi = Nh = !1;
            var c = 0;
            Ju !== 0 && (Mg() && (c = Ju), (Ju = 0));
            for (var h = Ar(), y = null, S = mi; S !== null; ) {
              var R = S.next,
                L = de(S, h);
              L === 0
                ? ((S.next = null),
                  y === null ? (mi = R) : (y.next = R),
                  R === null && (fl = y))
                : ((y = S), (c !== 0 || (L & 3) !== 0) && (Gi = !0)),
                (S = R);
            }
            X(c);
          }
          function de(c, h) {
            for (
              var y = c.suspendedLanes,
                S = c.pingedLanes,
                R = c.expirationTimes,
                L = c.pendingLanes & -62914561;
              0 < L;

            ) {
              var ee = 31 - Ii(L),
                _e = 1 << ee,
                Le = R[ee];
              Le === -1
                ? ((_e & y) === 0 || (_e & S) !== 0) && (R[ee] = P(_e, h))
                : Le <= h && (c.expiredLanes |= _e),
                (L &= ~_e);
            }
            if (
              ((h = ni),
              (y = wn),
              (y = I(c, c === h ? y : 0)),
              (S = c.callbackNode),
              y === 0 ||
                (c === h && $n === 2) ||
                c.cancelPendingCommit !== null)
            )
              return (
                S !== null && S !== null && rs(S),
                (c.callbackNode = null),
                (c.callbackPriority = 0)
              );
            if ((y & 3) === 0 || N(c, y)) {
              if (((h = y & -y), h === c.callbackPriority)) return h;
              switch ((S !== null && rs(S), ue(y))) {
                case 2:
                case 8:
                  y = af;
                  break;
                case 32:
                  y = Xu;
                  break;
                case 268435456:
                  y = Ql;
                  break;
                default:
                  y = Xu;
              }
              return (
                (S = Ee.bind(null, c)),
                (y = Cs(y, S)),
                (c.callbackPriority = h),
                (c.callbackNode = y),
                h
              );
            }
            return (
              S !== null && S !== null && rs(S),
              (c.callbackPriority = 2),
              (c.callbackNode = null),
              2
            );
          }
          function Ee(c, h) {
            var y = c.callbackNode;
            if (Ko() && c.callbackNode !== y) return null;
            var S = wn;
            return (
              (S = I(c, c === ni ? S : 0)),
              S === 0
                ? null
                : (vr(c, S, h),
                  de(c, Ar()),
                  c.callbackNode != null && c.callbackNode === y
                    ? Ee.bind(null, c)
                    : null)
            );
          }
          function we(c, h) {
            if (Ko()) return null;
            vr(c, h, !0);
          }
          function He(c) {
            Cg
              ? Rg(function () {
                  (Rn & 6) !== 0 ? Cs(Uh, c) : c();
                })
              : Cs(Uh, c);
          }
          function tt() {
            return Ju === 0 && (Ju = F()), Ju;
          }
          function Ke(c, h) {
            if (qu === null) {
              var y = (qu = []);
              (Fh = 0),
                (gi = tt()),
                (ca = {
                  status: "pending",
                  value: void 0,
                  then: function (S) {
                    y.push(S);
                  },
                });
            }
            return Fh++, h.then(st, st), h;
          }
          function st() {
            if (--Fh === 0 && qu !== null) {
              ca !== null && (ca.status = "fulfilled");
              var c = qu;
              (qu = null), (gi = 0), (ca = null);
              for (var h = 0; h < c.length; h++) (0, c[h])();
            }
          }
          function Ut(c, h) {
            var y = [],
              S = {
                status: "pending",
                value: null,
                reason: null,
                then: function (R) {
                  y.push(R);
                },
              };
            return (
              c.then(
                function () {
                  (S.status = "fulfilled"), (S.value = h);
                  for (var R = 0; R < y.length; R++) (0, y[R])(h);
                },
                function (R) {
                  for (
                    S.status = "rejected", S.reason = R, R = 0;
                    R < y.length;
                    R++
                  )
                    (0, y[R])(void 0);
                }
              ),
              S
            );
          }
          function et(c) {
            c.updateQueue = {
              baseState: c.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: { pending: null, lanes: 0, hiddenCallbacks: null },
              callbacks: null,
            };
          }
          function At(c, h) {
            (c = c.updateQueue),
              h.updateQueue === c &&
                (h.updateQueue = {
                  baseState: c.baseState,
                  firstBaseUpdate: c.firstBaseUpdate,
                  lastBaseUpdate: c.lastBaseUpdate,
                  shared: c.shared,
                  callbacks: null,
                });
          }
          function mt(c) {
            return {
              lane: c,
              tag: 0,
              payload: null,
              callback: null,
              next: null,
            };
          }
          function nt(c, h, y) {
            var S = c.updateQueue;
            if (S === null) return null;
            if (((S = S.shared), (Rn & 2) !== 0)) {
              var R = S.pending;
              return (
                R === null ? (h.next = h) : ((h.next = R.next), (R.next = h)),
                (S.pending = h),
                (h = ht(c)),
                Ue(c, null, y),
                h
              );
            }
            return ft(c, S, h, y), ht(c);
          }
          function Ze(c, h, y) {
            if (
              ((h = h.updateQueue),
              h !== null && ((h = h.shared), (y & 4194176) !== 0))
            ) {
              var S = h.lanes;
              (S &= c.pendingLanes), (y |= S), (h.lanes = y), Z(c, y);
            }
          }
          function le(c, h) {
            var y = c.updateQueue,
              S = c.alternate;
            if (S !== null && ((S = S.updateQueue), y === S)) {
              var R = null,
                L = null;
              if (((y = y.firstBaseUpdate), y !== null)) {
                do {
                  var ee = {
                    lane: y.lane,
                    tag: y.tag,
                    payload: y.payload,
                    callback: null,
                    next: null,
                  };
                  L === null ? (R = L = ee) : (L = L.next = ee), (y = y.next);
                } while (y !== null);
                L === null ? (R = L = h) : (L = L.next = h);
              } else R = L = h;
              (y = {
                baseState: S.baseState,
                firstBaseUpdate: R,
                lastBaseUpdate: L,
                shared: S.shared,
                callbacks: S.callbacks,
              }),
                (c.updateQueue = y);
              return;
            }
            (c = y.lastBaseUpdate),
              c === null ? (y.firstBaseUpdate = h) : (c.next = h),
              (y.lastBaseUpdate = h);
          }
          function Be() {
            if (Ph) {
              var c = ca;
              if (c !== null) throw c;
            }
          }
          function vt(c, h, y, S) {
            Ph = !1;
            var R = c.updateQueue;
            Ra = !1;
            var L = R.firstBaseUpdate,
              ee = R.lastBaseUpdate,
              _e = R.shared.pending;
            if (_e !== null) {
              R.shared.pending = null;
              var Le = _e,
                ut = Le.next;
              (Le.next = null),
                ee === null ? (L = ut) : (ee.next = ut),
                (ee = Le);
              var Et = c.alternate;
              Et !== null &&
                ((Et = Et.updateQueue),
                (_e = Et.lastBaseUpdate),
                _e !== ee &&
                  (_e === null ? (Et.firstBaseUpdate = ut) : (_e.next = ut),
                  (Et.lastBaseUpdate = Le)));
            }
            if (L !== null) {
              var Ot = R.baseState;
              (ee = 0), (Et = ut = Le = null), (_e = L);
              do {
                var bt = _e.lane & -536870913,
                  cn = bt !== _e.lane;
                if (cn ? (wn & bt) === bt : (S & bt) === bt) {
                  bt !== 0 && bt === gi && (Ph = !0),
                    Et !== null &&
                      (Et = Et.next =
                        {
                          lane: 0,
                          tag: _e.tag,
                          payload: _e.payload,
                          callback: null,
                          next: null,
                        });
                  e: {
                    var Wr = c,
                      ec = _e;
                    bt = h;
                    var ru = y;
                    switch (ec.tag) {
                      case 1:
                        if (((Wr = ec.payload), typeof Wr == "function")) {
                          Ot = Wr.call(ru, Ot, bt);
                          break e;
                        }
                        Ot = Wr;
                        break e;
                      case 3:
                        Wr.flags = (Wr.flags & -65537) | 128;
                      case 0:
                        if (
                          ((Wr = ec.payload),
                          (bt =
                            typeof Wr == "function" ? Wr.call(ru, Ot, bt) : Wr),
                          bt == null)
                        )
                          break e;
                        Ot = Li({}, Ot, bt);
                        break e;
                      case 2:
                        Ra = !0;
                    }
                  }
                  (bt = _e.callback),
                    bt !== null &&
                      ((c.flags |= 64),
                      cn && (c.flags |= 8192),
                      (cn = R.callbacks),
                      cn === null ? (R.callbacks = [bt]) : cn.push(bt));
                } else
                  (cn = {
                    lane: bt,
                    tag: _e.tag,
                    payload: _e.payload,
                    callback: _e.callback,
                    next: null,
                  }),
                    Et === null
                      ? ((ut = Et = cn), (Le = Ot))
                      : (Et = Et.next = cn),
                    (ee |= bt);
                if (((_e = _e.next), _e === null)) {
                  if (((_e = R.shared.pending), _e === null)) break;
                  (cn = _e),
                    (_e = cn.next),
                    (cn.next = null),
                    (R.lastBaseUpdate = cn),
                    (R.shared.pending = null);
                }
              } while (!0);
              Et === null && (Le = Ot),
                (R.baseState = Le),
                (R.firstBaseUpdate = ut),
                (R.lastBaseUpdate = Et),
                L === null && (R.shared.lanes = 0),
                (Xr |= ee),
                (c.lanes = ee),
                (c.memoizedState = Ot);
            }
          }
          function ce(c, h) {
            if (typeof c != "function") throw Error(i(191, c));
            c.call(h);
          }
          function xe(c, h) {
            var y = c.callbacks;
            if (y !== null)
              for (c.callbacks = null, c = 0; c < y.length; c++) ce(y[c], h);
          }
          function Re(c, h) {
            if (Ga(c, h)) return !0;
            if (
              typeof c != "object" ||
              c === null ||
              typeof h != "object" ||
              h === null
            )
              return !1;
            var y = Object.keys(c),
              S = Object.keys(h);
            if (y.length !== S.length) return !1;
            for (S = 0; S < y.length; S++) {
              var R = y[S];
              if (!rv.call(h, R) || !Ga(c[R], h[R])) return !1;
            }
            return !0;
          }
          function Qe(c) {
            return (c = c.status), c === "fulfilled" || c === "rejected";
          }
          function gt() {}
          function dt(c, h, y) {
            switch (
              ((y = c[y]),
              y === void 0 ? c.push(h) : y !== h && (h.then(gt, gt), (h = y)),
              h.status)
            ) {
              case "fulfilled":
                return h.value;
              case "rejected":
                throw ((c = h.reason), c === of ? Error(i(483)) : c);
              default:
                if (typeof h.status == "string") h.then(gt, gt);
                else {
                  if (((c = ni), c !== null && 100 < c.shellSuspendCounter))
                    throw Error(i(482));
                  (c = h),
                    (c.status = "pending"),
                    c.then(
                      function (S) {
                        if (h.status === "pending") {
                          var R = h;
                          (R.status = "fulfilled"), (R.value = S);
                        }
                      },
                      function (S) {
                        if (h.status === "pending") {
                          var R = h;
                          (R.status = "rejected"), (R.reason = S);
                        }
                      }
                    );
                }
                switch (h.status) {
                  case "fulfilled":
                    return h.value;
                  case "rejected":
                    throw ((c = h.reason), c === of ? Error(i(483)) : c);
                }
                throw ((wa = h), of);
            }
          }
          function Ct() {
            if (wa === null) throw Error(i(459));
            var c = wa;
            return (wa = null), c;
          }
          function Ht(c) {
            var h = Ba;
            return (Ba += 1), $l === null && ($l = []), dt($l, c, h);
          }
          function Nt(c, h) {
            (h = h.props.ref), (c.ref = h !== void 0 ? h : null);
          }
          function Ft(c, h) {
            throw h.$$typeof === lp
              ? Error(i(525))
              : ((c = Object.prototype.toString.call(h)),
                Error(
                  i(
                    31,
                    c === "[object Object]"
                      ? "object with keys {" + Object.keys(h).join(", ") + "}"
                      : c
                  )
                ));
          }
          function gn(c) {
            var h = c._init;
            return h(c._payload);
          }
          function vn(c) {
            function h(ze, De) {
              if (c) {
                var Xe = ze.deletions;
                Xe === null
                  ? ((ze.deletions = [De]), (ze.flags |= 16))
                  : Xe.push(De);
              }
            }
            function y(ze, De) {
              if (!c) return null;
              for (; De !== null; ) h(ze, De), (De = De.sibling);
              return null;
            }
            function S(ze) {
              for (var De = new Map(); ze !== null; )
                ze.key !== null ? De.set(ze.key, ze) : De.set(ze.index, ze),
                  (ze = ze.sibling);
              return De;
            }
            function R(ze, De) {
              return (ze = ao(ze, De)), (ze.index = 0), (ze.sibling = null), ze;
            }
            function L(ze, De, Xe) {
              return (
                (ze.index = Xe),
                c
                  ? ((Xe = ze.alternate),
                    Xe !== null
                      ? ((Xe = Xe.index),
                        Xe < De ? ((ze.flags |= 33554434), De) : Xe)
                      : ((ze.flags |= 33554434), De))
                  : ((ze.flags |= 1048576), De)
              );
            }
            function ee(ze) {
              return c && ze.alternate === null && (ze.flags |= 33554434), ze;
            }
            function _e(ze, De, Xe, Mt) {
              return De === null || De.tag !== 6
                ? ((De = Zc(Xe, ze.mode, Mt)), (De.return = ze), De)
                : ((De = R(De, Xe)), (De.return = ze), De);
            }
            function Le(ze, De, Xe, Mt) {
              var Wt = Xe.type;
              return Wt === el
                ? Et(ze, De, Xe.props.children, Mt, Xe.key)
                : De !== null &&
                  (De.elementType === Wt ||
                    (typeof Wt == "object" &&
                      Wt !== null &&
                      Wt.$$typeof === lo &&
                      gn(Wt) === De.type))
                ? ((De = R(De, Xe.props)), Nt(De, Xe), (De.return = ze), De)
                : ((De = Xl(Xe.type, Xe.key, Xe.props, null, ze.mode, Mt)),
                  Nt(De, Xe),
                  (De.return = ze),
                  De);
            }
            function ut(ze, De, Xe, Mt) {
              return De === null ||
                De.tag !== 4 ||
                De.stateNode.containerInfo !== Xe.containerInfo ||
                De.stateNode.implementation !== Xe.implementation
                ? ((De = nr(Xe, ze.mode, Mt)), (De.return = ze), De)
                : ((De = R(De, Xe.children || [])), (De.return = ze), De);
            }
            function Et(ze, De, Xe, Mt, Wt) {
              return De === null || De.tag !== 7
                ? ((De = Qo(Xe, ze.mode, Mt, Wt)), (De.return = ze), De)
                : ((De = R(De, Xe)), (De.return = ze), De);
            }
            function Ot(ze, De, Xe) {
              if (
                (typeof De == "string" && De !== "") ||
                typeof De == "number" ||
                typeof De == "bigint"
              )
                return (De = Zc("" + De, ze.mode, Xe)), (De.return = ze), De;
              if (typeof De == "object" && De !== null) {
                switch (De.$$typeof) {
                  case $o:
                    return (
                      (Xe = Xl(De.type, De.key, De.props, null, ze.mode, Xe)),
                      Nt(Xe, De),
                      (Xe.return = ze),
                      Xe
                    );
                  case bs:
                    return (De = nr(De, ze.mode, Xe)), (De.return = ze), De;
                  case lo:
                    var Mt = De._init;
                    return (De = Mt(De._payload)), Ot(ze, De, Xe);
                }
                if (rl(De) || a(De))
                  return (De = Qo(De, ze.mode, Xe, null)), (De.return = ze), De;
                if (typeof De.then == "function") return Ot(ze, Ht(De), Xe);
                if (De.$$typeof === nl) return Ot(ze, Nc(ze, De), Xe);
                Ft(ze, De);
              }
              return null;
            }
            function bt(ze, De, Xe, Mt) {
              var Wt = De !== null ? De.key : null;
              if (
                (typeof Xe == "string" && Xe !== "") ||
                typeof Xe == "number" ||
                typeof Xe == "bigint"
              )
                return Wt !== null ? null : _e(ze, De, "" + Xe, Mt);
              if (typeof Xe == "object" && Xe !== null) {
                switch (Xe.$$typeof) {
                  case $o:
                    return Xe.key === Wt ? Le(ze, De, Xe, Mt) : null;
                  case bs:
                    return Xe.key === Wt ? ut(ze, De, Xe, Mt) : null;
                  case lo:
                    return (
                      (Wt = Xe._init),
                      (Xe = Wt(Xe._payload)),
                      bt(ze, De, Xe, Mt)
                    );
                }
                if (rl(Xe) || a(Xe))
                  return Wt !== null ? null : Et(ze, De, Xe, Mt, null);
                if (typeof Xe.then == "function") return bt(ze, De, Ht(Xe), Mt);
                if (Xe.$$typeof === nl) return bt(ze, De, Nc(ze, Xe), Mt);
                Ft(ze, Xe);
              }
              return null;
            }
            function cn(ze, De, Xe, Mt, Wt) {
              if (
                (typeof Mt == "string" && Mt !== "") ||
                typeof Mt == "number" ||
                typeof Mt == "bigint"
              )
                return (ze = ze.get(Xe) || null), _e(De, ze, "" + Mt, Wt);
              if (typeof Mt == "object" && Mt !== null) {
                switch (Mt.$$typeof) {
                  case $o:
                    return (
                      (ze = ze.get(Mt.key === null ? Xe : Mt.key) || null),
                      Le(De, ze, Mt, Wt)
                    );
                  case bs:
                    return (
                      (ze = ze.get(Mt.key === null ? Xe : Mt.key) || null),
                      ut(De, ze, Mt, Wt)
                    );
                  case lo:
                    var ii = Mt._init;
                    return (Mt = ii(Mt._payload)), cn(ze, De, Xe, Mt, Wt);
                }
                if (rl(Mt) || a(Mt))
                  return (ze = ze.get(Xe) || null), Et(De, ze, Mt, Wt, null);
                if (typeof Mt.then == "function")
                  return cn(ze, De, Xe, Ht(Mt), Wt);
                if (Mt.$$typeof === nl) return cn(ze, De, Xe, Nc(De, Mt), Wt);
                Ft(De, Mt);
              }
              return null;
            }
            function Wr(ze, De, Xe, Mt) {
              for (
                var Wt = null, ii = null, tn = De, En = (De = 0), si = null;
                tn !== null && En < Xe.length;
                En++
              ) {
                tn.index > En ? ((si = tn), (tn = null)) : (si = tn.sibling);
                var Bn = bt(ze, tn, Xe[En], Mt);
                if (Bn === null) {
                  tn === null && (tn = si);
                  break;
                }
                c && tn && Bn.alternate === null && h(ze, tn),
                  (De = L(Bn, De, En)),
                  ii === null ? (Wt = Bn) : (ii.sibling = Bn),
                  (ii = Bn),
                  (tn = si);
              }
              if (En === Xe.length) return y(ze, tn), Pn && V(ze, En), Wt;
              if (tn === null) {
                for (; En < Xe.length; En++)
                  (tn = Ot(ze, Xe[En], Mt)),
                    tn !== null &&
                      ((De = L(tn, De, En)),
                      ii === null ? (Wt = tn) : (ii.sibling = tn),
                      (ii = tn));
                return Pn && V(ze, En), Wt;
              }
              for (tn = S(tn); En < Xe.length; En++)
                (si = cn(tn, ze, En, Xe[En], Mt)),
                  si !== null &&
                    (c &&
                      si.alternate !== null &&
                      tn.delete(si.key === null ? En : si.key),
                    (De = L(si, De, En)),
                    ii === null ? (Wt = si) : (ii.sibling = si),
                    (ii = si));
              return (
                c &&
                  tn.forEach(function (Al) {
                    return h(ze, Al);
                  }),
                Pn && V(ze, En),
                Wt
              );
            }
            function ec(ze, De, Xe, Mt) {
              if (Xe == null) throw Error(i(151));
              for (
                var Wt = null,
                  ii = null,
                  tn = De,
                  En = (De = 0),
                  si = null,
                  Bn = Xe.next();
                tn !== null && !Bn.done;
                En++, Bn = Xe.next()
              ) {
                tn.index > En ? ((si = tn), (tn = null)) : (si = tn.sibling);
                var Al = bt(ze, tn, Bn.value, Mt);
                if (Al === null) {
                  tn === null && (tn = si);
                  break;
                }
                c && tn && Al.alternate === null && h(ze, tn),
                  (De = L(Al, De, En)),
                  ii === null ? (Wt = Al) : (ii.sibling = Al),
                  (ii = Al),
                  (tn = si);
              }
              if (Bn.done) return y(ze, tn), Pn && V(ze, En), Wt;
              if (tn === null) {
                for (; !Bn.done; En++, Bn = Xe.next())
                  (Bn = Ot(ze, Bn.value, Mt)),
                    Bn !== null &&
                      ((De = L(Bn, De, En)),
                      ii === null ? (Wt = Bn) : (ii.sibling = Bn),
                      (ii = Bn));
                return Pn && V(ze, En), Wt;
              }
              for (tn = S(tn); !Bn.done; En++, Bn = Xe.next())
                (Bn = cn(tn, ze, En, Bn.value, Mt)),
                  Bn !== null &&
                    (c &&
                      Bn.alternate !== null &&
                      tn.delete(Bn.key === null ? En : Bn.key),
                    (De = L(Bn, De, En)),
                    ii === null ? (Wt = Bn) : (ii.sibling = Bn),
                    (ii = Bn));
              return (
                c &&
                  tn.forEach(function (ov) {
                    return h(ze, ov);
                  }),
                Pn && V(ze, En),
                Wt
              );
            }
            function ru(ze, De, Xe, Mt) {
              if (
                (typeof Xe == "object" &&
                  Xe !== null &&
                  Xe.type === el &&
                  Xe.key === null &&
                  (Xe = Xe.props.children),
                typeof Xe == "object" && Xe !== null)
              ) {
                switch (Xe.$$typeof) {
                  case $o:
                    e: {
                      for (var Wt = Xe.key; De !== null; ) {
                        if (De.key === Wt) {
                          if (((Wt = Xe.type), Wt === el)) {
                            if (De.tag === 7) {
                              y(ze, De.sibling),
                                (Mt = R(De, Xe.props.children)),
                                (Mt.return = ze),
                                (ze = Mt);
                              break e;
                            }
                          } else if (
                            De.elementType === Wt ||
                            (typeof Wt == "object" &&
                              Wt !== null &&
                              Wt.$$typeof === lo &&
                              gn(Wt) === De.type)
                          ) {
                            y(ze, De.sibling),
                              (Mt = R(De, Xe.props)),
                              Nt(Mt, Xe),
                              (Mt.return = ze),
                              (ze = Mt);
                            break e;
                          }
                          y(ze, De);
                          break;
                        } else h(ze, De);
                        De = De.sibling;
                      }
                      Xe.type === el
                        ? ((Mt = Qo(Xe.props.children, ze.mode, Mt, Xe.key)),
                          (Mt.return = ze),
                          (ze = Mt))
                        : ((Mt = Xl(
                            Xe.type,
                            Xe.key,
                            Xe.props,
                            null,
                            ze.mode,
                            Mt
                          )),
                          Nt(Mt, Xe),
                          (Mt.return = ze),
                          (ze = Mt));
                    }
                    return ee(ze);
                  case bs:
                    e: {
                      for (Wt = Xe.key; De !== null; ) {
                        if (De.key === Wt)
                          if (
                            De.tag === 4 &&
                            De.stateNode.containerInfo === Xe.containerInfo &&
                            De.stateNode.implementation === Xe.implementation
                          ) {
                            y(ze, De.sibling),
                              (Mt = R(De, Xe.children || [])),
                              (Mt.return = ze),
                              (ze = Mt);
                            break e;
                          } else {
                            y(ze, De);
                            break;
                          }
                        else h(ze, De);
                        De = De.sibling;
                      }
                      (Mt = nr(Xe, ze.mode, Mt)), (Mt.return = ze), (ze = Mt);
                    }
                    return ee(ze);
                  case lo:
                    return (
                      (Wt = Xe._init),
                      (Xe = Wt(Xe._payload)),
                      ru(ze, De, Xe, Mt)
                    );
                }
                if (rl(Xe)) return Wr(ze, De, Xe, Mt);
                if (a(Xe)) {
                  if (((Wt = a(Xe)), typeof Wt != "function"))
                    throw Error(i(150));
                  return (Xe = Wt.call(Xe)), ec(ze, De, Xe, Mt);
                }
                if (typeof Xe.then == "function") return ru(ze, De, Ht(Xe), Mt);
                if (Xe.$$typeof === nl) return ru(ze, De, Nc(ze, Xe), Mt);
                Ft(ze, Xe);
              }
              return (typeof Xe == "string" && Xe !== "") ||
                typeof Xe == "number" ||
                typeof Xe == "bigint"
                ? ((Xe = "" + Xe),
                  De !== null && De.tag === 6
                    ? (y(ze, De.sibling),
                      (Mt = R(De, Xe)),
                      (Mt.return = ze),
                      (ze = Mt))
                    : (y(ze, De),
                      (Mt = Zc(Xe, ze.mode, Mt)),
                      (Mt.return = ze),
                      (ze = Mt)),
                  ee(ze))
                : y(ze, De);
            }
            return function (ze, De, Xe, Mt) {
              try {
                Ba = 0;
                var Wt = ru(ze, De, Xe, Mt);
                return ($l = null), Wt;
              } catch (tn) {
                if (tn === of) throw tn;
                var ii = t(29, tn, null, ze.mode);
                return (ii.lanes = Mt), (ii.return = ze), ii;
              } finally {
              }
            };
          }
          function ai(c, h) {
            (c = hs), w(cs, c), w(us, h), (hs = c | h.baseLanes);
          }
          function Bi() {
            w(cs, hs), w(us, us.current);
          }
          function ui() {
            (hs = cs.current), b(us), b(cs);
          }
          function di(c) {
            var h = c.alternate;
            w(fi, fi.current & 1),
              w(sr, c),
              Gr === null &&
                (h === null ||
                  us.current !== null ||
                  h.memoizedState !== null) &&
                (Gr = c);
          }
          function Di(c) {
            if (c.tag === 22) {
              if ((w(fi, fi.current), w(sr, c), Gr === null)) {
                var h = c.alternate;
                h !== null && h.memoizedState !== null && (Gr = c);
              }
            } else pi();
          }
          function pi() {
            w(fi, fi.current), w(sr, sr.current);
          }
          function zt(c) {
            b(sr), Gr === c && (Gr = null), b(fi);
          }
          function pn(c) {
            for (var h = c; h !== null; ) {
              if (h.tag === 13) {
                var y = h.memoizedState;
                if (
                  y !== null &&
                  ((y = y.dehydrated), y === null || ql(y) || tf(y))
                )
                  return h;
              } else if (
                h.tag === 19 &&
                h.memoizedProps.revealOrder !== void 0
              ) {
                if ((h.flags & 128) !== 0) return h;
              } else if (h.child !== null) {
                (h.child.return = h), (h = h.child);
                continue;
              }
              if (h === c) break;
              for (; h.sibling === null; ) {
                if (h.return === null || h.return === c) return null;
                h = h.return;
              }
              (h.sibling.return = h.return), (h = h.sibling);
            }
            return null;
          }
          function en() {
            throw Error(i(321));
          }
          function H(c, h) {
            if (h === null) return !1;
            for (var y = 0; y < h.length && y < c.length; y++)
              if (!Ga(c[y], h[y])) return !1;
            return !0;
          }
          function te(c, h, y, S, R, L) {
            return (
              (go = L),
              (ln = h),
              (h.memoizedState = null),
              (h.updateQueue = null),
              (h.lanes = 0),
              (nn.H = c === null || c.memoizedState === null ? _o : Ha),
              (dl = !1),
              (L = y(S, R)),
              (dl = !1),
              eu && (L = Ge(h, y, S, R)),
              Ae(c),
              L
            );
          }
          function Ae(c) {
            nn.H = zi;
            var h = Vn !== null && Vn.next !== null;
            if (
              ((go = 0),
              (xi = Vn = ln = null),
              (vo = !1),
              (ju = 0),
              (yo = null),
              h)
            )
              throw Error(i(300));
            c === null ||
              qi ||
              ((c = c.dependencies), c !== null && Lc(c) && (qi = !0));
          }
          function Ge(c, h, y, S) {
            ln = c;
            var R = 0;
            do {
              if ((eu && (yo = null), (ju = 0), (eu = !1), 25 <= R))
                throw Error(i(301));
              if (((R += 1), (xi = Vn = null), c.updateQueue != null)) {
                var L = c.updateQueue;
                (L.lastEffect = null),
                  (L.events = null),
                  (L.stores = null),
                  L.memoCache != null && (L.memoCache.index = 0);
              }
              (nn.H = ml), (L = h(y, S));
            } while (eu);
            return L;
          }
          function qe() {
            var c = nn.H,
              h = c.useState()[0];
            return (
              (h = typeof h.then == "function" ? pe(h) : h),
              (c = c.useState()[0]),
              (Vn !== null ? Vn.memoizedState : null) !== c &&
                (ln.flags |= 1024),
              h
            );
          }
          function Je() {
            var c = pl !== 0;
            return (pl = 0), c;
          }
          function St(c, h, y) {
            (h.updateQueue = c.updateQueue),
              (h.flags &= -2053),
              (c.lanes &= ~y);
          }
          function yt(c) {
            if (vo) {
              for (c = c.memoizedState; c !== null; ) {
                var h = c.queue;
                h !== null && (h.pending = null), (c = c.next);
              }
              vo = !1;
            }
            (go = 0),
              (xi = Vn = ln = null),
              (eu = !1),
              (ju = pl = 0),
              (yo = null);
          }
          function z() {
            var c = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null,
            };
            return (
              xi === null ? (ln.memoizedState = xi = c) : (xi = xi.next = c), xi
            );
          }
          function re() {
            if (Vn === null) {
              var c = ln.alternate;
              c = c !== null ? c.memoizedState : null;
            } else c = Vn.next;
            var h = xi === null ? ln.memoizedState : xi.next;
            if (h !== null) (xi = h), (Vn = c);
            else {
              if (c === null)
                throw ln.alternate === null ? Error(i(467)) : Error(i(310));
              (Vn = c),
                (c = {
                  memoizedState: Vn.memoizedState,
                  baseState: Vn.baseState,
                  baseQueue: Vn.baseQueue,
                  queue: Vn.queue,
                  next: null,
                }),
                xi === null ? (ln.memoizedState = xi = c) : (xi = xi.next = c);
            }
            return xi;
          }
          function pe(c) {
            var h = ju;
            return (
              (ju += 1),
              yo === null && (yo = []),
              (c = dt(yo, c, h)),
              (h = ln),
              (xi === null ? h.memoizedState : xi.next) === null &&
                ((h = h.alternate),
                (nn.H = h === null || h.memoizedState === null ? _o : Ha)),
              c
            );
          }
          function ne(c) {
            if (c !== null && typeof c == "object") {
              if (typeof c.then == "function") return pe(c);
              if (c.$$typeof === nl) return pa(c);
            }
            throw Error(i(438, String(c)));
          }
          function Se(c) {
            var h = null,
              y = ln.updateQueue;
            if ((y !== null && (h = y.memoCache), h == null)) {
              var S = ln.alternate;
              S !== null &&
                ((S = S.updateQueue),
                S !== null &&
                  ((S = S.memoCache),
                  S != null &&
                    (h = {
                      data: S.data.map(function (R) {
                        return R.slice();
                      }),
                      index: 0,
                    })));
            }
            if (
              (h == null && (h = { data: [], index: 0 }),
              y === null && ((y = Lp()), (ln.updateQueue = y)),
              (y.memoCache = h),
              (y = h.data[h.index]),
              y === void 0)
            )
              for (y = h.data[h.index] = Array(c), S = 0; S < c; S++) y[S] = xn;
            return h.index++, y;
          }
          function Ne(c, h) {
            return typeof h == "function" ? h(c) : h;
          }
          function Ye(c) {
            var h = re();
            return lt(h, Vn, c);
          }
          function lt(c, h, y) {
            var S = c.queue;
            if (S === null) throw Error(i(311));
            S.lastRenderedReducer = y;
            var R = c.baseQueue,
              L = S.pending;
            if (L !== null) {
              if (R !== null) {
                var ee = R.next;
                (R.next = L.next), (L.next = ee);
              }
              (h.baseQueue = R = L), (S.pending = null);
            }
            if (((L = c.baseState), R === null)) c.memoizedState = L;
            else {
              h = R.next;
              var _e = (ee = null),
                Le = null,
                ut = h,
                Et = !1;
              do {
                var Ot = ut.lane & -536870913;
                if (Ot !== ut.lane ? (wn & Ot) === Ot : (go & Ot) === Ot) {
                  var bt = ut.revertLane;
                  if (bt === 0)
                    Le !== null &&
                      (Le = Le.next =
                        {
                          lane: 0,
                          revertLane: 0,
                          action: ut.action,
                          hasEagerState: ut.hasEagerState,
                          eagerState: ut.eagerState,
                          next: null,
                        }),
                      Ot === gi && (Et = !0);
                  else if ((go & bt) === bt) {
                    (ut = ut.next), bt === gi && (Et = !0);
                    continue;
                  } else
                    (Ot = {
                      lane: 0,
                      revertLane: ut.revertLane,
                      action: ut.action,
                      hasEagerState: ut.hasEagerState,
                      eagerState: ut.eagerState,
                      next: null,
                    }),
                      Le === null
                        ? ((_e = Le = Ot), (ee = L))
                        : (Le = Le.next = Ot),
                      (ln.lanes |= bt),
                      (Xr |= bt);
                  (Ot = ut.action),
                    dl && y(L, Ot),
                    (L = ut.hasEagerState ? ut.eagerState : y(L, Ot));
                } else
                  (bt = {
                    lane: Ot,
                    revertLane: ut.revertLane,
                    action: ut.action,
                    hasEagerState: ut.hasEagerState,
                    eagerState: ut.eagerState,
                    next: null,
                  }),
                    Le === null
                      ? ((_e = Le = bt), (ee = L))
                      : (Le = Le.next = bt),
                    (ln.lanes |= Ot),
                    (Xr |= Ot);
                ut = ut.next;
              } while (ut !== null && ut !== h);
              if (
                (Le === null ? (ee = L) : (Le.next = _e),
                !Ga(L, c.memoizedState) &&
                  ((qi = !0), Et && ((y = ca), y !== null)))
              )
                throw y;
              (c.memoizedState = L),
                (c.baseState = ee),
                (c.baseQueue = Le),
                (S.lastRenderedState = L);
            }
            return R === null && (S.lanes = 0), [c.memoizedState, S.dispatch];
          }
          function pt(c) {
            var h = re(),
              y = h.queue;
            if (y === null) throw Error(i(311));
            y.lastRenderedReducer = c;
            var S = y.dispatch,
              R = y.pending,
              L = h.memoizedState;
            if (R !== null) {
              y.pending = null;
              var ee = (R = R.next);
              do (L = c(L, ee.action)), (ee = ee.next);
              while (ee !== R);
              Ga(L, h.memoizedState) || (qi = !0),
                (h.memoizedState = L),
                h.baseQueue === null && (h.baseState = L),
                (y.lastRenderedState = L);
            }
            return [L, S];
          }
          function wt(c, h, y) {
            var S = ln,
              R = re(),
              L = Pn;
            if (L) {
              if (y === void 0) throw Error(i(407));
              y = y();
            } else y = h();
            var ee = !Ga((Vn || R).memoizedState, y);
            if (
              (ee && ((R.memoizedState = y), (qi = !0)),
              (R = R.queue),
              Qr(jt.bind(null, S, R, c), [c]),
              R.getSnapshot !== h ||
                ee ||
                (xi !== null && xi.memoizedState.tag & 1))
            ) {
              if (
                ((S.flags |= 2048),
                Sa(9, Rt.bind(null, S, R, y, h), { destroy: void 0 }, null),
                ni === null)
              )
                throw Error(i(349));
              L || (go & 60) !== 0 || Bt(S, h, y);
            }
            return y;
          }
          function Bt(c, h, y) {
            (c.flags |= 16384),
              (c = { getSnapshot: h, value: y }),
              (h = ln.updateQueue),
              h === null
                ? ((h = Lp()), (ln.updateQueue = h), (h.stores = [c]))
                : ((y = h.stores), y === null ? (h.stores = [c]) : y.push(c));
          }
          function Rt(c, h, y, S) {
            (h.value = y), (h.getSnapshot = S), Pt(h) && yn(c);
          }
          function jt(c, h, y) {
            return y(function () {
              Pt(h) && yn(c);
            });
          }
          function Pt(c) {
            var h = c.getSnapshot;
            c = c.value;
            try {
              var y = h();
              return !Ga(c, y);
            } catch {
              return !0;
            }
          }
          function yn(c) {
            var h = rt(c, 2);
            h !== null && ci(h, c, 2);
          }
          function Vt(c) {
            var h = z();
            if (typeof c == "function") {
              var y = c;
              if (((c = y()), dl)) {
                ge(!0);
                try {
                  y();
                } finally {
                  ge(!1);
                }
              }
            }
            return (
              (h.memoizedState = h.baseState = c),
              (h.queue = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Ne,
                lastRenderedState: c,
              }),
              h
            );
          }
          function Gt(c, h, y, S) {
            return (
              (c.baseState = y), lt(c, Vn, typeof S == "function" ? S : Ne)
            );
          }
          function It(c, h, y, S, R) {
            if (zo(c)) throw Error(i(485));
            if (((c = h.action), c !== null)) {
              var L = {
                payload: R,
                action: c,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function (ee) {
                  L.listeners.push(ee);
                },
              };
              nn.T !== null ? y(!0) : (L.isTransition = !1),
                S(L),
                (y = h.pending),
                y === null
                  ? ((L.next = h.pending = L), Jn(h, L))
                  : ((L.next = y.next), (h.pending = y.next = L));
            }
          }
          function Jn(c, h) {
            var y = h.action,
              S = h.payload,
              R = c.state;
            if (h.isTransition) {
              var L = nn.T,
                ee = {};
              nn.T = ee;
              try {
                var _e = y(R, S),
                  Le = nn.S;
                Le !== null && Le(ee, _e), qt(c, h, _e);
              } catch (ut) {
                Ln(c, h, ut);
              } finally {
                nn.T = L;
              }
            } else
              try {
                (L = y(R, S)), qt(c, h, L);
              } catch (ut) {
                Ln(c, h, ut);
              }
          }
          function qt(c, h, y) {
            y !== null && typeof y == "object" && typeof y.then == "function"
              ? y.then(
                  function (S) {
                    rn(c, h, S);
                  },
                  function (S) {
                    return Ln(c, h, S);
                  }
                )
              : rn(c, h, y);
          }
          function rn(c, h, y) {
            (h.status = "fulfilled"),
              (h.value = y),
              sn(h),
              (c.state = y),
              (h = c.pending),
              h !== null &&
                ((y = h.next),
                y === h
                  ? (c.pending = null)
                  : ((y = y.next), (h.next = y), Jn(c, y)));
          }
          function Ln(c, h, y) {
            var S = c.pending;
            if (((c.pending = null), S !== null)) {
              S = S.next;
              do (h.status = "rejected"), (h.reason = y), sn(h), (h = h.next);
              while (h !== S);
            }
            c.action = null;
          }
          function sn(c) {
            c = c.listeners;
            for (var h = 0; h < c.length; h++) (0, c[h])();
          }
          function Xt(c, h) {
            return h;
          }
          function on(c, h) {
            if (Pn) {
              var y = ni.formState;
              if (y !== null) {
                e: {
                  var S = ln;
                  if (Pn) {
                    if (ei) {
                      var R = Jg(ei, os);
                      if (R) {
                        (ei = ol(R)), (S = Ts(R));
                        break e;
                      }
                    }
                    be(S);
                  }
                  S = !1;
                }
                S && (h = y[0]);
              }
            }
            (y = z()),
              (y.memoizedState = y.baseState = h),
              (S = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Xt,
                lastRenderedState: h,
              }),
              (y.queue = S),
              (y = Tu.bind(null, ln, S)),
              (S.dispatch = y),
              (S = Vt(!1));
            var L = Xs.bind(null, ln, !1, S.queue);
            return (
              (S = z()),
              (R = { state: h, dispatch: null, action: c, pending: null }),
              (S.queue = R),
              (y = It.bind(null, ln, R, L, y)),
              (R.dispatch = y),
              (S.memoizedState = c),
              [h, y, !1]
            );
          }
          function Zn(c) {
            var h = re();
            return Tn(h, Vn, c);
          }
          function Tn(c, h, y) {
            (h = lt(c, h, Xt)[0]),
              (c = Ye(Ne)[0]),
              (h =
                typeof h == "object" &&
                h !== null &&
                typeof h.then == "function"
                  ? pe(h)
                  : h);
            var S = re(),
              R = S.queue,
              L = R.dispatch;
            return (
              y !== S.memoizedState &&
                ((ln.flags |= 2048),
                Sa(9, Nn.bind(null, R, y), { destroy: void 0 }, null)),
              [h, L, c]
            );
          }
          function Nn(c, h) {
            c.action = h;
          }
          function Mi(c) {
            var h = re(),
              y = Vn;
            if (y !== null) return Tn(h, y, c);
            re(), (h = h.memoizedState), (y = re());
            var S = y.queue.dispatch;
            return (y.memoizedState = c), [h, S, !1];
          }
          function Sa(c, h, y, S) {
            return (
              (c = { tag: c, create: h, inst: y, deps: S, next: null }),
              (h = ln.updateQueue),
              h === null && ((h = Lp()), (ln.updateQueue = h)),
              (y = h.lastEffect),
              y === null
                ? (h.lastEffect = c.next = c)
                : ((S = y.next),
                  (y.next = c),
                  (c.next = S),
                  (h.lastEffect = c)),
              c
            );
          }
          function ea() {
            return re().memoizedState;
          }
          function Bl(c, h, y, S) {
            var R = z();
            (ln.flags |= c),
              (R.memoizedState = Sa(
                1 | h,
                y,
                { destroy: void 0 },
                S === void 0 ? null : S
              ));
          }
          function Fo(c, h, y, S) {
            var R = re();
            S = S === void 0 ? null : S;
            var L = R.memoizedState.inst;
            Vn !== null && S !== null && H(S, Vn.memoizedState.deps)
              ? (R.memoizedState = Sa(h, y, L, S))
              : ((ln.flags |= c), (R.memoizedState = Sa(1 | h, y, L, S)));
          }
          function Dl(c, h) {
            Bl(8390656, 8, c, h);
          }
          function Qr(c, h) {
            Fo(2048, 8, c, h);
          }
          function Rc(c, h) {
            return Fo(4, 2, c, h);
          }
          function Ul(c, h) {
            return Fo(4, 4, c, h);
          }
          function wr(c, h) {
            if (typeof h == "function") {
              c = c();
              var y = h(c);
              return function () {
                typeof y == "function" ? y() : h(null);
              };
            }
            if (h != null)
              return (
                (c = c()),
                (h.current = c),
                function () {
                  h.current = null;
                }
              );
          }
          function $r(c, h, y) {
            (y = y != null ? y.concat([c]) : null),
              Fo(4, 4, wr.bind(null, h, c), y);
          }
          function es() {}
          function ys(c, h) {
            var y = re();
            h = h === void 0 ? null : h;
            var S = y.memoizedState;
            return h !== null && H(h, S[1])
              ? S[0]
              : ((y.memoizedState = [c, h]), c);
          }
          function pr(c, h) {
            var y = re();
            h = h === void 0 ? null : h;
            var S = y.memoizedState;
            if (h !== null && H(h, S[1])) return S[0];
            if (((S = c()), dl)) {
              ge(!0);
              try {
                c();
              } finally {
                ge(!1);
              }
            }
            return (y.memoizedState = [S, h]), S;
          }
          function Po(c, h, y) {
            return y === void 0 || (go & 1073741824) !== 0
              ? (c.memoizedState = h)
              : ((c.memoizedState = y),
                (c = Xc()),
                (ln.lanes |= c),
                (Xr |= c),
                y);
          }
          function Go(c, h, y, S) {
            return Ga(y, h)
              ? y
              : us.current !== null
              ? ((c = Po(c, y, S)), Ga(c, h) || (qi = !0), c)
              : (go & 42) === 0
              ? ((qi = !0), (c.memoizedState = y))
              : ((c = Xc()), (ln.lanes |= c), (Xr |= c), h);
          }
          function Eu(c, h, y, S, R) {
            var L = sl();
            Pa(L !== 0 && 8 > L ? L : 8);
            var ee = nn.T,
              _e = {};
            (nn.T = _e), Xs(c, !1, h, y);
            try {
              var Le = R(),
                ut = nn.S;
              if (
                (ut !== null && ut(_e, Le),
                Le !== null &&
                  typeof Le == "object" &&
                  typeof Le.then == "function")
              ) {
                var Et = Ut(Le, S);
                Br(c, h, Et, ba(c));
              } else Br(c, h, S, ba(c));
            } catch (Ot) {
              Br(
                c,
                h,
                { then: function () {}, status: "rejected", reason: Ot },
                ba()
              );
            } finally {
              Pa(L), (nn.T = ee);
            }
          }
          function ts(c) {
            var h = c.memoizedState;
            if (h !== null) return h;
            h = {
              memoizedState: Jl,
              baseState: Jl,
              baseQueue: null,
              queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Ne,
                lastRenderedState: Jl,
              },
              next: null,
            };
            var y = {};
            return (
              (h.next = {
                memoizedState: y,
                baseState: y,
                baseQueue: null,
                queue: {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: Ne,
                  lastRenderedState: y,
                },
                next: null,
              }),
              (c.memoizedState = h),
              (c = c.alternate),
              c !== null && (c.memoizedState = h),
              h
            );
          }
          function Vs() {
            return pa(co);
          }
          function ks() {
            return re().memoizedState;
          }
          function Ui() {
            return re().memoizedState;
          }
          function Ol(c) {
            for (var h = c.return; h !== null; ) {
              switch (h.tag) {
                case 24:
                case 3:
                  var y = ba();
                  c = mt(y);
                  var S = nt(h, c, y);
                  S !== null && (ci(S, h, y), Ze(S, h, y)),
                    (h = { cache: ko() }),
                    (c.payload = h);
                  return;
              }
              h = h.return;
            }
          }
          function Ll(c, h, y) {
            var S = ba();
            (y = {
              lane: S,
              revertLane: 0,
              action: y,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            }),
              zo(c)
                ? Oi(h, y)
                : ((y = Pe(c, h, y, S)),
                  y !== null && (ci(y, c, S), ja(y, h, S)));
          }
          function Tu(c, h, y) {
            var S = ba();
            Br(c, h, y, S);
          }
          function Br(c, h, y, S) {
            var R = {
              lane: S,
              revertLane: 0,
              action: y,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            };
            if (zo(c)) Oi(h, R);
            else {
              var L = c.alternate;
              if (
                c.lanes === 0 &&
                (L === null || L.lanes === 0) &&
                ((L = h.lastRenderedReducer), L !== null)
              )
                try {
                  var ee = h.lastRenderedState,
                    _e = L(ee, y);
                  if (((R.hasEagerState = !0), (R.eagerState = _e), Ga(_e, ee)))
                    return ft(c, h, R, 0), ni === null && $(), !1;
                } catch {
                } finally {
                }
              if (((y = Pe(c, h, R, S)), y !== null))
                return ci(y, c, S), ja(y, h, S), !0;
            }
            return !1;
          }
          function Xs(c, h, y, S) {
            if (
              ((S = {
                lane: 2,
                revertLane: tt(),
                action: S,
                hasEagerState: !1,
                eagerState: null,
                next: null,
              }),
              zo(c))
            ) {
              if (h) throw Error(i(479));
            } else (h = Pe(c, y, S, 2)), h !== null && ci(h, c, 2);
          }
          function zo(c) {
            var h = c.alternate;
            return c === ln || (h !== null && h === ln);
          }
          function Oi(c, h) {
            eu = vo = !0;
            var y = c.pending;
            y === null ? (h.next = h) : ((h.next = y.next), (y.next = h)),
              (c.pending = h);
          }
          function ja(c, h, y) {
            if ((y & 4194176) !== 0) {
              var S = h.lanes;
              (S &= c.pendingLanes), (y |= S), (h.lanes = y), Z(c, y);
            }
          }
          function Ia(c, h, y, S) {
            (h = c.memoizedState),
              (y = y(S, h)),
              (y = y == null ? h : Li({}, h, y)),
              (c.memoizedState = y),
              c.lanes === 0 && (c.updateQueue.baseState = y);
          }
          function Ys(c, h, y, S, R, L, ee) {
            return (
              (c = c.stateNode),
              typeof c.shouldComponentUpdate == "function"
                ? c.shouldComponentUpdate(S, L, ee)
                : h.prototype && h.prototype.isPureReactComponent
                ? !Re(y, S) || !Re(R, L)
                : !0
            );
          }
          function Cu(c, h, y, S) {
            (c = h.state),
              typeof h.componentWillReceiveProps == "function" &&
                h.componentWillReceiveProps(y, S),
              typeof h.UNSAFE_componentWillReceiveProps == "function" &&
                h.UNSAFE_componentWillReceiveProps(y, S),
              h.state !== c && Ku.enqueueReplaceState(h, h.state, null);
          }
          function mr(c, h) {
            var y = h;
            if ("ref" in h) {
              y = {};
              for (var S in h) S !== "ref" && (y[S] = h[S]);
            }
            if ((c = c.defaultProps)) {
              y === h && (y = Li({}, y));
              for (var R in c) y[R] === void 0 && (y[R] = c[R]);
            }
            return y;
          }
          function Dr(c, h) {
            try {
              var y = c.onUncaughtError;
              y(h.value, { componentStack: h.stack });
            } catch (S) {
              setTimeout(function () {
                throw S;
              });
            }
          }
          function Ws(c, h, y) {
            try {
              var S = c.onCaughtError;
              S(y.value, {
                componentStack: y.stack,
                errorBoundary: h.tag === 1 ? h.stateNode : null,
              });
            } catch (R) {
              setTimeout(function () {
                throw R;
              });
            }
          }
          function Ur(c, h, y) {
            return (
              (y = mt(y)),
              (y.tag = 3),
              (y.payload = { element: null }),
              (y.callback = function () {
                Dr(c, h);
              }),
              y
            );
          }
          function Nl(c) {
            return (c = mt(c)), (c.tag = 3), c;
          }
          function Ma(c, h, y, S) {
            var R = y.type.getDerivedStateFromError;
            if (typeof R == "function") {
              var L = S.value;
              (c.payload = function () {
                return R(L);
              }),
                (c.callback = function () {
                  Ws(h, y, S);
                });
            }
            var ee = y.stateNode;
            ee !== null &&
              typeof ee.componentDidCatch == "function" &&
              (c.callback = function () {
                Ws(h, y, S),
                  typeof R != "function" &&
                    (Os === null ? (Os = new Set([this])) : Os.add(this));
                var _e = S.stack;
                this.componentDidCatch(S.value, {
                  componentStack: _e !== null ? _e : "",
                });
              });
          }
          function Vd(c, h, y, S, R) {
            if (
              ((y.flags |= 32768),
              S !== null && typeof S == "object" && typeof S.then == "function")
            ) {
              if (
                ((h = y.alternate),
                h !== null && Oc(h, y, R, !0),
                (y = sr.current),
                y !== null)
              ) {
                switch (y.tag) {
                  case 13:
                    return (
                      Gr === null
                        ? Ir()
                        : y.alternate === null && Si === 0 && (Si = 3),
                      (y.flags &= -257),
                      (y.flags |= 65536),
                      (y.lanes = R),
                      S === za
                        ? (y.flags |= 16384)
                        : ((h = y.updateQueue),
                          h === null
                            ? (y.updateQueue = new Set([S]))
                            : h.add(S),
                          Zo(c, S, R)),
                      !1
                    );
                  case 22:
                    return (
                      (y.flags |= 65536),
                      S === za
                        ? (y.flags |= 16384)
                        : ((h = y.updateQueue),
                          h === null
                            ? ((h = {
                                transitions: null,
                                markerInstances: null,
                                retryQueue: new Set([S]),
                              }),
                              (y.updateQueue = h))
                            : ((y = h.retryQueue),
                              y === null
                                ? (h.retryQueue = new Set([S]))
                                : y.add(S)),
                          Zo(c, S, R)),
                      !1
                    );
                }
                throw Error(i(435, y.tag));
              }
              return Zo(c, S, R), Ir(), !1;
            }
            if (Pn)
              return (
                (h = sr.current),
                h !== null
                  ? ((h.flags & 65536) === 0 && (h.flags |= 256),
                    (h.flags |= 65536),
                    (h.lanes = R),
                    S !== sf &&
                      ((c = Error(i(422), { cause: S })), Ie(me(c, y))))
                  : (S !== sf &&
                      ((h = Error(i(423), { cause: S })), Ie(me(h, y))),
                    (c = c.current.alternate),
                    (c.flags |= 65536),
                    (R &= -R),
                    (c.lanes |= R),
                    (S = me(S, y)),
                    (R = Ur(c.stateNode, S, R)),
                    le(c, R),
                    Si !== 4 && (Si = 2)),
                !1
              );
            var L = Error(i(520), { cause: S });
            if (
              ((L = me(L, y)),
              Qu === null ? (Qu = [L]) : Qu.push(L),
              Si !== 4 && (Si = 2),
              h === null)
            )
              return !0;
            (S = me(S, y)), (y = h);
            do {
              switch (y.tag) {
                case 3:
                  return (
                    (y.flags |= 65536),
                    (c = R & -R),
                    (y.lanes |= c),
                    (c = Ur(y.stateNode, S, c)),
                    le(y, c),
                    !1
                  );
                case 1:
                  if (
                    ((h = y.type),
                    (L = y.stateNode),
                    (y.flags & 128) === 0 &&
                      (typeof h.getDerivedStateFromError == "function" ||
                        (L !== null &&
                          typeof L.componentDidCatch == "function" &&
                          (Os === null || !Os.has(L)))))
                  )
                    return (
                      (y.flags |= 65536),
                      (R &= -R),
                      (y.lanes |= R),
                      (R = Nl(R)),
                      Ma(R, c, y, S),
                      le(y, R),
                      !1
                    );
              }
              y = y.return;
            } while (y !== null);
            return !1;
          }
          function Ti(c, h, y, S) {
            h.child = c === null ? Bs(h, null, y, S) : hl(h, c.child, y, S);
          }
          function Js(c, h, y, S, R) {
            y = y.render;
            var L = h.ref;
            if ("ref" in S) {
              var ee = {};
              for (var _e in S) _e !== "ref" && (ee[_e] = S[_e]);
            } else ee = S;
            return (
              Vo(h),
              (S = te(c, h, y, ee, L, R)),
              (_e = Je()),
              c !== null && !qi
                ? (St(c, h, R), qs(c, h, R))
                : (Pn && _e && ae(h), (h.flags |= 1), Ti(c, h, S, R), h.child)
            );
          }
          function wc(c, h, y, S, R) {
            if (c === null) {
              var L = y.type;
              return typeof L == "function" &&
                !io(L) &&
                L.defaultProps === void 0 &&
                y.compare === null
                ? ((h.tag = 15), (h.type = L), ih(c, h, L, S, R))
                : ((c = Xl(y.type, null, S, h, h.mode, R)),
                  (c.ref = h.ref),
                  (c.return = h),
                  (h.child = c));
            }
            if (((L = c.child), !Jd(c, R))) {
              var ee = L.memoizedProps;
              if (
                ((y = y.compare),
                (y = y !== null ? y : Re),
                y(ee, S) && c.ref === h.ref)
              )
                return qs(c, h, R);
            }
            return (
              (h.flags |= 1),
              (c = ao(L, S)),
              (c.ref = h.ref),
              (c.return = h),
              (h.child = c)
            );
          }
          function ih(c, h, y, S, R) {
            if (c !== null) {
              var L = c.memoizedProps;
              if (Re(L, S) && c.ref === h.ref)
                if (((qi = !1), (h.pendingProps = S = L), Jd(c, R)))
                  (c.flags & 131072) !== 0 && (qi = !0);
                else return (h.lanes = c.lanes), qs(c, h, R);
            }
            return gr(c, h, y, S, R);
          }
          function da(c, h, y) {
            var S = h.pendingProps,
              R = S.children,
              L = (h.stateNode._pendingVisibility & 2) !== 0,
              ee = c !== null ? c.memoizedState : null;
            if ((ki(c, h), S.mode === "hidden" || L)) {
              if ((h.flags & 128) !== 0) {
                if (((S = ee !== null ? ee.baseLanes | y : y), c !== null)) {
                  for (R = h.child = c.child, L = 0; R !== null; )
                    (L = L | R.lanes | R.childLanes), (R = R.sibling);
                  h.childLanes = L & ~S;
                } else (h.childLanes = 0), (h.child = null);
                return Ka(c, h, S, y);
              }
              if ((y & 536870912) !== 0)
                (h.memoizedState = { baseLanes: 0, cachePool: null }),
                  c !== null && rh(h, ee !== null ? ee.cachePool : null),
                  ee !== null ? ai(h, ee) : Bi(),
                  Di(h);
              else
                return (
                  (h.lanes = h.childLanes = 536870912),
                  Ka(c, h, ee !== null ? ee.baseLanes | y : y, y)
                );
            } else
              ee !== null
                ? (rh(h, ee.cachePool),
                  ai(h, ee),
                  pi(),
                  (h.memoizedState = null))
                : (c !== null && rh(h, null), Bi(), pi());
            return Ti(c, h, R, y), h.child;
          }
          function Ka(c, h, y, S) {
            var R = jd();
            return (
              (R =
                R === null
                  ? null
                  : {
                      parent: is ? Ri._currentValue : Ri._currentValue2,
                      pool: R,
                    }),
              (h.memoizedState = { baseLanes: y, cachePool: R }),
              c !== null && rh(h, null),
              Bi(),
              Di(h),
              c !== null && Oc(c, h, S, !0),
              null
            );
          }
          function ki(c, h) {
            var y = h.ref;
            if (y === null)
              c !== null && c.ref !== null && (h.flags |= 2097664);
            else {
              if (typeof y != "function" && typeof y != "object")
                throw Error(i(284));
              (c === null || c.ref !== y) && (h.flags |= 2097664);
            }
          }
          function gr(c, h, y, S, R) {
            return (
              Vo(h),
              (y = te(c, h, y, S, void 0, R)),
              (S = Je()),
              c !== null && !qi
                ? (St(c, h, R), qs(c, h, R))
                : (Pn && S && ae(h), (h.flags |= 1), Ti(c, h, y, R), h.child)
            );
          }
          function Bc(c, h, y, S, R, L) {
            return (
              Vo(h),
              (h.updateQueue = null),
              (y = Ge(h, S, y, R)),
              Ae(c),
              (S = Je()),
              c !== null && !qi
                ? (St(c, h, L), qs(c, h, L))
                : (Pn && S && ae(h), (h.flags |= 1), Ti(c, h, y, L), h.child)
            );
          }
          function ag(c, h, y, S, R) {
            if ((Vo(h), h.stateNode === null)) {
              var L = Zl,
                ee = y.contextType;
              typeof ee == "object" && ee !== null && (L = pa(ee)),
                (L = new y(S, L)),
                (h.memoizedState =
                  L.state !== null && L.state !== void 0 ? L.state : null),
                (L.updater = Ku),
                (h.stateNode = L),
                (L._reactInternals = h),
                (L = h.stateNode),
                (L.props = S),
                (L.state = h.memoizedState),
                (L.refs = {}),
                et(h),
                (ee = y.contextType),
                (L.context =
                  typeof ee == "object" && ee !== null ? pa(ee) : Zl),
                (L.state = h.memoizedState),
                (ee = y.getDerivedStateFromProps),
                typeof ee == "function" &&
                  (Ia(h, y, ee, S), (L.state = h.memoizedState)),
                typeof y.getDerivedStateFromProps == "function" ||
                  typeof L.getSnapshotBeforeUpdate == "function" ||
                  (typeof L.UNSAFE_componentWillMount != "function" &&
                    typeof L.componentWillMount != "function") ||
                  ((ee = L.state),
                  typeof L.componentWillMount == "function" &&
                    L.componentWillMount(),
                  typeof L.UNSAFE_componentWillMount == "function" &&
                    L.UNSAFE_componentWillMount(),
                  ee !== L.state && Ku.enqueueReplaceState(L, L.state, null),
                  vt(h, S, L, R),
                  Be(),
                  (L.state = h.memoizedState)),
                typeof L.componentDidMount == "function" &&
                  (h.flags |= 4194308),
                (S = !0);
            } else if (c === null) {
              L = h.stateNode;
              var _e = h.memoizedProps,
                Le = mr(y, _e);
              L.props = Le;
              var ut = L.context,
                Et = y.contextType;
              (ee = Zl), typeof Et == "object" && Et !== null && (ee = pa(Et));
              var Ot = y.getDerivedStateFromProps;
              (Et =
                typeof Ot == "function" ||
                typeof L.getSnapshotBeforeUpdate == "function"),
                (_e = h.pendingProps !== _e),
                Et ||
                  (typeof L.UNSAFE_componentWillReceiveProps != "function" &&
                    typeof L.componentWillReceiveProps != "function") ||
                  ((_e || ut !== ee) && Cu(h, L, S, ee)),
                (Ra = !1);
              var bt = h.memoizedState;
              (L.state = bt),
                vt(h, S, L, R),
                Be(),
                (ut = h.memoizedState),
                _e || bt !== ut || Ra
                  ? (typeof Ot == "function" &&
                      (Ia(h, y, Ot, S), (ut = h.memoizedState)),
                    (Le = Ra || Ys(h, y, Le, S, bt, ut, ee))
                      ? (Et ||
                          (typeof L.UNSAFE_componentWillMount != "function" &&
                            typeof L.componentWillMount != "function") ||
                          (typeof L.componentWillMount == "function" &&
                            L.componentWillMount(),
                          typeof L.UNSAFE_componentWillMount == "function" &&
                            L.UNSAFE_componentWillMount()),
                        typeof L.componentDidMount == "function" &&
                          (h.flags |= 4194308))
                      : (typeof L.componentDidMount == "function" &&
                          (h.flags |= 4194308),
                        (h.memoizedProps = S),
                        (h.memoizedState = ut)),
                    (L.props = S),
                    (L.state = ut),
                    (L.context = ee),
                    (S = Le))
                  : (typeof L.componentDidMount == "function" &&
                      (h.flags |= 4194308),
                    (S = !1));
            } else {
              (L = h.stateNode),
                At(c, h),
                (ee = h.memoizedProps),
                (Et = mr(y, ee)),
                (L.props = Et),
                (Ot = h.pendingProps),
                (bt = L.context),
                (ut = y.contextType),
                (Le = Zl),
                typeof ut == "object" && ut !== null && (Le = pa(ut)),
                (_e = y.getDerivedStateFromProps),
                (ut =
                  typeof _e == "function" ||
                  typeof L.getSnapshotBeforeUpdate == "function") ||
                  (typeof L.UNSAFE_componentWillReceiveProps != "function" &&
                    typeof L.componentWillReceiveProps != "function") ||
                  ((ee !== Ot || bt !== Le) && Cu(h, L, S, Le)),
                (Ra = !1),
                (bt = h.memoizedState),
                (L.state = bt),
                vt(h, S, L, R),
                Be();
              var cn = h.memoizedState;
              ee !== Ot ||
              bt !== cn ||
              Ra ||
              (c !== null && c.dependencies !== null && Lc(c.dependencies))
                ? (typeof _e == "function" &&
                    (Ia(h, y, _e, S), (cn = h.memoizedState)),
                  (Et =
                    Ra ||
                    Ys(h, y, Et, S, bt, cn, Le) ||
                    (c !== null &&
                      c.dependencies !== null &&
                      Lc(c.dependencies)))
                    ? (ut ||
                        (typeof L.UNSAFE_componentWillUpdate != "function" &&
                          typeof L.componentWillUpdate != "function") ||
                        (typeof L.componentWillUpdate == "function" &&
                          L.componentWillUpdate(S, cn, Le),
                        typeof L.UNSAFE_componentWillUpdate == "function" &&
                          L.UNSAFE_componentWillUpdate(S, cn, Le)),
                      typeof L.componentDidUpdate == "function" &&
                        (h.flags |= 4),
                      typeof L.getSnapshotBeforeUpdate == "function" &&
                        (h.flags |= 1024))
                    : (typeof L.componentDidUpdate != "function" ||
                        (ee === c.memoizedProps && bt === c.memoizedState) ||
                        (h.flags |= 4),
                      typeof L.getSnapshotBeforeUpdate != "function" ||
                        (ee === c.memoizedProps && bt === c.memoizedState) ||
                        (h.flags |= 1024),
                      (h.memoizedProps = S),
                      (h.memoizedState = cn)),
                  (L.props = S),
                  (L.state = cn),
                  (L.context = Le),
                  (S = Et))
                : (typeof L.componentDidUpdate != "function" ||
                    (ee === c.memoizedProps && bt === c.memoizedState) ||
                    (h.flags |= 4),
                  typeof L.getSnapshotBeforeUpdate != "function" ||
                    (ee === c.memoizedProps && bt === c.memoizedState) ||
                    (h.flags |= 1024),
                  (S = !1));
            }
            return (
              (L = S),
              ki(c, h),
              (S = (h.flags & 128) !== 0),
              L || S
                ? ((L = h.stateNode),
                  (y =
                    S && typeof y.getDerivedStateFromError != "function"
                      ? null
                      : L.render()),
                  (h.flags |= 1),
                  c !== null && S
                    ? ((h.child = hl(h, c.child, null, R)),
                      (h.child = hl(h, null, y, R)))
                    : Ti(c, h, y, R),
                  (h.memoizedState = L.state),
                  (c = h.child))
                : (c = qs(c, h, R)),
              c
            );
          }
          function rg(c, h, y, S) {
            return Me(), (h.flags |= 256), Ti(c, h, y, S), h.child;
          }
          function kd(c) {
            return { baseLanes: c, cachePool: Kd() };
          }
          function Dc(c, h, y) {
            return (c = c !== null ? c.childLanes & ~y : 0), h && (c |= Mr), c;
          }
          function sg(c, h, y) {
            var S = h.pendingProps,
              R = !1,
              L = (h.flags & 128) !== 0,
              ee;
            if (
              ((ee = L) ||
                (ee =
                  c !== null && c.memoizedState === null
                    ? !1
                    : (fi.current & 2) !== 0),
              ee && ((R = !0), (h.flags &= -129)),
              (ee = (h.flags & 32) !== 0),
              (h.flags &= -33),
              c === null)
            ) {
              if (Pn) {
                if ((R ? di(h) : pi(), Pn)) {
                  var _e = ei,
                    Le;
                  (Le = _e) &&
                    ((_e = jg(_e, os)),
                    _e !== null
                      ? ((h.memoizedState = {
                          dehydrated: _e,
                          treeContext:
                            ss !== null ? { id: Rs, overflow: ws } : null,
                          retryLane: 536870912,
                        }),
                        (Le = t(18, null, null, 0)),
                        (Le.stateNode = _e),
                        (Le.return = h),
                        (h.child = Le),
                        (Pi = h),
                        (ei = null),
                        (Le = !0))
                      : (Le = !1)),
                    Le || be(h);
                }
                if (
                  ((_e = h.memoizedState),
                  _e !== null && ((_e = _e.dehydrated), _e !== null))
                )
                  return tf(_e) ? (h.lanes = 16) : (h.lanes = 536870912), null;
                zt(h);
              }
              return (
                (_e = S.children),
                (S = S.fallback),
                R
                  ? (pi(),
                    (R = h.mode),
                    (_e = Yd({ mode: "hidden", children: _e }, R)),
                    (S = Qo(S, R, y, null)),
                    (_e.return = h),
                    (S.return = h),
                    (_e.sibling = S),
                    (h.child = _e),
                    (R = h.child),
                    (R.memoizedState = kd(y)),
                    (R.childLanes = Dc(c, ee, y)),
                    (h.memoizedState = uf),
                    S)
                  : (di(h), Xd(h, _e))
              );
            }
            if (
              ((Le = c.memoizedState),
              Le !== null && ((_e = Le.dehydrated), _e !== null))
            ) {
              if (L)
                h.flags & 256
                  ? (di(h), (h.flags &= -257), (h = ah(c, h, y)))
                  : h.memoizedState !== null
                  ? (pi(), (h.child = c.child), (h.flags |= 128), (h = null))
                  : (pi(),
                    (R = S.fallback),
                    (_e = h.mode),
                    (S = Yd({ mode: "visible", children: S.children }, _e)),
                    (R = Qo(R, _e, y, null)),
                    (R.flags |= 2),
                    (S.return = h),
                    (R.return = h),
                    (S.sibling = R),
                    (h.child = S),
                    hl(h, c.child, null, y),
                    (S = h.child),
                    (S.memoizedState = kd(y)),
                    (S.childLanes = Dc(c, ee, y)),
                    (h.memoizedState = uf),
                    (h = R));
              else if ((di(h), tf(_e)))
                (ee = Th(_e).digest),
                  (S = Error(i(419))),
                  (S.stack = ""),
                  (S.digest = ee),
                  Ie({ value: S, source: null, stack: null }),
                  (h = ah(c, h, y));
              else if (
                (qi || Oc(c, h, y, !1),
                (ee = (y & c.childLanes) !== 0),
                qi || ee)
              ) {
                if (((ee = ni), ee !== null)) {
                  if (((S = y & -y), (S & 42) !== 0)) S = 1;
                  else
                    switch (S) {
                      case 2:
                        S = 1;
                        break;
                      case 8:
                        S = 4;
                        break;
                      case 32:
                        S = 16;
                        break;
                      case 128:
                      case 256:
                      case 512:
                      case 1024:
                      case 2048:
                      case 4096:
                      case 8192:
                      case 16384:
                      case 32768:
                      case 65536:
                      case 131072:
                      case 262144:
                      case 524288:
                      case 1048576:
                      case 2097152:
                      case 4194304:
                      case 8388608:
                      case 16777216:
                      case 33554432:
                        S = 64;
                        break;
                      case 268435456:
                        S = 134217728;
                        break;
                      default:
                        S = 0;
                    }
                  if (
                    ((S = (S & (ee.suspendedLanes | y)) !== 0 ? 0 : S),
                    S !== 0 && S !== Le.retryLane)
                  )
                    throw ((Le.retryLane = S), rt(c, S), ci(ee, c, S), Np);
                }
                ql(_e) || Ir(), (h = ah(c, h, y));
              } else
                ql(_e)
                  ? ((h.flags |= 128),
                    (h.child = c.child),
                    (h = Kc.bind(null, c)),
                    Wg(_e, h),
                    (h = null))
                  : ((c = Le.treeContext),
                    ir &&
                      ((ei = Ap(_e)),
                      (Pi = h),
                      (Pn = !0),
                      (Pr = null),
                      (os = !1),
                      c !== null &&
                        ((ar[Ca++] = Rs),
                        (ar[Ca++] = ws),
                        (ar[Ca++] = ss),
                        (Rs = c.id),
                        (ws = c.overflow),
                        (ss = h))),
                    (h = Xd(h, S.children)),
                    (h.flags |= 4096));
              return h;
            }
            return R
              ? (pi(),
                (R = S.fallback),
                (_e = h.mode),
                (Le = c.child),
                (L = Le.sibling),
                (S = ao(Le, { mode: "hidden", children: S.children })),
                (S.subtreeFlags = Le.subtreeFlags & 31457280),
                L !== null
                  ? (R = ao(L, R))
                  : ((R = Qo(R, _e, y, null)), (R.flags |= 2)),
                (R.return = h),
                (S.return = h),
                (S.sibling = R),
                (h.child = S),
                (S = R),
                (R = h.child),
                (_e = c.child.memoizedState),
                _e === null
                  ? (_e = kd(y))
                  : ((Le = _e.cachePool),
                    Le !== null
                      ? ((L = is ? Ri._currentValue : Ri._currentValue2),
                        (Le = Le.parent !== L ? { parent: L, pool: L } : Le))
                      : (Le = Kd()),
                    (_e = { baseLanes: _e.baseLanes | y, cachePool: Le })),
                (R.memoizedState = _e),
                (R.childLanes = Dc(c, ee, y)),
                (h.memoizedState = uf),
                S)
              : (di(h),
                (y = c.child),
                (c = y.sibling),
                (y = ao(y, { mode: "visible", children: S.children })),
                (y.return = h),
                (y.sibling = null),
                c !== null &&
                  ((ee = h.deletions),
                  ee === null
                    ? ((h.deletions = [c]), (h.flags |= 16))
                    : ee.push(c)),
                (h.child = y),
                (h.memoizedState = null),
                y);
          }
          function Xd(c, h) {
            return (
              (h = Yd({ mode: "visible", children: h }, c.mode)),
              (h.return = c),
              (c.child = h)
            );
          }
          function Yd(c, h) {
            return vh(c, h, 0, null);
          }
          function ah(c, h, y) {
            return (
              hl(h, c.child, null, y),
              (c = Xd(h, h.pendingProps.children)),
              (c.flags |= 2),
              (h.memoizedState = null),
              c
            );
          }
          function og(c, h, y) {
            c.lanes |= h;
            var S = c.alternate;
            S !== null && (S.lanes |= h), Uc(c.return, h, y);
          }
          function Wd(c, h, y, S, R) {
            var L = c.memoizedState;
            L === null
              ? (c.memoizedState = {
                  isBackwards: h,
                  rendering: null,
                  renderingStartTime: 0,
                  last: S,
                  tail: y,
                  tailMode: R,
                })
              : ((L.isBackwards = h),
                (L.rendering = null),
                (L.renderingStartTime = 0),
                (L.last = S),
                (L.tail = y),
                (L.tailMode = R));
          }
          function lg(c, h, y) {
            var S = h.pendingProps,
              R = S.revealOrder,
              L = S.tail;
            if ((Ti(c, h, S.children, y), (S = fi.current), (S & 2) !== 0))
              (S = (S & 1) | 2), (h.flags |= 128);
            else {
              if (c !== null && (c.flags & 128) !== 0)
                e: for (c = h.child; c !== null; ) {
                  if (c.tag === 13) c.memoizedState !== null && og(c, y, h);
                  else if (c.tag === 19) og(c, y, h);
                  else if (c.child !== null) {
                    (c.child.return = c), (c = c.child);
                    continue;
                  }
                  if (c === h) break e;
                  for (; c.sibling === null; ) {
                    if (c.return === null || c.return === h) break e;
                    c = c.return;
                  }
                  (c.sibling.return = c.return), (c = c.sibling);
                }
              S &= 1;
            }
            switch ((w(fi, S), R)) {
              case "forwards":
                for (y = h.child, R = null; y !== null; )
                  (c = y.alternate),
                    c !== null && pn(c) === null && (R = y),
                    (y = y.sibling);
                (y = R),
                  y === null
                    ? ((R = h.child), (h.child = null))
                    : ((R = y.sibling), (y.sibling = null)),
                  Wd(h, !1, R, y, L);
                break;
              case "backwards":
                for (y = null, R = h.child, h.child = null; R !== null; ) {
                  if (((c = R.alternate), c !== null && pn(c) === null)) {
                    h.child = R;
                    break;
                  }
                  (c = R.sibling), (R.sibling = y), (y = R), (R = c);
                }
                Wd(h, !0, y, null, L);
                break;
              case "together":
                Wd(h, !1, null, null, void 0);
                break;
              default:
                h.memoizedState = null;
            }
            return h.child;
          }
          function qs(c, h, y) {
            if (
              (c !== null && (h.dependencies = c.dependencies),
              (Xr |= h.lanes),
              (y & h.childLanes) === 0)
            )
              if (c !== null) {
                if ((Oc(c, h, y, !1), (y & h.childLanes) === 0)) return null;
              } else return null;
            if (c !== null && h.child !== c.child) throw Error(i(153));
            if (h.child !== null) {
              for (
                c = h.child,
                  y = ao(c, c.pendingProps),
                  h.child = y,
                  y.return = h;
                c.sibling !== null;

              )
                (c = c.sibling),
                  (y = y.sibling = ao(c, c.pendingProps)),
                  (y.return = h);
              y.sibling = null;
            }
            return h.child;
          }
          function Jd(c, h) {
            return (c.lanes & h) !== 0
              ? !0
              : ((c = c.dependencies), !!(c !== null && Lc(c)));
          }
          function f_(c, h, y) {
            switch (h.tag) {
              case 3:
                j(h, h.stateNode.containerInfo),
                  Ho(h, Ri, c.memoizedState.cache),
                  Me();
                break;
              case 27:
              case 5:
                ve(h);
                break;
              case 4:
                j(h, h.stateNode.containerInfo);
                break;
              case 10:
                Ho(h, h.type, h.memoizedProps.value);
                break;
              case 13:
                var S = h.memoizedState;
                if (S !== null)
                  return S.dehydrated !== null
                    ? (di(h), (h.flags |= 128), null)
                    : (y & h.child.childLanes) !== 0
                    ? sg(c, h, y)
                    : (di(h), (c = qs(c, h, y)), c !== null ? c.sibling : null);
                di(h);
                break;
              case 19:
                var R = (c.flags & 128) !== 0;
                if (
                  ((S = (y & h.childLanes) !== 0),
                  S || (Oc(c, h, y, !1), (S = (y & h.childLanes) !== 0)),
                  R)
                ) {
                  if (S) return lg(c, h, y);
                  h.flags |= 128;
                }
                if (
                  ((R = h.memoizedState),
                  R !== null &&
                    ((R.rendering = null),
                    (R.tail = null),
                    (R.lastEffect = null)),
                  w(fi, fi.current),
                  S)
                )
                  break;
                return null;
              case 22:
              case 23:
                return (h.lanes = 0), da(c, h, y);
              case 24:
                Ho(h, Ri, c.memoizedState.cache);
            }
            return qs(c, h, y);
          }
          function ug(c, h, y) {
            if (c !== null)
              if (c.memoizedProps !== h.pendingProps) qi = !0;
              else {
                if (!Jd(c, y) && (h.flags & 128) === 0)
                  return (qi = !1), f_(c, h, y);
                qi = (c.flags & 131072) !== 0;
              }
            else
              (qi = !1), Pn && (h.flags & 1048576) !== 0 && Y(h, Wu, h.index);
            switch (((h.lanes = 0), h.tag)) {
              case 16:
                e: {
                  c = h.pendingProps;
                  var S = h.elementType,
                    R = S._init;
                  if (
                    ((S = R(S._payload)), (h.type = S), typeof S == "function")
                  )
                    io(S)
                      ? ((c = mr(S, c)),
                        (h.tag = 1),
                        (h = ag(null, h, S, c, y)))
                      : ((h.tag = 0), (h = gr(null, h, S, c, y)));
                  else {
                    if (S != null) {
                      if (((R = S.$$typeof), R === yh)) {
                        (h.tag = 11), (h = Js(null, h, S, c, y));
                        break e;
                      } else if (R === Fu) {
                        (h.tag = 14), (h = wc(null, h, S, c, y));
                        break e;
                      }
                    }
                    throw ((h = l(S) || S), Error(i(306, h, "")));
                  }
                }
                return h;
              case 0:
                return gr(c, h, h.type, h.pendingProps, y);
              case 1:
                return (
                  (S = h.type), (R = mr(S, h.pendingProps)), ag(c, h, S, R, y)
                );
              case 3:
                e: {
                  if ((j(h, h.stateNode.containerInfo), c === null))
                    throw Error(i(387));
                  var L = h.pendingProps;
                  (R = h.memoizedState),
                    (S = R.element),
                    At(c, h),
                    vt(h, L, null, y);
                  var ee = h.memoizedState;
                  if (
                    ((L = ee.cache),
                    Ho(h, Ri, L),
                    L !== R.cache && Il(h, [Ri], y, !0),
                    Be(),
                    (L = ee.element),
                    ir && R.isDehydrated)
                  )
                    if (
                      ((R = { element: L, isDehydrated: !1, cache: ee.cache }),
                      (h.updateQueue.baseState = R),
                      (h.memoizedState = R),
                      h.flags & 256)
                    ) {
                      h = rg(c, h, L, y);
                      break e;
                    } else if (L !== S) {
                      (S = me(Error(i(424)), h)), Ie(S), (h = rg(c, h, L, y));
                      break e;
                    } else
                      for (
                        ir &&
                          ((ei = jl(h.stateNode.containerInfo)),
                          (Pi = h),
                          (Pn = !0),
                          (Pr = null),
                          (os = !0)),
                          y = Bs(h, null, L, y),
                          h.child = y;
                        y;

                      )
                        (y.flags = (y.flags & -3) | 4096), (y = y.sibling);
                  else {
                    if ((Me(), L === S)) {
                      h = qs(c, h, y);
                      break e;
                    }
                    Ti(c, h, L, y);
                  }
                  h = h.child;
                }
                return h;
              case 26:
                if (_r)
                  return (
                    ki(c, h),
                    c === null
                      ? (y = bp(h.type, null, h.pendingProps, null))
                        ? (h.memoizedState = y)
                        : Pn ||
                          (h.stateNode = Rp(
                            h.type,
                            h.pendingProps,
                            po.current,
                            h
                          ))
                      : (h.memoizedState = bp(
                          h.type,
                          c.memoizedProps,
                          h.pendingProps,
                          c.memoizedState
                        )),
                    null
                  );
              case 27:
                if (ua)
                  return (
                    ve(h),
                    c === null &&
                      ua &&
                      Pn &&
                      ((S = h.stateNode =
                        wh(h.type, h.pendingProps, po.current, Fi.current, !1)),
                      (Pi = h),
                      (os = !0),
                      (ei = fo(S))),
                    (S = h.pendingProps.children),
                    c !== null || Pn
                      ? Ti(c, h, S, y)
                      : (h.child = hl(h, null, S, y)),
                    ki(c, h),
                    h.child
                  );
              case 5:
                return (
                  c === null &&
                    Pn &&
                    (ev(h.type, h.pendingProps, Fi.current),
                    (R = S = ei) &&
                      ((S = xp(S, h.type, h.pendingProps, os)),
                      S !== null
                        ? ((h.stateNode = S),
                          (Pi = h),
                          (ei = fo(S)),
                          (os = !1),
                          (R = !0))
                        : (R = !1)),
                    R || be(h)),
                  ve(h),
                  (R = h.type),
                  (L = h.pendingProps),
                  (ee = c !== null ? c.memoizedProps : null),
                  (S = L.children),
                  ga(R, L)
                    ? (S = null)
                    : ee !== null && ga(R, ee) && (h.flags |= 32),
                  h.memoizedState !== null &&
                    ((R = te(c, h, qe, null, null, y)),
                    is ? (co._currentValue = R) : (co._currentValue2 = R)),
                  ki(c, h),
                  Ti(c, h, S, y),
                  h.child
                );
              case 6:
                return (
                  c === null &&
                    Pn &&
                    (A_(h.pendingProps, Fi.current),
                    (c = y = ei) &&
                      ((y = qg(y, h.pendingProps, os)),
                      y !== null
                        ? ((h.stateNode = y), (Pi = h), (ei = null), (c = !0))
                        : (c = !1)),
                    c || be(h)),
                  null
                );
              case 13:
                return sg(c, h, y);
              case 4:
                return (
                  j(h, h.stateNode.containerInfo),
                  (S = h.pendingProps),
                  c === null ? (h.child = hl(h, null, S, y)) : Ti(c, h, S, y),
                  h.child
                );
              case 11:
                return Js(c, h, h.type, h.pendingProps, y);
              case 7:
                return Ti(c, h, h.pendingProps, y), h.child;
              case 8:
                return Ti(c, h, h.pendingProps.children, y), h.child;
              case 12:
                return Ti(c, h, h.pendingProps.children, y), h.child;
              case 10:
                return (
                  (S = h.pendingProps),
                  Ho(h, h.type, S.value),
                  Ti(c, h, S.children, y),
                  h.child
                );
              case 9:
                return (
                  (R = h.type._context),
                  (S = h.pendingProps.children),
                  Vo(h),
                  (R = pa(R)),
                  (S = S(R)),
                  (h.flags |= 1),
                  Ti(c, h, S, y),
                  h.child
                );
              case 14:
                return wc(c, h, h.type, h.pendingProps, y);
              case 15:
                return ih(c, h, h.type, h.pendingProps, y);
              case 19:
                return lg(c, h, y);
              case 22:
                return da(c, h, y);
              case 24:
                return (
                  Vo(h),
                  (S = pa(Ri)),
                  c === null
                    ? ((R = jd()),
                      R === null &&
                        ((R = ni),
                        (L = ko()),
                        (R.pooledCache = L),
                        L.refCount++,
                        L !== null && (R.pooledCacheLanes |= y),
                        (R = L)),
                      (h.memoizedState = { parent: S, cache: R }),
                      et(h),
                      Ho(h, Ri, R))
                    : ((c.lanes & y) !== 0 &&
                        (At(c, h), vt(h, null, null, y), Be()),
                      (R = c.memoizedState),
                      (L = h.memoizedState),
                      R.parent !== S
                        ? ((R = { parent: S, cache: S }),
                          (h.memoizedState = R),
                          h.lanes === 0 &&
                            (h.memoizedState = h.updateQueue.baseState = R),
                          Ho(h, Ri, S))
                        : ((S = L.cache),
                          Ho(h, Ri, S),
                          S !== R.cache && Il(h, [Ri], y, !0))),
                  Ti(c, h, h.pendingProps.children, y),
                  h.child
                );
              case 29:
                throw h.pendingProps;
            }
            throw Error(i(156, h.tag));
          }
          function Ho(c, h, y) {
            is
              ? (w(zr, h._currentValue), (h._currentValue = y))
              : (w(zr, h._currentValue2), (h._currentValue2 = y));
          }
          function js(c) {
            var h = zr.current;
            is ? (c._currentValue = h) : (c._currentValue2 = h), b(zr);
          }
          function Uc(c, h, y) {
            for (; c !== null; ) {
              var S = c.alternate;
              if (
                ((c.childLanes & h) !== h
                  ? ((c.childLanes |= h), S !== null && (S.childLanes |= h))
                  : S !== null &&
                    (S.childLanes & h) !== h &&
                    (S.childLanes |= h),
                c === y)
              )
                break;
              c = c.return;
            }
          }
          function Il(c, h, y, S) {
            var R = c.child;
            for (R !== null && (R.return = c); R !== null; ) {
              var L = R.dependencies;
              if (L !== null) {
                var ee = R.child;
                L = L.firstContext;
                e: for (; L !== null; ) {
                  var _e = L;
                  L = R;
                  for (var Le = 0; Le < h.length; Le++)
                    if (_e.context === h[Le]) {
                      (L.lanes |= y),
                        (_e = L.alternate),
                        _e !== null && (_e.lanes |= y),
                        Uc(L.return, y, c),
                        S || (ee = null);
                      break e;
                    }
                  L = _e.next;
                }
              } else if (R.tag === 18) {
                if (((ee = R.return), ee === null)) throw Error(i(341));
                (ee.lanes |= y),
                  (L = ee.alternate),
                  L !== null && (L.lanes |= y),
                  Uc(ee, y, c),
                  (ee = null);
              } else ee = R.child;
              if (ee !== null) ee.return = R;
              else
                for (ee = R; ee !== null; ) {
                  if (ee === c) {
                    ee = null;
                    break;
                  }
                  if (((R = ee.sibling), R !== null)) {
                    (R.return = ee.return), (ee = R);
                    break;
                  }
                  ee = ee.return;
                }
              R = ee;
            }
          }
          function Oc(c, h, y, S) {
            c = null;
            for (var R = h, L = !1; R !== null; ) {
              if (!L) {
                if ((R.flags & 524288) !== 0) L = !0;
                else if ((R.flags & 262144) !== 0) break;
              }
              if (R.tag === 10) {
                var ee = R.alternate;
                if (ee === null) throw Error(i(387));
                if (((ee = ee.memoizedProps), ee !== null)) {
                  var _e = R.type;
                  Ga(R.pendingProps.value, ee.value) ||
                    (c !== null ? c.push(_e) : (c = [_e]));
                }
              } else if (R === rf.current) {
                if (((ee = R.alternate), ee === null)) throw Error(i(387));
                ee.memoizedState.memoizedState !==
                  R.memoizedState.memoizedState &&
                  (c !== null ? c.push(co) : (c = [co]));
              }
              R = R.return;
            }
            c !== null && Il(h, c, y, S), (h.flags |= 262144);
          }
          function Lc(c) {
            for (c = c.firstContext; c !== null; ) {
              var h = c.context;
              if (!Ga(is ? h._currentValue : h._currentValue2, c.memoizedValue))
                return !0;
              c = c.next;
            }
            return !1;
          }
          function Vo(c) {
            (vl = c),
              (Hr = null),
              (c = c.dependencies),
              c !== null && (c.firstContext = null);
          }
          function pa(c) {
            return qd(vl, c);
          }
          function Nc(c, h) {
            return vl === null && Vo(c), qd(c, h);
          }
          function qd(c, h) {
            var y = is ? h._currentValue : h._currentValue2;
            if (
              ((h = { context: h, memoizedValue: y, next: null }), Hr === null)
            ) {
              if (c === null) throw Error(i(308));
              (Hr = h),
                (c.dependencies = { lanes: 0, firstContext: h }),
                (c.flags |= 524288);
            } else Hr = Hr.next = h;
            return y;
          }
          function ko() {
            return { controller: new cf(), data: new Map(), refCount: 0 };
          }
          function Ic(c) {
            c.refCount--,
              c.refCount === 0 &&
                bi(S_, function () {
                  c.controller.abort();
                });
          }
          function jd() {
            var c = tu.current;
            return c !== null ? c : ni.pooledCache;
          }
          function rh(c, h) {
            h === null ? w(tu, tu.current) : w(tu, h.pool);
          }
          function Kd() {
            var c = jd();
            return c === null
              ? null
              : { parent: is ? Ri._currentValue : Ri._currentValue2, pool: c };
          }
          function Za(c) {
            c.flags |= 4;
          }
          function Ru(c, h) {
            if (c !== null && c.child === h.child) return !1;
            if ((h.flags & 16) !== 0) return !0;
            for (c = h.child; c !== null; ) {
              if ((c.flags & 13878) !== 0 || (c.subtreeFlags & 13878) !== 0)
                return !0;
              c = c.sibling;
            }
            return !1;
          }
          function Fl(c, h, y, S) {
            if (Ai)
              for (y = h.child; y !== null; ) {
                if (y.tag === 5 || y.tag === 6) $c(c, y.stateNode);
                else if (
                  !(y.tag === 4 || (ua && y.tag === 27)) &&
                  y.child !== null
                ) {
                  (y.child.return = y), (y = y.child);
                  continue;
                }
                if (y === h) break;
                for (; y.sibling === null; ) {
                  if (y.return === null || y.return === h) return;
                  y = y.return;
                }
                (y.sibling.return = y.return), (y = y.sibling);
              }
            else if (as)
              for (var R = h.child; R !== null; ) {
                if (R.tag === 5) {
                  var L = R.stateNode;
                  y && S && (L = Yg(L, R.type, R.memoizedProps)), $c(c, L);
                } else if (R.tag === 6)
                  (L = R.stateNode),
                    y && S && (L = _p(L, R.memoizedProps)),
                    $c(c, L);
                else if (R.tag !== 4) {
                  if (R.tag === 22 && R.memoizedState !== null)
                    (L = R.child),
                      L !== null && (L.return = R),
                      Fl(c, R, !0, !0);
                  else if (R.child !== null) {
                    (R.child.return = R), (R = R.child);
                    continue;
                  }
                }
                if (R === h) break;
                for (; R.sibling === null; ) {
                  if (R.return === null || R.return === h) return;
                  R = R.return;
                }
                (R.sibling.return = R.return), (R = R.sibling);
              }
          }
          function cg(c, h, y, S) {
            if (as)
              for (var R = h.child; R !== null; ) {
                if (R.tag === 5) {
                  var L = R.stateNode;
                  y && S && (L = Yg(L, R.type, R.memoizedProps)), yp(c, L);
                } else if (R.tag === 6)
                  (L = R.stateNode),
                    y && S && (L = _p(L, R.memoizedProps)),
                    yp(c, L);
                else if (R.tag !== 4) {
                  if (R.tag === 22 && R.memoizedState !== null)
                    (L = R.child),
                      L !== null && (L.return = R),
                      cg(
                        c,
                        R,
                        !(
                          R.memoizedProps !== null &&
                          R.memoizedProps.mode === "manual"
                        ),
                        !0
                      );
                  else if (R.child !== null) {
                    (R.child.return = R), (R = R.child);
                    continue;
                  }
                }
                if (R === h) break;
                for (; R.sibling === null; ) {
                  if (R.return === null || R.return === h) return;
                  R = R.return;
                }
                (R.sibling.return = R.return), (R = R.sibling);
              }
          }
          function Fc(c, h) {
            if (as && Ru(c, h)) {
              c = h.stateNode;
              var y = c.containerInfo,
                S = Eh();
              cg(S, h, !1, !1), (c.pendingChildren = S), Za(h), kg(y, S);
            }
          }
          function sh(c, h, y, S) {
            if (Ai) c.memoizedProps !== S && Za(h);
            else if (as) {
              var R = c.stateNode,
                L = c.memoizedProps;
              if ((c = Ru(c, h)) || L !== S) {
                var ee = Fi.current;
                (L = Vg(R, y, L, S, !c, null)),
                  L === R
                    ? (h.stateNode = R)
                    : (_h(L, y, S, ee) && Za(h),
                      (h.stateNode = L),
                      c ? Fl(L, h, !1, !1) : Za(h));
              } else h.stateNode = R;
            }
          }
          function oh(c, h, y) {
            if (hp(h, y)) {
              if (((c.flags |= 16777216), !dp(h, y)))
                if (la()) c.flags |= 8192;
                else throw ((wa = za), lf);
            } else c.flags &= -16777217;
          }
          function lh(c, h) {
            if (iv(h)) {
              if (((c.flags |= 16777216), !wp(h)))
                if (la()) c.flags |= 8192;
                else throw ((wa = za), lf);
            } else c.flags &= -16777217;
          }
          function wu(c, h) {
            h !== null && (c.flags |= 4),
              c.flags & 16384 &&
                ((h = c.tag !== 22 ? O() : 536870912),
                (c.lanes |= h),
                (Ki |= h));
          }
          function Bu(c, h) {
            if (!Pn)
              switch (c.tailMode) {
                case "hidden":
                  h = c.tail;
                  for (var y = null; h !== null; )
                    h.alternate !== null && (y = h), (h = h.sibling);
                  y === null ? (c.tail = null) : (y.sibling = null);
                  break;
                case "collapsed":
                  y = c.tail;
                  for (var S = null; y !== null; )
                    y.alternate !== null && (S = y), (y = y.sibling);
                  S === null
                    ? h || c.tail === null
                      ? (c.tail = null)
                      : (c.tail.sibling = null)
                    : (S.sibling = null);
              }
          }
          function _i(c) {
            var h = c.alternate !== null && c.alternate.child === c.child,
              y = 0,
              S = 0;
            if (h)
              for (var R = c.child; R !== null; )
                (y |= R.lanes | R.childLanes),
                  (S |= R.subtreeFlags & 31457280),
                  (S |= R.flags & 31457280),
                  (R.return = c),
                  (R = R.sibling);
            else
              for (R = c.child; R !== null; )
                (y |= R.lanes | R.childLanes),
                  (S |= R.subtreeFlags),
                  (S |= R.flags),
                  (R.return = c),
                  (R = R.sibling);
            return (c.subtreeFlags |= S), (c.childLanes = y), h;
          }
          function fg(c, h, y) {
            var S = h.pendingProps;
            switch ((fe(h), h.tag)) {
              case 16:
              case 15:
              case 0:
              case 11:
              case 7:
              case 8:
              case 12:
              case 9:
              case 14:
                return _i(h), null;
              case 1:
                return _i(h), null;
              case 3:
                return (
                  (y = h.stateNode),
                  (S = null),
                  c !== null && (S = c.memoizedState.cache),
                  h.memoizedState.cache !== S && (h.flags |= 2048),
                  js(Ri),
                  se(),
                  y.pendingContext &&
                    ((y.context = y.pendingContext), (y.pendingContext = null)),
                  (c === null || c.child === null) &&
                    ($e(h)
                      ? Za(h)
                      : c === null ||
                        (c.memoizedState.isDehydrated &&
                          (h.flags & 256) === 0) ||
                        ((h.flags |= 1024),
                        Pr !== null && (to(Pr), (Pr = null)))),
                  Fc(c, h),
                  _i(h),
                  null
                );
              case 26:
                if (_r) {
                  y = h.type;
                  var R = h.memoizedState;
                  return (
                    c === null
                      ? (Za(h),
                        R !== null ? (_i(h), lh(h, R)) : (_i(h), oh(h, y, S)))
                      : R
                      ? R !== c.memoizedState
                        ? (Za(h), _i(h), lh(h, R))
                        : (_i(h), (h.flags &= -16777217))
                      : (Ai ? c.memoizedProps !== S && Za(h) : sh(c, h, y, S),
                        _i(h),
                        oh(h, y, S)),
                    null
                  );
                }
              case 27:
                if (ua) {
                  if (
                    (ye(h),
                    (y = po.current),
                    (R = h.type),
                    c !== null && h.stateNode != null)
                  )
                    Ai ? c.memoizedProps !== S && Za(h) : sh(c, h, R, S);
                  else {
                    if (!S) {
                      if (h.stateNode === null) throw Error(i(166));
                      return _i(h), null;
                    }
                    (c = Fi.current),
                      $e(h)
                        ? it(h, c)
                        : ((c = wh(R, S, y, c, !0)), (h.stateNode = c), Za(h));
                  }
                  return _i(h), null;
                }
              case 5:
                if ((ye(h), (y = h.type), c !== null && h.stateNode != null))
                  sh(c, h, y, S);
                else {
                  if (!S) {
                    if (h.stateNode === null) throw Error(i(166));
                    return _i(h), null;
                  }
                  (c = Fi.current),
                    $e(h)
                      ? it(h, c)
                      : ((R = fp(y, S, po.current, c, h)),
                        Fl(R, h, !1, !1),
                        (h.stateNode = R),
                        _h(R, y, S, c) && Za(h));
                }
                return _i(h), oh(h, h.type, h.pendingProps), null;
              case 6:
                if (c && h.stateNode != null)
                  (y = c.memoizedProps),
                    Ai
                      ? y !== S && Za(h)
                      : as &&
                        (y !== S
                          ? ((h.stateNode = Ni(S, po.current, Fi.current, h)),
                            Za(h))
                          : (h.stateNode = c.stateNode));
                else {
                  if (typeof S != "string" && h.stateNode === null)
                    throw Error(i(166));
                  if (((c = po.current), (y = Fi.current), $e(h))) {
                    if (!ir) throw Error(i(176));
                    if (
                      ((c = h.stateNode),
                      (y = h.memoizedProps),
                      (S = null),
                      (R = Pi),
                      R !== null)
                    )
                      switch (R.tag) {
                        case 27:
                        case 5:
                          S = R.memoizedProps;
                      }
                    Ch(c, y, h, S) || be(h);
                  } else h.stateNode = Ni(S, c, y, h);
                }
                return _i(h), null;
              case 13:
                if (
                  ((S = h.memoizedState),
                  c === null ||
                    (c.memoizedState !== null &&
                      c.memoizedState.dehydrated !== null))
                ) {
                  if (((R = $e(h)), S !== null && S.dehydrated !== null)) {
                    if (c === null) {
                      if (!R) throw Error(i(318));
                      if (!ir) throw Error(i(344));
                      if (
                        ((R = h.memoizedState),
                        (R = R !== null ? R.dehydrated : null),
                        !R)
                      )
                        throw Error(i(317));
                      Kg(R, h);
                    } else
                      Me(),
                        (h.flags & 128) === 0 && (h.memoizedState = null),
                        (h.flags |= 4);
                    _i(h), (R = !1);
                  } else Pr !== null && (to(Pr), (Pr = null)), (R = !0);
                  if (!R) return h.flags & 256 ? (zt(h), h) : (zt(h), null);
                }
                if ((zt(h), (h.flags & 128) !== 0)) return (h.lanes = y), h;
                if (
                  ((y = S !== null),
                  (c = c !== null && c.memoizedState !== null),
                  y)
                ) {
                  (S = h.child),
                    (R = null),
                    S.alternate !== null &&
                      S.alternate.memoizedState !== null &&
                      S.alternate.memoizedState.cachePool !== null &&
                      (R = S.alternate.memoizedState.cachePool.pool);
                  var L = null;
                  S.memoizedState !== null &&
                    S.memoizedState.cachePool !== null &&
                    (L = S.memoizedState.cachePool.pool),
                    L !== R && (S.flags |= 2048);
                }
                return (
                  y !== c && y && (h.child.flags |= 8192),
                  wu(h, h.updateQueue),
                  _i(h),
                  null
                );
              case 4:
                return (
                  se(),
                  Fc(c, h),
                  c === null && xg(h.stateNode.containerInfo),
                  _i(h),
                  null
                );
              case 10:
                return js(h.type), _i(h), null;
              case 19:
                if ((b(fi), (R = h.memoizedState), R === null))
                  return _i(h), null;
                if (
                  ((S = (h.flags & 128) !== 0), (L = R.rendering), L === null)
                )
                  if (S) Bu(R, !1);
                  else {
                    if (Si !== 0 || (c !== null && (c.flags & 128) !== 0))
                      for (c = h.child; c !== null; ) {
                        if (((L = pn(c)), L !== null)) {
                          for (
                            h.flags |= 128,
                              Bu(R, !1),
                              c = L.updateQueue,
                              h.updateQueue = c,
                              wu(h, c),
                              h.subtreeFlags = 0,
                              c = y,
                              y = h.child;
                            y !== null;

                          )
                            kl(y, c), (y = y.sibling);
                          return w(fi, (fi.current & 1) | 2), h.child;
                        }
                        c = c.sibling;
                      }
                    R.tail !== null &&
                      Ar() > br &&
                      ((h.flags |= 128),
                      (S = !0),
                      Bu(R, !1),
                      (h.lanes = 4194304));
                  }
                else {
                  if (!S)
                    if (((c = pn(L)), c !== null)) {
                      if (
                        ((h.flags |= 128),
                        (S = !0),
                        (c = c.updateQueue),
                        (h.updateQueue = c),
                        wu(h, c),
                        Bu(R, !0),
                        R.tail === null &&
                          R.tailMode === "hidden" &&
                          !L.alternate &&
                          !Pn)
                      )
                        return _i(h), null;
                    } else
                      2 * Ar() - R.renderingStartTime > br &&
                        y !== 536870912 &&
                        ((h.flags |= 128),
                        (S = !0),
                        Bu(R, !1),
                        (h.lanes = 4194304));
                  R.isBackwards
                    ? ((L.sibling = h.child), (h.child = L))
                    : ((c = R.last),
                      c !== null ? (c.sibling = L) : (h.child = L),
                      (R.last = L));
                }
                return R.tail !== null
                  ? ((h = R.tail),
                    (R.rendering = h),
                    (R.tail = h.sibling),
                    (R.renderingStartTime = Ar()),
                    (h.sibling = null),
                    (c = fi.current),
                    w(fi, S ? (c & 1) | 2 : c & 1),
                    h)
                  : (_i(h), null);
              case 22:
              case 23:
                return (
                  zt(h),
                  ui(),
                  (S = h.memoizedState !== null),
                  c !== null
                    ? (c.memoizedState !== null) !== S && (h.flags |= 8192)
                    : S && (h.flags |= 8192),
                  S
                    ? (y & 536870912) !== 0 &&
                      (h.flags & 128) === 0 &&
                      (_i(h), h.subtreeFlags & 6 && (h.flags |= 8192))
                    : _i(h),
                  (y = h.updateQueue),
                  y !== null && wu(h, y.retryQueue),
                  (y = null),
                  c !== null &&
                    c.memoizedState !== null &&
                    c.memoizedState.cachePool !== null &&
                    (y = c.memoizedState.cachePool.pool),
                  (S = null),
                  h.memoizedState !== null &&
                    h.memoizedState.cachePool !== null &&
                    (S = h.memoizedState.cachePool.pool),
                  S !== y && (h.flags |= 2048),
                  c !== null && b(tu),
                  null
                );
              case 24:
                return (
                  (y = null),
                  c !== null && (y = c.memoizedState.cache),
                  h.memoizedState.cache !== y && (h.flags |= 2048),
                  js(Ri),
                  _i(h),
                  null
                );
              case 25:
                return null;
            }
            throw Error(i(156, h.tag));
          }
          function h_(c, h) {
            switch ((fe(h), h.tag)) {
              case 1:
                return (
                  (c = h.flags),
                  c & 65536 ? ((h.flags = (c & -65537) | 128), h) : null
                );
              case 3:
                return (
                  js(Ri),
                  se(),
                  (c = h.flags),
                  (c & 65536) !== 0 && (c & 128) === 0
                    ? ((h.flags = (c & -65537) | 128), h)
                    : null
                );
              case 26:
              case 27:
              case 5:
                return ye(h), null;
              case 13:
                if (
                  (zt(h),
                  (c = h.memoizedState),
                  c !== null && c.dehydrated !== null)
                ) {
                  if (h.alternate === null) throw Error(i(340));
                  Me();
                }
                return (
                  (c = h.flags),
                  c & 65536 ? ((h.flags = (c & -65537) | 128), h) : null
                );
              case 19:
                return b(fi), null;
              case 4:
                return se(), null;
              case 10:
                return js(h.type), null;
              case 22:
              case 23:
                return (
                  zt(h),
                  ui(),
                  c !== null && b(tu),
                  (c = h.flags),
                  c & 65536 ? ((h.flags = (c & -65537) | 128), h) : null
                );
              case 24:
                return js(Ri), null;
              case 25:
                return null;
              default:
                return null;
            }
          }
          function hg(c, h) {
            switch ((fe(h), h.tag)) {
              case 3:
                js(Ri), se();
                break;
              case 26:
              case 27:
              case 5:
                ye(h);
                break;
              case 4:
                se();
                break;
              case 13:
                zt(h);
                break;
              case 19:
                b(fi);
                break;
              case 10:
                js(h.type);
                break;
              case 22:
              case 23:
                zt(h), ui(), c !== null && b(tu);
                break;
              case 24:
                js(Ri);
            }
          }
          function Pc(c, h) {
            try {
              var y = h.updateQueue,
                S = y !== null ? y.lastEffect : null;
              if (S !== null) {
                var R = S.next;
                y = R;
                do {
                  if ((y.tag & c) === c) {
                    S = void 0;
                    var L = y.create,
                      ee = y.inst;
                    (S = L()), (ee.destroy = S);
                  }
                  y = y.next;
                } while (y !== R);
              }
            } catch (_e) {
              qn(h, h.return, _e);
            }
          }
          function Xo(c, h, y) {
            try {
              var S = h.updateQueue,
                R = S !== null ? S.lastEffect : null;
              if (R !== null) {
                var L = R.next;
                S = L;
                do {
                  if ((S.tag & c) === c) {
                    var ee = S.inst,
                      _e = ee.destroy;
                    if (_e !== void 0) {
                      (ee.destroy = void 0), (R = h);
                      var Le = y;
                      try {
                        _e();
                      } catch (ut) {
                        qn(R, Le, ut);
                      }
                    }
                  }
                  S = S.next;
                } while (S !== L);
              }
            } catch (ut) {
              qn(h, h.return, ut);
            }
          }
          function dg(c) {
            var h = c.updateQueue;
            if (h !== null) {
              var y = c.stateNode;
              try {
                xe(h, y);
              } catch (S) {
                qn(c, c.return, S);
              }
            }
          }
          function Qa(c, h, y) {
            (y.props = mr(c.type, c.memoizedProps)),
              (y.state = c.memoizedState);
            try {
              y.componentWillUnmount();
            } catch (S) {
              qn(c, h, S);
            }
          }
          function ns(c, h) {
            try {
              var y = c.ref;
              if (y !== null) {
                var S = c.stateNode;
                switch (c.tag) {
                  case 26:
                  case 27:
                  case 5:
                    var R = Wl(S);
                    break;
                  default:
                    R = S;
                }
                typeof y == "function"
                  ? (c.refCleanup = y(R))
                  : (y.current = R);
              }
            } catch (L) {
              qn(c, h, L);
            }
          }
          function $a(c, h) {
            var y = c.ref,
              S = c.refCleanup;
            if (y !== null)
              if (typeof S == "function")
                try {
                  S();
                } catch (R) {
                  qn(c, h, R);
                } finally {
                  (c.refCleanup = null),
                    (c = c.alternate),
                    c != null && (c.refCleanup = null);
                }
              else if (typeof y == "function")
                try {
                  y(null);
                } catch (R) {
                  qn(c, h, R);
                }
              else y.current = null;
          }
          function Zd(c) {
            var h = c.type,
              y = c.memoizedProps,
              S = c.stateNode;
            try {
              Lg(S, h, y, c);
            } catch (R) {
              qn(c, c.return, R);
            }
          }
          function Qd(c, h, y) {
            try {
              Ng(c.stateNode, c.type, y, h, c);
            } catch (S) {
              qn(c, c.return, S);
            }
          }
          function $d(c) {
            return (
              c.tag === 5 ||
              c.tag === 3 ||
              (_r ? c.tag === 26 : !1) ||
              (ua ? c.tag === 27 : !1) ||
              c.tag === 4
            );
          }
          function Gc(c) {
            e: for (;;) {
              for (; c.sibling === null; ) {
                if (c.return === null || $d(c.return)) return null;
                c = c.return;
              }
              for (
                c.sibling.return = c.return, c = c.sibling;
                c.tag !== 5 &&
                c.tag !== 6 &&
                (!ua || c.tag !== 27) &&
                c.tag !== 18;

              ) {
                if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
                (c.child.return = c), (c = c.child);
              }
              if (!(c.flags & 2)) return c.stateNode;
            }
          }
          function ep(c, h, y) {
            var S = c.tag;
            if (S === 5 || S === 6)
              (c = c.stateNode), h ? gp(y, c, h) : mp(y, c);
            else if (
              !(S === 4 || (ua && S === 27)) &&
              ((c = c.child), c !== null)
            )
              for (ep(c, h, y), c = c.sibling; c !== null; )
                ep(c, h, y), (c = c.sibling);
          }
          function uh(c, h, y) {
            var S = c.tag;
            if (S === 5 || S === 6)
              (c = c.stateNode), h ? Ig(y, c, h) : Ug(y, c);
            else if (
              !(S === 4 || (ua && S === 27)) &&
              ((c = c.child), c !== null)
            )
              for (uh(c, h, y), c = c.sibling; c !== null; )
                uh(c, h, y), (c = c.sibling);
          }
          function Pl(c, h, y) {
            c = c.containerInfo;
            try {
              Xg(c, y);
            } catch (S) {
              qn(h, h.return, S);
            }
          }
          function tp(c, h) {
            for (Ag(c.containerInfo), Zt = h; Zt !== null; )
              if (
                ((c = Zt),
                (h = c.child),
                (c.subtreeFlags & 1028) !== 0 && h !== null)
              )
                (h.return = c), (Zt = h);
              else
                for (; Zt !== null; ) {
                  c = Zt;
                  var y = c.alternate;
                  switch (((h = c.flags), c.tag)) {
                    case 0:
                      break;
                    case 11:
                    case 15:
                      break;
                    case 1:
                      if ((h & 1024) !== 0 && y !== null) {
                        h = void 0;
                        var S = c,
                          R = y.memoizedProps;
                        y = y.memoizedState;
                        var L = S.stateNode;
                        try {
                          var ee = mr(S.type, R, S.elementType === S.type);
                          (h = L.getSnapshotBeforeUpdate(ee, y)),
                            (L.__reactInternalSnapshotBeforeUpdate = h);
                        } catch (_e) {
                          qn(S, S.return, _e);
                        }
                      }
                      break;
                    case 3:
                      (h & 1024) !== 0 && Ai && Hg(c.stateNode.containerInfo);
                      break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                      break;
                    default:
                      if ((h & 1024) !== 0) throw Error(i(163));
                  }
                  if (((h = c.sibling), h !== null)) {
                    (h.return = c.return), (Zt = h);
                    break;
                  }
                  Zt = c.return;
                }
            return (ee = ri), (ri = !1), ee;
          }
          function Du(c, h, y) {
            var S = y.flags;
            switch (y.tag) {
              case 0:
              case 11:
              case 15:
                Zs(c, y), S & 4 && Pc(5, y);
                break;
              case 1:
                if ((Zs(c, y), S & 4))
                  if (((c = y.stateNode), h === null))
                    try {
                      c.componentDidMount();
                    } catch (_e) {
                      qn(y, y.return, _e);
                    }
                  else {
                    var R = mr(y.type, h.memoizedProps);
                    h = h.memoizedState;
                    try {
                      c.componentDidUpdate(
                        R,
                        h,
                        c.__reactInternalSnapshotBeforeUpdate
                      );
                    } catch (_e) {
                      qn(y, y.return, _e);
                    }
                  }
                S & 64 && dg(y), S & 512 && ns(y, y.return);
                break;
              case 3:
                if ((Zs(c, y), S & 64 && ((S = y.updateQueue), S !== null))) {
                  if (((c = null), y.child !== null))
                    switch (y.child.tag) {
                      case 27:
                      case 5:
                        c = Wl(y.child.stateNode);
                        break;
                      case 1:
                        c = y.child.stateNode;
                    }
                  try {
                    xe(S, c);
                  } catch (_e) {
                    qn(y, y.return, _e);
                  }
                }
                break;
              case 26:
                if (_r) {
                  Zs(c, y), S & 512 && ns(y, y.return);
                  break;
                }
              case 27:
              case 5:
                Zs(c, y),
                  h === null && S & 4 && Zd(y),
                  S & 512 && ns(y, y.return);
                break;
              case 12:
                Zs(c, y);
                break;
              case 13:
                Zs(c, y), S & 4 && Gl(c, y);
                break;
              case 22:
                if (((R = y.memoizedState !== null || Ao), !R)) {
                  h = (h !== null && h.memoizedState !== null) || un;
                  var L = Ao,
                    ee = un;
                  (Ao = R),
                    (un = h) && !ee
                      ? Yo(c, y, (y.subtreeFlags & 8772) !== 0)
                      : Zs(c, y),
                    (Ao = L),
                    (un = ee);
                }
                S & 512 &&
                  (y.memoizedProps.mode === "manual"
                    ? ns(y, y.return)
                    : $a(y, y.return));
                break;
              default:
                Zs(c, y);
            }
          }
          function ch(c) {
            var h = c.alternate;
            h !== null && ((c.alternate = null), ch(h)),
              (c.child = null),
              (c.deletions = null),
              (c.sibling = null),
              c.tag === 5 && ((h = c.stateNode), h !== null && bg(h)),
              (c.stateNode = null),
              (c.return = null),
              (c.dependencies = null),
              (c.memoizedProps = null),
              (c.memoizedState = null),
              (c.pendingProps = null),
              (c.stateNode = null),
              (c.updateQueue = null);
          }
          function Or(c, h, y) {
            for (y = y.child; y !== null; ) Ks(c, h, y), (y = y.sibling);
          }
          function Ks(c, h, y) {
            if (Ji && typeof Ji.onCommitFiberUnmount == "function")
              try {
                Ji.onCommitFiberUnmount(Yu, y);
              } catch {}
            switch (y.tag) {
              case 26:
                if (_r) {
                  un || $a(y, h),
                    Or(c, h, y),
                    y.memoizedState
                      ? Tp(y.memoizedState)
                      : y.stateNode && Vu(y.stateNode);
                  break;
                }
              case 27:
                if (ua) {
                  un || $a(y, h);
                  var S = kn,
                    R = Hi;
                  (kn = y.stateNode),
                    Or(c, h, y),
                    Up(y.stateNode),
                    (kn = S),
                    (Hi = R);
                  break;
                }
              case 5:
                un || $a(y, h);
              case 6:
                if (Ai) {
                  if (
                    ((S = kn),
                    (R = Hi),
                    (kn = null),
                    Or(c, h, y),
                    (kn = S),
                    (Hi = R),
                    kn !== null)
                  )
                    if (Hi)
                      try {
                        Pg(kn, y.stateNode);
                      } catch (L) {
                        qn(y, h, L);
                      }
                    else
                      try {
                        Fg(kn, y.stateNode);
                      } catch (L) {
                        qn(y, h, L);
                      }
                } else Or(c, h, y);
                break;
              case 18:
                Ai &&
                  kn !== null &&
                  (Hi ? Sp(kn, y.stateNode) : $g(kn, y.stateNode));
                break;
              case 4:
                Ai
                  ? ((S = kn),
                    (R = Hi),
                    (kn = y.stateNode.containerInfo),
                    (Hi = !0),
                    Or(c, h, y),
                    (kn = S),
                    (Hi = R))
                  : (as && Pl(y.stateNode, y, Eh()), Or(c, h, y));
                break;
              case 0:
              case 11:
              case 14:
              case 15:
                un || Xo(2, y, h), un || Xo(4, y, h), Or(c, h, y);
                break;
              case 1:
                un ||
                  ($a(y, h),
                  (S = y.stateNode),
                  typeof S.componentWillUnmount == "function" && Qa(y, h, S)),
                  Or(c, h, y);
                break;
              case 21:
                Or(c, h, y);
                break;
              case 22:
                un || $a(y, h),
                  (un = (S = un) || y.memoizedState !== null),
                  Or(c, h, y),
                  (un = S);
                break;
              default:
                Or(c, h, y);
            }
          }
          function Gl(c, h) {
            if (
              ir &&
              h.memoizedState === null &&
              ((c = h.alternate),
              c !== null &&
                ((c = c.memoizedState),
                c !== null && ((c = c.dehydrated), c !== null)))
            )
              try {
                Rh(c);
              } catch (y) {
                qn(h, h.return, y);
              }
          }
          function np(c) {
            switch (c.tag) {
              case 13:
              case 19:
                var h = c.stateNode;
                return h === null && (h = c.stateNode = new bn()), h;
              case 22:
                return (
                  (c = c.stateNode),
                  (h = c._retryCache),
                  h === null && (h = c._retryCache = new bn()),
                  h
                );
              default:
                throw Error(i(435, c.tag));
            }
          }
          function fh(c, h) {
            var y = np(c);
            h.forEach(function (S) {
              var R = gh.bind(null, c, S);
              y.has(S) || (y.add(S), S.then(R, R));
            });
          }
          function Xi(c, h) {
            var y = h.deletions;
            if (y !== null)
              for (var S = 0; S < y.length; S++) {
                var R = y[S],
                  L = c,
                  ee = h;
                if (Ai) {
                  var _e = ee;
                  e: for (; _e !== null; ) {
                    switch (_e.tag) {
                      case 27:
                      case 5:
                        (kn = _e.stateNode), (Hi = !1);
                        break e;
                      case 3:
                        (kn = _e.stateNode.containerInfo), (Hi = !0);
                        break e;
                      case 4:
                        (kn = _e.stateNode.containerInfo), (Hi = !0);
                        break e;
                    }
                    _e = _e.return;
                  }
                  if (kn === null) throw Error(i(160));
                  Ks(L, ee, R), (kn = null), (Hi = !1);
                } else Ks(L, ee, R);
                (L = R.alternate),
                  L !== null && (L.return = null),
                  (R.return = null);
              }
            if (h.subtreeFlags & 13878)
              for (h = h.child; h !== null; ) ip(h, c), (h = h.sibling);
          }
          function ip(c, h) {
            var y = c.alternate,
              S = c.flags;
            switch (c.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Xi(h, c),
                  er(c),
                  S & 4 && (Xo(3, c, c.return), Pc(3, c), Xo(5, c, c.return));
                break;
              case 1:
                Xi(h, c),
                  er(c),
                  S & 512 && (un || y === null || $a(y, y.return)),
                  S & 64 &&
                    Ao &&
                    ((c = c.updateQueue),
                    c !== null &&
                      ((S = c.callbacks),
                      S !== null &&
                        ((y = c.shared.hiddenCallbacks),
                        (c.shared.hiddenCallbacks =
                          y === null ? S : y.concat(S)))));
                break;
              case 26:
                if (_r) {
                  var R = Da;
                  Xi(h, c),
                    er(c),
                    S & 512 && (un || y === null || $a(y, y.return)),
                    S & 4 &&
                      ((S = y !== null ? y.memoizedState : null),
                      (h = c.memoizedState),
                      y === null
                        ? h === null
                          ? c.stateNode === null
                            ? (c.stateNode = tv(R, c.type, c.memoizedProps, c))
                            : Cp(R, c.type, c.stateNode)
                          : (c.stateNode = Ep(R, h, c.memoizedProps))
                        : S !== h
                        ? (S === null
                            ? y.stateNode !== null && Vu(y.stateNode)
                            : Tp(S),
                          h === null
                            ? Cp(R, c.type, c.stateNode)
                            : Ep(R, h, c.memoizedProps))
                        : h === null &&
                          c.stateNode !== null &&
                          Qd(c, c.memoizedProps, y.memoizedProps));
                  break;
                }
              case 27:
                if (ua && S & 4 && c.alternate === null) {
                  R = c.stateNode;
                  var L = c.memoizedProps;
                  try {
                    av(R), Dp(c.type, L, R, c);
                  } catch (Et) {
                    qn(c, c.return, Et);
                  }
                }
              case 5:
                if (
                  (Xi(h, c),
                  er(c),
                  S & 512 && (un || y === null || $a(y, y.return)),
                  Ai)
                ) {
                  if (c.flags & 32) {
                    h = c.stateNode;
                    try {
                      bh(h);
                    } catch (Et) {
                      qn(c, c.return, Et);
                    }
                  }
                  S & 4 &&
                    c.stateNode != null &&
                    ((h = c.memoizedProps),
                    Qd(c, h, y !== null ? y.memoizedProps : h)),
                    S & 1024 && (ti = !0);
                }
                break;
              case 6:
                if ((Xi(h, c), er(c), S & 4 && Ai)) {
                  if (c.stateNode === null) throw Error(i(162));
                  (S = c.memoizedProps),
                    (y = y !== null ? y.memoizedProps : S),
                    (h = c.stateNode);
                  try {
                    Og(h, y, S);
                  } catch (Et) {
                    qn(c, c.return, Et);
                  }
                }
                break;
              case 3:
                if (
                  (_r
                    ? (nv(),
                      (R = Da),
                      (Da = na(h.containerInfo)),
                      Xi(h, c),
                      (Da = R))
                    : Xi(h, c),
                  er(c),
                  S & 4)
                ) {
                  if (Ai && ir && y !== null && y.memoizedState.isDehydrated)
                    try {
                      Qg(h.containerInfo);
                    } catch (Et) {
                      qn(c, c.return, Et);
                    }
                  if (as) {
                    (S = h.containerInfo), (y = h.pendingChildren);
                    try {
                      Xg(S, y);
                    } catch (Et) {
                      qn(c, c.return, Et);
                    }
                  }
                }
                ti && ((ti = !1), ap(c));
                break;
              case 4:
                _r
                  ? ((y = Da),
                    (Da = na(c.stateNode.containerInfo)),
                    Xi(h, c),
                    er(c),
                    (Da = y))
                  : (Xi(h, c), er(c)),
                  S & 4 &&
                    as &&
                    Pl(c.stateNode, c, c.stateNode.pendingChildren);
                break;
              case 12:
                Xi(h, c), er(c);
                break;
              case 13:
                Xi(h, c),
                  er(c),
                  c.child.flags & 8192 &&
                    (c.memoizedState !== null) !=
                      (y !== null && y.memoizedState !== null) &&
                    (Fp = Ar()),
                  S & 4 &&
                    ((S = c.updateQueue),
                    S !== null && ((c.updateQueue = null), fh(c, S)));
                break;
              case 22:
                S & 512 && (un || y === null || $a(y, y.return)),
                  (R = c.memoizedState !== null);
                var ee = y !== null && y.memoizedState !== null,
                  _e = Ao,
                  Le = un;
                if (
                  ((Ao = _e || R),
                  (un = Le || ee),
                  Xi(h, c),
                  (un = Le),
                  (Ao = _e),
                  er(c),
                  (h = c.stateNode),
                  (h._current = c),
                  (h._visibility &= -3),
                  (h._visibility |= h._pendingVisibility & 2),
                  S & 8192 &&
                    ((h._visibility = R
                      ? h._visibility & -2
                      : h._visibility | 1),
                    R && ((h = Ao || un), y === null || ee || h || Uu(c)),
                    Ai &&
                      (c.memoizedProps === null ||
                        c.memoizedProps.mode !== "manual")))
                ) {
                  e: if (((y = null), Ai))
                    for (h = c; ; ) {
                      if (
                        h.tag === 5 ||
                        (_r && h.tag === 26) ||
                        (ua && h.tag === 27)
                      ) {
                        if (y === null) {
                          ee = y = h;
                          try {
                            (L = ee.stateNode),
                              R ? Gg(L) : __(ee.stateNode, ee.memoizedProps);
                          } catch (Et) {
                            qn(ee, ee.return, Et);
                          }
                        }
                      } else if (h.tag === 6) {
                        if (y === null) {
                          ee = h;
                          try {
                            var ut = ee.stateNode;
                            R ? zg(ut) : vp(ut, ee.memoizedProps);
                          } catch (Et) {
                            qn(ee, ee.return, Et);
                          }
                        }
                      } else if (
                        ((h.tag !== 22 && h.tag !== 23) ||
                          h.memoizedState === null ||
                          h === c) &&
                        h.child !== null
                      ) {
                        (h.child.return = h), (h = h.child);
                        continue;
                      }
                      if (h === c) break e;
                      for (; h.sibling === null; ) {
                        if (h.return === null || h.return === c) break e;
                        y === h && (y = null), (h = h.return);
                      }
                      y === h && (y = null),
                        (h.sibling.return = h.return),
                        (h = h.sibling);
                    }
                }
                S & 4 &&
                  ((S = c.updateQueue),
                  S !== null &&
                    ((y = S.retryQueue),
                    y !== null && ((S.retryQueue = null), fh(c, y))));
                break;
              case 19:
                Xi(h, c),
                  er(c),
                  S & 4 &&
                    ((S = c.updateQueue),
                    S !== null && ((c.updateQueue = null), fh(c, S)));
                break;
              case 21:
                break;
              default:
                Xi(h, c), er(c);
            }
          }
          function er(c) {
            var h = c.flags;
            if (h & 2) {
              try {
                if (Ai && (!ua || c.tag !== 27)) {
                  e: {
                    for (var y = c.return; y !== null; ) {
                      if ($d(y)) {
                        var S = y;
                        break e;
                      }
                      y = y.return;
                    }
                    throw Error(i(160));
                  }
                  switch (S.tag) {
                    case 27:
                      if (ua) {
                        var R = S.stateNode,
                          L = Gc(c);
                        uh(c, L, R);
                        break;
                      }
                    case 5:
                      var ee = S.stateNode;
                      S.flags & 32 && (bh(ee), (S.flags &= -33));
                      var _e = Gc(c);
                      uh(c, _e, ee);
                      break;
                    case 3:
                    case 4:
                      var Le = S.stateNode.containerInfo,
                        ut = Gc(c);
                      ep(c, ut, Le);
                      break;
                    default:
                      throw Error(i(161));
                  }
                }
              } catch (Et) {
                qn(c, c.return, Et);
              }
              c.flags &= -3;
            }
            h & 4096 && (c.flags &= -4097);
          }
          function ap(c) {
            if (c.subtreeFlags & 1024)
              for (c = c.child; c !== null; ) {
                var h = c;
                ap(h),
                  h.tag === 5 && h.flags & 1024 && Tg(h.stateNode),
                  (c = c.sibling);
              }
          }
          function Zs(c, h) {
            if (h.subtreeFlags & 8772)
              for (h = h.child; h !== null; )
                Du(c, h.alternate, h), (h = h.sibling);
          }
          function Uu(c) {
            for (c = c.child; c !== null; ) {
              var h = c;
              switch (h.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Xo(4, h, h.return), Uu(h);
                  break;
                case 1:
                  $a(h, h.return);
                  var y = h.stateNode;
                  typeof y.componentWillUnmount == "function" &&
                    Qa(h, h.return, y),
                    Uu(h);
                  break;
                case 26:
                case 27:
                case 5:
                  $a(h, h.return), Uu(h);
                  break;
                case 22:
                  $a(h, h.return), h.memoizedState === null && Uu(h);
                  break;
                default:
                  Uu(h);
              }
              c = c.sibling;
            }
          }
          function Yo(c, h, y) {
            for (
              y = y && (h.subtreeFlags & 8772) !== 0, h = h.child;
              h !== null;

            ) {
              var S = h.alternate,
                R = c,
                L = h,
                ee = L.flags;
              switch (L.tag) {
                case 0:
                case 11:
                case 15:
                  Yo(R, L, y), Pc(4, L);
                  break;
                case 1:
                  if (
                    (Yo(R, L, y),
                    (S = L),
                    (R = S.stateNode),
                    typeof R.componentDidMount == "function")
                  )
                    try {
                      R.componentDidMount();
                    } catch (ut) {
                      qn(S, S.return, ut);
                    }
                  if (((S = L), (R = S.updateQueue), R !== null)) {
                    var _e = S.stateNode;
                    try {
                      var Le = R.shared.hiddenCallbacks;
                      if (Le !== null)
                        for (
                          R.shared.hiddenCallbacks = null, R = 0;
                          R < Le.length;
                          R++
                        )
                          ce(Le[R], _e);
                    } catch (ut) {
                      qn(S, S.return, ut);
                    }
                  }
                  y && ee & 64 && dg(L), ns(L, L.return);
                  break;
                case 26:
                case 27:
                case 5:
                  Yo(R, L, y),
                    y && S === null && ee & 4 && Zd(L),
                    ns(L, L.return);
                  break;
                case 12:
                  Yo(R, L, y);
                  break;
                case 13:
                  Yo(R, L, y), y && ee & 4 && Gl(R, L);
                  break;
                case 22:
                  L.memoizedState === null && Yo(R, L, y), ns(L, L.return);
                  break;
                default:
                  Yo(R, L, y);
              }
              h = h.sibling;
            }
          }
          function hh(c, h) {
            var y = null;
            c !== null &&
              c.memoizedState !== null &&
              c.memoizedState.cachePool !== null &&
              (y = c.memoizedState.cachePool.pool),
              (c = null),
              h.memoizedState !== null &&
                h.memoizedState.cachePool !== null &&
                (c = h.memoizedState.cachePool.pool),
              c !== y && (c != null && c.refCount++, y != null && Ic(y));
          }
          function dh(c, h) {
            (c = null),
              h.alternate !== null && (c = h.alternate.memoizedState.cache),
              (h = h.memoizedState.cache),
              h !== c && (h.refCount++, c != null && Ic(c));
          }
          function Qs(c, h, y, S) {
            if (h.subtreeFlags & 10256)
              for (h = h.child; h !== null; ) Lr(c, h, y, S), (h = h.sibling);
          }
          function Lr(c, h, y, S) {
            var R = h.flags;
            switch (h.tag) {
              case 0:
              case 11:
              case 15:
                Qs(c, h, y, S), R & 2048 && Pc(9, h);
                break;
              case 3:
                Qs(c, h, y, S),
                  R & 2048 &&
                    ((c = null),
                    h.alternate !== null &&
                      (c = h.alternate.memoizedState.cache),
                    (h = h.memoizedState.cache),
                    h !== c && (h.refCount++, c != null && Ic(c)));
                break;
              case 12:
                if (R & 2048) {
                  Qs(c, h, y, S), (c = h.stateNode);
                  try {
                    var L = h.memoizedProps,
                      ee = L.id,
                      _e = L.onPostCommit;
                    typeof _e == "function" &&
                      _e(
                        ee,
                        h.alternate === null ? "mount" : "update",
                        c.passiveEffectDuration,
                        -0
                      );
                  } catch (Le) {
                    qn(h, h.return, Le);
                  }
                } else Qs(c, h, y, S);
                break;
              case 23:
                break;
              case 22:
                (L = h.stateNode),
                  h.memoizedState !== null
                    ? L._visibility & 4
                      ? Qs(c, h, y, S)
                      : _s(c, h)
                    : L._visibility & 4
                    ? Qs(c, h, y, S)
                    : ((L._visibility |= 4),
                      ma(c, h, y, S, (h.subtreeFlags & 10256) !== 0)),
                  R & 2048 && hh(h.alternate, h);
                break;
              case 24:
                Qs(c, h, y, S), R & 2048 && dh(h.alternate, h);
                break;
              default:
                Qs(c, h, y, S);
            }
          }
          function ma(c, h, y, S, R) {
            for (
              R = R && (h.subtreeFlags & 10256) !== 0, h = h.child;
              h !== null;

            ) {
              var L = c,
                ee = h,
                _e = y,
                Le = S,
                ut = ee.flags;
              switch (ee.tag) {
                case 0:
                case 11:
                case 15:
                  ma(L, ee, _e, Le, R), Pc(8, ee);
                  break;
                case 23:
                  break;
                case 22:
                  var Et = ee.stateNode;
                  ee.memoizedState !== null
                    ? Et._visibility & 4
                      ? ma(L, ee, _e, Le, R)
                      : _s(L, ee)
                    : ((Et._visibility |= 4), ma(L, ee, _e, Le, R)),
                    R && ut & 2048 && hh(ee.alternate, ee);
                  break;
                case 24:
                  ma(L, ee, _e, Le, R), R && ut & 2048 && dh(ee.alternate, ee);
                  break;
                default:
                  ma(L, ee, _e, Le, R);
              }
              h = h.sibling;
            }
          }
          function _s(c, h) {
            if (h.subtreeFlags & 10256)
              for (h = h.child; h !== null; ) {
                var y = c,
                  S = h,
                  R = S.flags;
                switch (S.tag) {
                  case 22:
                    _s(y, S), R & 2048 && hh(S.alternate, S);
                    break;
                  case 24:
                    _s(y, S), R & 2048 && dh(S.alternate, S);
                    break;
                  default:
                    _s(y, S);
                }
                h = h.sibling;
              }
          }
          function $s(c) {
            if (c.subtreeFlags & yl)
              for (c = c.child; c !== null; ) zc(c), (c = c.sibling);
          }
          function zc(c) {
            switch (c.tag) {
              case 26:
                $s(c),
                  c.flags & yl &&
                    (c.memoizedState !== null
                      ? Bp(Da, c.memoizedState, c.memoizedProps)
                      : pp(c.type, c.memoizedProps));
                break;
              case 5:
                $s(c), c.flags & yl && pp(c.type, c.memoizedProps);
                break;
              case 3:
              case 4:
                if (_r) {
                  var h = Da;
                  (Da = na(c.stateNode.containerInfo)), $s(c), (Da = h);
                } else $s(c);
                break;
              case 22:
                c.memoizedState === null &&
                  ((h = c.alternate),
                  h !== null && h.memoizedState !== null
                    ? ((h = yl), (yl = 16777216), $s(c), (yl = h))
                    : $s(c));
                break;
              default:
                $s(c);
            }
          }
          function Hc(c) {
            var h = c.alternate;
            if (h !== null && ((c = h.child), c !== null)) {
              h.child = null;
              do (h = c.sibling), (c.sibling = null), (c = h);
              while (c !== null);
            }
          }
          function zl(c) {
            var h = c.deletions;
            if ((c.flags & 16) !== 0) {
              if (h !== null)
                for (var y = 0; y < h.length; y++) {
                  var S = h[y];
                  (Zt = S), kc(S, c);
                }
              Hc(c);
            }
            if (c.subtreeFlags & 10256)
              for (c = c.child; c !== null; ) eo(c), (c = c.sibling);
          }
          function eo(c) {
            switch (c.tag) {
              case 0:
              case 11:
              case 15:
                zl(c), c.flags & 2048 && Xo(9, c, c.return);
                break;
              case 3:
                zl(c);
                break;
              case 12:
                zl(c);
                break;
              case 22:
                var h = c.stateNode;
                c.memoizedState !== null &&
                h._visibility & 4 &&
                (c.return === null || c.return.tag !== 13)
                  ? ((h._visibility &= -5), Vc(c))
                  : zl(c);
                break;
              default:
                zl(c);
            }
          }
          function Vc(c) {
            var h = c.deletions;
            if ((c.flags & 16) !== 0) {
              if (h !== null)
                for (var y = 0; y < h.length; y++) {
                  var S = h[y];
                  (Zt = S), kc(S, c);
                }
              Hc(c);
            }
            for (c = c.child; c !== null; ) {
              switch (((h = c), h.tag)) {
                case 0:
                case 11:
                case 15:
                  Xo(8, h, h.return), Vc(h);
                  break;
                case 22:
                  (y = h.stateNode),
                    y._visibility & 4 && ((y._visibility &= -5), Vc(h));
                  break;
                default:
                  Vc(h);
              }
              c = c.sibling;
            }
          }
          function kc(c, h) {
            for (; Zt !== null; ) {
              var y = Zt;
              switch (y.tag) {
                case 0:
                case 11:
                case 15:
                  Xo(8, y, h);
                  break;
                case 23:
                case 22:
                  if (
                    y.memoizedState !== null &&
                    y.memoizedState.cachePool !== null
                  ) {
                    var S = y.memoizedState.cachePool.pool;
                    S != null && S.refCount++;
                  }
                  break;
                case 24:
                  Ic(y.memoizedState.cache);
              }
              if (((S = y.child), S !== null)) (S.return = y), (Zt = S);
              else
                e: for (y = c; Zt !== null; ) {
                  S = Zt;
                  var R = S.sibling,
                    L = S.return;
                  if ((ch(S), S === y)) {
                    Zt = null;
                    break e;
                  }
                  if (R !== null) {
                    (R.return = L), (Zt = R);
                    break e;
                  }
                  Zt = L;
                }
            }
          }
          function Wo(c) {
            var h = xh(c);
            if (h != null) {
              if (typeof h.memoizedProps["data-testname"] != "string")
                throw Error(i(364));
              return h;
            }
            if (((c = wg(c)), c === null)) throw Error(i(362));
            return c.stateNode.current;
          }
          function ph(c, h) {
            var y = c.tag;
            switch (h.$$typeof) {
              case vi:
                if (c.type === h.value) return !0;
                break;
              case fs:
                e: {
                  for (h = h.value, c = [c, 0], y = 0; y < c.length; ) {
                    var S = c[y++],
                      R = S.tag,
                      L = c[y++],
                      ee = h[L];
                    if ((R !== 5 && R !== 26 && R !== 27) || !Es(S)) {
                      for (; ee != null && ph(S, ee); ) L++, (ee = h[L]);
                      if (L === h.length) {
                        h = !0;
                        break e;
                      } else
                        for (S = S.child; S !== null; )
                          c.push(S, L), (S = S.sibling);
                    }
                  }
                  h = !1;
                }
                return h;
              case Ds:
                if (
                  (y === 5 || y === 26 || y === 27) &&
                  Dg(c.stateNode, h.value)
                )
                  return !0;
                break;
              case Va:
                if (
                  (y === 5 || y === 6 || y === 26 || y === 27) &&
                  ((c = Bg(c)), c !== null && 0 <= c.indexOf(h.value))
                )
                  return !0;
                break;
              case Zu:
                if (
                  (y === 5 || y === 26 || y === 27) &&
                  ((c = c.memoizedProps["data-testname"]),
                  typeof c == "string" &&
                    c.toLowerCase() === h.value.toLowerCase())
                )
                  return !0;
                break;
              default:
                throw Error(i(365));
            }
            return !1;
          }
          function tr(c) {
            switch (c.$$typeof) {
              case vi:
                return "<" + (l(c.value) || "Unknown") + ">";
              case fs:
                return ":has(" + (tr(c) || "") + ")";
              case Ds:
                return '[role="' + c.value + '"]';
              case Va:
                return '"' + c.value + '"';
              case Zu:
                return '[data-testname="' + c.value + '"]';
              default:
                throw Error(i(365));
            }
          }
          function Hl(c, h) {
            var y = [];
            c = [c, 0];
            for (var S = 0; S < c.length; ) {
              var R = c[S++],
                L = R.tag,
                ee = c[S++],
                _e = h[ee];
              if ((L !== 5 && L !== 26 && L !== 27) || !Es(R)) {
                for (; _e != null && ph(R, _e); ) ee++, (_e = h[ee]);
                if (ee === h.length) y.push(R);
                else
                  for (R = R.child; R !== null; )
                    c.push(R, ee), (R = R.sibling);
              }
            }
            return y;
          }
          function Jo(c, h) {
            if (!Hu) throw Error(i(363));
            (c = Wo(c)), (c = Hl(c, h)), (h = []), (c = Array.from(c));
            for (var y = 0; y < c.length; ) {
              var S = c[y++],
                R = S.tag;
              if (R === 5 || R === 26 || R === 27) Es(S) || h.push(S.stateNode);
              else for (S = S.child; S !== null; ) c.push(S), (S = S.sibling);
            }
            return h;
          }
          function ba() {
            if ((Rn & 2) !== 0 && wn !== 0) return wn & -wn;
            if (nn.T !== null) {
              var c = gi;
              return c !== 0 ? c : tt();
            }
            return Sg();
          }
          function Xc() {
            Mr === 0 && (Mr = (wn & 536870912) === 0 || Pn ? F() : 536870912);
            var c = sr.current;
            return c !== null && (c.flags |= 32), Mr;
          }
          function ci(c, h, y) {
            ((c === ni && $n === 2) || c.cancelPendingCommit !== null) &&
              (qo(c, 0), Fa(c, wn, Mr, !1)),
              W(c, y),
              ((Rn & 2) === 0 || c !== ni) &&
                (c === ni &&
                  ((Rn & 2) === 0 && (So |= y), Si === 4 && Fa(c, wn, Mr, !1)),
                Ve(c));
          }
          function vr(c, h, y) {
            if ((Rn & 6) !== 0) throw Error(i(327));
            var S =
                (!y && (h & 60) === 0 && (h & c.expiredLanes) === 0) || N(c, h),
              R = S ? pg(c, h) : Wc(c, h, !0),
              L = S;
            do {
              if (R === 0) {
                kr && !S && Fa(c, h, 0, !1);
                break;
              } else if (R === 6) Fa(c, h, 0, !Vr);
              else {
                if (((y = c.current.alternate), L && !no(y))) {
                  (R = Wc(c, h, !1)), (L = !1);
                  continue;
                }
                if (R === 2) {
                  if (((L = h), c.errorRecoveryDisabledLanes & L)) var ee = 0;
                  else
                    (ee = c.pendingLanes & -536870913),
                      (ee = ee !== 0 ? ee : ee & 536870912 ? 536870912 : 0);
                  if (ee !== 0) {
                    h = ee;
                    e: {
                      var _e = c;
                      R = Qu;
                      var Le = ir && _e.current.memoizedState.isDehydrated;
                      if (
                        (Le && (qo(_e, ee).flags |= 256),
                        (ee = Wc(_e, ee, !1)),
                        ee !== 2)
                      ) {
                        if (nu && !Le) {
                          (_e.errorRecoveryDisabledLanes |= L),
                            (So |= L),
                            (R = 4);
                          break e;
                        }
                        (L = Yr), (Yr = R), L !== null && to(L);
                      }
                      R = ee;
                    }
                    if (((L = !1), R !== 2)) continue;
                  }
                }
                if (R === 1) {
                  qo(c, 0), Fa(c, h, 0, !0);
                  break;
                }
                e: {
                  switch (((S = c), R)) {
                    case 0:
                    case 1:
                      throw Error(i(345));
                    case 4:
                      if ((h & 4194176) === h) {
                        Fa(S, h, Mr, !Vr);
                        break e;
                      }
                      break;
                    case 2:
                      Yr = null;
                      break;
                    case 3:
                    case 5:
                      break;
                    default:
                      throw Error(i(329));
                  }
                  if (
                    ((S.finishedWork = y),
                    (S.finishedLanes = h),
                    (h & 62914560) === h && ((L = Fp + 300 - Ar()), 10 < L))
                  ) {
                    if ((Fa(S, h, Mr, !Vr), I(S, 0) !== 0)) break e;
                    S.timeoutHandle = Ah(
                      As.bind(
                        null,
                        S,
                        y,
                        Yr,
                        iu,
                        Gh,
                        h,
                        Mr,
                        So,
                        Ki,
                        Vr,
                        2,
                        -0,
                        0
                      ),
                      L
                    );
                    break e;
                  }
                  As(S, y, Yr, iu, Gh, h, Mr, So, Ki, Vr, 0, -0, 0);
                }
              }
              break;
            } while (!0);
            Ve(c);
          }
          function to(c) {
            Yr === null ? (Yr = c) : Yr.push.apply(Yr, c);
          }
          function As(c, h, y, S, R, L, ee, _e, Le, ut, Et, Ot, bt) {
            var cn = h.subtreeFlags;
            if (
              (cn & 8192 || (cn & 16785408) === 16785408) &&
              (v_(), zc(h), (h = Eg()), h !== null)
            ) {
              (c.cancelPendingCommit = h(
                mh.bind(null, c, y, S, R, ee, _e, Le, 1, Ot, bt)
              )),
                Fa(c, L, ee, !ut);
              return;
            }
            mh(c, y, S, R, ee, _e, Le, Et, Ot, bt);
          }
          function no(c) {
            for (var h = c; ; ) {
              var y = h.tag;
              if (
                (y === 0 || y === 11 || y === 15) &&
                h.flags & 16384 &&
                ((y = h.updateQueue),
                y !== null && ((y = y.stores), y !== null))
              )
                for (var S = 0; S < y.length; S++) {
                  var R = y[S],
                    L = R.getSnapshot;
                  R = R.value;
                  try {
                    if (!Ga(L(), R)) return !1;
                  } catch {
                    return !1;
                  }
                }
              if (((y = h.child), h.subtreeFlags & 16384 && y !== null))
                (y.return = h), (h = y);
              else {
                if (h === c) break;
                for (; h.sibling === null; ) {
                  if (h.return === null || h.return === c) return !0;
                  h = h.return;
                }
                (h.sibling.return = h.return), (h = h.sibling);
              }
            }
            return !0;
          }
          function Fa(c, h, y, S) {
            (h &= ~ka),
              (h &= ~So),
              (c.suspendedLanes |= h),
              (c.pingedLanes &= ~h),
              S && (c.warmLanes |= h),
              (S = c.expirationTimes);
            for (var R = h; 0 < R; ) {
              var L = 31 - Ii(R),
                ee = 1 << L;
              (S[L] = -1), (R &= ~ee);
            }
            y !== 0 && q(c, y, h);
          }
          function rp() {
            return (Rn & 6) === 0 ? (X(0), !1) : !0;
          }
          function Yc() {
            if (Sn !== null) {
              if ($n === 0) var c = Sn.return;
              else
                (c = Sn),
                  (Hr = vl = null),
                  yt(c),
                  ($l = null),
                  (Ba = 0),
                  (c = Sn);
              for (; c !== null; ) hg(c.alternate, c), (c = c.return);
              Sn = null;
            }
          }
          function qo(c, h) {
            (c.finishedWork = null), (c.finishedLanes = 0);
            var y = c.timeoutHandle;
            y !== zu && ((c.timeoutHandle = zu), ef(y)),
              (y = c.cancelPendingCommit),
              y !== null && ((c.cancelPendingCommit = null), y()),
              Yc(),
              (ni = c),
              (Sn = y = ao(c.current, null)),
              (wn = h),
              ($n = 0),
              (ji = null),
              (Vr = !1),
              (kr = N(c, h)),
              (nu = !1),
              (Ki = Mr = ka = So = Xr = Si = 0),
              (Yr = Qu = null),
              (Gh = !1),
              (h & 8) !== 0 && (h |= h & 32);
            var S = c.entangledLanes;
            if (S !== 0)
              for (c = c.entanglements, S &= h; 0 < S; ) {
                var R = 31 - Ii(S),
                  L = 1 << R;
                (h |= c[R]), (S &= ~L);
              }
            return (hs = h), $(), y;
          }
          function Ea(c, h) {
            (ln = null),
              (nn.H = zi),
              h === of
                ? ((h = Ct()), ($n = 3))
                : h === lf
                ? ((h = Ct()), ($n = 4))
                : ($n =
                    h === Np
                      ? 8
                      : h !== null &&
                        typeof h == "object" &&
                        typeof h.then == "function"
                      ? 6
                      : 1),
              (ji = h),
              Sn === null && ((Si = 1), Dr(c, me(h, c.current)));
          }
          function la() {
            var c = sr.current;
            return c === null
              ? !0
              : (wn & 4194176) === wn
              ? Gr === null
              : (wn & 62914560) === wn || (wn & 536870912) !== 0
              ? c === Gr
              : !1;
          }
          function Fn() {
            var c = nn.H;
            return (nn.H = zi), c === null ? zi : c;
          }
          function Nr() {
            var c = nn.A;
            return (nn.A = xo), c;
          }
          function Ir() {
            (Si = 4),
              Vr || ((wn & 4194176) !== wn && sr.current !== null) || (kr = !0),
              ((Xr & 134217727) === 0 && (So & 134217727) === 0) ||
                ni === null ||
                Fa(ni, wn, Mr, !1);
          }
          function Wc(c, h, y) {
            var S = Rn;
            Rn |= 2;
            var R = Fn(),
              L = Nr();
            (ni !== c || wn !== h) && ((iu = null), qo(c, h)), (h = !1);
            var ee = Si;
            e: do
              try {
                if ($n !== 0 && Sn !== null) {
                  var _e = Sn,
                    Le = ji;
                  switch ($n) {
                    case 8:
                      Yc(), (ee = 6);
                      break e;
                    case 3:
                    case 2:
                    case 6:
                      sr.current === null && (h = !0);
                      var ut = $n;
                      if ((($n = 0), (ji = null), xs(c, _e, Le, ut), y && kr)) {
                        ee = 0;
                        break e;
                      }
                      break;
                    default:
                      (ut = $n), ($n = 0), (ji = null), xs(c, _e, Le, ut);
                  }
                }
                Vl(), (ee = Si);
                break;
              } catch (Et) {
                Ea(c, Et);
              }
            while (!0);
            return (
              h && c.shellSuspendCounter++,
              (Hr = vl = null),
              (Rn = S),
              (nn.H = R),
              (nn.A = L),
              Sn === null && ((ni = null), (wn = 0), $()),
              ee
            );
          }
          function Vl() {
            for (; Sn !== null; ) Ou(Sn);
          }
          function pg(c, h) {
            var y = Rn;
            Rn |= 2;
            var S = Fn(),
              R = Nr();
            ni !== c || wn !== h
              ? ((iu = null), (br = Ar() + 500), qo(c, h))
              : (kr = N(c, h));
            e: do
              try {
                if ($n !== 0 && Sn !== null) {
                  h = Sn;
                  var L = ji;
                  t: switch ($n) {
                    case 1:
                      ($n = 0), (ji = null), xs(c, h, L, 1);
                      break;
                    case 2:
                      if (Qe(L)) {
                        ($n = 0), (ji = null), Lu(h);
                        break;
                      }
                      (h = function () {
                        $n === 2 && ni === c && ($n = 7), Ve(c);
                      }),
                        L.then(h, h);
                      break e;
                    case 3:
                      $n = 7;
                      break e;
                    case 4:
                      $n = 5;
                      break e;
                    case 7:
                      Qe(L)
                        ? (($n = 0), (ji = null), Lu(h))
                        : (($n = 0), (ji = null), xs(c, h, L, 7));
                      break;
                    case 5:
                      var ee = null;
                      switch (Sn.tag) {
                        case 26:
                          ee = Sn.memoizedState;
                        case 5:
                        case 27:
                          var _e = Sn,
                            Le = _e.type,
                            ut = _e.pendingProps;
                          if (ee ? wp(ee) : dp(Le, ut)) {
                            ($n = 0), (ji = null);
                            var Et = _e.sibling;
                            if (Et !== null) Sn = Et;
                            else {
                              var Ot = _e.return;
                              Ot !== null ? ((Sn = Ot), jo(Ot)) : (Sn = null);
                            }
                            break t;
                          }
                      }
                      ($n = 0), (ji = null), xs(c, h, L, 5);
                      break;
                    case 6:
                      ($n = 0), (ji = null), xs(c, h, L, 6);
                      break;
                    case 8:
                      Yc(), (Si = 6);
                      break e;
                    default:
                      throw Error(i(462));
                  }
                }
                mg();
                break;
              } catch (bt) {
                Ea(c, bt);
              }
            while (!0);
            return (
              (Hr = vl = null),
              (nn.H = S),
              (nn.A = R),
              (Rn = y),
              Sn !== null ? 0 : ((ni = null), (wn = 0), $(), Si)
            );
          }
          function mg() {
            for (; Sn !== null && !ul(); ) Ou(Sn);
          }
          function Ou(c) {
            var h = ug(c.alternate, c, hs);
            (c.memoizedProps = c.pendingProps), h === null ? jo(c) : (Sn = h);
          }
          function Lu(c) {
            var h = c,
              y = h.alternate;
            switch (h.tag) {
              case 15:
              case 0:
                h = Bc(y, h, h.pendingProps, h.type, void 0, wn);
                break;
              case 11:
                h = Bc(y, h, h.pendingProps, h.type.render, h.ref, wn);
                break;
              case 5:
                yt(h);
              default:
                hg(y, h), (h = Sn = kl(h, hs)), (h = ug(y, h, hs));
            }
            (c.memoizedProps = c.pendingProps), h === null ? jo(c) : (Sn = h);
          }
          function xs(c, h, y, S) {
            (Hr = vl = null), yt(h), ($l = null), (Ba = 0);
            var R = h.return;
            try {
              if (Vd(c, R, h, y, wn)) {
                (Si = 1), Dr(c, me(y, c.current)), (Sn = null);
                return;
              }
            } catch (L) {
              if (R !== null) throw ((Sn = R), L);
              (Si = 1), Dr(c, me(y, c.current)), (Sn = null);
              return;
            }
            h.flags & 32768
              ? (Pn || S === 1
                  ? (c = !0)
                  : kr || (wn & 536870912) !== 0
                  ? (c = !1)
                  : ((Vr = c = !0),
                    (S === 2 || S === 3 || S === 6) &&
                      ((S = sr.current),
                      S !== null && S.tag === 13 && (S.flags |= 16384))),
                sp(h, c))
              : jo(h);
          }
          function jo(c) {
            var h = c;
            do {
              if ((h.flags & 32768) !== 0) {
                sp(h, Vr);
                return;
              }
              c = h.return;
              var y = fg(h.alternate, h, hs);
              if (y !== null) {
                Sn = y;
                return;
              }
              if (((h = h.sibling), h !== null)) {
                Sn = h;
                return;
              }
              Sn = h = c;
            } while (h !== null);
            Si === 0 && (Si = 5);
          }
          function sp(c, h) {
            do {
              var y = h_(c.alternate, c);
              if (y !== null) {
                (y.flags &= 32767), (Sn = y);
                return;
              }
              if (
                ((y = c.return),
                y !== null &&
                  ((y.flags |= 32768),
                  (y.subtreeFlags = 0),
                  (y.deletions = null)),
                !h && ((c = c.sibling), c !== null))
              ) {
                Sn = c;
                return;
              }
              Sn = c = y;
            } while (c !== null);
            (Si = 6), (Sn = null);
          }
          function mh(c, h, y, S, R, L, ee, _e, Le, ut) {
            var Et = nn.T,
              Ot = sl();
            try {
              Pa(2), (nn.T = null), gg(c, h, y, S, Ot, R, L, ee, _e, Le, ut);
            } finally {
              (nn.T = Et), Pa(Ot);
            }
          }
          function gg(c, h, y, S, R, L, ee, _e) {
            do Ko();
            while (_l !== null);
            if ((Rn & 6) !== 0) throw Error(i(327));
            var Le = c.finishedWork;
            if (((S = c.finishedLanes), Le === null)) return null;
            if (
              ((c.finishedWork = null), (c.finishedLanes = 0), Le === c.current)
            )
              throw Error(i(177));
            (c.callbackNode = null),
              (c.callbackPriority = 0),
              (c.cancelPendingCommit = null);
            var ut = Le.lanes | Le.childLanes;
            if (
              ((ut |= ls),
              J(c, S, ut, L, ee, _e),
              c === ni && ((Sn = ni = null), (wn = 0)),
              ((Le.subtreeFlags & 10256) === 0 && (Le.flags & 10256) === 0) ||
                Mo ||
                ((Mo = !0),
                (zh = ut),
                (hf = y),
                vg(Xu, function () {
                  return Ko(), null;
                })),
              (y = (Le.flags & 15990) !== 0),
              (Le.subtreeFlags & 15990) !== 0 || y
                ? ((y = nn.T),
                  (nn.T = null),
                  (L = sl()),
                  Pa(2),
                  (ee = Rn),
                  (Rn |= 4),
                  tp(c, Le),
                  ip(Le, c),
                  g_(c.containerInfo),
                  (c.current = Le),
                  Du(c, Le.alternate, Le),
                  ho(),
                  (Rn = ee),
                  Pa(L),
                  (nn.T = y))
                : (c.current = Le),
              Mo ? ((Mo = !1), (_l = c), ($u = S)) : Jc(c, ut),
              (ut = c.pendingLanes),
              ut === 0 && (Os = null),
              K(Le.stateNode),
              Ve(c),
              h !== null)
            )
              for (R = c.onRecoverableError, Le = 0; Le < h.length; Le++)
                (ut = h[Le]), R(ut.value, { componentStack: ut.stack });
            return (
              ($u & 3) !== 0 && Ko(),
              (ut = c.pendingLanes),
              (S & 4194218) !== 0 && (ut & 42) !== 0
                ? c === Pp
                  ? au++
                  : ((au = 0), (Pp = c))
                : (au = 0),
              X(0),
              null
            );
          }
          function Jc(c, h) {
            (c.pooledCacheLanes &= h) === 0 &&
              ((h = c.pooledCache),
              h != null && ((c.pooledCache = null), Ic(h)));
          }
          function Ko() {
            if (_l !== null) {
              var c = _l,
                h = zh;
              zh = 0;
              var y = ue($u),
                S = 32 > y ? 32 : y;
              y = nn.T;
              var R = sl();
              try {
                if ((Pa(S), (nn.T = null), _l === null)) var L = !1;
                else {
                  (S = hf), (hf = null);
                  var ee = _l,
                    _e = $u;
                  if (((_l = null), ($u = 0), (Rn & 6) !== 0))
                    throw Error(i(331));
                  var Le = Rn;
                  if (
                    ((Rn |= 4),
                    eo(ee.current),
                    Lr(ee, ee.current, _e, S),
                    (Rn = Le),
                    X(0, !1),
                    Ji && typeof Ji.onPostCommitFiberRoot == "function")
                  )
                    try {
                      Ji.onPostCommitFiberRoot(Yu, ee);
                    } catch {}
                  L = !0;
                }
                return L;
              } finally {
                Pa(R), (nn.T = y), Jc(c, h);
              }
            }
            return !1;
          }
          function Nu(c, h, y) {
            (h = me(y, h)),
              (h = Ur(c.stateNode, h, 2)),
              (c = nt(c, h, 2)),
              c !== null && (W(c, 2), Ve(c));
          }
          function qn(c, h, y) {
            if (c.tag === 3) Nu(c, c, y);
            else
              for (; h !== null; ) {
                if (h.tag === 3) {
                  Nu(h, c, y);
                  break;
                } else if (h.tag === 1) {
                  var S = h.stateNode;
                  if (
                    typeof h.type.getDerivedStateFromError == "function" ||
                    (typeof S.componentDidCatch == "function" &&
                      (Os === null || !Os.has(S)))
                  ) {
                    (c = me(y, c)),
                      (y = Nl(2)),
                      (S = nt(h, y, 2)),
                      S !== null && (Ma(y, S, h, c), W(S, 2), Ve(S));
                    break;
                  }
                }
                h = h.return;
              }
          }
          function Zo(c, h, y) {
            var S = c.pingCache;
            if (S === null) {
              S = c.pingCache = new ff();
              var R = new Set();
              S.set(h, R);
            } else
              (R = S.get(h)), R === void 0 && ((R = new Set()), S.set(h, R));
            R.has(y) ||
              ((nu = !0), R.add(y), (c = qc.bind(null, c, h, y)), h.then(c, c));
          }
          function qc(c, h, y) {
            var S = c.pingCache;
            S !== null && S.delete(h),
              (c.pingedLanes |= c.suspendedLanes & y),
              (c.warmLanes &= ~y),
              ni === c &&
                (wn & y) === y &&
                (Si === 4 ||
                (Si === 3 && (wn & 62914560) === wn && 300 > Ar() - Fp)
                  ? (Rn & 2) === 0 && qo(c, 0)
                  : (ka |= y),
                Ki === wn && (Ki = 0)),
              Ve(c);
          }
          function jc(c, h) {
            h === 0 && (h = O()),
              (c = rt(c, h)),
              c !== null && (W(c, h), Ve(c));
          }
          function Kc(c) {
            var h = c.memoizedState,
              y = 0;
            h !== null && (y = h.retryLane), jc(c, y);
          }
          function gh(c, h) {
            var y = 0;
            switch (c.tag) {
              case 13:
                var S = c.stateNode,
                  R = c.memoizedState;
                R !== null && (y = R.retryLane);
                break;
              case 19:
                S = c.stateNode;
                break;
              case 22:
                S = c.stateNode._retryCache;
                break;
              default:
                throw Error(i(314));
            }
            S !== null && S.delete(h), jc(c, y);
          }
          function vg(c, h) {
            return Cs(c, h);
          }
          function yg(c, h, y, S) {
            (this.tag = c),
              (this.key = y),
              (this.sibling =
                this.child =
                this.return =
                this.stateNode =
                this.type =
                this.elementType =
                  null),
              (this.index = 0),
              (this.refCleanup = this.ref = null),
              (this.pendingProps = h),
              (this.dependencies =
                this.memoizedState =
                this.updateQueue =
                this.memoizedProps =
                  null),
              (this.mode = S),
              (this.subtreeFlags = this.flags = 0),
              (this.deletions = null),
              (this.childLanes = this.lanes = 0),
              (this.alternate = null);
          }
          function io(c) {
            return (c = c.prototype), !(!c || !c.isReactComponent);
          }
          function ao(c, h) {
            var y = c.alternate;
            return (
              y === null
                ? ((y = t(c.tag, h, c.key, c.mode)),
                  (y.elementType = c.elementType),
                  (y.type = c.type),
                  (y.stateNode = c.stateNode),
                  (y.alternate = c),
                  (c.alternate = y))
                : ((y.pendingProps = h),
                  (y.type = c.type),
                  (y.flags = 0),
                  (y.subtreeFlags = 0),
                  (y.deletions = null)),
              (y.flags = c.flags & 31457280),
              (y.childLanes = c.childLanes),
              (y.lanes = c.lanes),
              (y.child = c.child),
              (y.memoizedProps = c.memoizedProps),
              (y.memoizedState = c.memoizedState),
              (y.updateQueue = c.updateQueue),
              (h = c.dependencies),
              (y.dependencies =
                h === null
                  ? null
                  : { lanes: h.lanes, firstContext: h.firstContext }),
              (y.sibling = c.sibling),
              (y.index = c.index),
              (y.ref = c.ref),
              (y.refCleanup = c.refCleanup),
              y
            );
          }
          function kl(c, h) {
            c.flags &= 31457282;
            var y = c.alternate;
            return (
              y === null
                ? ((c.childLanes = 0),
                  (c.lanes = h),
                  (c.child = null),
                  (c.subtreeFlags = 0),
                  (c.memoizedProps = null),
                  (c.memoizedState = null),
                  (c.updateQueue = null),
                  (c.dependencies = null),
                  (c.stateNode = null))
                : ((c.childLanes = y.childLanes),
                  (c.lanes = y.lanes),
                  (c.child = y.child),
                  (c.subtreeFlags = 0),
                  (c.deletions = null),
                  (c.memoizedProps = y.memoizedProps),
                  (c.memoizedState = y.memoizedState),
                  (c.updateQueue = y.updateQueue),
                  (c.type = y.type),
                  (h = y.dependencies),
                  (c.dependencies =
                    h === null
                      ? null
                      : { lanes: h.lanes, firstContext: h.firstContext })),
              c
            );
          }
          function Xl(c, h, y, S, R, L) {
            var ee = 0;
            if (((S = c), typeof c == "function")) io(c) && (ee = 1);
            else if (typeof c == "string")
              ee =
                _r && ua
                  ? ta(c, y, Fi.current)
                    ? 26
                    : Bh(c)
                    ? 27
                    : 5
                  : _r
                  ? ta(c, y, Fi.current)
                    ? 26
                    : 5
                  : ua && Bh(c)
                  ? 27
                  : 5;
            else
              e: switch (c) {
                case el:
                  return Qo(y.children, R, L, h);
                case Yl:
                  (ee = 8), (R |= 24);
                  break;
                case tl:
                  return (
                    (c = t(12, y, h, R | 2)),
                    (c.elementType = tl),
                    (c.lanes = L),
                    c
                  );
                case oo:
                  return (
                    (c = t(13, y, h, R)), (c.elementType = oo), (c.lanes = L), c
                  );
                case Qc:
                  return (
                    (c = t(19, y, h, R)), (c.elementType = Qc), (c.lanes = L), c
                  );
                case uo:
                  return vh(y, R, L, h);
                default:
                  if (typeof c == "object" && c !== null)
                    switch (c.$$typeof) {
                      case p_:
                      case nl:
                        ee = 10;
                        break e;
                      case up:
                        ee = 9;
                        break e;
                      case yh:
                        ee = 11;
                        break e;
                      case Fu:
                        ee = 14;
                        break e;
                      case lo:
                        (ee = 16), (S = null);
                        break e;
                    }
                  (ee = 29),
                    (y = Error(i(130, c === null ? "null" : typeof c, ""))),
                    (S = null);
              }
            return (
              (h = t(ee, y, h, R)),
              (h.elementType = c),
              (h.type = S),
              (h.lanes = L),
              h
            );
          }
          function Qo(c, h, y, S) {
            return (c = t(7, c, S, h)), (c.lanes = y), c;
          }
          function vh(c, h, y, S) {
            (c = t(22, c, S, h)), (c.elementType = uo), (c.lanes = y);
            var R = {
              _visibility: 1,
              _pendingVisibility: 1,
              _pendingMarkers: null,
              _retryCache: null,
              _transitions: null,
              _current: null,
              detach: function () {
                var L = R._current;
                if (L === null) throw Error(i(456));
                if ((R._pendingVisibility & 2) === 0) {
                  var ee = rt(L, 2);
                  ee !== null && ((R._pendingVisibility |= 2), ci(ee, L, 2));
                }
              },
              attach: function () {
                var L = R._current;
                if (L === null) throw Error(i(456));
                if ((R._pendingVisibility & 2) !== 0) {
                  var ee = rt(L, 2);
                  ee !== null && ((R._pendingVisibility &= -3), ci(ee, L, 2));
                }
              },
            };
            return (c.stateNode = R), c;
          }
          function Zc(c, h, y) {
            return (c = t(6, c, null, h)), (c.lanes = y), c;
          }
          function nr(c, h, y) {
            return (
              (h = t(4, c.children !== null ? c.children : [], c.key, h)),
              (h.lanes = y),
              (h.stateNode = {
                containerInfo: c.containerInfo,
                pendingChildren: null,
                implementation: c.implementation,
              }),
              h
            );
          }
          function Ss(c, h, y, S, R, L, ee, _e) {
            (this.tag = 1),
              (this.containerInfo = c),
              (this.finishedWork =
                this.pingCache =
                this.current =
                this.pendingChildren =
                  null),
              (this.timeoutHandle = zu),
              (this.callbackNode =
                this.next =
                this.pendingContext =
                this.context =
                this.cancelPendingCommit =
                  null),
              (this.callbackPriority = 0),
              (this.expirationTimes = U(-1)),
              (this.entangledLanes =
                this.shellSuspendCounter =
                this.errorRecoveryDisabledLanes =
                this.finishedLanes =
                this.expiredLanes =
                this.warmLanes =
                this.pingedLanes =
                this.suspendedLanes =
                this.pendingLanes =
                  0),
              (this.entanglements = U(0)),
              (this.hiddenUpdates = U(null)),
              (this.identifierPrefix = S),
              (this.onUncaughtError = R),
              (this.onCaughtError = L),
              (this.onRecoverableError = ee),
              (this.pooledCache = null),
              (this.pooledCacheLanes = 0),
              (this.formState = _e),
              (this.incompleteTransitions = new Map());
          }
          function ro(c, h, y, S, R, L, ee, _e, Le, ut, Et, Ot) {
            return (
              (c = new Ss(c, h, y, ee, _e, Le, ut, Ot)),
              (h = 1),
              L === !0 && (h |= 24),
              (L = t(3, null, null, h)),
              (c.current = L),
              (L.stateNode = c),
              (h = ko()),
              h.refCount++,
              (c.pooledCache = h),
              h.refCount++,
              (L.memoizedState = { element: S, isDehydrated: y, cache: h }),
              et(L),
              c
            );
          }
          function op(c) {
            return c ? ((c = Zl), c) : Zl;
          }
          function so(c) {
            var h = c._reactInternals;
            if (h === void 0)
              throw typeof c.render == "function"
                ? Error(i(188))
                : ((c = Object.keys(c).join(",")), Error(i(268, c)));
            return (
              (c = A(h)),
              (c = c !== null ? M(c) : null),
              c === null ? null : Wl(c.stateNode)
            );
          }
          function Ms(c, h, y, S, R, L) {
            (R = op(R)),
              S.context === null ? (S.context = R) : (S.pendingContext = R),
              (S = mt(h)),
              (S.payload = { element: y }),
              (L = L === void 0 ? null : L),
              L !== null && (S.callback = L),
              (y = nt(c, S, h)),
              y !== null && (ci(y, c, h), Ze(y, c, h));
          }
          function Yi(c, h) {
            if (((c = c.memoizedState), c !== null && c.dehydrated !== null)) {
              var y = c.retryLane;
              c.retryLane = y !== 0 && y < h ? y : h;
            }
          }
          function Iu(c, h) {
            Yi(c, h), (c = c.alternate) && Yi(c, h);
          }
          var Cn = {},
            d_ = Ud(),
            yr = HA(),
            Li = Object.assign,
            lp = Symbol.for("react.element"),
            $o = Symbol.for("react.transitional.element"),
            bs = Symbol.for("react.portal"),
            el = Symbol.for("react.fragment"),
            Yl = Symbol.for("react.strict_mode"),
            tl = Symbol.for("react.profiler"),
            p_ = Symbol.for("react.provider"),
            up = Symbol.for("react.consumer"),
            nl = Symbol.for("react.context"),
            yh = Symbol.for("react.forward_ref"),
            oo = Symbol.for("react.suspense"),
            Qc = Symbol.for("react.suspense_list"),
            Fu = Symbol.for("react.memo"),
            lo = Symbol.for("react.lazy"),
            uo = Symbol.for("react.offscreen"),
            xn = Symbol.for("react.memo_cache_sentinel"),
            Qn = Symbol.iterator,
            Wi = Symbol.for("react.client.reference"),
            nn =
              d_.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
            il,
            al,
            Pu = !1,
            rl = Array.isArray,
            Gu = e.rendererVersion,
            m_ = e.rendererPackageName,
            Ci = e.extraDevToolsConfig,
            Wl = e.getPublicInstance,
            cp = e.getRootHostContext,
            _g = e.getChildHostContext,
            Ag = e.prepareForCommit,
            g_ = e.resetAfterCommit,
            fp = e.createInstance,
            $c = e.appendInitialChild,
            _h = e.finalizeInitialChildren,
            ga = e.shouldSetTextContent,
            Ni = e.createTextInstance,
            Ah = e.scheduleTimeout,
            ef = e.cancelTimeout,
            zu = e.noTimeout,
            is = e.isPrimaryRenderer;
          e.warnsIfNotActing;
          var Ai = e.supportsMutation,
            as = e.supportsPersistence,
            ir = e.supportsHydration,
            xh = e.getInstanceFromNode;
          e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
          var xg = e.preparePortalMount;
          e.prepareScopeUpdate, e.getInstanceFromScope;
          var Pa = e.setCurrentUpdatePriority,
            sl = e.getCurrentUpdatePriority,
            Sg = e.resolveUpdatePriority;
          e.resolveEventType, e.resolveEventTimeStamp;
          var Mg = e.shouldAttemptEagerTransition,
            bg = e.detachDeletedInstance;
          e.requestPostPaintCallback;
          var hp = e.maySuspendCommit,
            dp = e.preloadInstance,
            v_ = e.startSuspendingCommit,
            pp = e.suspendInstance,
            Eg = e.waitForCommitToBeReady,
            Jl = e.NotPendingTransition,
            co = e.HostTransitionContext,
            Tg = e.resetFormInstance;
          e.bindToConsole;
          var Cg = e.supportsMicrotasks,
            Rg = e.scheduleMicrotask,
            Hu = e.supportsTestSelectors,
            wg = e.findFiberRoot,
            y_ = e.getBoundingRect,
            Bg = e.getTextContent,
            Es = e.isHiddenSubtree,
            Dg = e.matchAccessibilityRole,
            Sh = e.setFocusIfFocusable,
            Mh = e.setupIntersectionObserver,
            Ug = e.appendChild,
            mp = e.appendChildToContainer,
            Og = e.commitTextUpdate,
            Lg = e.commitMount,
            Ng = e.commitUpdate,
            Ig = e.insertBefore,
            gp = e.insertInContainerBefore,
            Fg = e.removeChild,
            Pg = e.removeChildFromContainer,
            bh = e.resetTextContent,
            Gg = e.hideInstance,
            zg = e.hideTextInstance,
            __ = e.unhideInstance,
            vp = e.unhideTextInstance,
            Hg = e.clearContainer,
            Vg = e.cloneInstance,
            Eh = e.createContainerChildSet,
            yp = e.appendChildToContainerChildSet,
            kg = e.finalizeContainerChildren,
            Xg = e.replaceContainerChildren,
            Yg = e.cloneHiddenInstance,
            _p = e.cloneHiddenTextInstance,
            ql = e.isSuspenseInstancePending,
            tf = e.isSuspenseInstanceFallback,
            Th = e.getSuspenseInstanceFallbackErrorDetails,
            Wg = e.registerSuspenseInstanceRetry,
            Jg = e.canHydrateFormStateMarker,
            Ts = e.isFormStateMarkerMatching,
            ol = e.getNextHydratableSibling,
            fo = e.getFirstHydratableChild,
            jl = e.getFirstHydratableChildWithinContainer,
            Ap = e.getFirstHydratableChildWithinSuspenseInstance,
            xp = e.canHydrateInstance,
            qg = e.canHydrateTextInstance,
            jg = e.canHydrateSuspenseInstance,
            Kl = e.hydrateInstance,
            Ch = e.hydrateTextInstance,
            Kg = e.hydrateSuspenseInstance,
            Zg = e.getNextHydratableInstanceAfterSuspenseInstance,
            Qg = e.commitHydratedContainer,
            Rh = e.commitHydratedSuspenseInstance,
            $g = e.clearSuspenseBoundary,
            Sp = e.clearSuspenseBoundaryFromContainer,
            Mp = e.shouldDeleteUnhydratedTailInstances;
          e.diffHydratedPropsForDevWarnings,
            e.diffHydratedTextForDevWarnings,
            e.describeHydratableInstanceForDevWarnings;
          var ev = e.validateHydratableInstance,
            A_ = e.validateHydratableTextInstance,
            _r = e.supportsResources,
            ta = e.isHostHoistableType,
            na = e.getHoistableRoot,
            bp = e.getResource,
            Ep = e.acquireResource,
            Tp = e.releaseResource,
            tv = e.hydrateHoistable,
            Cp = e.mountHoistable,
            Vu = e.unmountHoistable,
            Rp = e.createHoistableInstance,
            nv = e.prepareToCommitHoistables,
            iv = e.mayResourceSuspendCommit,
            wp = e.preloadResource,
            Bp = e.suspendResource,
            ua = e.supportsSingletons,
            wh = e.resolveSingletonInstance,
            av = e.clearSingleton,
            Dp = e.acquireSingletonInstance,
            Up = e.releaseSingletonInstance,
            Bh = e.isHostSingletonType,
            Dh = [],
            ll = -1,
            Zl = {},
            Ii = Math.clz32 ? Math.clz32 : D,
            Op = Math.log,
            x_ = Math.LN2,
            nf = 128,
            ku = 4194304,
            Cs = yr.unstable_scheduleCallback,
            rs = yr.unstable_cancelCallback,
            ul = yr.unstable_shouldYield,
            ho = yr.unstable_requestPaint,
            Ar = yr.unstable_now,
            Uh = yr.unstable_ImmediatePriority,
            af = yr.unstable_UserBlockingPriority,
            Xu = yr.unstable_NormalPriority,
            Ql = yr.unstable_IdlePriority,
            Ta = yr.log,
            Oh = yr.unstable_setDisableYieldValue,
            Yu = null,
            Ji = null,
            Ga = typeof Object.is == "function" ? Object.is : oe,
            Lh = new WeakMap(),
            xr = [],
            Sr = 0,
            cl = null,
            Wu = 0,
            ar = [],
            Ca = 0,
            ss = null,
            Rs = 1,
            ws = "",
            Fi = E(null),
            Fr = E(null),
            po = E(null),
            rf = E(null),
            Pi = null,
            ei = null,
            Pn = !1,
            Pr = null,
            os = !1,
            sf = Error(i(519)),
            rr = [],
            mo = 0,
            ls = 0,
            mi = null,
            fl = null,
            Nh = !1,
            Gi = !1,
            Ih = !1,
            Ju = 0,
            qu = null,
            Fh = 0,
            gi = 0,
            ca = null,
            Ra = !1,
            Ph = !1,
            rv = Object.prototype.hasOwnProperty,
            of = Error(i(460)),
            lf = Error(i(474)),
            za = { then: function () {} },
            wa = null,
            $l = null,
            Ba = 0,
            hl = vn(!0),
            Bs = vn(!1),
            us = E(null),
            cs = E(0),
            sr = E(null),
            Gr = null,
            fi = E(0),
            go = 0,
            ln = null,
            Vn = null,
            xi = null,
            vo = !1,
            eu = !1,
            dl = !1,
            pl = 0,
            ju = 0,
            yo = null,
            sv = 0,
            Lp = function () {
              return {
                lastEffect: null,
                events: null,
                stores: null,
                memoCache: null,
              };
            },
            zi = {
              readContext: pa,
              use: ne,
              useCallback: en,
              useContext: en,
              useEffect: en,
              useImperativeHandle: en,
              useLayoutEffect: en,
              useInsertionEffect: en,
              useMemo: en,
              useReducer: en,
              useRef: en,
              useState: en,
              useDebugValue: en,
              useDeferredValue: en,
              useTransition: en,
              useSyncExternalStore: en,
              useId: en,
            };
          (zi.useCacheRefresh = en),
            (zi.useMemoCache = en),
            (zi.useHostTransitionStatus = en),
            (zi.useFormState = en),
            (zi.useActionState = en),
            (zi.useOptimistic = en);
          var _o = {
            readContext: pa,
            use: ne,
            useCallback: function (c, h) {
              return (z().memoizedState = [c, h === void 0 ? null : h]), c;
            },
            useContext: pa,
            useEffect: Dl,
            useImperativeHandle: function (c, h, y) {
              (y = y != null ? y.concat([c]) : null),
                Bl(4194308, 4, wr.bind(null, h, c), y);
            },
            useLayoutEffect: function (c, h) {
              return Bl(4194308, 4, c, h);
            },
            useInsertionEffect: function (c, h) {
              Bl(4, 2, c, h);
            },
            useMemo: function (c, h) {
              var y = z();
              h = h === void 0 ? null : h;
              var S = c();
              if (dl) {
                ge(!0);
                try {
                  c();
                } finally {
                  ge(!1);
                }
              }
              return (y.memoizedState = [S, h]), S;
            },
            useReducer: function (c, h, y) {
              var S = z();
              if (y !== void 0) {
                var R = y(h);
                if (dl) {
                  ge(!0);
                  try {
                    y(h);
                  } finally {
                    ge(!1);
                  }
                }
              } else R = h;
              return (
                (S.memoizedState = S.baseState = R),
                (c = {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: c,
                  lastRenderedState: R,
                }),
                (S.queue = c),
                (c = c.dispatch = Ll.bind(null, ln, c)),
                [S.memoizedState, c]
              );
            },
            useRef: function (c) {
              var h = z();
              return (c = { current: c }), (h.memoizedState = c);
            },
            useState: function (c) {
              c = Vt(c);
              var h = c.queue,
                y = Tu.bind(null, ln, h);
              return (h.dispatch = y), [c.memoizedState, y];
            },
            useDebugValue: es,
            useDeferredValue: function (c, h) {
              var y = z();
              return Po(y, c, h);
            },
            useTransition: function () {
              var c = Vt(!1);
              return (
                (c = Eu.bind(null, ln, c.queue, !0, !1)),
                (z().memoizedState = c),
                [!1, c]
              );
            },
            useSyncExternalStore: function (c, h, y) {
              var S = ln,
                R = z();
              if (Pn) {
                if (y === void 0) throw Error(i(407));
                y = y();
              } else {
                if (((y = h()), ni === null)) throw Error(i(349));
                (wn & 60) !== 0 || Bt(S, h, y);
              }
              R.memoizedState = y;
              var L = { value: y, getSnapshot: h };
              return (
                (R.queue = L),
                Dl(jt.bind(null, S, L, c), [c]),
                (S.flags |= 2048),
                Sa(9, Rt.bind(null, S, L, y, h), { destroy: void 0 }, null),
                y
              );
            },
            useId: function () {
              var c = z(),
                h = ni.identifierPrefix;
              if (Pn) {
                var y = ws,
                  S = Rs;
                (y = (S & ~(1 << (32 - Ii(S) - 1))).toString(32) + y),
                  (h = ":" + h + "R" + y),
                  (y = pl++),
                  0 < y && (h += "H" + y.toString(32)),
                  (h += ":");
              } else (y = sv++), (h = ":" + h + "r" + y.toString(32) + ":");
              return (c.memoizedState = h);
            },
            useCacheRefresh: function () {
              return (z().memoizedState = Ol.bind(null, ln));
            },
          };
          (_o.useMemoCache = Se),
            (_o.useHostTransitionStatus = Vs),
            (_o.useFormState = on),
            (_o.useActionState = on),
            (_o.useOptimistic = function (c) {
              var h = z();
              h.memoizedState = h.baseState = c;
              var y = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null,
              };
              return (
                (h.queue = y),
                (h = Xs.bind(null, ln, !0, y)),
                (y.dispatch = h),
                [c, h]
              );
            });
          var Ha = {
            readContext: pa,
            use: ne,
            useCallback: ys,
            useContext: pa,
            useEffect: Qr,
            useImperativeHandle: $r,
            useInsertionEffect: Rc,
            useLayoutEffect: Ul,
            useMemo: pr,
            useReducer: Ye,
            useRef: ea,
            useState: function () {
              return Ye(Ne);
            },
            useDebugValue: es,
            useDeferredValue: function (c, h) {
              var y = re();
              return Go(y, Vn.memoizedState, c, h);
            },
            useTransition: function () {
              var c = Ye(Ne)[0],
                h = re().memoizedState;
              return [typeof c == "boolean" ? c : pe(c), h];
            },
            useSyncExternalStore: wt,
            useId: ks,
          };
          (Ha.useCacheRefresh = Ui),
            (Ha.useMemoCache = Se),
            (Ha.useHostTransitionStatus = Vs),
            (Ha.useFormState = Zn),
            (Ha.useActionState = Zn),
            (Ha.useOptimistic = function (c, h) {
              var y = re();
              return Gt(y, Vn, c, h);
            });
          var ml = {
            readContext: pa,
            use: ne,
            useCallback: ys,
            useContext: pa,
            useEffect: Qr,
            useImperativeHandle: $r,
            useInsertionEffect: Rc,
            useLayoutEffect: Ul,
            useMemo: pr,
            useReducer: pt,
            useRef: ea,
            useState: function () {
              return pt(Ne);
            },
            useDebugValue: es,
            useDeferredValue: function (c, h) {
              var y = re();
              return Vn === null ? Po(y, c, h) : Go(y, Vn.memoizedState, c, h);
            },
            useTransition: function () {
              var c = pt(Ne)[0],
                h = re().memoizedState;
              return [typeof c == "boolean" ? c : pe(c), h];
            },
            useSyncExternalStore: wt,
            useId: ks,
          };
          (ml.useCacheRefresh = Ui),
            (ml.useMemoCache = Se),
            (ml.useHostTransitionStatus = Vs),
            (ml.useFormState = Mi),
            (ml.useActionState = Mi),
            (ml.useOptimistic = function (c, h) {
              var y = re();
              return Vn !== null
                ? Gt(y, Vn, c, h)
                : ((y.baseState = c), [c, y.queue.dispatch]);
            });
          var Ku = {
              isMounted: function (c) {
                return (c = c._reactInternals) ? v(c) === c : !1;
              },
              enqueueSetState: function (c, h, y) {
                c = c._reactInternals;
                var S = ba(),
                  R = mt(S);
                (R.payload = h),
                  y != null && (R.callback = y),
                  (h = nt(c, R, S)),
                  h !== null && (ci(h, c, S), Ze(h, c, S));
              },
              enqueueReplaceState: function (c, h, y) {
                c = c._reactInternals;
                var S = ba(),
                  R = mt(S);
                (R.tag = 1),
                  (R.payload = h),
                  y != null && (R.callback = y),
                  (h = nt(c, R, S)),
                  h !== null && (ci(h, c, S), Ze(h, c, S));
              },
              enqueueForceUpdate: function (c, h) {
                c = c._reactInternals;
                var y = ba(),
                  S = mt(y);
                (S.tag = 2),
                  h != null && (S.callback = h),
                  (h = nt(c, S, y)),
                  h !== null && (ci(h, c, y), Ze(h, c, y));
              },
            },
            gl =
              typeof reportError == "function"
                ? reportError
                : function (c) {
                    if (
                      typeof window == "object" &&
                      typeof window.ErrorEvent == "function"
                    ) {
                      var h = new window.ErrorEvent("error", {
                        bubbles: !0,
                        cancelable: !0,
                        message:
                          typeof c == "object" &&
                          c !== null &&
                          typeof c.message == "string"
                            ? String(c.message)
                            : String(c),
                        error: c,
                      });
                      if (!window.dispatchEvent(h)) return;
                    } else if (
                      typeof process == "object" &&
                      typeof process.emit == "function"
                    ) {
                      process.emit("uncaughtException", c);
                      return;
                    }
                    console.error(c);
                  },
            Np = Error(i(461)),
            qi = !1,
            uf = { dehydrated: null, treeContext: null, retryLane: 0 },
            zr = E(null),
            vl = null,
            Hr = null,
            cf =
              typeof AbortController < "u"
                ? AbortController
                : function () {
                    var c = [],
                      h = (this.signal = {
                        aborted: !1,
                        addEventListener: function (y, S) {
                          c.push(S);
                        },
                      });
                    this.abort = function () {
                      (h.aborted = !0),
                        c.forEach(function (y) {
                          return y();
                        });
                    };
                  },
            bi = yr.unstable_scheduleCallback,
            S_ = yr.unstable_NormalPriority,
            Ri = {
              $$typeof: nl,
              Consumer: null,
              Provider: null,
              _currentValue: null,
              _currentValue2: null,
              _threadCount: 0,
            },
            Ip = nn.S;
          nn.S = function (c, h) {
            typeof h == "object" &&
              h !== null &&
              typeof h.then == "function" &&
              Ke(c, h),
              Ip !== null && Ip(c, h);
          };
          var tu = E(null),
            Ao = !1,
            un = !1,
            ti = !1,
            bn = typeof WeakSet == "function" ? WeakSet : Set,
            Zt = null,
            ri = !1,
            kn = null,
            Hi = !1,
            Da = null,
            yl = 8192,
            xo = {
              getCacheForType: function (c) {
                var h = pa(Ri),
                  y = h.data.get(c);
                return y === void 0 && ((y = c()), h.data.set(c, y)), y;
              },
            },
            vi = 0,
            fs = 1,
            Ds = 2,
            Zu = 3,
            Va = 4;
          if (typeof Symbol == "function" && Symbol.for) {
            var Us = Symbol.for;
            (vi = Us("selector.component")),
              (fs = Us("selector.has_pseudo_class")),
              (Ds = Us("selector.role")),
              (Zu = Us("selector.test_id")),
              (Va = Us("selector.text"));
          }
          var ff = typeof WeakMap == "function" ? WeakMap : Map,
            Rn = 0,
            ni = null,
            Sn = null,
            wn = 0,
            $n = 0,
            ji = null,
            Vr = !1,
            kr = !1,
            nu = !1,
            hs = 0,
            Si = 0,
            Xr = 0,
            So = 0,
            ka = 0,
            Mr = 0,
            Ki = 0,
            Qu = null,
            Yr = null,
            Gh = !1,
            Fp = 0,
            br = 1 / 0,
            iu = null,
            Os = null,
            Mo = !1,
            _l = null,
            $u = 0,
            zh = 0,
            hf = null,
            au = 0,
            Pp = null;
          return (
            (Cn.attemptContinuousHydration = function (c) {
              if (c.tag === 13) {
                var h = rt(c, 67108864);
                h !== null && ci(h, c, 67108864), Iu(c, 67108864);
              }
            }),
            (Cn.attemptHydrationAtCurrentPriority = function (c) {
              if (c.tag === 13) {
                var h = ba(),
                  y = rt(c, h);
                y !== null && ci(y, c, h), Iu(c, h);
              }
            }),
            (Cn.attemptSynchronousHydration = function (c) {
              switch (c.tag) {
                case 3:
                  if (
                    ((c = c.stateNode), c.current.memoizedState.isDehydrated)
                  ) {
                    var h = B(c.pendingLanes);
                    if (h !== 0) {
                      for (c.pendingLanes |= 2, c.entangledLanes |= 2; h; ) {
                        var y = 1 << (31 - Ii(h));
                        (c.entanglements[1] |= y), (h &= ~y);
                      }
                      Ve(c), (Rn & 6) === 0 && ((br = Ar() + 500), X(0));
                    }
                  }
                  break;
                case 13:
                  (h = rt(c, 2)), h !== null && ci(h, c, 2), rp(), Iu(c, 2);
              }
            }),
            (Cn.batchedUpdates = function (c, h) {
              return c(h);
            }),
            (Cn.createComponentSelector = function (c) {
              return { $$typeof: vi, value: c };
            }),
            (Cn.createContainer = function (c, h, y, S, R, L, ee, _e, Le, ut) {
              return ro(c, h, !1, null, y, S, L, ee, _e, Le, ut, null);
            }),
            (Cn.createHasPseudoClassSelector = function (c) {
              return { $$typeof: fs, value: c };
            }),
            (Cn.createHydrationContainer = function (
              c,
              h,
              y,
              S,
              R,
              L,
              ee,
              _e,
              Le,
              ut,
              Et,
              Ot,
              bt
            ) {
              return (
                (c = ro(y, S, !0, c, R, L, _e, Le, ut, Et, Ot, bt)),
                (c.context = op(null)),
                (y = c.current),
                (S = ba()),
                (R = mt(S)),
                (R.callback = h ?? null),
                nt(y, R, S),
                (c.current.lanes = S),
                W(c, S),
                Ve(c),
                c
              );
            }),
            (Cn.createPortal = function (c, h, y) {
              var S =
                3 < arguments.length && arguments[3] !== void 0
                  ? arguments[3]
                  : null;
              return {
                $$typeof: bs,
                key: S == null ? null : "" + S,
                children: c,
                containerInfo: h,
                implementation: y,
              };
            }),
            (Cn.createRoleSelector = function (c) {
              return { $$typeof: Ds, value: c };
            }),
            (Cn.createTestNameSelector = function (c) {
              return { $$typeof: Zu, value: c };
            }),
            (Cn.createTextSelector = function (c) {
              return { $$typeof: Va, value: c };
            }),
            (Cn.defaultOnCaughtError = function (c) {
              console.error(c);
            }),
            (Cn.defaultOnRecoverableError = function (c) {
              gl(c);
            }),
            (Cn.defaultOnUncaughtError = function (c) {
              gl(c);
            }),
            (Cn.deferredUpdates = function (c) {
              var h = nn.T,
                y = sl();
              try {
                return Pa(32), (nn.T = null), c();
              } finally {
                Pa(y), (nn.T = h);
              }
            }),
            (Cn.discreteUpdates = function (c, h, y, S, R) {
              var L = nn.T,
                ee = sl();
              try {
                return Pa(2), (nn.T = null), c(h, y, S, R);
              } finally {
                Pa(ee), (nn.T = L), Rn === 0 && (br = Ar() + 500);
              }
            }),
            (Cn.findAllNodes = Jo),
            (Cn.findBoundingRects = function (c, h) {
              if (!Hu) throw Error(i(363));
              (h = Jo(c, h)), (c = []);
              for (var y = 0; y < h.length; y++) c.push(y_(h[y]));
              for (h = c.length - 1; 0 < h; h--) {
                y = c[h];
                for (
                  var S = y.x,
                    R = S + y.width,
                    L = y.y,
                    ee = L + y.height,
                    _e = h - 1;
                  0 <= _e;
                  _e--
                )
                  if (h !== _e) {
                    var Le = c[_e],
                      ut = Le.x,
                      Et = ut + Le.width,
                      Ot = Le.y,
                      bt = Ot + Le.height;
                    if (S >= ut && L >= Ot && R <= Et && ee <= bt) {
                      c.splice(h, 1);
                      break;
                    } else if (
                      S !== ut ||
                      y.width !== Le.width ||
                      bt < L ||
                      Ot > ee
                    ) {
                      if (
                        !(
                          L !== Ot ||
                          y.height !== Le.height ||
                          Et < S ||
                          ut > R
                        )
                      ) {
                        ut > S && ((Le.width += ut - S), (Le.x = S)),
                          Et < R && (Le.width = R - ut),
                          c.splice(h, 1);
                        break;
                      }
                    } else {
                      Ot > L && ((Le.height += Ot - L), (Le.y = L)),
                        bt < ee && (Le.height = ee - Ot),
                        c.splice(h, 1);
                      break;
                    }
                  }
              }
              return c;
            }),
            (Cn.findHostInstance = so),
            (Cn.findHostInstanceWithNoPortals = function (c) {
              return (
                (c = A(c)),
                (c = c !== null ? T(c) : null),
                c === null ? null : Wl(c.stateNode)
              );
            }),
            (Cn.findHostInstanceWithWarning = function (c) {
              return so(c);
            }),
            (Cn.flushPassiveEffects = Ko),
            (Cn.flushSyncFromReconciler = function (c) {
              var h = Rn;
              Rn |= 1;
              var y = nn.T,
                S = sl();
              try {
                if ((Pa(2), (nn.T = null), c)) return c();
              } finally {
                Pa(S), (nn.T = y), (Rn = h), (Rn & 6) === 0 && X(0);
              }
            }),
            (Cn.flushSyncWork = rp),
            (Cn.focusWithin = function (c, h) {
              if (!Hu) throw Error(i(363));
              for (
                c = Wo(c), h = Hl(c, h), h = Array.from(h), c = 0;
                c < h.length;

              ) {
                var y = h[c++],
                  S = y.tag;
                if (!Es(y)) {
                  if ((S === 5 || S === 26 || S === 27) && Sh(y.stateNode))
                    return !0;
                  for (y = y.child; y !== null; ) h.push(y), (y = y.sibling);
                }
              }
              return !1;
            }),
            (Cn.getFindAllNodesFailureDescription = function (c, h) {
              if (!Hu) throw Error(i(363));
              var y = 0,
                S = [];
              c = [Wo(c), 0];
              for (var R = 0; R < c.length; ) {
                var L = c[R++],
                  ee = L.tag,
                  _e = c[R++],
                  Le = h[_e];
                if (
                  ((ee !== 5 && ee !== 26 && ee !== 27) || !Es(L)) &&
                  (ph(L, Le) && (S.push(tr(Le)), _e++, _e > y && (y = _e)),
                  _e < h.length)
                )
                  for (L = L.child; L !== null; )
                    c.push(L, _e), (L = L.sibling);
              }
              if (y < h.length) {
                for (c = []; y < h.length; y++) c.push(tr(h[y]));
                return (
                  `findAllNodes was able to match part of the selector:
  ` +
                  (S.join(" > ") +
                    `

No matching component was found for:
  `) +
                  c.join(" > ")
                );
              }
              return null;
            }),
            (Cn.getPublicRootInstance = function (c) {
              if (((c = c.current), !c.child)) return null;
              switch (c.child.tag) {
                case 27:
                case 5:
                  return Wl(c.child.stateNode);
                default:
                  return c.child.stateNode;
              }
            }),
            (Cn.injectIntoDevTools = function () {
              var c = {
                bundleType: 0,
                version: Gu,
                rendererPackageName: m_,
                currentDispatcherRef: nn,
                findFiberByHostInstance: xh,
                reconcilerVersion: "19.0.0",
              };
              if (
                (Ci !== null && (c.rendererConfig = Ci),
                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
              )
                c = !1;
              else {
                var h = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (h.isDisabled || !h.supportsFiber) c = !0;
                else {
                  try {
                    (Yu = h.inject(c)), (Ji = h);
                  } catch {}
                  c = !!h.checkDCE;
                }
              }
              return c;
            }),
            (Cn.isAlreadyRendering = function () {
              return !1;
            }),
            (Cn.observeVisibleRects = function (c, h, y, S) {
              if (!Hu) throw Error(i(363));
              c = Jo(c, h);
              var R = Mh(c, y, S).disconnect;
              return {
                disconnect: function () {
                  R();
                },
              };
            }),
            (Cn.shouldError = function () {
              return null;
            }),
            (Cn.shouldSuspend = function () {
              return !1;
            }),
            (Cn.startHostTransition = function (c, h, y, S) {
              if (c.tag !== 5) throw Error(i(476));
              var R = ts(c).queue;
              Eu(
                c,
                R,
                h,
                Jl,
                y === null
                  ? n
                  : function () {
                      var L = ts(c).next.queue;
                      return Br(c, L, {}, ba()), y(S);
                    }
              );
            }),
            (Cn.updateContainer = function (c, h, y, S) {
              var R = h.current,
                L = ba();
              return Ms(R, L, c, h, y, S), L;
            }),
            (Cn.updateContainerSync = function (c, h, y, S) {
              return h.tag === 0 && Ko(), Ms(h.current, 2, c, h, y, S), 2;
            }),
            Cn
          );
        }),
          (s.exports.default = s.exports),
          Object.defineProperty(s.exports, "__esModule", { value: !0 });
      })(X1)),
    X1.exports
  );
}
var Cb;
function sN() {
  return Cb || ((Cb = 1), (k1.exports = rN())), k1.exports;
}
var oN = sN();
const lN = My(oN);
var Rb = HA();
const uN = (s) => typeof s == "object" && typeof s.then == "function",
  Gf = [];
function QT(s, e, t = (n, i) => n === i) {
  if (s === e) return !0;
  if (!s || !e) return !1;
  const n = s.length;
  if (e.length !== n) return !1;
  for (let i = 0; i < n; i++) if (!t(s[i], e[i])) return !1;
  return !0;
}
function $T(s, e = null, t = !1, n = {}) {
  e === null && (e = [s]);
  for (const a of Gf)
    if (QT(e, a.keys, a.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(a, "error")) throw a.error;
      if (Object.prototype.hasOwnProperty.call(a, "response"))
        return (
          n.lifespan &&
            n.lifespan > 0 &&
            (a.timeout && clearTimeout(a.timeout),
            (a.timeout = setTimeout(a.remove, n.lifespan))),
          a.response
        );
      if (!t) throw a.promise;
    }
  const i = {
    keys: e,
    equal: n.equal,
    remove: () => {
      const a = Gf.indexOf(i);
      a !== -1 && Gf.splice(a, 1);
    },
    promise: (uN(s) ? s : s(...e))
      .then((a) => {
        (i.response = a),
          n.lifespan &&
            n.lifespan > 0 &&
            (i.timeout = setTimeout(i.remove, n.lifespan));
      })
      .catch((a) => (i.error = a)),
  };
  if ((Gf.push(i), !t)) throw i.promise;
}
const e2 = (s, e, t) => $T(s, e, !1, t),
  cN = (s, e, t) => void $T(s, e, !0, t),
  fN = (s) => {
    if (s === void 0 || s.length === 0) Gf.splice(0, Gf.length);
    else {
      const e = Gf.find((t) => QT(s, t.keys, t.equal));
      e && e.remove();
    }
  };
function Ox(s, e, t) {
  if (!s) return;
  if (t(s) === !0) return s;
  let n = e ? s.return : s.child;
  for (; n; ) {
    const i = Ox(n, e, t);
    if (i) return i;
    n = e ? null : n.sibling;
  }
}
function t2(s) {
  try {
    return Object.defineProperties(s, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return s;
  }
}
const Lx = t2(je.createContext(null));
class n2 extends je.Component {
  render() {
    return je.createElement(
      Lx.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function i2() {
  const s = je.useContext(Lx);
  if (s === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = je.useId();
  return je.useMemo(() => {
    for (const t of [s, s == null ? void 0 : s.alternate]) {
      if (!t) continue;
      const n = Ox(t, !1, (i) => {
        let a = i.memoizedState;
        for (; a; ) {
          if (a.memoizedState === e) return !0;
          a = a.next;
        }
      });
      if (n) return n;
    }
  }, [s, e]);
}
const hN = Symbol.for("react.context"),
  dN = (s) =>
    s !== null && typeof s == "object" && "$$typeof" in s && s.$$typeof === hN;
function pN() {
  const s = i2(),
    [e] = je.useState(() => new Map());
  e.clear();
  let t = s;
  for (; t; ) {
    const n = t.type;
    dN(n) && n !== Lx && !e.has(n) && e.set(n, je.use(t2(n))), (t = t.return);
  }
  return e;
}
function mN() {
  const s = pN();
  return je.useMemo(
    () =>
      Array.from(s.keys()).reduce(
        (e, t) => (n) =>
          je.createElement(
            e,
            null,
            je.createElement(t.Provider, { ...n, value: s.get(t) })
          ),
        (e) => je.createElement(n2, { ...e })
      ),
    [s]
  );
}
function a2(s) {
  let e = s.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const r2 = (s) => s && s.isOrthographicCamera,
  gN = (s) => s && s.hasOwnProperty("current"),
  vN = (s) =>
    s != null && (typeof s == "string" || typeof s == "number" || s.isColor),
  ng = ((s, e) =>
    typeof window < "u" &&
    (((s = window.document) == null ? void 0 : s.createElement) ||
      ((e = window.navigator) == null ? void 0 : e.product) ===
        "ReactNative"))()
    ? je.useLayoutEffect
    : je.useEffect;
function Nx(s) {
  const e = je.useRef(s);
  return ng(() => void (e.current = s), [s]), e;
}
function yN() {
  const s = i2(),
    e = mN();
  return je.useMemo(
    () =>
      ({ children: t }) => {
        const i = !!Ox(s, !0, (a) => a.type === je.StrictMode)
          ? je.StrictMode
          : je.Fragment;
        return Tt.jsx(i, { children: Tt.jsx(e, { children: t }) });
      },
    [s, e]
  );
}
function _N({ set: s }) {
  return ng(() => (s(new Promise(() => null)), () => s(!1)), [s]), null;
}
const AN = ((s) => (
  (s = class extends je.Component {
    constructor(...t) {
      super(...t), (this.state = { error: !1 });
    }
    componentDidCatch(t) {
      this.props.set(t);
    }
    render() {
      return this.state.error ? null : this.props.children;
    }
  }),
  (s.getDerivedStateFromError = () => ({ error: !0 })),
  s
))();
function s2(s) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(s) ? Math.min(Math.max(s[0], t), s[1]) : s;
}
function ud(s) {
  var e;
  return (e = s.__r3f) == null ? void 0 : e.root.getState();
}
const wi = {
  obj: (s) => s === Object(s) && !wi.arr(s) && typeof s != "function",
  fun: (s) => typeof s == "function",
  str: (s) => typeof s == "string",
  num: (s) => typeof s == "number",
  boo: (s) => typeof s == "boolean",
  und: (s) => s === void 0,
  nul: (s) => s === null,
  arr: (s) => Array.isArray(s),
  equ(
    s,
    e,
    { arrays: t = "shallow", objects: n = "reference", strict: i = !0 } = {}
  ) {
    if (typeof s != typeof e || !!s != !!e) return !1;
    if (wi.str(s) || wi.num(s) || wi.boo(s)) return s === e;
    const a = wi.obj(s);
    if (a && n === "reference") return s === e;
    const l = wi.arr(s);
    if (l && t === "reference") return s === e;
    if ((l || a) && s === e) return !0;
    let u;
    for (u in s) if (!(u in e)) return !1;
    if (a && t === "shallow" && n === "shallow") {
      for (u in i ? e : s)
        if (!wi.equ(s[u], e[u], { strict: i, objects: "reference" })) return !1;
    } else for (u in i ? e : s) if (s[u] !== e[u]) return !1;
    if (wi.und(u)) {
      if (
        (l && s.length === 0 && e.length === 0) ||
        (a && Object.keys(s).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (s !== e) return !1;
    }
    return !0;
  },
};
function xN(s) {
  const e = { nodes: {}, materials: {} };
  return (
    s &&
      s.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function SN(s) {
  s.type !== "Scene" && (s.dispose == null || s.dispose());
  for (const e in s) {
    const t = s[e];
    (t == null ? void 0 : t.type) !== "Scene" &&
      (t == null || t.dispose == null || t.dispose());
  }
}
const o2 = ["children", "key", "ref"];
function MN(s) {
  const e = {};
  for (const t in s) o2.includes(t) || (e[t] = s[t]);
  return e;
}
function gy(s, e, t, n) {
  const i = s;
  let a = i == null ? void 0 : i.__r3f;
  return (
    a ||
      ((a = {
        root: e,
        type: t,
        parent: null,
        children: [],
        props: MN(n),
        object: i,
        eventCount: 0,
        handlers: {},
        isHidden: !1,
      }),
      i && (i.__r3f = a)),
    a
  );
}
function zm(s, e) {
  var t;
  let n = s[e];
  if (!e.includes("-")) return { root: s, key: e, target: n };
  const i = e.split("-");
  return (
    (n = i.reduce((a, l) => a[l], s)),
    (e = i.pop()),
    ((t = n) != null && t.set) || (s = i.reduce((a, l) => a[l], s)),
    { root: s, key: e, target: n }
  );
}
const wb = /-\d+$/;
function vy(s, e) {
  if (wi.str(e.props.attach)) {
    if (wb.test(e.props.attach)) {
      const i = e.props.attach.replace(wb, ""),
        { root: a, key: l } = zm(s.object, i);
      Array.isArray(a[l]) || (a[l] = []);
    }
    const { root: t, key: n } = zm(s.object, e.props.attach);
    (e.previousAttach = t[n]), (t[n] = e.object);
  } else
    wi.fun(e.props.attach) &&
      (e.previousAttach = e.props.attach(s.object, e.object));
}
function yy(s, e) {
  if (wi.str(e.props.attach)) {
    const { root: t, key: n } = zm(s.object, e.props.attach),
      i = e.previousAttach;
    i === void 0 ? delete t[n] : (t[n] = i);
  } else e.previousAttach == null || e.previousAttach(s.object, e.object);
  delete e.previousAttach;
}
const RA = [
    ...o2,
    "args",
    "dispose",
    "attach",
    "object",
    "onUpdate",
    "dispose",
  ],
  Bb = new Map();
function bN(s) {
  let e = Bb.get(s.constructor);
  try {
    e || ((e = new s.constructor()), Bb.set(s.constructor, e));
  } catch {}
  return e;
}
function EN(s, e) {
  const t = {};
  for (const n in e)
    if (!RA.includes(n) && !wi.equ(e[n], s.props[n])) {
      t[n] = e[n];
      for (const i in e) i.startsWith(`${n}-`) && (t[i] = e[i]);
    }
  for (const n in s.props) {
    if (RA.includes(n) || e.hasOwnProperty(n)) continue;
    const { root: i, key: a } = zm(s.object, n);
    if (i.constructor && i.constructor.length === 0) {
      const l = bN(i);
      wi.und(l) || (t[a] = l[a]);
    } else t[a] = 0;
  }
  return t;
}
const TN = [
    "map",
    "emissiveMap",
    "sheenColorMap",
    "specularColorMap",
    "envMap",
  ],
  CN = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;
function Sl(s, e) {
  var t;
  const n = s.__r3f,
    i = n && a2(n).getState(),
    a = n == null ? void 0 : n.eventCount;
  for (const u in e) {
    let f = e[u];
    if (RA.includes(u)) continue;
    if (n && CN.test(u)) {
      typeof f == "function" ? (n.handlers[u] = f) : delete n.handlers[u],
        (n.eventCount = Object.keys(n.handlers).length);
      continue;
    }
    if (f === void 0) continue;
    let { root: d, key: m, target: v } = zm(s, u);
    if (v instanceof Rd && f instanceof Rd) v.mask = f.mask;
    else if (v instanceof Dt && vN(f)) v.set(f);
    else if (
      v !== null &&
      typeof v == "object" &&
      typeof v.set == "function" &&
      typeof v.copy == "function" &&
      f != null &&
      f.constructor &&
      v.constructor === f.constructor
    )
      v.copy(f);
    else if (
      v !== null &&
      typeof v == "object" &&
      typeof v.set == "function" &&
      Array.isArray(f)
    )
      typeof v.fromArray == "function" ? v.fromArray(f) : v.set(...f);
    else if (
      v !== null &&
      typeof v == "object" &&
      typeof v.set == "function" &&
      typeof f == "number"
    )
      typeof v.setScalar == "function" ? v.setScalar(f) : v.set(f);
    else {
      var l;
      (d[m] = f),
        i &&
          !i.linear &&
          TN.includes(m) &&
          (l = d[m]) != null &&
          l.isTexture &&
          d[m].format === oa &&
          d[m].type === Zr &&
          (d[m].colorSpace = Wa);
    }
  }
  if (
    n != null &&
    n.parent &&
    i != null &&
    i.internal &&
    (t = n.object) != null &&
    t.isObject3D &&
    a !== n.eventCount
  ) {
    const u = n.object,
      f = i.internal.interaction.indexOf(u);
    f > -1 && i.internal.interaction.splice(f, 1),
      n.eventCount && u.raycast !== null && i.internal.interaction.push(u);
  }
  return (
    n &&
      n.props.attach === void 0 &&
      (n.object.isBufferGeometry
        ? (n.props.attach = "geometry")
        : n.object.isMaterial && (n.props.attach = "material")),
    n && Gd(n),
    s
  );
}
function Gd(s) {
  var e;
  if (!s.parent) return;
  s.props.onUpdate == null || s.props.onUpdate(s.object);
  const t = (e = s.root) == null || e.getState == null ? void 0 : e.getState();
  t && t.internal.frames === 0 && t.invalidate();
}
function l2(s, e) {
  s.manual ||
    (r2(s)
      ? ((s.left = e.width / -2),
        (s.right = e.width / 2),
        (s.top = e.height / 2),
        (s.bottom = e.height / -2))
      : (s.aspect = e.width / e.height),
    s.updateProjectionMatrix());
}
const Cr = (s) => (s == null ? void 0 : s.isObject3D);
function m0(s) {
  return (s.eventObject || s.object).uuid + "/" + s.index + s.instanceId;
}
function u2(s, e, t, n) {
  const i = t.get(e);
  i &&
    (t.delete(e),
    t.size === 0 && (s.delete(n), i.target.releasePointerCapture(n)));
}
function RN(s, e) {
  const { internal: t } = s.getState();
  (t.interaction = t.interaction.filter((n) => n !== e)),
    (t.initialHits = t.initialHits.filter((n) => n !== e)),
    t.hovered.forEach((n, i) => {
      (n.eventObject === e || n.object === e) && t.hovered.delete(i);
    }),
    t.capturedMap.forEach((n, i) => {
      u2(t.capturedMap, e, n, i);
    });
}
function wN(s) {
  function e(f) {
    const { internal: d } = s.getState(),
      m = f.offsetX - d.initialClick[0],
      v = f.offsetY - d.initialClick[1];
    return Math.round(Math.sqrt(m * m + v * v));
  }
  function t(f) {
    return f.filter((d) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((m) => {
        var v;
        return (v = d.__r3f) == null ? void 0 : v.handlers["onPointer" + m];
      })
    );
  }
  function n(f, d) {
    const m = s.getState(),
      v = new Set(),
      _ = [],
      A = d ? d(m.internal.interaction) : m.internal.interaction;
    for (let b = 0; b < A.length; b++) {
      const w = ud(A[b]);
      w && (w.raycaster.camera = void 0);
    }
    m.previousRoot || m.events.compute == null || m.events.compute(f, m);
    function M(b) {
      const w = ud(b);
      if (!w || !w.events.enabled || w.raycaster.camera === null) return [];
      if (w.raycaster.camera === void 0) {
        var D;
        w.events.compute == null ||
          w.events.compute(
            f,
            w,
            (D = w.previousRoot) == null ? void 0 : D.getState()
          ),
          w.raycaster.camera === void 0 && (w.raycaster.camera = null);
      }
      return w.raycaster.camera ? w.raycaster.intersectObject(b, !0) : [];
    }
    let T = A.flatMap(M)
      .sort((b, w) => {
        const D = ud(b.object),
          B = ud(w.object);
        return !D || !B
          ? b.distance - w.distance
          : B.events.priority - D.events.priority || b.distance - w.distance;
      })
      .filter((b) => {
        const w = m0(b);
        return v.has(w) ? !1 : (v.add(w), !0);
      });
    m.events.filter && (T = m.events.filter(T, m));
    for (const b of T) {
      let w = b.object;
      for (; w; ) {
        var E;
        (E = w.__r3f) != null &&
          E.eventCount &&
          _.push({ ...b, eventObject: w }),
          (w = w.parent);
      }
    }
    if ("pointerId" in f && m.internal.capturedMap.has(f.pointerId))
      for (let b of m.internal.capturedMap.get(f.pointerId).values())
        v.has(m0(b.intersection)) || _.push(b.intersection);
    return _;
  }
  function i(f, d, m, v) {
    if (f.length) {
      const _ = { stopped: !1 };
      for (const A of f) {
        let M = ud(A.object);
        if (
          (M ||
            A.object.traverseAncestors((T) => {
              const E = ud(T);
              if (E) return (M = E), !1;
            }),
          M)
        ) {
          const { raycaster: T, pointer: E, camera: b, internal: w } = M,
            D = new ie(E.x, E.y, 0).unproject(b),
            B = (O) => {
              var U, W;
              return (U =
                (W = w.capturedMap.get(O)) == null
                  ? void 0
                  : W.has(A.eventObject)) != null
                ? U
                : !1;
            },
            I = (O) => {
              const U = { intersection: A, target: d.target };
              w.capturedMap.has(O)
                ? w.capturedMap.get(O).set(A.eventObject, U)
                : w.capturedMap.set(O, new Map([[A.eventObject, U]])),
                d.target.setPointerCapture(O);
            },
            N = (O) => {
              const U = w.capturedMap.get(O);
              U && u2(w.capturedMap, A.eventObject, U, O);
            };
          let P = {};
          for (let O in d) {
            let U = d[O];
            typeof U != "function" && (P[O] = U);
          }
          let F = {
            ...A,
            ...P,
            pointer: E,
            intersections: f,
            stopped: _.stopped,
            delta: m,
            unprojectedPoint: D,
            ray: T.ray,
            camera: b,
            stopPropagation() {
              const O = "pointerId" in d && w.capturedMap.get(d.pointerId);
              if (
                (!O || O.has(A.eventObject)) &&
                ((F.stopped = _.stopped = !0),
                w.hovered.size &&
                  Array.from(w.hovered.values()).find(
                    (U) => U.eventObject === A.eventObject
                  ))
              ) {
                const U = f.slice(0, f.indexOf(A));
                a([...U, A]);
              }
            },
            target: {
              hasPointerCapture: B,
              setPointerCapture: I,
              releasePointerCapture: N,
            },
            currentTarget: {
              hasPointerCapture: B,
              setPointerCapture: I,
              releasePointerCapture: N,
            },
            nativeEvent: d,
          };
          if ((v(F), _.stopped === !0)) break;
        }
      }
    }
    return f;
  }
  function a(f) {
    const { internal: d } = s.getState();
    for (const m of d.hovered.values())
      if (
        !f.length ||
        !f.find(
          (v) =>
            v.object === m.object &&
            v.index === m.index &&
            v.instanceId === m.instanceId
        )
      ) {
        const _ = m.eventObject.__r3f;
        if ((d.hovered.delete(m0(m)), _ != null && _.eventCount)) {
          const A = _.handlers,
            M = { ...m, intersections: f };
          A.onPointerOut == null || A.onPointerOut(M),
            A.onPointerLeave == null || A.onPointerLeave(M);
        }
      }
  }
  function l(f, d) {
    for (let m = 0; m < d.length; m++) {
      const v = d[m].__r3f;
      v == null ||
        v.handlers.onPointerMissed == null ||
        v.handlers.onPointerMissed(f);
    }
  }
  function u(f) {
    switch (f) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => a([]);
      case "onLostPointerCapture":
        return (d) => {
          const { internal: m } = s.getState();
          "pointerId" in d &&
            m.capturedMap.has(d.pointerId) &&
            requestAnimationFrame(() => {
              m.capturedMap.has(d.pointerId) &&
                (m.capturedMap.delete(d.pointerId), a([]));
            });
        };
    }
    return function (m) {
      const { onPointerMissed: v, internal: _ } = s.getState();
      _.lastEvent.current = m;
      const A = f === "onPointerMove",
        M = f === "onClick" || f === "onContextMenu" || f === "onDoubleClick",
        E = n(m, A ? t : void 0),
        b = M ? e(m) : 0;
      f === "onPointerDown" &&
        ((_.initialClick = [m.offsetX, m.offsetY]),
        (_.initialHits = E.map((D) => D.eventObject))),
        M && !E.length && b <= 2 && (l(m, _.interaction), v && v(m)),
        A && a(E);
      function w(D) {
        const B = D.eventObject,
          I = B.__r3f;
        if (!(I != null && I.eventCount)) return;
        const N = I.handlers;
        if (A) {
          if (
            N.onPointerOver ||
            N.onPointerEnter ||
            N.onPointerOut ||
            N.onPointerLeave
          ) {
            const P = m0(D),
              F = _.hovered.get(P);
            F
              ? F.stopped && D.stopPropagation()
              : (_.hovered.set(P, D),
                N.onPointerOver == null || N.onPointerOver(D),
                N.onPointerEnter == null || N.onPointerEnter(D));
          }
          N.onPointerMove == null || N.onPointerMove(D);
        } else {
          const P = N[f];
          P
            ? (!M || _.initialHits.includes(B)) &&
              (l(
                m,
                _.interaction.filter((F) => !_.initialHits.includes(F))
              ),
              P(D))
            : M &&
              _.initialHits.includes(B) &&
              l(
                m,
                _.interaction.filter((F) => !_.initialHits.includes(F))
              );
        }
      }
      i(E, m, b, w);
    };
  }
  return { handlePointer: u };
}
const Db = (s) => !!(s != null && s.render),
  Ix = je.createContext(null),
  BN = (s, e) => {
    const t = ZT((u, f) => {
        const d = new ie(),
          m = new ie(),
          v = new ie();
        function _(b = f().camera, w = m, D = f().size) {
          const { width: B, height: I, top: N, left: P } = D,
            F = B / I;
          w.isVector3 ? v.copy(w) : v.set(...w);
          const O = b.getWorldPosition(d).distanceTo(v);
          if (r2(b))
            return {
              width: B / b.zoom,
              height: I / b.zoom,
              top: N,
              left: P,
              factor: 1,
              distance: O,
              aspect: F,
            };
          {
            const U = (b.fov * Math.PI) / 180,
              W = 2 * Math.tan(U / 2) * O,
              J = W * (B / I);
            return {
              width: J,
              height: W,
              top: N,
              left: P,
              factor: B / J,
              distance: O,
              aspect: F,
            };
          }
        }
        let A;
        const M = (b) =>
            u((w) => ({ performance: { ...w.performance, current: b } })),
          T = new at();
        return {
          set: u,
          get: f,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          scene: null,
          xr: null,
          invalidate: (b = 1) => s(f(), b),
          advance: (b, w) => e(b, w, f()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new Tx(),
          pointer: T,
          mouse: T,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const b = f();
              A && clearTimeout(A),
                b.performance.current !== b.performance.min &&
                  M(b.performance.min),
                (A = setTimeout(
                  () => M(f().performance.max),
                  b.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: _,
          },
          setEvents: (b) => u((w) => ({ ...w, events: { ...w.events, ...b } })),
          setSize: (b, w, D = 0, B = 0) => {
            const I = f().camera,
              N = { width: b, height: w, top: D, left: B };
            u((P) => ({ size: N, viewport: { ...P.viewport, ..._(I, m, N) } }));
          },
          setDpr: (b) =>
            u((w) => {
              const D = s2(b);
              return {
                viewport: {
                  ...w.viewport,
                  dpr: D,
                  initialDpr: w.viewport.initialDpr || D,
                },
              };
            }),
          setFrameloop: (b = "always") => {
            const w = f().clock;
            w.stop(),
              (w.elapsedTime = 0),
              b !== "never" && (w.start(), (w.elapsedTime = 0)),
              u(() => ({ frameloop: b }));
          },
          previousRoot: void 0,
          internal: {
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            lastEvent: je.createRef(),
            active: !1,
            frames: 0,
            priority: 0,
            subscribe: (b, w, D) => {
              const B = f().internal;
              return (
                (B.priority = B.priority + (w > 0 ? 1 : 0)),
                B.subscribers.push({ ref: b, priority: w, store: D }),
                (B.subscribers = B.subscribers.sort(
                  (I, N) => I.priority - N.priority
                )),
                () => {
                  const I = f().internal;
                  I != null &&
                    I.subscribers &&
                    ((I.priority = I.priority - (w > 0 ? 1 : 0)),
                    (I.subscribers = I.subscribers.filter((N) => N.ref !== b)));
                }
              );
            },
          },
        };
      }),
      n = t.getState();
    let i = n.size,
      a = n.viewport.dpr,
      l = n.camera;
    return (
      t.subscribe(() => {
        const { camera: u, size: f, viewport: d, gl: m, set: v } = t.getState();
        if (f.width !== i.width || f.height !== i.height || d.dpr !== a) {
          (i = f), (a = d.dpr), l2(u, f), d.dpr > 0 && m.setPixelRatio(d.dpr);
          const _ =
            typeof HTMLCanvasElement < "u" &&
            m.domElement instanceof HTMLCanvasElement;
          m.setSize(f.width, f.height, _);
        }
        u !== l &&
          ((l = u),
          v((_) => ({
            viewport: { ..._.viewport, ..._.viewport.getCurrentViewport(u) },
          })));
      }),
      t.subscribe((u) => s(u)),
      t
    );
  };
function Fx() {
  const s = je.useContext(Ix);
  if (!s)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return s;
}
function aa(s = (t) => t, e) {
  return Fx()(s, e);
}
function zd(s, e = 0) {
  const t = Fx(),
    n = t.getState().internal.subscribe,
    i = Nx(s);
  return ng(() => n(i, e, t), [e, n, t]), null;
}
const Ub = new WeakMap(),
  DN = (s) => {
    var e;
    return (
      typeof s == "function" &&
      (s == null || (e = s.prototype) == null ? void 0 : e.constructor) === s
    );
  };
function c2(s, e) {
  return function (t, ...n) {
    let i;
    return (
      DN(t) ? ((i = Ub.get(t)), i || ((i = new t()), Ub.set(t, i))) : (i = t),
      s && s(i),
      Promise.all(
        n.map(
          (a) =>
            new Promise((l, u) =>
              i.load(
                a,
                (f) => {
                  Cr(f == null ? void 0 : f.scene) &&
                    Object.assign(f, xN(f.scene)),
                    l(f);
                },
                e,
                (f) =>
                  u(
                    new Error(
                      `Could not load ${a}: ${f == null ? void 0 : f.message}`
                    )
                  )
              )
            )
        )
      )
    );
  };
}
function Gs(s, e, t, n) {
  const i = Array.isArray(e) ? e : [e],
    a = e2(c2(t, n), [s, ...i], { equal: wi.equ });
  return Array.isArray(e) ? a : a[0];
}
Gs.preload = function (s, e, t) {
  const n = Array.isArray(e) ? e : [e];
  return cN(c2(t), [s, ...n]);
};
Gs.clear = function (s, e) {
  const t = Array.isArray(e) ? e : [e];
  return fN([s, ...t]);
};
function UN(s) {
  const e = lN(s);
  return (
    e.injectIntoDevTools({
      bundleType: 0,
      rendererPackageName: "@react-three/fiber",
      version: je.version,
    }),
    e
  );
}
const f2 = 0,
  Dd = {},
  ON = /^three(?=[A-Z])/,
  l_ = (s) => `${s[0].toUpperCase()}${s.slice(1)}`;
let LN = 0;
const NN = (s) => typeof s == "function";
function Px(s) {
  if (NN(s)) {
    const e = `${LN++}`;
    return (Dd[e] = s), e;
  } else Object.assign(Dd, s);
}
function h2(s, e) {
  const t = l_(s),
    n = Dd[t];
  if (s !== "primitive" && !n)
    throw new Error(
      `R3F: ${t} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
    );
  if (s === "primitive" && !e.object)
    throw new Error("R3F: Primitives without 'object' are invalid!");
  if (e.args !== void 0 && !Array.isArray(e.args))
    throw new Error("R3F: The args prop must be an array!");
}
function IN(s, e, t) {
  var n;
  return (
    (s = l_(s) in Dd ? s : s.replace(ON, "")),
    h2(s, e),
    s === "primitive" &&
      (n = e.object) != null &&
      n.__r3f &&
      delete e.object.__r3f,
    gy(e.object, t, s, e)
  );
}
function FN(s) {
  if (!s.isHidden) {
    var e;
    s.props.attach && (e = s.parent) != null && e.object
      ? yy(s.parent, s)
      : Cr(s.object) && (s.object.visible = !1),
      (s.isHidden = !0),
      Gd(s);
  }
}
function d2(s) {
  if (s.isHidden) {
    var e;
    s.props.attach && (e = s.parent) != null && e.object
      ? vy(s.parent, s)
      : Cr(s.object) && s.props.visible !== !1 && (s.object.visible = !0),
      (s.isHidden = !1),
      Gd(s);
  }
}
function Gx(s, e, t) {
  const n = e.root.getState();
  if (!(!s.parent && s.object !== n.scene)) {
    if (!e.object) {
      var i, a;
      const l = Dd[l_(e.type)];
      (e.object =
        (i = e.props.object) != null
          ? i
          : new l(...((a = e.props.args) != null ? a : []))),
        (e.object.__r3f = e);
    }
    if ((Sl(e.object, e.props), e.props.attach)) vy(s, e);
    else if (Cr(e.object) && Cr(s.object)) {
      const l = s.object.children.indexOf(t == null ? void 0 : t.object);
      t && l !== -1
        ? ((e.object.parent = s.object),
          s.object.children.splice(l, 0, e.object),
          e.object.dispatchEvent({ type: "added" }),
          s.object.dispatchEvent({ type: "childadded", child: e.object }))
        : s.object.add(e.object);
    }
    for (const l of e.children) Gx(e, l);
    Gd(e);
  }
}
function Y1(s, e) {
  e && ((e.parent = s), s.children.push(e), Gx(s, e));
}
function Ob(s, e, t) {
  if (!e || !t) return;
  e.parent = s;
  const n = s.children.indexOf(t);
  n !== -1 ? s.children.splice(n, 0, e) : s.children.push(e), Gx(s, e, t);
}
function p2(s) {
  if (typeof s.dispose == "function") {
    const e = () => {
      try {
        s.dispose();
      } catch {}
    };
    typeof IS_REACT_ACT_ENVIRONMENT < "u"
      ? e()
      : Rb.unstable_scheduleCallback(Rb.unstable_IdlePriority, e);
  }
}
function wA(s, e, t) {
  if (!e) return;
  e.parent = null;
  const n = s.children.indexOf(e);
  n !== -1 && s.children.splice(n, 1),
    e.props.attach
      ? yy(s, e)
      : Cr(e.object) &&
        Cr(s.object) &&
        (s.object.remove(e.object), RN(a2(e), e.object));
  const i = e.props.dispose !== null && t !== !1;
  for (let a = e.children.length - 1; a >= 0; a--) {
    const l = e.children[a];
    wA(e, l, i);
  }
  (e.children.length = 0),
    delete e.object.__r3f,
    i && e.type !== "primitive" && e.object.type !== "Scene" && p2(e.object),
    t === void 0 && Gd(e);
}
function PN(s, e) {
  for (const t of [s, s.alternate])
    if (t !== null)
      if (typeof t.ref == "function") {
        t.refCleanup == null || t.refCleanup();
        const n = t.ref(e);
        typeof n == "function" && (t.refCleanup = n);
      } else t.ref && (t.ref.current = e);
}
const R0 = [];
function GN() {
  for (const [t] of R0) {
    const n = t.parent;
    if (n) {
      t.props.attach
        ? yy(n, t)
        : Cr(t.object) && Cr(n.object) && n.object.remove(t.object);
      for (const i of t.children)
        i.props.attach
          ? yy(t, i)
          : Cr(i.object) && Cr(t.object) && t.object.remove(i.object);
    }
    t.isHidden && d2(t),
      t.object.__r3f && delete t.object.__r3f,
      t.type !== "primitive" && p2(t.object);
  }
  for (const [t, n, i] of R0) {
    t.props = n;
    const a = t.parent;
    if (a) {
      var s, e;
      const l = Dd[l_(t.type)];
      (t.object =
        (s = t.props.object) != null
          ? s
          : new l(...((e = t.props.args) != null ? e : []))),
        (t.object.__r3f = t),
        PN(i, t.object),
        Sl(t.object, t.props),
        t.props.attach
          ? vy(a, t)
          : Cr(t.object) && Cr(a.object) && a.object.add(t.object);
      for (const u of t.children)
        u.props.attach
          ? vy(t, u)
          : Cr(u.object) && Cr(t.object) && t.object.add(u.object);
      Gd(t);
    }
  }
  R0.length = 0;
}
const W1 = () => {},
  Lb = {};
let g0 = f2;
const zN = 0,
  HN = 4,
  _y = UN({
    isPrimaryRenderer: !1,
    warnsIfNotActing: !1,
    supportsMutation: !0,
    supportsPersistence: !1,
    supportsHydration: !1,
    createInstance: IN,
    removeChild: wA,
    appendChild: Y1,
    appendInitialChild: Y1,
    insertBefore: Ob,
    appendChildToContainer(s, e) {
      const t = s.getState().scene.__r3f;
      !e || !t || Y1(t, e);
    },
    removeChildFromContainer(s, e) {
      const t = s.getState().scene.__r3f;
      !e || !t || wA(t, e);
    },
    insertInContainerBefore(s, e, t) {
      const n = s.getState().scene.__r3f;
      !e || !t || !n || Ob(n, e, t);
    },
    getRootHostContext: () => Lb,
    getChildHostContext: () => Lb,
    commitUpdate(s, e, t, n, i) {
      var a, l, u;
      h2(e, n);
      let f = !1;
      if (
        (((s.type === "primitive" && t.object !== n.object) ||
          ((a = n.args) == null ? void 0 : a.length) !==
            ((l = t.args) == null ? void 0 : l.length) ||
          ((u = n.args) != null &&
            u.some((m, v) => {
              var _;
              return m !== ((_ = t.args) == null ? void 0 : _[v]);
            }))) &&
          (f = !0),
        f)
      )
        R0.push([s, { ...n }, i]);
      else {
        const m = EN(s, n);
        Object.keys(m).length && (Object.assign(s.props, m), Sl(s.object, m));
      }
      (i.sibling === null || (i.flags & HN) === zN) && GN();
    },
    finalizeInitialChildren: () => !1,
    commitMount() {},
    getPublicInstance: (s) => (s == null ? void 0 : s.object),
    prepareForCommit: () => null,
    preparePortalMount: (s) => gy(s.getState().scene, s, "", {}),
    resetAfterCommit: () => {},
    shouldSetTextContent: () => !1,
    clearContainer: () => !1,
    hideInstance: FN,
    unhideInstance: d2,
    createTextInstance: W1,
    hideTextInstance: W1,
    unhideTextInstance: W1,
    scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
    cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
    noTimeout: -1,
    getInstanceFromNode: () => null,
    beforeActiveInstanceBlur() {},
    afterActiveInstanceBlur() {},
    detachDeletedInstance() {},
    prepareScopeUpdate() {},
    getInstanceFromScope: () => null,
    shouldAttemptEagerTransition: () => !1,
    trackSchedulerEvent: () => {},
    resolveEventType: () => null,
    resolveEventTimeStamp: () => -1.1,
    requestPostPaintCallback() {},
    maySuspendCommit: () => !1,
    preloadInstance: () => !0,
    startSuspendingCommit() {},
    suspendInstance() {},
    waitForCommitToBeReady: () => null,
    NotPendingTransition: null,
    HostTransitionContext: je.createContext(null),
    setCurrentUpdatePriority(s) {
      g0 = s;
    },
    getCurrentUpdatePriority() {
      return g0;
    },
    resolveUpdatePriority() {
      var s;
      if (g0 !== f2) return g0;
      switch (
        typeof window < "u" &&
        ((s = window.event) == null ? void 0 : s.type)
      ) {
        case "click":
        case "contextmenu":
        case "dblclick":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
          return C0.DiscreteEventPriority;
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "pointerenter":
        case "pointerleave":
        case "wheel":
          return C0.ContinuousEventPriority;
        default:
          return C0.DefaultEventPriority;
      }
    },
    resetFormInstance() {},
  }),
  Qf = new Map(),
  cd = { objects: "shallow", strict: !1 };
function VN(s, e) {
  if (
    !e &&
    typeof HTMLCanvasElement < "u" &&
    s instanceof HTMLCanvasElement &&
    s.parentElement
  ) {
    const {
      width: t,
      height: n,
      top: i,
      left: a,
    } = s.parentElement.getBoundingClientRect();
    return { width: t, height: n, top: i, left: a };
  } else if (!e && typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas)
    return { width: s.width, height: s.height, top: 0, left: 0 };
  return { width: 0, height: 0, top: 0, left: 0, ...e };
}
function kN(s) {
  const e = Qf.get(s),
    t = e == null ? void 0 : e.fiber,
    n = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    a = n || BN(UA, Ib),
    l =
      t ||
      _y.createContainer(
        a,
        C0.ConcurrentRoot,
        null,
        !1,
        null,
        "",
        i,
        i,
        i,
        null
      );
  e || Qf.set(s, { fiber: l, store: a });
  let u,
    f,
    d = !1,
    m = null;
  return {
    async configure(v = {}) {
      let _;
      m = new Promise((Y) => (_ = Y));
      let {
          gl: A,
          size: M,
          scene: T,
          events: E,
          onCreated: b,
          shadows: w = !1,
          linear: D = !1,
          flat: B = !1,
          legacy: I = !1,
          orthographic: N = !1,
          frameloop: P = "always",
          dpr: F = [1, 2],
          performance: O,
          raycaster: U,
          camera: W,
          onPointerMissed: J,
        } = v,
        q = a.getState(),
        Z = q.gl;
      if (!q.gl) {
        const Y = {
            canvas: s,
            powerPreference: "high-performance",
            antialias: !0,
            alpha: !0,
          },
          ae = typeof A == "function" ? await A(Y) : A;
        Db(ae) ? (Z = ae) : (Z = new Ux({ ...Y, ...A })), q.set({ gl: Z });
      }
      let ue = q.raycaster;
      ue || q.set({ raycaster: (ue = new wx()) });
      const { params: K, ...ge } = U || {};
      if (
        (wi.equ(ge, ue, cd) || Sl(ue, { ...ge }),
        wi.equ(K, ue.params, cd) || Sl(ue, { params: { ...ue.params, ...K } }),
        !q.camera || (q.camera === f && !wi.equ(f, W, cd)))
      ) {
        f = W;
        const Y = W == null ? void 0 : W.isCamera,
          ae = Y
            ? W
            : N
            ? new Ps(0, 0, 0, 0, 0.1, 1e3)
            : new $i(75, 0, 0.1, 1e3);
        Y ||
          ((ae.position.z = 5),
          W &&
            (Sl(ae, W),
            ae.manual ||
              (("aspect" in W ||
                "left" in W ||
                "right" in W ||
                "bottom" in W ||
                "top" in W) &&
                ((ae.manual = !0), ae.updateProjectionMatrix()))),
          !q.camera && !(W != null && W.rotation) && ae.lookAt(0, 0, 0)),
          q.set({ camera: ae }),
          (ue.camera = ae);
      }
      if (!q.scene) {
        let Y;
        T != null && T.isScene
          ? ((Y = T), gy(Y, a, "", {}))
          : ((Y = new Nd()), gy(Y, a, "", {}), T && Sl(Y, T)),
          q.set({ scene: Y });
      }
      E && !q.events.handlers && q.set({ events: E(a) });
      const oe = VN(s, M);
      if (
        (wi.equ(oe, q.size, cd) ||
          q.setSize(oe.width, oe.height, oe.top, oe.left),
        F && q.viewport.dpr !== s2(F) && q.setDpr(F),
        q.frameloop !== P && q.setFrameloop(P),
        q.onPointerMissed || q.set({ onPointerMissed: J }),
        O &&
          !wi.equ(O, q.performance, cd) &&
          q.set((Y) => ({ performance: { ...Y.performance, ...O } })),
        !q.xr)
      ) {
        var me;
        const Y = (j, se) => {
            const ve = a.getState();
            ve.frameloop !== "never" && Ib(j, !0, ve, se);
          },
          ae = () => {
            const j = a.getState();
            (j.gl.xr.enabled = j.gl.xr.isPresenting),
              j.gl.xr.setAnimationLoop(j.gl.xr.isPresenting ? Y : null),
              j.gl.xr.isPresenting || UA(j);
          },
          fe = {
            connect() {
              const j = a.getState().gl;
              j.xr.addEventListener("sessionstart", ae),
                j.xr.addEventListener("sessionend", ae);
            },
            disconnect() {
              const j = a.getState().gl;
              j.xr.removeEventListener("sessionstart", ae),
                j.xr.removeEventListener("sessionend", ae);
            },
          };
        typeof ((me = Z.xr) == null ? void 0 : me.addEventListener) ==
          "function" && fe.connect(),
          q.set({ xr: fe });
      }
      if (Z.shadowMap) {
        const Y = Z.shadowMap.enabled,
          ae = Z.shadowMap.type;
        if (((Z.shadowMap.enabled = !!w), wi.boo(w))) Z.shadowMap.type = gm;
        else if (wi.str(w)) {
          var V;
          const fe = { basic: cE, percentage: by, soft: gm, variance: wo };
          Z.shadowMap.type = (V = fe[w]) != null ? V : gm;
        } else wi.obj(w) && Object.assign(Z.shadowMap, w);
        (Y !== Z.shadowMap.enabled || ae !== Z.shadowMap.type) &&
          (Z.shadowMap.needsUpdate = !0);
      }
      return (
        (zn.enabled = !I),
        d ||
          ((Z.outputColorSpace = D ? Oo : Wa), (Z.toneMapping = B ? bl : VA)),
        q.legacy !== I && q.set(() => ({ legacy: I })),
        q.linear !== D && q.set(() => ({ linear: D })),
        q.flat !== B && q.set(() => ({ flat: B })),
        A && !wi.fun(A) && !Db(A) && !wi.equ(A, Z, cd) && Sl(Z, A),
        (u = b),
        (d = !0),
        _(),
        this
      );
    },
    render(v) {
      return (
        !d && !m && this.configure(),
        m.then(() => {
          _y.updateContainer(
            Tt.jsx(XN, { store: a, children: v, onCreated: u, rootElement: s }),
            l,
            null,
            () => {}
          );
        }),
        a
      );
    },
    unmount() {
      m2(s);
    },
  };
}
function XN({ store: s, children: e, onCreated: t, rootElement: n }) {
  return (
    ng(() => {
      const i = s.getState();
      i.set((a) => ({ internal: { ...a.internal, active: !0 } })),
        t && t(i),
        s.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(n);
    }, []),
    Tt.jsx(Ix.Provider, { value: s, children: e })
  );
}
function m2(s, e) {
  const t = Qf.get(s),
    n = t == null ? void 0 : t.fiber;
  if (n) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1),
      _y.updateContainer(null, n, null, () => {
        i &&
          setTimeout(() => {
            try {
              var a, l, u, f;
              i.events.disconnect == null || i.events.disconnect(),
                (a = i.gl) == null ||
                  (l = a.renderLists) == null ||
                  l.dispose == null ||
                  l.dispose(),
                (u = i.gl) == null ||
                  u.forceContextLoss == null ||
                  u.forceContextLoss(),
                (f = i.gl) != null && f.xr && i.xr.disconnect(),
                SN(i.scene),
                Qf.delete(s);
            } catch {}
          }, 500);
      });
  }
}
function g2(s, e, t) {
  return Tt.jsx(YN, { children: s, container: e, state: t });
}
function YN({ state: s = {}, children: e, container: t }) {
  const { events: n, size: i, ...a } = s,
    l = Fx(),
    [u] = je.useState(() => new wx()),
    [f] = je.useState(() => new at()),
    d = Nx((v, _) => {
      let A;
      if (_.camera && i) {
        const M = _.camera;
        (A = v.viewport.getCurrentViewport(M, new ie(), i)),
          M !== v.camera && l2(M, i);
      }
      return {
        ...v,
        ..._,
        scene: t,
        raycaster: u,
        pointer: f,
        mouse: f,
        previousRoot: l,
        events: { ...v.events, ..._.events, ...n },
        size: { ...v.size, ...i },
        viewport: { ...v.viewport, ...A },
        setEvents: (M) =>
          _.set((T) => ({ ...T, events: { ...T.events, ...M } })),
      };
    }),
    m = je.useMemo(() => {
      const v = ZT((A, M) => ({ ...a, set: A, get: M })),
        _ = (A) => v.setState((M) => d.current(A, M));
      return _(l.getState()), l.subscribe(_), v;
    }, [l, t]);
  return Tt.jsx(Tt.Fragment, {
    children: _y.createPortal(
      Tt.jsx(Ix.Provider, { value: m, children: e }),
      m,
      null
    ),
  });
}
function v2(s, e) {
  const t = { callback: s };
  return e.add(t), () => void e.delete(t);
}
const y2 = new Set(),
  _2 = new Set(),
  WN = new Set(),
  JN = (s) => v2(s, y2),
  qN = (s) => v2(s, _2);
function J1(s, e) {
  if (s.size) for (const { callback: t } of s.values()) t(e);
}
function Em(s, e) {
  switch (s) {
    case "before":
      return J1(y2, e);
    case "after":
      return J1(_2, e);
    case "tail":
      return J1(WN, e);
  }
}
let q1, j1;
function BA(s, e, t) {
  let n = e.clock.getDelta();
  e.frameloop === "never" &&
    typeof s == "number" &&
    ((n = s - e.clock.elapsedTime),
    (e.clock.oldTime = e.clock.elapsedTime),
    (e.clock.elapsedTime = s)),
    (q1 = e.internal.subscribers);
  for (let i = 0; i < q1.length; i++)
    (j1 = q1[i]), j1.ref.current(j1.store.getState(), n, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
let Ay = !1,
  DA = !1,
  K1,
  Nb,
  fd;
function A2(s) {
  (Nb = requestAnimationFrame(A2)),
    (Ay = !0),
    (K1 = 0),
    Em("before", s),
    (DA = !0);
  for (const t of Qf.values()) {
    var e;
    (fd = t.store.getState()),
      fd.internal.active &&
        (fd.frameloop === "always" || fd.internal.frames > 0) &&
        !((e = fd.gl.xr) != null && e.isPresenting) &&
        (K1 += BA(s, fd));
  }
  if (((DA = !1), Em("after", s), K1 === 0))
    return Em("tail", s), (Ay = !1), cancelAnimationFrame(Nb);
}
function UA(s, e = 1) {
  var t;
  if (!s) return Qf.forEach((n) => UA(n.store.getState(), e));
  ((t = s.gl.xr) != null && t.isPresenting) ||
    !s.internal.active ||
    s.frameloop === "never" ||
    (e > 1
      ? (s.internal.frames = Math.min(60, s.internal.frames + e))
      : DA
      ? (s.internal.frames = 2)
      : (s.internal.frames = 1),
    Ay || ((Ay = !0), requestAnimationFrame(A2)));
}
function Ib(s, e = !0, t, n) {
  if ((e && Em("before", s), t)) BA(s, t, n);
  else for (const i of Qf.values()) BA(s, i.store.getState());
  e && Em("after", s);
}
const Z1 = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function jN(s) {
  const { handlePointer: e } = wN(s);
  return {
    priority: 1,
    enabled: !0,
    compute(t, n, i) {
      n.pointer.set(
        (t.offsetX / n.size.width) * 2 - 1,
        -(t.offsetY / n.size.height) * 2 + 1
      ),
        n.raycaster.setFromCamera(n.pointer, n.camera);
    },
    connected: void 0,
    handlers: Object.keys(Z1).reduce((t, n) => ({ ...t, [n]: e(n) }), {}),
    update: () => {
      var t;
      const { events: n, internal: i } = s.getState();
      (t = i.lastEvent) != null &&
        t.current &&
        n.handlers &&
        n.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      const { set: n, events: i } = s.getState();
      if (
        (i.disconnect == null || i.disconnect(),
        n((a) => ({ events: { ...a.events, connected: t } })),
        i.handlers)
      )
        for (const a in i.handlers) {
          const l = i.handlers[a],
            [u, f] = Z1[a];
          t.addEventListener(u, l, { passive: f });
        }
    },
    disconnect: () => {
      const { set: t, events: n } = s.getState();
      if (n.connected) {
        if (n.handlers)
          for (const i in n.handlers) {
            const a = n.handlers[i],
              [l] = Z1[i];
            n.connected.removeEventListener(l, a);
          }
        t((i) => ({ events: { ...i.events, connected: void 0 } }));
      }
    },
  };
}
function Fb(s, e) {
  let t;
  return (...n) => {
    window.clearTimeout(t), (t = window.setTimeout(() => s(...n), e));
  };
}
function KN(
  { debounce: s, scroll: e, polyfill: t, offsetSize: n } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const i = t || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!i)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [a, l] = je.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    u = je.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: a,
      orientationHandler: null,
    }),
    f = s ? (typeof s == "number" ? s : s.scroll) : null,
    d = s ? (typeof s == "number" ? s : s.resize) : null,
    m = je.useRef(!1);
  je.useEffect(() => ((m.current = !0), () => void (m.current = !1)));
  const [v, _, A] = je.useMemo(() => {
    const b = () => {
      if (!u.current.element) return;
      const {
          left: w,
          top: D,
          width: B,
          height: I,
          bottom: N,
          right: P,
          x: F,
          y: O,
        } = u.current.element.getBoundingClientRect(),
        U = {
          left: w,
          top: D,
          width: B,
          height: I,
          bottom: N,
          right: P,
          x: F,
          y: O,
        };
      u.current.element instanceof HTMLElement &&
        n &&
        ((U.height = u.current.element.offsetHeight),
        (U.width = u.current.element.offsetWidth)),
        Object.freeze(U),
        m.current &&
          !eI(u.current.lastBounds, U) &&
          l((u.current.lastBounds = U));
    };
    return [b, d ? Fb(b, d) : b, f ? Fb(b, f) : b];
  }, [l, n, f, d]);
  function M() {
    u.current.scrollContainers &&
      (u.current.scrollContainers.forEach((b) =>
        b.removeEventListener("scroll", A, !0)
      ),
      (u.current.scrollContainers = null)),
      u.current.resizeObserver &&
        (u.current.resizeObserver.disconnect(),
        (u.current.resizeObserver = null)),
      u.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              u.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              u.current.orientationHandler
            ));
  }
  function T() {
    u.current.element &&
      ((u.current.resizeObserver = new i(A)),
      u.current.resizeObserver.observe(u.current.element),
      e &&
        u.current.scrollContainers &&
        u.current.scrollContainers.forEach((b) =>
          b.addEventListener("scroll", A, { capture: !0, passive: !0 })
        ),
      (u.current.orientationHandler = () => {
        A();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            u.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            u.current.orientationHandler
          ));
  }
  const E = (b) => {
    !b ||
      b === u.current.element ||
      (M(), (u.current.element = b), (u.current.scrollContainers = x2(b)), T());
  };
  return (
    QN(A, !!e),
    ZN(_),
    je.useEffect(() => {
      M(), T();
    }, [e, A, _]),
    je.useEffect(() => M, []),
    [E, a, v]
  );
}
function ZN(s) {
  je.useEffect(() => {
    const e = s;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [s]);
}
function QN(s, e) {
  je.useEffect(() => {
    if (e) {
      const t = s;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [s, e]);
}
function x2(s) {
  const e = [];
  if (!s || s === document.body) return e;
  const {
    overflow: t,
    overflowX: n,
    overflowY: i,
  } = window.getComputedStyle(s);
  return (
    [t, n, i].some((a) => a === "auto" || a === "scroll") && e.push(s),
    [...e, ...x2(s.parentElement)]
  );
}
const $N = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  eI = (s, e) => $N.every((t) => s[t] === e[t]);
function tI({
  ref: s,
  children: e,
  fallback: t,
  resize: n,
  style: i,
  gl: a,
  events: l = jN,
  eventSource: u,
  eventPrefix: f,
  shadows: d,
  linear: m,
  flat: v,
  legacy: _,
  orthographic: A,
  frameloop: M,
  dpr: T,
  performance: E,
  raycaster: b,
  camera: w,
  scene: D,
  onPointerMissed: B,
  onCreated: I,
  ...N
}) {
  je.useMemo(() => Px(WL), []);
  const P = yN(),
    [F, O] = KN({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...n }),
    U = je.useRef(null),
    W = je.useRef(null);
  je.useImperativeHandle(s, () => U.current);
  const J = Nx(B),
    [q, Z] = je.useState(!1),
    [ue, K] = je.useState(!1);
  if (q) throw q;
  if (ue) throw ue;
  const ge = je.useRef(null);
  ng(() => {
    const me = U.current;
    if (O.width > 0 && O.height > 0 && me) {
      ge.current || (ge.current = kN(me));
      async function V() {
        await ge.current.configure({
          gl: a,
          scene: D,
          events: l,
          shadows: d,
          linear: m,
          flat: v,
          legacy: _,
          orthographic: A,
          frameloop: M,
          dpr: T,
          performance: E,
          raycaster: b,
          camera: w,
          size: O,
          onPointerMissed: (...Y) =>
            J.current == null ? void 0 : J.current(...Y),
          onCreated: (Y) => {
            Y.events.connect == null ||
              Y.events.connect(u ? (gN(u) ? u.current : u) : W.current),
              f &&
                Y.setEvents({
                  compute: (ae, fe) => {
                    const j = ae[f + "X"],
                      se = ae[f + "Y"];
                    fe.pointer.set(
                      (j / fe.size.width) * 2 - 1,
                      -(se / fe.size.height) * 2 + 1
                    ),
                      fe.raycaster.setFromCamera(fe.pointer, fe.camera);
                  },
                }),
              I == null || I(Y);
          },
        }),
          ge.current.render(
            Tt.jsx(P, {
              children: Tt.jsx(AN, {
                set: K,
                children: Tt.jsx(je.Suspense, {
                  fallback: Tt.jsx(_N, { set: Z }),
                  children: e ?? null,
                }),
              }),
            })
          );
      }
      V();
    }
  }),
    je.useEffect(() => {
      const me = U.current;
      if (me) return () => m2(me);
    }, []);
  const oe = u ? "none" : "auto";
  return Tt.jsx("div", {
    ref: W,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: oe,
      ...i,
    },
    ...N,
    children: Tt.jsx("div", {
      ref: F,
      style: { width: "100%", height: "100%" },
      children: Tt.jsx("canvas", {
        ref: U,
        style: { display: "block" },
        children: t,
      }),
    }),
  });
}
function nI(s) {
  return Tt.jsx(n2, { children: Tt.jsx(tI, { ...s }) });
}
function Mu() {
  return (
    (Mu = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t) ({}).hasOwnProperty.call(t, n) && (s[n] = t[n]);
          }
          return s;
        }),
    Mu.apply(null, arguments)
  );
}
const zx = parseInt(Od.replace(/\D+/g, ""));
function Pb(s, e) {
  if (e === HE)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      s
    );
  if (e === hy || e === ZA) {
    let t = s.getIndex();
    if (t === null) {
      const l = [],
        u = s.getAttribute("position");
      if (u !== void 0) {
        for (let f = 0; f < u.count; f++) l.push(f);
        s.setIndex(l), (t = s.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          s
        );
    }
    const n = t.count - 2,
      i = [];
    if (t)
      if (e === hy)
        for (let l = 1; l <= n; l++)
          i.push(t.getX(0)), i.push(t.getX(l)), i.push(t.getX(l + 1));
      else
        for (let l = 0; l < n; l++)
          l % 2 === 0
            ? (i.push(t.getX(l)), i.push(t.getX(l + 1)), i.push(t.getX(l + 2)))
            : (i.push(t.getX(l + 2)), i.push(t.getX(l + 1)), i.push(t.getX(l)));
    i.length / 3 !== n &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const a = s.clone();
    return a.setIndex(i), a.clearGroups(), a;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      s
    );
}
function iI(s, e = Math.PI / 3) {
  const t = Math.cos(e),
    n = (1 + 1e-10) * 100,
    i = [new ie(), new ie(), new ie()],
    a = new ie(),
    l = new ie(),
    u = new ie(),
    f = new ie();
  function d(T) {
    const E = ~~(T.x * n),
      b = ~~(T.y * n),
      w = ~~(T.z * n);
    return `${E},${b},${w}`;
  }
  const m = s.index ? s.toNonIndexed() : s,
    v = m.attributes.position,
    _ = {};
  for (let T = 0, E = v.count / 3; T < E; T++) {
    const b = 3 * T,
      w = i[0].fromBufferAttribute(v, b + 0),
      D = i[1].fromBufferAttribute(v, b + 1),
      B = i[2].fromBufferAttribute(v, b + 2);
    a.subVectors(B, D), l.subVectors(w, D);
    const I = new ie().crossVectors(a, l).normalize();
    for (let N = 0; N < 3; N++) {
      const P = i[N],
        F = d(P);
      F in _ || (_[F] = []), _[F].push(I);
    }
  }
  const A = new Float32Array(v.count * 3),
    M = new Yn(A, 3, !1);
  for (let T = 0, E = v.count / 3; T < E; T++) {
    const b = 3 * T,
      w = i[0].fromBufferAttribute(v, b + 0),
      D = i[1].fromBufferAttribute(v, b + 1),
      B = i[2].fromBufferAttribute(v, b + 2);
    a.subVectors(B, D), l.subVectors(w, D), u.crossVectors(a, l).normalize();
    for (let I = 0; I < 3; I++) {
      const N = i[I],
        P = d(N),
        F = _[P];
      f.set(0, 0, 0);
      for (let O = 0, U = F.length; O < U; O++) {
        const W = F[O];
        u.dot(W) > t && f.add(W);
      }
      f.normalize(), M.setXYZ(b + I, f.x, f.y, f.z);
    }
  }
  return m.setAttribute("normal", M), m;
}
var Fs = Uint8Array,
  gc = Uint16Array,
  OA = Uint32Array,
  S2 = new Fs([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0,
  ]),
  M2 = new Fs([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0,
  ]),
  aI = new Fs([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
  ]),
  b2 = function (s, e) {
    for (var t = new gc(31), n = 0; n < 31; ++n) t[n] = e += 1 << s[n - 1];
    for (var i = new OA(t[30]), n = 1; n < 30; ++n)
      for (var a = t[n]; a < t[n + 1]; ++a) i[a] = ((a - t[n]) << 5) | n;
    return [t, i];
  },
  E2 = b2(S2, 2),
  T2 = E2[0],
  rI = E2[1];
(T2[28] = 258), (rI[258] = 28);
var sI = b2(M2, 0),
  oI = sI[0],
  LA = new gc(32768);
for (var Ei = 0; Ei < 32768; ++Ei) {
  var dc = ((Ei & 43690) >>> 1) | ((Ei & 21845) << 1);
  (dc = ((dc & 52428) >>> 2) | ((dc & 13107) << 2)),
    (dc = ((dc & 61680) >>> 4) | ((dc & 3855) << 4)),
    (LA[Ei] = (((dc & 65280) >>> 8) | ((dc & 255) << 8)) >>> 1);
}
var Tm = function (s, e, t) {
    for (var n = s.length, i = 0, a = new gc(e); i < n; ++i) ++a[s[i] - 1];
    var l = new gc(e);
    for (i = 0; i < e; ++i) l[i] = (l[i - 1] + a[i - 1]) << 1;
    var u;
    if (t) {
      u = new gc(1 << e);
      var f = 15 - e;
      for (i = 0; i < n; ++i)
        if (s[i])
          for (
            var d = (i << 4) | s[i],
              m = e - s[i],
              v = l[s[i] - 1]++ << m,
              _ = v | ((1 << m) - 1);
            v <= _;
            ++v
          )
            u[LA[v] >>> f] = d;
    } else
      for (u = new gc(n), i = 0; i < n; ++i)
        s[i] && (u[i] = LA[l[s[i] - 1]++] >>> (15 - s[i]));
    return u;
  },
  ig = new Fs(288);
for (var Ei = 0; Ei < 144; ++Ei) ig[Ei] = 8;
for (var Ei = 144; Ei < 256; ++Ei) ig[Ei] = 9;
for (var Ei = 256; Ei < 280; ++Ei) ig[Ei] = 7;
for (var Ei = 280; Ei < 288; ++Ei) ig[Ei] = 8;
var C2 = new Fs(32);
for (var Ei = 0; Ei < 32; ++Ei) C2[Ei] = 5;
var lI = Tm(ig, 9, 1),
  uI = Tm(C2, 5, 1),
  Q1 = function (s) {
    for (var e = s[0], t = 1; t < s.length; ++t) s[t] > e && (e = s[t]);
    return e;
  },
  Ro = function (s, e, t) {
    var n = (e / 8) | 0;
    return ((s[n] | (s[n + 1] << 8)) >> (e & 7)) & t;
  },
  $1 = function (s, e) {
    var t = (e / 8) | 0;
    return (s[t] | (s[t + 1] << 8) | (s[t + 2] << 16)) >> (e & 7);
  },
  cI = function (s) {
    return ((s / 8) | 0) + (s & 7 && 1);
  },
  fI = function (s, e, t) {
    (t == null || t > s.length) && (t = s.length);
    var n = new (s instanceof gc ? gc : s instanceof OA ? OA : Fs)(t - e);
    return n.set(s.subarray(e, t)), n;
  },
  hI = function (s, e, t) {
    var n = s.length;
    if (!n || (t && !t.l && n < 5)) return e || new Fs(0);
    var i = !e || t,
      a = !t || t.i;
    t || (t = {}), e || (e = new Fs(n * 3));
    var l = function (ve) {
        var ye = e.length;
        if (ve > ye) {
          var be = new Fs(Math.max(ye * 2, ve));
          be.set(e), (e = be);
        }
      },
      u = t.f || 0,
      f = t.p || 0,
      d = t.b || 0,
      m = t.l,
      v = t.d,
      _ = t.m,
      A = t.n,
      M = n * 8;
    do {
      if (!m) {
        t.f = u = Ro(s, f, 1);
        var T = Ro(s, f + 1, 3);
        if (((f += 3), T))
          if (T == 1) (m = lI), (v = uI), (_ = 9), (A = 5);
          else if (T == 2) {
            var D = Ro(s, f, 31) + 257,
              B = Ro(s, f + 10, 15) + 4,
              I = D + Ro(s, f + 5, 31) + 1;
            f += 14;
            for (var N = new Fs(I), P = new Fs(19), F = 0; F < B; ++F)
              P[aI[F]] = Ro(s, f + F * 3, 7);
            f += B * 3;
            for (
              var O = Q1(P), U = (1 << O) - 1, W = Tm(P, O, 1), F = 0;
              F < I;

            ) {
              var J = W[Ro(s, f, U)];
              f += J & 15;
              var E = J >>> 4;
              if (E < 16) N[F++] = E;
              else {
                var q = 0,
                  Z = 0;
                for (
                  E == 16
                    ? ((Z = 3 + Ro(s, f, 3)), (f += 2), (q = N[F - 1]))
                    : E == 17
                    ? ((Z = 3 + Ro(s, f, 7)), (f += 3))
                    : E == 18 && ((Z = 11 + Ro(s, f, 127)), (f += 7));
                  Z--;

                )
                  N[F++] = q;
              }
            }
            var ue = N.subarray(0, D),
              K = N.subarray(D);
            (_ = Q1(ue)), (A = Q1(K)), (m = Tm(ue, _, 1)), (v = Tm(K, A, 1));
          } else throw "invalid block type";
        else {
          var E = cI(f) + 4,
            b = s[E - 4] | (s[E - 3] << 8),
            w = E + b;
          if (w > n) {
            if (a) throw "unexpected EOF";
            break;
          }
          i && l(d + b),
            e.set(s.subarray(E, w), d),
            (t.b = d += b),
            (t.p = f = w * 8);
          continue;
        }
        if (f > M) {
          if (a) throw "unexpected EOF";
          break;
        }
      }
      i && l(d + 131072);
      for (var ge = (1 << _) - 1, oe = (1 << A) - 1, me = f; ; me = f) {
        var q = m[$1(s, f) & ge],
          V = q >>> 4;
        if (((f += q & 15), f > M)) {
          if (a) throw "unexpected EOF";
          break;
        }
        if (!q) throw "invalid length/literal";
        if (V < 256) e[d++] = V;
        else if (V == 256) {
          (me = f), (m = null);
          break;
        } else {
          var Y = V - 254;
          if (V > 264) {
            var F = V - 257,
              ae = S2[F];
            (Y = Ro(s, f, (1 << ae) - 1) + T2[F]), (f += ae);
          }
          var fe = v[$1(s, f) & oe],
            j = fe >>> 4;
          if (!fe) throw "invalid distance";
          f += fe & 15;
          var K = oI[j];
          if (j > 3) {
            var ae = M2[j];
            (K += $1(s, f) & ((1 << ae) - 1)), (f += ae);
          }
          if (f > M) {
            if (a) throw "unexpected EOF";
            break;
          }
          i && l(d + 131072);
          for (var se = d + Y; d < se; d += 4)
            (e[d] = e[d - K]),
              (e[d + 1] = e[d + 1 - K]),
              (e[d + 2] = e[d + 2 - K]),
              (e[d + 3] = e[d + 3 - K]);
          d = se;
        }
      }
      (t.l = m),
        (t.p = me),
        (t.b = d),
        m && ((u = 1), (t.m = _), (t.d = v), (t.n = A));
    } while (!u);
    return d == e.length ? e : fI(e, 0, d);
  },
  dI = new Fs(0),
  pI = function (s) {
    if ((s[0] & 15) != 8 || s[0] >>> 4 > 7 || ((s[0] << 8) | s[1]) % 31)
      throw "invalid zlib data";
    if (s[1] & 32) throw "invalid zlib data: preset dictionaries not supported";
  };
function v0(s, e) {
  return hI((pI(s), s.subarray(2, -4)), e);
}
var mI = typeof TextDecoder < "u" && new TextDecoder(),
  gI = 0;
try {
  mI.decode(dI, { stream: !0 }), (gI = 1);
} catch {}
const vI = (s) => s && s.isCubeTexture;
class yI extends li {
  constructor(e, t) {
    var n, i;
    const a = vI(e),
      u =
        ((i = a
          ? (n = e.image[0]) == null
            ? void 0
            : n.width
          : e.image.width) != null
          ? i
          : 1024) / 4,
      f = Math.floor(Math.log2(u)),
      d = Math.pow(2, f),
      m = 3 * Math.max(d, 16 * 7),
      v = 4 * d,
      _ = [
        a ? "#define ENVMAP_TYPE_CUBE" : "",
        `#define CUBEUV_TEXEL_WIDTH ${1 / m}`,
        `#define CUBEUV_TEXEL_HEIGHT ${1 / v}`,
        `#define CUBEUV_MAX_MIP ${f}.0`,
      ],
      A = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,
      M =
        _.join(`
`) +
        `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${
              zx >= 154 ? "colorspace_fragment" : "encodings_fragment"
            }>
        }
        `,
      T = {
        map: { value: e },
        height: { value: (t == null ? void 0 : t.height) || 15 },
        radius: { value: (t == null ? void 0 : t.radius) || 100 },
      },
      E = new Zm(1, 16),
      b = new ra({ uniforms: T, fragmentShader: M, vertexShader: A, side: jr });
    super(E, b);
  }
  set radius(e) {
    this.material.uniforms.radius.value = e;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(e) {
    this.material.uniforms.height.value = e;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
}
var _I = Object.defineProperty,
  AI = (s, e, t) =>
    e in s
      ? _I(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  xI = (s, e, t) => (AI(s, e + "", t), t);
class SI {
  constructor() {
    xI(this, "_listeners");
  }
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const a = i.indexOf(t);
      a !== -1 && i.splice(a, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let a = 0, l = i.length; a < l; a++) i[a].call(this, e);
      e.target = null;
    }
  }
}
var MI = Object.defineProperty,
  bI = (s, e, t) =>
    e in s
      ? MI(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  $t = (s, e, t) => (bI(s, typeof e != "symbol" ? e + "" : e, t), t);
const y0 = new $f(),
  Gb = new mu(),
  EI = Math.cos(70 * (Math.PI / 180)),
  zb = (s, e) => ((s % e) + e) % e;
let TI = class extends SI {
  constructor(e, t) {
    super(),
      $t(this, "object"),
      $t(this, "domElement"),
      $t(this, "enabled", !0),
      $t(this, "target", new ie()),
      $t(this, "minDistance", 0),
      $t(this, "maxDistance", 1 / 0),
      $t(this, "minZoom", 0),
      $t(this, "maxZoom", 1 / 0),
      $t(this, "minPolarAngle", 0),
      $t(this, "maxPolarAngle", Math.PI),
      $t(this, "minAzimuthAngle", -1 / 0),
      $t(this, "maxAzimuthAngle", 1 / 0),
      $t(this, "enableDamping", !1),
      $t(this, "dampingFactor", 0.05),
      $t(this, "enableZoom", !0),
      $t(this, "zoomSpeed", 1),
      $t(this, "enableRotate", !0),
      $t(this, "rotateSpeed", 1),
      $t(this, "enablePan", !0),
      $t(this, "panSpeed", 1),
      $t(this, "screenSpacePanning", !0),
      $t(this, "keyPanSpeed", 7),
      $t(this, "zoomToCursor", !1),
      $t(this, "autoRotate", !1),
      $t(this, "autoRotateSpeed", 2),
      $t(this, "reverseOrbit", !1),
      $t(this, "reverseHorizontalOrbit", !1),
      $t(this, "reverseVerticalOrbit", !1),
      $t(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      $t(this, "mouseButtons", {
        LEFT: Rf.ROTATE,
        MIDDLE: Rf.DOLLY,
        RIGHT: Rf.PAN,
      }),
      $t(this, "touches", { ONE: wf.ROTATE, TWO: wf.DOLLY_PAN }),
      $t(this, "target0"),
      $t(this, "position0"),
      $t(this, "zoom0"),
      $t(this, "_domElementKeyEvents", null),
      $t(this, "getPolarAngle"),
      $t(this, "getAzimuthalAngle"),
      $t(this, "setPolarAngle"),
      $t(this, "setAzimuthalAngle"),
      $t(this, "getDistance"),
      $t(this, "getZoomScale"),
      $t(this, "listenToKeyEvents"),
      $t(this, "stopListenToKeyEvents"),
      $t(this, "saveState"),
      $t(this, "reset"),
      $t(this, "update"),
      $t(this, "connect"),
      $t(this, "dispose"),
      $t(this, "dollyIn"),
      $t(this, "dollyOut"),
      $t(this, "getScale"),
      $t(this, "setScale"),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => m.phi),
      (this.getAzimuthalAngle = () => m.theta),
      (this.setPolarAngle = (le) => {
        let Be = zb(le, 2 * Math.PI),
          vt = m.phi;
        vt < 0 && (vt += 2 * Math.PI), Be < 0 && (Be += 2 * Math.PI);
        let ce = Math.abs(Be - vt);
        2 * Math.PI - ce < ce &&
          (Be < vt ? (Be += 2 * Math.PI) : (vt += 2 * Math.PI)),
          (v.phi = Be - vt),
          n.update();
      }),
      (this.setAzimuthalAngle = (le) => {
        let Be = zb(le, 2 * Math.PI),
          vt = m.theta;
        vt < 0 && (vt += 2 * Math.PI), Be < 0 && (Be += 2 * Math.PI);
        let ce = Math.abs(Be - vt);
        2 * Math.PI - ce < ce &&
          (Be < vt ? (Be += 2 * Math.PI) : (vt += 2 * Math.PI)),
          (v.theta = Be - vt),
          n.update();
      }),
      (this.getDistance = () => n.object.position.distanceTo(n.target)),
      (this.listenToKeyEvents = (le) => {
        le.addEventListener("keydown", Ke), (this._domElementKeyEvents = le);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", Ke),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        n.target0.copy(n.target),
          n.position0.copy(n.object.position),
          (n.zoom0 = n.object.zoom);
      }),
      (this.reset = () => {
        n.target.copy(n.target0),
          n.object.position.copy(n.position0),
          (n.object.zoom = n.zoom0),
          n.object.updateProjectionMatrix(),
          n.dispatchEvent(i),
          n.update(),
          (f = u.NONE);
      }),
      (this.update = (() => {
        const le = new ie(),
          Be = new ie(0, 1, 0),
          vt = new La().setFromUnitVectors(e.up, Be),
          ce = vt.clone().invert(),
          xe = new ie(),
          Re = new La(),
          Qe = 2 * Math.PI;
        return function () {
          const dt = n.object.position;
          vt.setFromUnitVectors(e.up, Be),
            ce.copy(vt).invert(),
            le.copy(dt).sub(n.target),
            le.applyQuaternion(vt),
            m.setFromVector3(le),
            n.autoRotate && f === u.NONE && Z(J()),
            n.enableDamping
              ? ((m.theta += v.theta * n.dampingFactor),
                (m.phi += v.phi * n.dampingFactor))
              : ((m.theta += v.theta), (m.phi += v.phi));
          let Ct = n.minAzimuthAngle,
            Ht = n.maxAzimuthAngle;
          isFinite(Ct) &&
            isFinite(Ht) &&
            (Ct < -Math.PI ? (Ct += Qe) : Ct > Math.PI && (Ct -= Qe),
            Ht < -Math.PI ? (Ht += Qe) : Ht > Math.PI && (Ht -= Qe),
            Ct <= Ht
              ? (m.theta = Math.max(Ct, Math.min(Ht, m.theta)))
              : (m.theta =
                  m.theta > (Ct + Ht) / 2
                    ? Math.max(Ct, m.theta)
                    : Math.min(Ht, m.theta))),
            (m.phi = Math.max(
              n.minPolarAngle,
              Math.min(n.maxPolarAngle, m.phi)
            )),
            m.makeSafe(),
            n.enableDamping === !0
              ? n.target.addScaledVector(A, n.dampingFactor)
              : n.target.add(A),
            (n.zoomToCursor && O) || n.object.isOrthographicCamera
              ? (m.radius = fe(m.radius))
              : (m.radius = fe(m.radius * _)),
            le.setFromSpherical(m),
            le.applyQuaternion(ce),
            dt.copy(n.target).add(le),
            n.object.matrixAutoUpdate || n.object.updateMatrix(),
            n.object.lookAt(n.target),
            n.enableDamping === !0
              ? ((v.theta *= 1 - n.dampingFactor),
                (v.phi *= 1 - n.dampingFactor),
                A.multiplyScalar(1 - n.dampingFactor))
              : (v.set(0, 0, 0), A.set(0, 0, 0));
          let Nt = !1;
          if (n.zoomToCursor && O) {
            let Ft = null;
            if (n.object instanceof $i && n.object.isPerspectiveCamera) {
              const gn = le.length();
              Ft = fe(gn * _);
              const vn = gn - Ft;
              n.object.position.addScaledVector(P, vn),
                n.object.updateMatrixWorld();
            } else if (n.object.isOrthographicCamera) {
              const gn = new ie(F.x, F.y, 0);
              gn.unproject(n.object),
                (n.object.zoom = Math.max(
                  n.minZoom,
                  Math.min(n.maxZoom, n.object.zoom / _)
                )),
                n.object.updateProjectionMatrix(),
                (Nt = !0);
              const vn = new ie(F.x, F.y, 0);
              vn.unproject(n.object),
                n.object.position.sub(vn).add(gn),
                n.object.updateMatrixWorld(),
                (Ft = le.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (n.zoomToCursor = !1);
            Ft !== null &&
              (n.screenSpacePanning
                ? n.target
                    .set(0, 0, -1)
                    .transformDirection(n.object.matrix)
                    .multiplyScalar(Ft)
                    .add(n.object.position)
                : (y0.origin.copy(n.object.position),
                  y0.direction
                    .set(0, 0, -1)
                    .transformDirection(n.object.matrix),
                  Math.abs(n.object.up.dot(y0.direction)) < EI
                    ? e.lookAt(n.target)
                    : (Gb.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                      y0.intersectPlane(Gb, n.target))));
          } else
            n.object instanceof Ps &&
              n.object.isOrthographicCamera &&
              ((Nt = _ !== 1),
              Nt &&
                ((n.object.zoom = Math.max(
                  n.minZoom,
                  Math.min(n.maxZoom, n.object.zoom / _)
                )),
                n.object.updateProjectionMatrix()));
          return (
            (_ = 1),
            (O = !1),
            Nt ||
            xe.distanceToSquared(n.object.position) > d ||
            8 * (1 - Re.dot(n.object.quaternion)) > d
              ? (n.dispatchEvent(i),
                xe.copy(n.object.position),
                Re.copy(n.object.quaternion),
                (Nt = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (le) => {
        (n.domElement = le),
          (n.domElement.style.touchAction = "none"),
          n.domElement.addEventListener("contextmenu", et),
          n.domElement.addEventListener("pointerdown", k),
          n.domElement.addEventListener("pointercancel", Ee),
          n.domElement.addEventListener("wheel", tt);
      }),
      (this.dispose = () => {
        var le, Be, vt, ce, xe, Re;
        n.domElement && (n.domElement.style.touchAction = "auto"),
          (le = n.domElement) == null ||
            le.removeEventListener("contextmenu", et),
          (Be = n.domElement) == null ||
            Be.removeEventListener("pointerdown", k),
          (vt = n.domElement) == null ||
            vt.removeEventListener("pointercancel", Ee),
          (ce = n.domElement) == null || ce.removeEventListener("wheel", tt),
          (xe = n.domElement) == null ||
            xe.ownerDocument.removeEventListener("pointermove", de),
          (Re = n.domElement) == null ||
            Re.ownerDocument.removeEventListener("pointerup", Ee),
          n._domElementKeyEvents !== null &&
            n._domElementKeyEvents.removeEventListener("keydown", Ke);
      });
    const n = this,
      i = { type: "change" },
      a = { type: "start" },
      l = { type: "end" },
      u = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let f = u.NONE;
    const d = 1e-6,
      m = new bA(),
      v = new bA();
    let _ = 1;
    const A = new ie(),
      M = new at(),
      T = new at(),
      E = new at(),
      b = new at(),
      w = new at(),
      D = new at(),
      B = new at(),
      I = new at(),
      N = new at(),
      P = new ie(),
      F = new at();
    let O = !1;
    const U = [],
      W = {};
    function J() {
      return ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
    }
    function q() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function Z(le) {
      n.reverseOrbit || n.reverseHorizontalOrbit
        ? (v.theta += le)
        : (v.theta -= le);
    }
    function ue(le) {
      n.reverseOrbit || n.reverseVerticalOrbit ? (v.phi += le) : (v.phi -= le);
    }
    const K = (() => {
        const le = new ie();
        return function (vt, ce) {
          le.setFromMatrixColumn(ce, 0), le.multiplyScalar(-vt), A.add(le);
        };
      })(),
      ge = (() => {
        const le = new ie();
        return function (vt, ce) {
          n.screenSpacePanning === !0
            ? le.setFromMatrixColumn(ce, 1)
            : (le.setFromMatrixColumn(ce, 0), le.crossVectors(n.object.up, le)),
            le.multiplyScalar(vt),
            A.add(le);
        };
      })(),
      oe = (() => {
        const le = new ie();
        return function (vt, ce) {
          const xe = n.domElement;
          if (xe && n.object instanceof $i && n.object.isPerspectiveCamera) {
            const Re = n.object.position;
            le.copy(Re).sub(n.target);
            let Qe = le.length();
            (Qe *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
              K((2 * vt * Qe) / xe.clientHeight, n.object.matrix),
              ge((2 * ce * Qe) / xe.clientHeight, n.object.matrix);
          } else
            xe && n.object instanceof Ps && n.object.isOrthographicCamera
              ? (K(
                  (vt * (n.object.right - n.object.left)) /
                    n.object.zoom /
                    xe.clientWidth,
                  n.object.matrix
                ),
                ge(
                  (ce * (n.object.top - n.object.bottom)) /
                    n.object.zoom /
                    xe.clientHeight,
                  n.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (n.enablePan = !1));
        };
      })();
    function me(le) {
      (n.object instanceof $i && n.object.isPerspectiveCamera) ||
      (n.object instanceof Ps && n.object.isOrthographicCamera)
        ? (_ = le)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (n.enableZoom = !1));
    }
    function V(le) {
      me(_ / le);
    }
    function Y(le) {
      me(_ * le);
    }
    function ae(le) {
      if (!n.zoomToCursor || !n.domElement) return;
      O = !0;
      const Be = n.domElement.getBoundingClientRect(),
        vt = le.clientX - Be.left,
        ce = le.clientY - Be.top,
        xe = Be.width,
        Re = Be.height;
      (F.x = (vt / xe) * 2 - 1),
        (F.y = -(ce / Re) * 2 + 1),
        P.set(F.x, F.y, 1)
          .unproject(n.object)
          .sub(n.object.position)
          .normalize();
    }
    function fe(le) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, le));
    }
    function j(le) {
      M.set(le.clientX, le.clientY);
    }
    function se(le) {
      ae(le), B.set(le.clientX, le.clientY);
    }
    function ve(le) {
      b.set(le.clientX, le.clientY);
    }
    function ye(le) {
      T.set(le.clientX, le.clientY),
        E.subVectors(T, M).multiplyScalar(n.rotateSpeed);
      const Be = n.domElement;
      Be &&
        (Z((2 * Math.PI * E.x) / Be.clientHeight),
        ue((2 * Math.PI * E.y) / Be.clientHeight)),
        M.copy(T),
        n.update();
    }
    function be(le) {
      I.set(le.clientX, le.clientY),
        N.subVectors(I, B),
        N.y > 0 ? V(q()) : N.y < 0 && Y(q()),
        B.copy(I),
        n.update();
    }
    function it(le) {
      w.set(le.clientX, le.clientY),
        D.subVectors(w, b).multiplyScalar(n.panSpeed),
        oe(D.x, D.y),
        b.copy(w),
        n.update();
    }
    function We(le) {
      ae(le), le.deltaY < 0 ? Y(q()) : le.deltaY > 0 && V(q()), n.update();
    }
    function $e(le) {
      let Be = !1;
      switch (le.code) {
        case n.keys.UP:
          oe(0, n.keyPanSpeed), (Be = !0);
          break;
        case n.keys.BOTTOM:
          oe(0, -n.keyPanSpeed), (Be = !0);
          break;
        case n.keys.LEFT:
          oe(n.keyPanSpeed, 0), (Be = !0);
          break;
        case n.keys.RIGHT:
          oe(-n.keyPanSpeed, 0), (Be = !0);
          break;
      }
      Be && (le.preventDefault(), n.update());
    }
    function Me() {
      if (U.length == 1) M.set(U[0].pageX, U[0].pageY);
      else {
        const le = 0.5 * (U[0].pageX + U[1].pageX),
          Be = 0.5 * (U[0].pageY + U[1].pageY);
        M.set(le, Be);
      }
    }
    function Ie() {
      if (U.length == 1) b.set(U[0].pageX, U[0].pageY);
      else {
        const le = 0.5 * (U[0].pageX + U[1].pageX),
          Be = 0.5 * (U[0].pageY + U[1].pageY);
        b.set(le, Be);
      }
    }
    function $() {
      const le = U[0].pageX - U[1].pageX,
        Be = U[0].pageY - U[1].pageY,
        vt = Math.sqrt(le * le + Be * Be);
      B.set(0, vt);
    }
    function ft() {
      n.enableZoom && $(), n.enablePan && Ie();
    }
    function Pe() {
      n.enableZoom && $(), n.enableRotate && Me();
    }
    function rt(le) {
      if (U.length == 1) T.set(le.pageX, le.pageY);
      else {
        const vt = Ze(le),
          ce = 0.5 * (le.pageX + vt.x),
          xe = 0.5 * (le.pageY + vt.y);
        T.set(ce, xe);
      }
      E.subVectors(T, M).multiplyScalar(n.rotateSpeed);
      const Be = n.domElement;
      Be &&
        (Z((2 * Math.PI * E.x) / Be.clientHeight),
        ue((2 * Math.PI * E.y) / Be.clientHeight)),
        M.copy(T);
    }
    function Ue(le) {
      if (U.length == 1) w.set(le.pageX, le.pageY);
      else {
        const Be = Ze(le),
          vt = 0.5 * (le.pageX + Be.x),
          ce = 0.5 * (le.pageY + Be.y);
        w.set(vt, ce);
      }
      D.subVectors(w, b).multiplyScalar(n.panSpeed), oe(D.x, D.y), b.copy(w);
    }
    function ht(le) {
      const Be = Ze(le),
        vt = le.pageX - Be.x,
        ce = le.pageY - Be.y,
        xe = Math.sqrt(vt * vt + ce * ce);
      I.set(0, xe),
        N.set(0, Math.pow(I.y / B.y, n.zoomSpeed)),
        V(N.y),
        B.copy(I);
    }
    function Ve(le) {
      n.enableZoom && ht(le), n.enablePan && Ue(le);
    }
    function X(le) {
      n.enableZoom && ht(le), n.enableRotate && rt(le);
    }
    function k(le) {
      var Be, vt;
      n.enabled !== !1 &&
        (U.length === 0 &&
          ((Be = n.domElement) == null ||
            Be.ownerDocument.addEventListener("pointermove", de),
          (vt = n.domElement) == null ||
            vt.ownerDocument.addEventListener("pointerup", Ee)),
        At(le),
        le.pointerType === "touch" ? st(le) : we(le));
    }
    function de(le) {
      n.enabled !== !1 && (le.pointerType === "touch" ? Ut(le) : He(le));
    }
    function Ee(le) {
      var Be, vt, ce;
      mt(le),
        U.length === 0 &&
          ((Be = n.domElement) == null ||
            Be.releasePointerCapture(le.pointerId),
          (vt = n.domElement) == null ||
            vt.ownerDocument.removeEventListener("pointermove", de),
          (ce = n.domElement) == null ||
            ce.ownerDocument.removeEventListener("pointerup", Ee)),
        n.dispatchEvent(l),
        (f = u.NONE);
    }
    function we(le) {
      let Be;
      switch (le.button) {
        case 0:
          Be = n.mouseButtons.LEFT;
          break;
        case 1:
          Be = n.mouseButtons.MIDDLE;
          break;
        case 2:
          Be = n.mouseButtons.RIGHT;
          break;
        default:
          Be = -1;
      }
      switch (Be) {
        case Rf.DOLLY:
          if (n.enableZoom === !1) return;
          se(le), (f = u.DOLLY);
          break;
        case Rf.ROTATE:
          if (le.ctrlKey || le.metaKey || le.shiftKey) {
            if (n.enablePan === !1) return;
            ve(le), (f = u.PAN);
          } else {
            if (n.enableRotate === !1) return;
            j(le), (f = u.ROTATE);
          }
          break;
        case Rf.PAN:
          if (le.ctrlKey || le.metaKey || le.shiftKey) {
            if (n.enableRotate === !1) return;
            j(le), (f = u.ROTATE);
          } else {
            if (n.enablePan === !1) return;
            ve(le), (f = u.PAN);
          }
          break;
        default:
          f = u.NONE;
      }
      f !== u.NONE && n.dispatchEvent(a);
    }
    function He(le) {
      if (n.enabled !== !1)
        switch (f) {
          case u.ROTATE:
            if (n.enableRotate === !1) return;
            ye(le);
            break;
          case u.DOLLY:
            if (n.enableZoom === !1) return;
            be(le);
            break;
          case u.PAN:
            if (n.enablePan === !1) return;
            it(le);
            break;
        }
    }
    function tt(le) {
      n.enabled === !1 ||
        n.enableZoom === !1 ||
        (f !== u.NONE && f !== u.ROTATE) ||
        (le.preventDefault(), n.dispatchEvent(a), We(le), n.dispatchEvent(l));
    }
    function Ke(le) {
      n.enabled === !1 || n.enablePan === !1 || $e(le);
    }
    function st(le) {
      switch ((nt(le), U.length)) {
        case 1:
          switch (n.touches.ONE) {
            case wf.ROTATE:
              if (n.enableRotate === !1) return;
              Me(), (f = u.TOUCH_ROTATE);
              break;
            case wf.PAN:
              if (n.enablePan === !1) return;
              Ie(), (f = u.TOUCH_PAN);
              break;
            default:
              f = u.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case wf.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1) return;
              ft(), (f = u.TOUCH_DOLLY_PAN);
              break;
            case wf.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1) return;
              Pe(), (f = u.TOUCH_DOLLY_ROTATE);
              break;
            default:
              f = u.NONE;
          }
          break;
        default:
          f = u.NONE;
      }
      f !== u.NONE && n.dispatchEvent(a);
    }
    function Ut(le) {
      switch ((nt(le), f)) {
        case u.TOUCH_ROTATE:
          if (n.enableRotate === !1) return;
          rt(le), n.update();
          break;
        case u.TOUCH_PAN:
          if (n.enablePan === !1) return;
          Ue(le), n.update();
          break;
        case u.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1) return;
          Ve(le), n.update();
          break;
        case u.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1) return;
          X(le), n.update();
          break;
        default:
          f = u.NONE;
      }
    }
    function et(le) {
      n.enabled !== !1 && le.preventDefault();
    }
    function At(le) {
      U.push(le);
    }
    function mt(le) {
      delete W[le.pointerId];
      for (let Be = 0; Be < U.length; Be++)
        if (U[Be].pointerId == le.pointerId) {
          U.splice(Be, 1);
          return;
        }
    }
    function nt(le) {
      let Be = W[le.pointerId];
      Be === void 0 && ((Be = new at()), (W[le.pointerId] = Be)),
        Be.set(le.pageX, le.pageY);
    }
    function Ze(le) {
      const Be = le.pointerId === U[0].pointerId ? U[1] : U[0];
      return W[Be.pointerId];
    }
    (this.dollyIn = (le = q()) => {
      Y(le), n.update();
    }),
      (this.dollyOut = (le = q()) => {
        V(le), n.update();
      }),
      (this.getScale = () => _),
      (this.setScale = (le) => {
        me(le), n.update();
      }),
      (this.getZoomScale = () => q()),
      t !== void 0 && this.connect(t),
      this.update();
  }
};
var CI = Object.defineProperty,
  RI = (s, e, t) =>
    e in s
      ? CI(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  eA = (s, e, t) => (RI(s, typeof e != "symbol" ? e + "" : e, t), t);
class pd {
  constructor(e) {
    eA(this, "camera", new Ps(-1, 1, 1, -1, 0, 1)),
      eA(this, "geometry", new zs(2, 2)),
      eA(this, "mesh"),
      (this.mesh = new li(this.geometry, e));
  }
  get material() {
    return this.mesh.material;
  }
  set material(e) {
    this.mesh.material = e;
  }
  dispose() {
    this.mesh.geometry.dispose();
  }
  render(e) {
    e.render(this.mesh, this.camera);
  }
}
function xy(s) {
  if (typeof TextDecoder < "u") return new TextDecoder().decode(s);
  let e = "";
  for (let t = 0, n = s.length; t < n; t++) e += String.fromCharCode(s[t]);
  try {
    return decodeURIComponent(escape(e));
  } catch {
    return e;
  }
}
const zf = "srgb",
  xu = "srgb-linear",
  Hb = 3001,
  wI = 3e3;
class Hx extends qa {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new LI(t);
      }),
      this.register(function (t) {
        return new NI(t);
      }),
      this.register(function (t) {
        return new XI(t);
      }),
      this.register(function (t) {
        return new YI(t);
      }),
      this.register(function (t) {
        return new WI(t);
      }),
      this.register(function (t) {
        return new FI(t);
      }),
      this.register(function (t) {
        return new PI(t);
      }),
      this.register(function (t) {
        return new GI(t);
      }),
      this.register(function (t) {
        return new zI(t);
      }),
      this.register(function (t) {
        return new OI(t);
      }),
      this.register(function (t) {
        return new HI(t);
      }),
      this.register(function (t) {
        return new II(t);
      }),
      this.register(function (t) {
        return new kI(t);
      }),
      this.register(function (t) {
        return new VI(t);
      }),
      this.register(function (t) {
        return new DI(t);
      }),
      this.register(function (t) {
        return new JI(t);
      }),
      this.register(function (t) {
        return new qI(t);
      });
  }
  load(e, t, n, i) {
    const a = this;
    let l;
    if (this.resourcePath !== "") l = this.resourcePath;
    else if (this.path !== "") {
      const d = _c.extractUrlBase(e);
      l = _c.resolveURL(d, this.path);
    } else l = _c.extractUrlBase(e);
    this.manager.itemStart(e);
    const u = function (d) {
        i ? i(d) : console.error(d),
          a.manager.itemError(e),
          a.manager.itemEnd(e);
      },
      f = new Ja(this.manager);
    f.setPath(this.path),
      f.setResponseType("arraybuffer"),
      f.setRequestHeader(this.requestHeader),
      f.setWithCredentials(this.withCredentials),
      f.load(
        e,
        function (d) {
          try {
            a.parse(
              d,
              l,
              function (m) {
                t(m), a.manager.itemEnd(e);
              },
              u
            );
          } catch (m) {
            u(m);
          }
        },
        n,
        u
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, n, i) {
    let a;
    const l = {},
      u = {};
    if (typeof e == "string") a = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (xy(new Uint8Array(e.slice(0, 4))) === R2) {
        try {
          l[Un.KHR_BINARY_GLTF] = new jI(e);
        } catch (m) {
          i && i(m);
          return;
        }
        a = JSON.parse(l[Un.KHR_BINARY_GLTF].content);
      } else a = JSON.parse(xy(new Uint8Array(e)));
    else a = e;
    if (a.asset === void 0 || a.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const f = new lF(a, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    f.fileLoader.setRequestHeader(this.requestHeader);
    for (let d = 0; d < this.pluginCallbacks.length; d++) {
      const m = this.pluginCallbacks[d](f);
      m.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (u[m.name] = m),
        (l[m.name] = !0);
    }
    if (a.extensionsUsed)
      for (let d = 0; d < a.extensionsUsed.length; ++d) {
        const m = a.extensionsUsed[d],
          v = a.extensionsRequired || [];
        switch (m) {
          case Un.KHR_MATERIALS_UNLIT:
            l[m] = new UI();
            break;
          case Un.KHR_DRACO_MESH_COMPRESSION:
            l[m] = new KI(a, this.dracoLoader);
            break;
          case Un.KHR_TEXTURE_TRANSFORM:
            l[m] = new ZI();
            break;
          case Un.KHR_MESH_QUANTIZATION:
            l[m] = new QI();
            break;
          default:
            v.indexOf(m) >= 0 &&
              u[m] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + m + '".');
        }
      }
    f.setExtensions(l), f.setPlugins(u), f.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function (i, a) {
      n.parse(e, t, i, a);
    });
  }
}
function BI() {
  let s = {};
  return {
    get: function (e) {
      return s[e];
    },
    add: function (e, t) {
      s[e] = t;
    },
    remove: function (e) {
      delete s[e];
    },
    removeAll: function () {
      s = {};
    },
  };
}
const Un = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class DI {
  constructor(e) {
    (this.parser = e),
      (this.name = Un.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const a = t[n];
      a.extensions &&
        a.extensions[this.name] &&
        a.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, a.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      n = "light:" + e;
    let i = t.cache.get(n);
    if (i) return i;
    const a = t.json,
      f = (((a.extensions && a.extensions[this.name]) || {}).lights || [])[e];
    let d;
    const m = new Dt(16777215);
    f.color !== void 0 && m.setRGB(f.color[0], f.color[1], f.color[2], xu);
    const v = f.range !== void 0 ? f.range : 0;
    switch (f.type) {
      case "directional":
        (d = new Mx(m)), d.target.position.set(0, 0, -1), d.add(d.target);
        break;
      case "point":
        (d = new Sx(m)), (d.distance = v);
        break;
      case "spot":
        (d = new xx(m)),
          (d.distance = v),
          (f.spot = f.spot || {}),
          (f.spot.innerConeAngle =
            f.spot.innerConeAngle !== void 0 ? f.spot.innerConeAngle : 0),
          (f.spot.outerConeAngle =
            f.spot.outerConeAngle !== void 0
              ? f.spot.outerConeAngle
              : Math.PI / 4),
          (d.angle = f.spot.outerConeAngle),
          (d.penumbra = 1 - f.spot.innerConeAngle / f.spot.outerConeAngle),
          d.target.position.set(0, 0, -1),
          d.add(d.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + f.type);
    }
    return (
      d.position.set(0, 0, 0),
      (d.decay = 2),
      pu(d, f),
      f.intensity !== void 0 && (d.intensity = f.intensity),
      (d.name = t.createUniqueName(f.name || "light_" + e)),
      (i = Promise.resolve(d)),
      t.cache.add(n, i),
      i
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      n = this.parser,
      a = n.json.nodes[e],
      u = ((a.extensions && a.extensions[this.name]) || {}).light;
    return u === void 0
      ? null
      : this._loadLight(u).then(function (f) {
          return n._getNodeRef(t.cache, u, f);
        });
  }
}
class UI {
  constructor() {
    this.name = Un.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return fr;
  }
  extendParams(e, t, n) {
    const i = [];
    (e.color = new Dt(1, 1, 1)), (e.opacity = 1);
    const a = t.pbrMetallicRoughness;
    if (a) {
      if (Array.isArray(a.baseColorFactor)) {
        const l = a.baseColorFactor;
        e.color.setRGB(l[0], l[1], l[2], xu), (e.opacity = l[3]);
      }
      a.baseColorTexture !== void 0 &&
        i.push(n.assignTexture(e, "map", a.baseColorTexture, zf));
    }
    return Promise.all(i);
  }
}
class OI {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = i.extensions[this.name].emissiveStrength;
    return a !== void 0 && (t.emissiveIntensity = a), Promise.resolve();
  }
}
class LI {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Hs;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = [],
      l = i.extensions[this.name];
    if (
      (l.clearcoatFactor !== void 0 && (t.clearcoat = l.clearcoatFactor),
      l.clearcoatTexture !== void 0 &&
        a.push(n.assignTexture(t, "clearcoatMap", l.clearcoatTexture)),
      l.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = l.clearcoatRoughnessFactor),
      l.clearcoatRoughnessTexture !== void 0 &&
        a.push(
          n.assignTexture(
            t,
            "clearcoatRoughnessMap",
            l.clearcoatRoughnessTexture
          )
        ),
      l.clearcoatNormalTexture !== void 0 &&
        (a.push(
          n.assignTexture(t, "clearcoatNormalMap", l.clearcoatNormalTexture)
        ),
        l.clearcoatNormalTexture.scale !== void 0))
    ) {
      const u = l.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new at(u, u);
    }
    return Promise.all(a);
  }
}
class NI {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_MATERIALS_DISPERSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Hs;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = i.extensions[this.name];
    return (
      (t.dispersion = a.dispersion !== void 0 ? a.dispersion : 0),
      Promise.resolve()
    );
  }
}
class II {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Hs;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = [],
      l = i.extensions[this.name];
    return (
      l.iridescenceFactor !== void 0 && (t.iridescence = l.iridescenceFactor),
      l.iridescenceTexture !== void 0 &&
        a.push(n.assignTexture(t, "iridescenceMap", l.iridescenceTexture)),
      l.iridescenceIor !== void 0 && (t.iridescenceIOR = l.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      l.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = l.iridescenceThicknessMinimum),
      l.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = l.iridescenceThicknessMaximum),
      l.iridescenceThicknessTexture !== void 0 &&
        a.push(
          n.assignTexture(
            t,
            "iridescenceThicknessMap",
            l.iridescenceThicknessTexture
          )
        ),
      Promise.all(a)
    );
  }
}
class FI {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Hs;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = [];
    (t.sheenColor = new Dt(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const l = i.extensions[this.name];
    if (l.sheenColorFactor !== void 0) {
      const u = l.sheenColorFactor;
      t.sheenColor.setRGB(u[0], u[1], u[2], xu);
    }
    return (
      l.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = l.sheenRoughnessFactor),
      l.sheenColorTexture !== void 0 &&
        a.push(n.assignTexture(t, "sheenColorMap", l.sheenColorTexture, zf)),
      l.sheenRoughnessTexture !== void 0 &&
        a.push(
          n.assignTexture(t, "sheenRoughnessMap", l.sheenRoughnessTexture)
        ),
      Promise.all(a)
    );
  }
}
class PI {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Hs;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = [],
      l = i.extensions[this.name];
    return (
      l.transmissionFactor !== void 0 &&
        (t.transmission = l.transmissionFactor),
      l.transmissionTexture !== void 0 &&
        a.push(n.assignTexture(t, "transmissionMap", l.transmissionTexture)),
      Promise.all(a)
    );
  }
}
class GI {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Hs;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = [],
      l = i.extensions[this.name];
    (t.thickness = l.thicknessFactor !== void 0 ? l.thicknessFactor : 0),
      l.thicknessTexture !== void 0 &&
        a.push(n.assignTexture(t, "thicknessMap", l.thicknessTexture)),
      (t.attenuationDistance = l.attenuationDistance || 1 / 0);
    const u = l.attenuationColor || [1, 1, 1];
    return (
      (t.attenuationColor = new Dt().setRGB(u[0], u[1], u[2], xu)),
      Promise.all(a)
    );
  }
}
class zI {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Hs;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = i.extensions[this.name];
    return (t.ior = a.ior !== void 0 ? a.ior : 1.5), Promise.resolve();
  }
}
class HI {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Hs;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = [],
      l = i.extensions[this.name];
    (t.specularIntensity = l.specularFactor !== void 0 ? l.specularFactor : 1),
      l.specularTexture !== void 0 &&
        a.push(n.assignTexture(t, "specularIntensityMap", l.specularTexture));
    const u = l.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Dt().setRGB(u[0], u[1], u[2], xu)),
      l.specularColorTexture !== void 0 &&
        a.push(
          n.assignTexture(t, "specularColorMap", l.specularColorTexture, zf)
        ),
      Promise.all(a)
    );
  }
}
class VI {
  constructor(e) {
    (this.parser = e), (this.name = Un.EXT_MATERIALS_BUMP);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Hs;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = [],
      l = i.extensions[this.name];
    return (
      (t.bumpScale = l.bumpFactor !== void 0 ? l.bumpFactor : 1),
      l.bumpTexture !== void 0 &&
        a.push(n.assignTexture(t, "bumpMap", l.bumpTexture)),
      Promise.all(a)
    );
  }
}
class kI {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Hs;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const a = [],
      l = i.extensions[this.name];
    return (
      l.anisotropyStrength !== void 0 && (t.anisotropy = l.anisotropyStrength),
      l.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = l.anisotropyRotation),
      l.anisotropyTexture !== void 0 &&
        a.push(n.assignTexture(t, "anisotropyMap", l.anisotropyTexture)),
      Promise.all(a)
    );
  }
}
class XI {
  constructor(e) {
    (this.parser = e), (this.name = Un.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      n = t.json,
      i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const a = i.extensions[this.name],
      l = t.options.ktx2Loader;
    if (!l) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, a.source, l);
  }
}
class YI {
  constructor(e) {
    (this.parser = e),
      (this.name = Un.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      a = i.textures[e];
    if (!a.extensions || !a.extensions[t]) return null;
    const l = a.extensions[t],
      u = i.images[l.source];
    let f = n.textureLoader;
    if (u.uri) {
      const d = n.options.manager.getHandler(u.uri);
      d !== null && (f = d);
    }
    return this.detectSupport().then(function (d) {
      if (d) return n.loadTextureImage(e, l.source, f);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class WI {
  constructor(e) {
    (this.parser = e),
      (this.name = Un.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      a = i.textures[e];
    if (!a.extensions || !a.extensions[t]) return null;
    const l = a.extensions[t],
      u = i.images[l.source];
    let f = n.textureLoader;
    if (u.uri) {
      const d = n.options.manager.getHandler(u.uri);
      d !== null && (f = d);
    }
    return this.detectSupport().then(function (d) {
      if (d) return n.loadTextureImage(e, l.source, f);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class JI {
  constructor(e) {
    (this.name = Un.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name],
        a = this.parser.getDependency("buffer", i.buffer),
        l = this.parser.options.meshoptDecoder;
      if (!l || !l.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return a.then(function (u) {
        const f = i.byteOffset || 0,
          d = i.byteLength || 0,
          m = i.count,
          v = i.byteStride,
          _ = new Uint8Array(u, f, d);
        return l.decodeGltfBufferAsync
          ? l
              .decodeGltfBufferAsync(m, v, _, i.mode, i.filter)
              .then(function (A) {
                return A.buffer;
              })
          : l.ready.then(function () {
              const A = new ArrayBuffer(m * v);
              return (
                l.decodeGltfBuffer(
                  new Uint8Array(A),
                  m,
                  v,
                  _,
                  i.mode,
                  i.filter
                ),
                A
              );
            });
      });
    } else return null;
  }
}
class qI {
  constructor(e) {
    (this.name = Un.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const d of i.primitives)
      if (
        d.mode !== Is.TRIANGLES &&
        d.mode !== Is.TRIANGLE_STRIP &&
        d.mode !== Is.TRIANGLE_FAN &&
        d.mode !== void 0
      )
        return null;
    const l = n.extensions[this.name].attributes,
      u = [],
      f = {};
    for (const d in l)
      u.push(
        this.parser
          .getDependency("accessor", l[d])
          .then((m) => ((f[d] = m), f[d]))
      );
    return u.length < 1
      ? null
      : (u.push(this.parser.createNodeMesh(e)),
        Promise.all(u).then((d) => {
          const m = d.pop(),
            v = m.isGroup ? m.children : [m],
            _ = d[0].count,
            A = [];
          for (const M of v) {
            const T = new Qt(),
              E = new ie(),
              b = new La(),
              w = new ie(1, 1, 1),
              D = new ox(M.geometry, M.material, _);
            for (let B = 0; B < _; B++)
              f.TRANSLATION && E.fromBufferAttribute(f.TRANSLATION, B),
                f.ROTATION && b.fromBufferAttribute(f.ROTATION, B),
                f.SCALE && w.fromBufferAttribute(f.SCALE, B),
                D.setMatrixAt(B, T.compose(E, b, w));
            for (const B in f)
              if (B === "_COLOR_0") {
                const I = f[B];
                D.instanceColor = new bc(I.array, I.itemSize, I.normalized);
              } else
                B !== "TRANSLATION" &&
                  B !== "ROTATION" &&
                  B !== "SCALE" &&
                  M.geometry.setAttribute(B, f[B]);
            On.prototype.copy.call(D, M),
              this.parser.assignFinalMaterial(D),
              A.push(D);
          }
          return m.isGroup ? (m.clear(), m.add(...A), m) : A[0];
        }));
  }
}
const R2 = "glTF",
  um = 12,
  Vb = { JSON: 1313821514, BIN: 5130562 };
class jI {
  constructor(e) {
    (this.name = Un.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, um);
    if (
      ((this.header = {
        magic: xy(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== R2)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - um,
      i = new DataView(e, um);
    let a = 0;
    for (; a < n; ) {
      const l = i.getUint32(a, !0);
      a += 4;
      const u = i.getUint32(a, !0);
      if (((a += 4), u === Vb.JSON)) {
        const f = new Uint8Array(e, um + a, l);
        this.content = xy(f);
      } else if (u === Vb.BIN) {
        const f = um + a;
        this.body = e.slice(f, f + l);
      }
      a += l;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class KI {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = Un.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json,
      i = this.dracoLoader,
      a = e.extensions[this.name].bufferView,
      l = e.extensions[this.name].attributes,
      u = {},
      f = {},
      d = {};
    for (const m in l) {
      const v = NA[m] || m.toLowerCase();
      u[v] = l[m];
    }
    for (const m in e.attributes) {
      const v = NA[m] || m.toLowerCase();
      if (l[m] !== void 0) {
        const _ = n.accessors[e.attributes[m]],
          A = Ad[_.componentType];
        (d[v] = A.name), (f[v] = _.normalized === !0);
      }
    }
    return t.getDependency("bufferView", a).then(function (m) {
      return new Promise(function (v, _) {
        i.decodeDracoFile(
          m,
          function (A) {
            for (const M in A.attributes) {
              const T = A.attributes[M],
                E = f[M];
              E !== void 0 && (T.normalized = E);
            }
            v(A);
          },
          u,
          d,
          xu,
          _
        );
      });
    });
  }
}
class ZI {
  constructor() {
    this.name = Un.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class QI {
  constructor() {
    this.name = Un.KHR_MESH_QUANTIZATION;
  }
}
class w2 extends Fd {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      a = e * i * 3 + i;
    for (let l = 0; l !== i; l++) t[l] = n[a + l];
    return t;
  }
  interpolate_(e, t, n, i) {
    const a = this.resultBuffer,
      l = this.sampleValues,
      u = this.valueSize,
      f = u * 2,
      d = u * 3,
      m = i - t,
      v = (n - t) / m,
      _ = v * v,
      A = _ * v,
      M = e * d,
      T = M - d,
      E = -2 * A + 3 * _,
      b = A - _,
      w = 1 - E,
      D = b - _ + v;
    for (let B = 0; B !== u; B++) {
      const I = l[T + B + u],
        N = l[T + B + f] * m,
        P = l[M + B + u],
        F = l[M + B] * m;
      a[B] = w * I + D * N + E * P + b * F;
    }
    return a;
  }
}
const $I = new La();
class eF extends w2 {
  interpolate_(e, t, n, i) {
    const a = super.interpolate_(e, t, n, i);
    return $I.fromArray(a).normalize().toArray(a), a;
  }
}
const Is = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
  },
  Ad = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  kb = { 9728: Kn, 9729: In, 9984: Ey, 9985: yd, 9986: Of, 9987: ms },
  Xb = { 33071: sa, 33648: Md, 10497: Sc },
  tA = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  NA = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    ...(zx >= 152
      ? {
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
        }
      : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }),
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  pc = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  tF = { CUBICSPLINE: void 0, LINEAR: Td, STEP: Ed },
  nA = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function nF(s) {
  return (
    s.DefaultMaterial === void 0 &&
      (s.DefaultMaterial = new eg({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Tl,
      })),
    s.DefaultMaterial
  );
}
function Tf(s, e, t) {
  for (const n in t.extensions)
    s[n] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[n] = t.extensions[n]));
}
function pu(s, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(s.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function iF(s, e, t) {
  let n = !1,
    i = !1,
    a = !1;
  for (let d = 0, m = e.length; d < m; d++) {
    const v = e[d];
    if (
      (v.POSITION !== void 0 && (n = !0),
      v.NORMAL !== void 0 && (i = !0),
      v.COLOR_0 !== void 0 && (a = !0),
      n && i && a)
    )
      break;
  }
  if (!n && !i && !a) return Promise.resolve(s);
  const l = [],
    u = [],
    f = [];
  for (let d = 0, m = e.length; d < m; d++) {
    const v = e[d];
    if (n) {
      const _ =
        v.POSITION !== void 0
          ? t.getDependency("accessor", v.POSITION)
          : s.attributes.position;
      l.push(_);
    }
    if (i) {
      const _ =
        v.NORMAL !== void 0
          ? t.getDependency("accessor", v.NORMAL)
          : s.attributes.normal;
      u.push(_);
    }
    if (a) {
      const _ =
        v.COLOR_0 !== void 0
          ? t.getDependency("accessor", v.COLOR_0)
          : s.attributes.color;
      f.push(_);
    }
  }
  return Promise.all([Promise.all(l), Promise.all(u), Promise.all(f)]).then(
    function (d) {
      const m = d[0],
        v = d[1],
        _ = d[2];
      return (
        n && (s.morphAttributes.position = m),
        i && (s.morphAttributes.normal = v),
        a && (s.morphAttributes.color = _),
        (s.morphTargetsRelative = !0),
        s
      );
    }
  );
}
function aF(s, e) {
  if ((s.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, n = e.weights.length; t < n; t++)
      s.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (s.morphTargetInfluences.length === t.length) {
      s.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        s.morphTargetDictionary[t[n]] = n;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function rF(s) {
  let e;
  const t = s.extensions && s.extensions[Un.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = "draco:" + t.bufferView + ":" + t.indices + ":" + iA(t.attributes))
      : (e = s.indices + ":" + iA(s.attributes) + ":" + s.mode),
    s.targets !== void 0)
  )
    for (let n = 0, i = s.targets.length; n < i; n++)
      e += ":" + iA(s.targets[n]);
  return e;
}
function iA(s) {
  let e = "";
  const t = Object.keys(s).sort();
  for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + s[t[n]] + ";";
  return e;
}
function IA(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function sF(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const oF = new Qt();
class lF {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new BI()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let n = !1,
      i = !1,
      a = -1;
    typeof navigator < "u" &&
      typeof navigator.userAgent < "u" &&
      ((n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (i = navigator.userAgent.indexOf("Firefox") > -1),
      (a = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || n || (i && a < 98)
        ? (this.textureLoader = new tg(this.options.manager))
        : (this.textureLoader = new GT(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new Ja(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this,
      i = this.json,
      a = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (l) {
        return l._markDefs && l._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (l) {
          return l.beforeRoot && l.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies("scene"),
            n.getDependencies("animation"),
            n.getDependencies("camera"),
          ]);
        })
        .then(function (l) {
          const u = {
            scene: l[0][i.scene || 0],
            scenes: l[0],
            animations: l[1],
            cameras: l[2],
            asset: i.asset,
            parser: n,
            userData: {},
          };
          return (
            Tf(a, u, i),
            pu(u, i),
            Promise.all(
              n._invokeAll(function (f) {
                return f.afterRoot && f.afterRoot(u);
              })
            ).then(function () {
              for (const f of u.scenes) f.updateMatrixWorld();
              e(u);
            })
          );
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      n = this.json.meshes || [];
    for (let i = 0, a = t.length; i < a; i++) {
      const l = t[i].joints;
      for (let u = 0, f = l.length; u < f; u++) e[l[u]].isBone = !0;
    }
    for (let i = 0, a = e.length; i < a; i++) {
      const l = e[i];
      l.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, l.mesh),
        l.skin !== void 0 && (n[l.mesh].isSkinnedMesh = !0)),
        l.camera !== void 0 && this._addNodeRef(this.cameraCache, l.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const i = n.clone(),
      a = (l, u) => {
        const f = this.associations.get(l);
        f != null && this.associations.set(u, f);
        for (const [d, m] of l.children.entries()) a(m, u.children[d]);
      };
    return a(n, i), (i.name += "_instance_" + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const a = e(t[i]);
      a && n.push(a);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function (a) {
            return a.loadNode && a.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function (a) {
            return a.loadMesh && a.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function (a) {
            return a.loadBufferView && a.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function (a) {
            return a.loadMaterial && a.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function (a) {
            return a.loadTexture && a.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function (a) {
            return a.loadAnimation && a.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (
            ((i = this._invokeOne(function (a) {
              return a != this && a.getDependency && a.getDependency(e, t);
            })),
            !i)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this,
        i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        i.map(function (a, l) {
          return n.getDependency(e, l);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Un.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (a, l) {
      n.load(_c.resolveURL(t.uri, i.path), a, void 0, function () {
        l(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (n) {
      const i = t.byteLength || 0,
        a = t.byteOffset || 0;
      return n.slice(a, a + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      n = this.json,
      i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const l = tA[i.type],
        u = Ad[i.componentType],
        f = i.normalized === !0,
        d = new u(i.count * l);
      return Promise.resolve(new Yn(d, l, f));
    }
    const a = [];
    return (
      i.bufferView !== void 0
        ? a.push(this.getDependency("bufferView", i.bufferView))
        : a.push(null),
      i.sparse !== void 0 &&
        (a.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        a.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
      Promise.all(a).then(function (l) {
        const u = l[0],
          f = tA[i.type],
          d = Ad[i.componentType],
          m = d.BYTES_PER_ELEMENT,
          v = m * f,
          _ = i.byteOffset || 0,
          A =
            i.bufferView !== void 0
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          M = i.normalized === !0;
        let T, E;
        if (A && A !== v) {
          const b = Math.floor(_ / A),
            w =
              "InterleavedBuffer:" +
              i.bufferView +
              ":" +
              i.componentType +
              ":" +
              b +
              ":" +
              i.count;
          let D = t.cache.get(w);
          D ||
            ((T = new d(u, b * A, (i.count * A) / m)),
            (D = new Jm(T, A / m)),
            t.cache.add(w, D)),
            (E = new Mc(D, f, (_ % A) / m, M));
        } else u === null ? (T = new d(i.count * f)) : (T = new d(u, _, i.count * f)), (E = new Yn(T, f, M));
        if (i.sparse !== void 0) {
          const b = tA.SCALAR,
            w = Ad[i.sparse.indices.componentType],
            D = i.sparse.indices.byteOffset || 0,
            B = i.sparse.values.byteOffset || 0,
            I = new w(l[1], D, i.sparse.count * b),
            N = new d(l[2], B, i.sparse.count * f);
          u !== null && (E = new Yn(E.array.slice(), E.itemSize, E.normalized));
          for (let P = 0, F = I.length; P < F; P++) {
            const O = I[P];
            if (
              (E.setX(O, N[P * f]),
              f >= 2 && E.setY(O, N[P * f + 1]),
              f >= 3 && E.setZ(O, N[P * f + 2]),
              f >= 4 && E.setW(O, N[P * f + 3]),
              f >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return E;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      n = this.options,
      a = t.textures[e].source,
      l = t.images[a];
    let u = this.textureLoader;
    if (l.uri) {
      const f = n.manager.getHandler(l.uri);
      f !== null && (u = f);
    }
    return this.loadTextureImage(e, a, u);
  }
  loadTextureImage(e, t, n) {
    const i = this,
      a = this.json,
      l = a.textures[e],
      u = a.images[t],
      f = (u.uri || u.bufferView) + ":" + l.sampler;
    if (this.textureCache[f]) return this.textureCache[f];
    const d = this.loadImageSource(t, n)
      .then(function (m) {
        (m.flipY = !1),
          (m.name = l.name || u.name || ""),
          m.name === "" &&
            typeof u.uri == "string" &&
            u.uri.startsWith("data:image/") === !1 &&
            (m.name = u.uri);
        const _ = (a.samplers || {})[l.sampler] || {};
        return (
          (m.magFilter = kb[_.magFilter] || In),
          (m.minFilter = kb[_.minFilter] || ms),
          (m.wrapS = Xb[_.wrapS] || Sc),
          (m.wrapT = Xb[_.wrapT] || Sc),
          i.associations.set(m, { textures: e }),
          m
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[f] = d), d;
  }
  loadImageSource(e, t) {
    const n = this,
      i = this.json,
      a = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((v) => v.clone());
    const l = i.images[e],
      u = self.URL || self.webkitURL;
    let f = l.uri || "",
      d = !1;
    if (l.bufferView !== void 0)
      f = n.getDependency("bufferView", l.bufferView).then(function (v) {
        d = !0;
        const _ = new Blob([v], { type: l.mimeType });
        return (f = u.createObjectURL(_)), f;
      });
    else if (l.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const m = Promise.resolve(f)
      .then(function (v) {
        return new Promise(function (_, A) {
          let M = _;
          t.isImageBitmapLoader === !0 &&
            (M = function (T) {
              const E = new Wn(T);
              (E.needsUpdate = !0), _(E);
            }),
            t.load(_c.resolveURL(v, a.path), M, void 0, A);
        });
      })
      .then(function (v) {
        return (
          d === !0 && u.revokeObjectURL(f),
          pu(v, l),
          (v.userData.mimeType = l.mimeType || sF(l.uri)),
          v
        );
      })
      .catch(function (v) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", f), v);
      });
    return (this.sourceCache[e] = m), m;
  }
  assignTexture(e, t, n, i) {
    const a = this;
    return this.getDependency("texture", n.index).then(function (l) {
      if (!l) return null;
      if (
        (n.texCoord !== void 0 &&
          n.texCoord > 0 &&
          ((l = l.clone()), (l.channel = n.texCoord)),
        a.extensions[Un.KHR_TEXTURE_TRANSFORM])
      ) {
        const u =
          n.extensions !== void 0
            ? n.extensions[Un.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (u) {
          const f = a.associations.get(l);
          (l = a.extensions[Un.KHR_TEXTURE_TRANSFORM].extendTexture(l, u)),
            a.associations.set(l, f);
        }
      }
      return (
        i !== void 0 &&
          (typeof i == "number" && (i = i === Hb ? zf : xu),
          "colorSpace" in l
            ? (l.colorSpace = i)
            : (l.encoding = i === zf ? Hb : wI)),
        (e[t] = l),
        l
      );
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0,
      a = t.attributes.color !== void 0,
      l = t.attributes.normal === void 0;
    if (e.isPoints) {
      const u = "PointsMaterial:" + n.uuid;
      let f = this.cache.get(u);
      f ||
        ((f = new zy()),
        _a.prototype.copy.call(f, n),
        f.color.copy(n.color),
        (f.map = n.map),
        (f.sizeAttenuation = !1),
        this.cache.add(u, f)),
        (n = f);
    } else if (e.isLine) {
      const u = "LineBasicMaterial:" + n.uuid;
      let f = this.cache.get(u);
      f ||
        ((f = new dr()),
        _a.prototype.copy.call(f, n),
        f.color.copy(n.color),
        (f.map = n.map),
        this.cache.add(u, f)),
        (n = f);
    }
    if (i || a || l) {
      let u = "ClonedMaterial:" + n.uuid + ":";
      i && (u += "derivative-tangents:"),
        a && (u += "vertex-colors:"),
        l && (u += "flat-shading:");
      let f = this.cache.get(u);
      f ||
        ((f = n.clone()),
        a && (f.vertexColors = !0),
        l && (f.flatShading = !0),
        i &&
          (f.normalScale && (f.normalScale.y *= -1),
          f.clearcoatNormalScale && (f.clearcoatNormalScale.y *= -1)),
        this.cache.add(u, f),
        this.associations.set(f, this.associations.get(n))),
        (n = f);
    }
    e.material = n;
  }
  getMaterialType() {
    return eg;
  }
  loadMaterial(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      a = n.materials[e];
    let l;
    const u = {},
      f = a.extensions || {},
      d = [];
    if (f[Un.KHR_MATERIALS_UNLIT]) {
      const v = i[Un.KHR_MATERIALS_UNLIT];
      (l = v.getMaterialType()), d.push(v.extendParams(u, a, t));
    } else {
      const v = a.pbrMetallicRoughness || {};
      if (
        ((u.color = new Dt(1, 1, 1)),
        (u.opacity = 1),
        Array.isArray(v.baseColorFactor))
      ) {
        const _ = v.baseColorFactor;
        u.color.setRGB(_[0], _[1], _[2], xu), (u.opacity = _[3]);
      }
      v.baseColorTexture !== void 0 &&
        d.push(t.assignTexture(u, "map", v.baseColorTexture, zf)),
        (u.metalness = v.metallicFactor !== void 0 ? v.metallicFactor : 1),
        (u.roughness = v.roughnessFactor !== void 0 ? v.roughnessFactor : 1),
        v.metallicRoughnessTexture !== void 0 &&
          (d.push(
            t.assignTexture(u, "metalnessMap", v.metallicRoughnessTexture)
          ),
          d.push(
            t.assignTexture(u, "roughnessMap", v.metallicRoughnessTexture)
          )),
        (l = this._invokeOne(function (_) {
          return _.getMaterialType && _.getMaterialType(e);
        })),
        d.push(
          Promise.all(
            this._invokeAll(function (_) {
              return _.extendMaterialParams && _.extendMaterialParams(e, u);
            })
          )
        );
    }
    a.doubleSided === !0 && (u.side = jr);
    const m = a.alphaMode || nA.OPAQUE;
    if (
      (m === nA.BLEND
        ? ((u.transparent = !0), (u.depthWrite = !1))
        : ((u.transparent = !1),
          m === nA.MASK &&
            (u.alphaTest = a.alphaCutoff !== void 0 ? a.alphaCutoff : 0.5)),
      a.normalTexture !== void 0 &&
        l !== fr &&
        (d.push(t.assignTexture(u, "normalMap", a.normalTexture)),
        (u.normalScale = new at(1, 1)),
        a.normalTexture.scale !== void 0))
    ) {
      const v = a.normalTexture.scale;
      u.normalScale.set(v, v);
    }
    if (
      (a.occlusionTexture !== void 0 &&
        l !== fr &&
        (d.push(t.assignTexture(u, "aoMap", a.occlusionTexture)),
        a.occlusionTexture.strength !== void 0 &&
          (u.aoMapIntensity = a.occlusionTexture.strength)),
      a.emissiveFactor !== void 0 && l !== fr)
    ) {
      const v = a.emissiveFactor;
      u.emissive = new Dt().setRGB(v[0], v[1], v[2], xu);
    }
    return (
      a.emissiveTexture !== void 0 &&
        l !== fr &&
        d.push(t.assignTexture(u, "emissiveMap", a.emissiveTexture, zf)),
      Promise.all(d).then(function () {
        const v = new l(u);
        return (
          a.name && (v.name = a.name),
          pu(v, a),
          t.associations.set(v, { materials: e }),
          a.extensions && Tf(i, v, a),
          v
        );
      })
    );
  }
  createUniqueName(e) {
    const t = Xn.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      n = this.extensions,
      i = this.primitiveCache;
    function a(u) {
      return n[Un.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(u, t)
        .then(function (f) {
          return Yb(f, u, t);
        });
    }
    const l = [];
    for (let u = 0, f = e.length; u < f; u++) {
      const d = e[u],
        m = rF(d),
        v = i[m];
      if (v) l.push(v.promise);
      else {
        let _;
        d.extensions && d.extensions[Un.KHR_DRACO_MESH_COMPRESSION]
          ? (_ = a(d))
          : (_ = Yb(new mn(), d, t)),
          (i[m] = { primitive: d, promise: _ }),
          l.push(_);
      }
    }
    return Promise.all(l);
  }
  loadMesh(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      a = n.meshes[e],
      l = a.primitives,
      u = [];
    for (let f = 0, d = l.length; f < d; f++) {
      const m =
        l[f].material === void 0
          ? nF(this.cache)
          : this.getDependency("material", l[f].material);
      u.push(m);
    }
    return (
      u.push(t.loadGeometries(l)),
      Promise.all(u).then(function (f) {
        const d = f.slice(0, f.length - 1),
          m = f[f.length - 1],
          v = [];
        for (let A = 0, M = m.length; A < M; A++) {
          const T = m[A],
            E = l[A];
          let b;
          const w = d[A];
          if (
            E.mode === Is.TRIANGLES ||
            E.mode === Is.TRIANGLE_STRIP ||
            E.mode === Is.TRIANGLE_FAN ||
            E.mode === void 0
          )
            (b = a.isSkinnedMesh === !0 ? new sx(T, w) : new li(T, w)),
              b.isSkinnedMesh === !0 && b.normalizeSkinWeights(),
              E.mode === Is.TRIANGLE_STRIP
                ? (b.geometry = Pb(b.geometry, ZA))
                : E.mode === Is.TRIANGLE_FAN &&
                  (b.geometry = Pb(b.geometry, hy));
          else if (E.mode === Is.LINES) b = new Lo(T, w);
          else if (E.mode === Is.LINE_STRIP) b = new Su(T, w);
          else if (E.mode === Is.LINE_LOOP) b = new lx(T, w);
          else if (E.mode === Is.POINTS) b = new ux(T, w);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + E.mode
            );
          Object.keys(b.geometry.morphAttributes).length > 0 && aF(b, a),
            (b.name = t.createUniqueName(a.name || "mesh_" + e)),
            pu(b, a),
            E.extensions && Tf(i, b, E),
            t.assignFinalMaterial(b),
            v.push(b);
        }
        for (let A = 0, M = v.length; A < M; A++)
          t.associations.set(v[A], { meshes: e, primitives: A });
        if (v.length === 1) return a.extensions && Tf(i, v[0], a), v[0];
        const _ = new yu();
        a.extensions && Tf(i, _, a), t.associations.set(_, { meshes: e });
        for (let A = 0, M = v.length; A < M; A++) _.add(v[A]);
        return _;
      })
    );
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e],
      i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      n.type === "perspective"
        ? (t = new $i(
            tx.radToDeg(i.yfov),
            i.aspectRatio || 1,
            i.znear || 1,
            i.zfar || 2e6
          ))
        : n.type === "orthographic" &&
          (t = new Ps(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      n.name && (t.name = this.createUniqueName(n.name)),
      pu(t, n),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      n = [];
    for (let i = 0, a = t.joints.length; i < a; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return (
      t.inverseBindMatrices !== void 0
        ? n.push(this.getDependency("accessor", t.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (i) {
        const a = i.pop(),
          l = i,
          u = [],
          f = [];
        for (let d = 0, m = l.length; d < m; d++) {
          const v = l[d];
          if (v) {
            u.push(v);
            const _ = new Qt();
            a !== null && _.fromArray(a.array, d * 16), f.push(_);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[d]
            );
        }
        return new qm(u, f);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json,
      n = this,
      i = t.animations[e],
      a = i.name ? i.name : "animation_" + e,
      l = [],
      u = [],
      f = [],
      d = [],
      m = [];
    for (let v = 0, _ = i.channels.length; v < _; v++) {
      const A = i.channels[v],
        M = i.samplers[A.sampler],
        T = A.target,
        E = T.node,
        b = i.parameters !== void 0 ? i.parameters[M.input] : M.input,
        w = i.parameters !== void 0 ? i.parameters[M.output] : M.output;
      T.node !== void 0 &&
        (l.push(this.getDependency("node", E)),
        u.push(this.getDependency("accessor", b)),
        f.push(this.getDependency("accessor", w)),
        d.push(M),
        m.push(T));
    }
    return Promise.all([
      Promise.all(l),
      Promise.all(u),
      Promise.all(f),
      Promise.all(d),
      Promise.all(m),
    ]).then(function (v) {
      const _ = v[0],
        A = v[1],
        M = v[2],
        T = v[3],
        E = v[4],
        b = [];
      for (let w = 0, D = _.length; w < D; w++) {
        const B = _[w],
          I = A[w],
          N = M[w],
          P = T[w],
          F = E[w];
        if (B === void 0) continue;
        B.updateMatrix && B.updateMatrix();
        const O = n._createAnimationTracks(B, I, N, P, F);
        if (O) for (let U = 0; U < O.length; U++) b.push(O[U]);
      }
      return new Bd(a, void 0, b);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : n.getDependency("mesh", i.mesh).then(function (a) {
          const l = n._getNodeRef(n.meshCache, i.mesh, a);
          return (
            i.weights !== void 0 &&
              l.traverse(function (u) {
                if (u.isMesh)
                  for (let f = 0, d = i.weights.length; f < d; f++)
                    u.morphTargetInfluences[f] = i.weights[f];
              }),
            l
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e],
      a = n._loadNodeShallow(e),
      l = [],
      u = i.children || [];
    for (let d = 0, m = u.length; d < m; d++)
      l.push(n.getDependency("node", u[d]));
    const f =
      i.skin === void 0
        ? Promise.resolve(null)
        : n.getDependency("skin", i.skin);
    return Promise.all([a, Promise.all(l), f]).then(function (d) {
      const m = d[0],
        v = d[1],
        _ = d[2];
      _ !== null &&
        m.traverse(function (A) {
          A.isSkinnedMesh && A.bind(_, oF);
        });
      for (let A = 0, M = v.length; A < M; A++) m.add(v[A]);
      return m;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      n = this.extensions,
      i = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const a = t.nodes[e],
      l = a.name ? i.createUniqueName(a.name) : "",
      u = [],
      f = i._invokeOne(function (d) {
        return d.createNodeMesh && d.createNodeMesh(e);
      });
    return (
      f && u.push(f),
      a.camera !== void 0 &&
        u.push(
          i.getDependency("camera", a.camera).then(function (d) {
            return i._getNodeRef(i.cameraCache, a.camera, d);
          })
        ),
      i
        ._invokeAll(function (d) {
          return d.createNodeAttachment && d.createNodeAttachment(e);
        })
        .forEach(function (d) {
          u.push(d);
        }),
      (this.nodeCache[e] = Promise.all(u).then(function (d) {
        let m;
        if (
          (a.isBone === !0
            ? (m = new Gy())
            : d.length > 1
            ? (m = new yu())
            : d.length === 1
            ? (m = d[0])
            : (m = new On()),
          m !== d[0])
        )
          for (let v = 0, _ = d.length; v < _; v++) m.add(d[v]);
        if (
          (a.name && ((m.userData.name = a.name), (m.name = l)),
          pu(m, a),
          a.extensions && Tf(n, m, a),
          a.matrix !== void 0)
        ) {
          const v = new Qt();
          v.fromArray(a.matrix), m.applyMatrix4(v);
        } else a.translation !== void 0 && m.position.fromArray(a.translation), a.rotation !== void 0 && m.quaternion.fromArray(a.rotation), a.scale !== void 0 && m.scale.fromArray(a.scale);
        return (
          i.associations.has(m) || i.associations.set(m, {}),
          (i.associations.get(m).nodes = e),
          m
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      n = this.json.scenes[e],
      i = this,
      a = new yu();
    n.name && (a.name = i.createUniqueName(n.name)),
      pu(a, n),
      n.extensions && Tf(t, a, n);
    const l = n.nodes || [],
      u = [];
    for (let f = 0, d = l.length; f < d; f++)
      u.push(i.getDependency("node", l[f]));
    return Promise.all(u).then(function (f) {
      for (let m = 0, v = f.length; m < v; m++) a.add(f[m]);
      const d = (m) => {
        const v = new Map();
        for (const [_, A] of i.associations)
          (_ instanceof _a || _ instanceof Wn) && v.set(_, A);
        return (
          m.traverse((_) => {
            const A = i.associations.get(_);
            A != null && v.set(_, A);
          }),
          v
        );
      };
      return (i.associations = d(a)), a;
    });
  }
  _createAnimationTracks(e, t, n, i, a) {
    const l = [],
      u = e.name ? e.name : e.uuid,
      f = [];
    pc[a.path] === pc.weights
      ? e.traverse(function (_) {
          _.morphTargetInfluences && f.push(_.name ? _.name : _.uuid);
        })
      : f.push(u);
    let d;
    switch (pc[a.path]) {
      case pc.weights:
        d = jf;
        break;
      case pc.rotation:
        d = Kf;
        break;
      case pc.position:
      case pc.scale:
        d = Zf;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            d = jf;
            break;
          case 2:
          case 3:
          default:
            d = Zf;
            break;
        }
        break;
    }
    const m = i.interpolation !== void 0 ? tF[i.interpolation] : Td,
      v = this._getArrayFromAccessor(n);
    for (let _ = 0, A = f.length; _ < A; _++) {
      const M = new d(f[_] + "." + pc[a.path], t.array, v, m);
      i.interpolation === "CUBICSPLINE" &&
        this._createCubicSplineTrackInterpolant(M),
        l.push(M);
    }
    return l;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = IA(t.constructor),
        i = new Float32Array(t.length);
      for (let a = 0, l = t.length; a < l; a++) i[a] = t[a] * n;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (n) {
      const i = this instanceof Kf ? eF : w2;
      return new i(this.times, this.values, this.getValueSize() / 3, n);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function uF(s, e, t) {
  const n = e.attributes,
    i = new ya();
  if (n.POSITION !== void 0) {
    const u = t.json.accessors[n.POSITION],
      f = u.min,
      d = u.max;
    if (f !== void 0 && d !== void 0) {
      if (
        (i.set(new ie(f[0], f[1], f[2]), new ie(d[0], d[1], d[2])),
        u.normalized)
      ) {
        const m = IA(Ad[u.componentType]);
        i.min.multiplyScalar(m), i.max.multiplyScalar(m);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const a = e.targets;
  if (a !== void 0) {
    const u = new ie(),
      f = new ie();
    for (let d = 0, m = a.length; d < m; d++) {
      const v = a[d];
      if (v.POSITION !== void 0) {
        const _ = t.json.accessors[v.POSITION],
          A = _.min,
          M = _.max;
        if (A !== void 0 && M !== void 0) {
          if (
            (f.setX(Math.max(Math.abs(A[0]), Math.abs(M[0]))),
            f.setY(Math.max(Math.abs(A[1]), Math.abs(M[1]))),
            f.setZ(Math.max(Math.abs(A[2]), Math.abs(M[2]))),
            _.normalized)
          ) {
            const T = IA(Ad[_.componentType]);
            f.multiplyScalar(T);
          }
          u.max(f);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    i.expandByVector(u);
  }
  s.boundingBox = i;
  const l = new Na();
  i.getCenter(l.center),
    (l.radius = i.min.distanceTo(i.max) / 2),
    (s.boundingSphere = l);
}
function Yb(s, e, t) {
  const n = e.attributes,
    i = [];
  function a(l, u) {
    return t.getDependency("accessor", l).then(function (f) {
      s.setAttribute(u, f);
    });
  }
  for (const l in n) {
    const u = NA[l] || l.toLowerCase();
    u in s.attributes || i.push(a(n[l], u));
  }
  if (e.indices !== void 0 && !s.index) {
    const l = t.getDependency("accessor", e.indices).then(function (u) {
      s.setIndex(u);
    });
    i.push(l);
  }
  return (
    pu(s, e),
    uF(s, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? iF(s, e.targets, t) : s;
    })
  );
}
class cF extends _x {
  constructor(e) {
    super(e), (this.type = va);
  }
  parse(e) {
    const l = function (F, O) {
        switch (F) {
          case 1:
            throw new Error("THREE.RGBELoader: Read Error: " + (O || ""));
          case 2:
            throw new Error("THREE.RGBELoader: Write Error: " + (O || ""));
          case 3:
            throw new Error("THREE.RGBELoader: Bad File Format: " + (O || ""));
          default:
          case 4:
            throw new Error("THREE.RGBELoader: Memory Error: " + (O || ""));
        }
      },
      m = `
`,
      v = function (F, O, U) {
        O = O || 1024;
        let J = F.pos,
          q = -1,
          Z = 0,
          ue = "",
          K = String.fromCharCode.apply(
            null,
            new Uint16Array(F.subarray(J, J + 128))
          );
        for (; 0 > (q = K.indexOf(m)) && Z < O && J < F.byteLength; )
          (ue += K),
            (Z += K.length),
            (J += 128),
            (K += String.fromCharCode.apply(
              null,
              new Uint16Array(F.subarray(J, J + 128))
            ));
        return -1 < q ? ((F.pos += Z + q + 1), ue + K.slice(0, q)) : !1;
      },
      _ = function (F) {
        const O = /^#\?(\S+)/,
          U = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          W = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          J = /^\s*FORMAT=(\S+)\s*$/,
          q = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          Z = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          };
        let ue, K;
        for (
          (F.pos >= F.byteLength || !(ue = v(F))) && l(1, "no header found"),
            (K = ue.match(O)) || l(3, "bad initial token"),
            Z.valid |= 1,
            Z.programtype = K[1],
            Z.string +=
              ue +
              `
`;
          (ue = v(F)), ue !== !1;

        ) {
          if (
            ((Z.string +=
              ue +
              `
`),
            ue.charAt(0) === "#")
          ) {
            Z.comments +=
              ue +
              `
`;
            continue;
          }
          if (
            ((K = ue.match(U)) && (Z.gamma = parseFloat(K[1])),
            (K = ue.match(W)) && (Z.exposure = parseFloat(K[1])),
            (K = ue.match(J)) && ((Z.valid |= 2), (Z.format = K[1])),
            (K = ue.match(q)) &&
              ((Z.valid |= 4),
              (Z.height = parseInt(K[1], 10)),
              (Z.width = parseInt(K[2], 10))),
            Z.valid & 2 && Z.valid & 4)
          )
            break;
        }
        return (
          Z.valid & 2 || l(3, "missing format specifier"),
          Z.valid & 4 || l(3, "missing image size specifier"),
          Z
        );
      },
      A = function (F, O, U) {
        const W = O;
        if (W < 8 || W > 32767 || F[0] !== 2 || F[1] !== 2 || F[2] & 128)
          return new Uint8Array(F);
        W !== ((F[2] << 8) | F[3]) && l(3, "wrong scanline width");
        const J = new Uint8Array(4 * O * U);
        J.length || l(4, "unable to allocate buffer space");
        let q = 0,
          Z = 0;
        const ue = 4 * W,
          K = new Uint8Array(4),
          ge = new Uint8Array(ue);
        let oe = U;
        for (; oe > 0 && Z < F.byteLength; ) {
          Z + 4 > F.byteLength && l(1),
            (K[0] = F[Z++]),
            (K[1] = F[Z++]),
            (K[2] = F[Z++]),
            (K[3] = F[Z++]),
            (K[0] != 2 || K[1] != 2 || ((K[2] << 8) | K[3]) != W) &&
              l(3, "bad rgbe scanline format");
          let me = 0,
            V;
          for (; me < ue && Z < F.byteLength; ) {
            V = F[Z++];
            const ae = V > 128;
            if (
              (ae && (V -= 128),
              (V === 0 || me + V > ue) && l(3, "bad scanline data"),
              ae)
            ) {
              const fe = F[Z++];
              for (let j = 0; j < V; j++) ge[me++] = fe;
            } else ge.set(F.subarray(Z, Z + V), me), (me += V), (Z += V);
          }
          const Y = W;
          for (let ae = 0; ae < Y; ae++) {
            let fe = 0;
            (J[q] = ge[ae + fe]),
              (fe += W),
              (J[q + 1] = ge[ae + fe]),
              (fe += W),
              (J[q + 2] = ge[ae + fe]),
              (fe += W),
              (J[q + 3] = ge[ae + fe]),
              (q += 4);
          }
          oe--;
        }
        return J;
      },
      M = function (F, O, U, W) {
        const J = F[O + 3],
          q = Math.pow(2, J - 128) / 255;
        (U[W + 0] = F[O + 0] * q),
          (U[W + 1] = F[O + 1] * q),
          (U[W + 2] = F[O + 2] * q),
          (U[W + 3] = 1);
      },
      T = function (F, O, U, W) {
        const J = F[O + 3],
          q = Math.pow(2, J - 128) / 255;
        (U[W + 0] = Ff.toHalfFloat(Math.min(F[O + 0] * q, 65504))),
          (U[W + 1] = Ff.toHalfFloat(Math.min(F[O + 1] * q, 65504))),
          (U[W + 2] = Ff.toHalfFloat(Math.min(F[O + 2] * q, 65504))),
          (U[W + 3] = Ff.toHalfFloat(1));
      },
      E = new Uint8Array(e);
    E.pos = 0;
    const b = _(E),
      w = b.width,
      D = b.height,
      B = A(E.subarray(E.pos), w, D);
    let I, N, P;
    switch (this.type) {
      case yi:
        P = B.length / 4;
        const F = new Float32Array(P * 4);
        for (let U = 0; U < P; U++) M(B, U * 4, F, U * 4);
        (I = F), (N = yi);
        break;
      case va:
        P = B.length / 4;
        const O = new Uint16Array(P * 4);
        for (let U = 0; U < P; U++) T(B, U * 4, O, U * 4);
        (I = O), (N = va);
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: w,
      height: D,
      data: I,
      header: b.string,
      gamma: b.gamma,
      exposure: b.exposure,
      type: N,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, n, i) {
    function a(l, u) {
      switch (l.type) {
        case yi:
        case va:
          "colorSpace" in l
            ? (l.colorSpace = "srgb-linear")
            : (l.encoding = 3e3),
            (l.minFilter = In),
            (l.magFilter = In),
            (l.generateMipmaps = !1),
            (l.flipY = !0);
          break;
      }
      t && t(l, u);
    }
    return super.load(e, a, n, i);
  }
}
const cm = zx >= 152;
class fF extends _x {
  constructor(e) {
    super(e), (this.type = va);
  }
  parse(e) {
    const O = Math.pow(2.7182818, 2.2);
    function U(H, te) {
      for (var Ae = 0, Ge = 0; Ge < 65536; ++Ge)
        (Ge == 0 || H[Ge >> 3] & (1 << (Ge & 7))) && (te[Ae++] = Ge);
      for (var qe = Ae - 1; Ae < 65536; ) te[Ae++] = 0;
      return qe;
    }
    function W(H) {
      for (var te = 0; te < 16384; te++)
        (H[te] = {}), (H[te].len = 0), (H[te].lit = 0), (H[te].p = null);
    }
    const J = { l: 0, c: 0, lc: 0 };
    function q(H, te, Ae, Ge, qe) {
      for (; Ae < H; ) (te = (te << 8) | Ze(Ge, qe)), (Ae += 8);
      (Ae -= H), (J.l = (te >> Ae) & ((1 << H) - 1)), (J.c = te), (J.lc = Ae);
    }
    const Z = new Array(59);
    function ue(H) {
      for (var te = 0; te <= 58; ++te) Z[te] = 0;
      for (var te = 0; te < 65537; ++te) Z[H[te]] += 1;
      for (var Ae = 0, te = 58; te > 0; --te) {
        var Ge = (Ae + Z[te]) >> 1;
        (Z[te] = Ae), (Ae = Ge);
      }
      for (var te = 0; te < 65537; ++te) {
        var qe = H[te];
        qe > 0 && (H[te] = qe | (Z[qe]++ << 6));
      }
    }
    function K(H, te, Ae, Ge, qe, Je, St) {
      for (var yt = Ae, z = 0, re = 0; qe <= Je; qe++) {
        if (yt.value - Ae.value > Ge) return !1;
        q(6, z, re, H, yt);
        var pe = J.l;
        if (((z = J.c), (re = J.lc), (St[qe] = pe), pe == 63)) {
          if (yt.value - Ae.value > Ge)
            throw "Something wrong with hufUnpackEncTable";
          q(8, z, re, H, yt);
          var ne = J.l + 6;
          if (((z = J.c), (re = J.lc), qe + ne > Je + 1))
            throw "Something wrong with hufUnpackEncTable";
          for (; ne--; ) St[qe++] = 0;
          qe--;
        } else if (pe >= 59) {
          var ne = pe - 59 + 2;
          if (qe + ne > Je + 1) throw "Something wrong with hufUnpackEncTable";
          for (; ne--; ) St[qe++] = 0;
          qe--;
        }
      }
      ue(St);
    }
    function ge(H) {
      return H & 63;
    }
    function oe(H) {
      return H >> 6;
    }
    function me(H, te, Ae, Ge) {
      for (; te <= Ae; te++) {
        var qe = oe(H[te]),
          Je = ge(H[te]);
        if (qe >> Je) throw "Invalid table entry";
        if (Je > 14) {
          var St = Ge[qe >> (Je - 14)];
          if (St.len) throw "Invalid table entry";
          if ((St.lit++, St.p)) {
            var yt = St.p;
            St.p = new Array(St.lit);
            for (var z = 0; z < St.lit - 1; ++z) St.p[z] = yt[z];
          } else St.p = new Array(1);
          St.p[St.lit - 1] = te;
        } else if (Je)
          for (var re = 0, z = 1 << (14 - Je); z > 0; z--) {
            var St = Ge[(qe << (14 - Je)) + re];
            if (St.len || St.p) throw "Invalid table entry";
            (St.len = Je), (St.lit = te), re++;
          }
      }
      return !0;
    }
    const V = { c: 0, lc: 0 };
    function Y(H, te, Ae, Ge) {
      (H = (H << 8) | Ze(Ae, Ge)), (te += 8), (V.c = H), (V.lc = te);
    }
    const ae = { c: 0, lc: 0 };
    function fe(H, te, Ae, Ge, qe, Je, St, yt, z, re) {
      if (H == te) {
        Ge < 8 && (Y(Ae, Ge, qe, St), (Ae = V.c), (Ge = V.lc)), (Ge -= 8);
        var pe = Ae >> Ge,
          pe = new Uint8Array([pe])[0];
        if (z.value + pe > re) return !1;
        for (var ne = yt[z.value - 1]; pe-- > 0; ) yt[z.value++] = ne;
      } else if (z.value < re) yt[z.value++] = H;
      else return !1;
      (ae.c = Ae), (ae.lc = Ge);
    }
    function j(H) {
      return H & 65535;
    }
    function se(H) {
      var te = j(H);
      return te > 32767 ? te - 65536 : te;
    }
    const ve = { a: 0, b: 0 };
    function ye(H, te) {
      var Ae = se(H),
        Ge = se(te),
        qe = Ge,
        Je = Ae + (qe & 1) + (qe >> 1),
        St = Je,
        yt = Je - qe;
      (ve.a = St), (ve.b = yt);
    }
    function be(H, te) {
      var Ae = j(H),
        Ge = j(te),
        qe = (Ae - (Ge >> 1)) & 65535,
        Je = (Ge + qe - 32768) & 65535;
      (ve.a = Je), (ve.b = qe);
    }
    function it(H, te, Ae, Ge, qe, Je, St) {
      for (var yt = St < 16384, z = Ae > qe ? qe : Ae, re = 1, pe; re <= z; )
        re <<= 1;
      for (re >>= 1, pe = re, re >>= 1; re >= 1; ) {
        for (
          var ne = 0,
            Se = ne + Je * (qe - pe),
            Ne = Je * re,
            Ye = Je * pe,
            lt = Ge * re,
            pt = Ge * pe,
            wt,
            Bt,
            Rt,
            jt;
          ne <= Se;
          ne += Ye
        ) {
          for (var Pt = ne, yn = ne + Ge * (Ae - pe); Pt <= yn; Pt += pt) {
            var Vt = Pt + lt,
              Gt = Pt + Ne,
              It = Gt + lt;
            yt
              ? (ye(H[Pt + te], H[Gt + te]),
                (wt = ve.a),
                (Rt = ve.b),
                ye(H[Vt + te], H[It + te]),
                (Bt = ve.a),
                (jt = ve.b),
                ye(wt, Bt),
                (H[Pt + te] = ve.a),
                (H[Vt + te] = ve.b),
                ye(Rt, jt),
                (H[Gt + te] = ve.a),
                (H[It + te] = ve.b))
              : (be(H[Pt + te], H[Gt + te]),
                (wt = ve.a),
                (Rt = ve.b),
                be(H[Vt + te], H[It + te]),
                (Bt = ve.a),
                (jt = ve.b),
                be(wt, Bt),
                (H[Pt + te] = ve.a),
                (H[Vt + te] = ve.b),
                be(Rt, jt),
                (H[Gt + te] = ve.a),
                (H[It + te] = ve.b));
          }
          if (Ae & re) {
            var Gt = Pt + Ne;
            yt ? ye(H[Pt + te], H[Gt + te]) : be(H[Pt + te], H[Gt + te]),
              (wt = ve.a),
              (H[Gt + te] = ve.b),
              (H[Pt + te] = wt);
          }
        }
        if (qe & re)
          for (var Pt = ne, yn = ne + Ge * (Ae - pe); Pt <= yn; Pt += pt) {
            var Vt = Pt + lt;
            yt ? ye(H[Pt + te], H[Vt + te]) : be(H[Pt + te], H[Vt + te]),
              (wt = ve.a),
              (H[Vt + te] = ve.b),
              (H[Pt + te] = wt);
          }
        (pe = re), (re >>= 1);
      }
      return ne;
    }
    function We(H, te, Ae, Ge, qe, Je, St, yt, z, re) {
      for (
        var pe = 0, ne = 0, Se = yt, Ne = Math.trunc(qe.value + (Je + 7) / 8);
        qe.value < Ne;

      )
        for (Y(pe, ne, Ae, qe), pe = V.c, ne = V.lc; ne >= 14; ) {
          var Ye = (pe >> (ne - 14)) & 16383,
            lt = te[Ye];
          if (lt.len)
            (ne -= lt.len),
              fe(lt.lit, St, pe, ne, Ae, Ge, qe, z, re, Se),
              (pe = ae.c),
              (ne = ae.lc);
          else {
            if (!lt.p) throw "hufDecode issues";
            var pt;
            for (pt = 0; pt < lt.lit; pt++) {
              for (var wt = ge(H[lt.p[pt]]); ne < wt && qe.value < Ne; )
                Y(pe, ne, Ae, qe), (pe = V.c), (ne = V.lc);
              if (
                ne >= wt &&
                oe(H[lt.p[pt]]) == ((pe >> (ne - wt)) & ((1 << wt) - 1))
              ) {
                (ne -= wt),
                  fe(lt.p[pt], St, pe, ne, Ae, Ge, qe, z, re, Se),
                  (pe = ae.c),
                  (ne = ae.lc);
                break;
              }
            }
            if (pt == lt.lit) throw "hufDecode issues";
          }
        }
      var Bt = (8 - Je) & 7;
      for (pe >>= Bt, ne -= Bt; ne > 0; ) {
        var lt = te[(pe << (14 - ne)) & 16383];
        if (lt.len)
          (ne -= lt.len),
            fe(lt.lit, St, pe, ne, Ae, Ge, qe, z, re, Se),
            (pe = ae.c),
            (ne = ae.lc);
        else throw "hufDecode issues";
      }
      return !0;
    }
    function $e(H, te, Ae, Ge, qe, Je) {
      var St = { value: 0 },
        yt = Ae.value,
        z = nt(te, Ae),
        re = nt(te, Ae);
      Ae.value += 4;
      var pe = nt(te, Ae);
      if (((Ae.value += 4), z < 0 || z >= 65537 || re < 0 || re >= 65537))
        throw "Something wrong with HUF_ENCSIZE";
      var ne = new Array(65537),
        Se = new Array(16384);
      W(Se);
      var Ne = Ge - (Ae.value - yt);
      if ((K(H, te, Ae, Ne, z, re, ne), pe > 8 * (Ge - (Ae.value - yt))))
        throw "Something wrong with hufUncompress";
      me(ne, z, re, Se), We(ne, Se, H, te, Ae, pe, re, Je, qe, St);
    }
    function Me(H, te, Ae) {
      for (var Ge = 0; Ge < Ae; ++Ge) te[Ge] = H[te[Ge]];
    }
    function Ie(H) {
      for (var te = 1; te < H.length; te++) {
        var Ae = H[te - 1] + H[te] - 128;
        H[te] = Ae;
      }
    }
    function $(H, te) {
      for (
        var Ae = 0,
          Ge = Math.floor((H.length + 1) / 2),
          qe = 0,
          Je = H.length - 1;
        !(qe > Je || ((te[qe++] = H[Ae++]), qe > Je));

      )
        te[qe++] = H[Ge++];
    }
    function ft(H) {
      for (
        var te = H.byteLength, Ae = new Array(), Ge = 0, qe = new DataView(H);
        te > 0;

      ) {
        var Je = qe.getInt8(Ge++);
        if (Je < 0) {
          var St = -Je;
          te -= St + 1;
          for (var yt = 0; yt < St; yt++) Ae.push(qe.getUint8(Ge++));
        } else {
          var St = Je;
          te -= 2;
          for (var z = qe.getUint8(Ge++), yt = 0; yt < St + 1; yt++) Ae.push(z);
        }
      }
      return Ae;
    }
    function Pe(H, te, Ae, Ge, qe, Je) {
      var Vt = new DataView(Je.buffer),
        St = Ae[H.idx[0]].width,
        yt = Ae[H.idx[0]].height,
        z = 3,
        re = Math.floor(St / 8),
        pe = Math.ceil(St / 8),
        ne = Math.ceil(yt / 8),
        Se = St - (pe - 1) * 8,
        Ne = yt - (ne - 1) * 8,
        Ye = { value: 0 },
        lt = new Array(z),
        pt = new Array(z),
        wt = new Array(z),
        Bt = new Array(z),
        Rt = new Array(z);
      for (let rn = 0; rn < z; ++rn)
        (Rt[rn] = te[H.idx[rn]]),
          (lt[rn] = rn < 1 ? 0 : lt[rn - 1] + pe * ne),
          (pt[rn] = new Float32Array(64)),
          (wt[rn] = new Uint16Array(64)),
          (Bt[rn] = new Uint16Array(pe * 64));
      for (let rn = 0; rn < ne; ++rn) {
        var jt = 8;
        rn == ne - 1 && (jt = Ne);
        var Pt = 8;
        for (let sn = 0; sn < pe; ++sn) {
          sn == pe - 1 && (Pt = Se);
          for (let Xt = 0; Xt < z; ++Xt)
            wt[Xt].fill(0),
              (wt[Xt][0] = qe[lt[Xt]++]),
              rt(Ye, Ge, wt[Xt]),
              Ue(wt[Xt], pt[Xt]),
              ht(pt[Xt]);
          Ve(pt);
          for (let Xt = 0; Xt < z; ++Xt) X(pt[Xt], Bt[Xt], sn * 64);
        }
        let Ln = 0;
        for (let sn = 0; sn < z; ++sn) {
          const Xt = Ae[H.idx[sn]].type;
          for (let on = 8 * rn; on < 8 * rn + jt; ++on) {
            Ln = Rt[sn][on];
            for (let Zn = 0; Zn < re; ++Zn) {
              const Tn = Zn * 64 + (on & 7) * 8;
              Vt.setUint16(Ln + 0 * 2 * Xt, Bt[sn][Tn + 0], !0),
                Vt.setUint16(Ln + 1 * 2 * Xt, Bt[sn][Tn + 1], !0),
                Vt.setUint16(Ln + 2 * 2 * Xt, Bt[sn][Tn + 2], !0),
                Vt.setUint16(Ln + 3 * 2 * Xt, Bt[sn][Tn + 3], !0),
                Vt.setUint16(Ln + 4 * 2 * Xt, Bt[sn][Tn + 4], !0),
                Vt.setUint16(Ln + 5 * 2 * Xt, Bt[sn][Tn + 5], !0),
                Vt.setUint16(Ln + 6 * 2 * Xt, Bt[sn][Tn + 6], !0),
                Vt.setUint16(Ln + 7 * 2 * Xt, Bt[sn][Tn + 7], !0),
                (Ln += 8 * 2 * Xt);
            }
          }
          if (re != pe)
            for (let on = 8 * rn; on < 8 * rn + jt; ++on) {
              const Zn = Rt[sn][on] + 8 * re * 2 * Xt,
                Tn = re * 64 + (on & 7) * 8;
              for (let Nn = 0; Nn < Pt; ++Nn)
                Vt.setUint16(Zn + Nn * 2 * Xt, Bt[sn][Tn + Nn], !0);
            }
        }
      }
      for (
        var yn = new Uint16Array(St), Vt = new DataView(Je.buffer), Gt = 0;
        Gt < z;
        ++Gt
      ) {
        Ae[H.idx[Gt]].decoded = !0;
        var It = Ae[H.idx[Gt]].type;
        if (Ae[Gt].type == 2)
          for (var Jn = 0; Jn < yt; ++Jn) {
            const rn = Rt[Gt][Jn];
            for (var qt = 0; qt < St; ++qt)
              yn[qt] = Vt.getUint16(rn + qt * 2 * It, !0);
            for (var qt = 0; qt < St; ++qt)
              Vt.setFloat32(rn + qt * 2 * It, xe(yn[qt]), !0);
          }
      }
    }
    function rt(H, te, Ae) {
      for (var Ge, qe = 1; qe < 64; )
        (Ge = te[H.value]),
          Ge == 65280
            ? (qe = 64)
            : Ge >> 8 == 255
            ? (qe += Ge & 255)
            : ((Ae[qe] = Ge), qe++),
          H.value++;
    }
    function Ue(H, te) {
      (te[0] = xe(H[0])),
        (te[1] = xe(H[1])),
        (te[2] = xe(H[5])),
        (te[3] = xe(H[6])),
        (te[4] = xe(H[14])),
        (te[5] = xe(H[15])),
        (te[6] = xe(H[27])),
        (te[7] = xe(H[28])),
        (te[8] = xe(H[2])),
        (te[9] = xe(H[4])),
        (te[10] = xe(H[7])),
        (te[11] = xe(H[13])),
        (te[12] = xe(H[16])),
        (te[13] = xe(H[26])),
        (te[14] = xe(H[29])),
        (te[15] = xe(H[42])),
        (te[16] = xe(H[3])),
        (te[17] = xe(H[8])),
        (te[18] = xe(H[12])),
        (te[19] = xe(H[17])),
        (te[20] = xe(H[25])),
        (te[21] = xe(H[30])),
        (te[22] = xe(H[41])),
        (te[23] = xe(H[43])),
        (te[24] = xe(H[9])),
        (te[25] = xe(H[11])),
        (te[26] = xe(H[18])),
        (te[27] = xe(H[24])),
        (te[28] = xe(H[31])),
        (te[29] = xe(H[40])),
        (te[30] = xe(H[44])),
        (te[31] = xe(H[53])),
        (te[32] = xe(H[10])),
        (te[33] = xe(H[19])),
        (te[34] = xe(H[23])),
        (te[35] = xe(H[32])),
        (te[36] = xe(H[39])),
        (te[37] = xe(H[45])),
        (te[38] = xe(H[52])),
        (te[39] = xe(H[54])),
        (te[40] = xe(H[20])),
        (te[41] = xe(H[22])),
        (te[42] = xe(H[33])),
        (te[43] = xe(H[38])),
        (te[44] = xe(H[46])),
        (te[45] = xe(H[51])),
        (te[46] = xe(H[55])),
        (te[47] = xe(H[60])),
        (te[48] = xe(H[21])),
        (te[49] = xe(H[34])),
        (te[50] = xe(H[37])),
        (te[51] = xe(H[47])),
        (te[52] = xe(H[50])),
        (te[53] = xe(H[56])),
        (te[54] = xe(H[59])),
        (te[55] = xe(H[61])),
        (te[56] = xe(H[35])),
        (te[57] = xe(H[36])),
        (te[58] = xe(H[48])),
        (te[59] = xe(H[49])),
        (te[60] = xe(H[57])),
        (te[61] = xe(H[58])),
        (te[62] = xe(H[62])),
        (te[63] = xe(H[63]));
    }
    function ht(H) {
      const te = 0.5 * Math.cos(0.7853975),
        Ae = 0.5 * Math.cos(3.14159 / 16),
        Ge = 0.5 * Math.cos(3.14159 / 8),
        qe = 0.5 * Math.cos((3 * 3.14159) / 16),
        Je = 0.5 * Math.cos((5 * 3.14159) / 16),
        St = 0.5 * Math.cos((3 * 3.14159) / 8),
        yt = 0.5 * Math.cos((7 * 3.14159) / 16);
      for (
        var z = new Array(4),
          re = new Array(4),
          pe = new Array(4),
          ne = new Array(4),
          Se = 0;
        Se < 8;
        ++Se
      ) {
        var Ne = Se * 8;
        (z[0] = Ge * H[Ne + 2]),
          (z[1] = St * H[Ne + 2]),
          (z[2] = Ge * H[Ne + 6]),
          (z[3] = St * H[Ne + 6]),
          (re[0] =
            Ae * H[Ne + 1] + qe * H[Ne + 3] + Je * H[Ne + 5] + yt * H[Ne + 7]),
          (re[1] =
            qe * H[Ne + 1] - yt * H[Ne + 3] - Ae * H[Ne + 5] - Je * H[Ne + 7]),
          (re[2] =
            Je * H[Ne + 1] - Ae * H[Ne + 3] + yt * H[Ne + 5] + qe * H[Ne + 7]),
          (re[3] =
            yt * H[Ne + 1] - Je * H[Ne + 3] + qe * H[Ne + 5] - Ae * H[Ne + 7]),
          (pe[0] = te * (H[Ne + 0] + H[Ne + 4])),
          (pe[3] = te * (H[Ne + 0] - H[Ne + 4])),
          (pe[1] = z[0] + z[3]),
          (pe[2] = z[1] - z[2]),
          (ne[0] = pe[0] + pe[1]),
          (ne[1] = pe[3] + pe[2]),
          (ne[2] = pe[3] - pe[2]),
          (ne[3] = pe[0] - pe[1]),
          (H[Ne + 0] = ne[0] + re[0]),
          (H[Ne + 1] = ne[1] + re[1]),
          (H[Ne + 2] = ne[2] + re[2]),
          (H[Ne + 3] = ne[3] + re[3]),
          (H[Ne + 4] = ne[3] - re[3]),
          (H[Ne + 5] = ne[2] - re[2]),
          (H[Ne + 6] = ne[1] - re[1]),
          (H[Ne + 7] = ne[0] - re[0]);
      }
      for (var Ye = 0; Ye < 8; ++Ye)
        (z[0] = Ge * H[16 + Ye]),
          (z[1] = St * H[16 + Ye]),
          (z[2] = Ge * H[48 + Ye]),
          (z[3] = St * H[48 + Ye]),
          (re[0] =
            Ae * H[8 + Ye] +
            qe * H[24 + Ye] +
            Je * H[40 + Ye] +
            yt * H[56 + Ye]),
          (re[1] =
            qe * H[8 + Ye] -
            yt * H[24 + Ye] -
            Ae * H[40 + Ye] -
            Je * H[56 + Ye]),
          (re[2] =
            Je * H[8 + Ye] -
            Ae * H[24 + Ye] +
            yt * H[40 + Ye] +
            qe * H[56 + Ye]),
          (re[3] =
            yt * H[8 + Ye] -
            Je * H[24 + Ye] +
            qe * H[40 + Ye] -
            Ae * H[56 + Ye]),
          (pe[0] = te * (H[Ye] + H[32 + Ye])),
          (pe[3] = te * (H[Ye] - H[32 + Ye])),
          (pe[1] = z[0] + z[3]),
          (pe[2] = z[1] - z[2]),
          (ne[0] = pe[0] + pe[1]),
          (ne[1] = pe[3] + pe[2]),
          (ne[2] = pe[3] - pe[2]),
          (ne[3] = pe[0] - pe[1]),
          (H[0 + Ye] = ne[0] + re[0]),
          (H[8 + Ye] = ne[1] + re[1]),
          (H[16 + Ye] = ne[2] + re[2]),
          (H[24 + Ye] = ne[3] + re[3]),
          (H[32 + Ye] = ne[3] - re[3]),
          (H[40 + Ye] = ne[2] - re[2]),
          (H[48 + Ye] = ne[1] - re[1]),
          (H[56 + Ye] = ne[0] - re[0]);
    }
    function Ve(H) {
      for (var te = 0; te < 64; ++te) {
        var Ae = H[0][te],
          Ge = H[1][te],
          qe = H[2][te];
        (H[0][te] = Ae + 1.5747 * qe),
          (H[1][te] = Ae - 0.1873 * Ge - 0.4682 * qe),
          (H[2][te] = Ae + 1.8556 * Ge);
      }
    }
    function X(H, te, Ae) {
      for (var Ge = 0; Ge < 64; ++Ge) te[Ae + Ge] = Ff.toHalfFloat(k(H[Ge]));
    }
    function k(H) {
      return H <= 1
        ? Math.sign(H) * Math.pow(Math.abs(H), 2.2)
        : Math.sign(H) * Math.pow(O, Math.abs(H) - 1);
    }
    function de(H) {
      return new DataView(H.array.buffer, H.offset.value, H.size);
    }
    function Ee(H) {
      var te = H.viewer.buffer.slice(H.offset.value, H.offset.value + H.size),
        Ae = new Uint8Array(ft(te)),
        Ge = new Uint8Array(Ae.length);
      return Ie(Ae), $(Ae, Ge), new DataView(Ge.buffer);
    }
    function we(H) {
      var te = H.array.slice(H.offset.value, H.offset.value + H.size),
        Ae = v0(te),
        Ge = new Uint8Array(Ae.length);
      return Ie(Ae), $(Ae, Ge), new DataView(Ge.buffer);
    }
    function He(H) {
      for (
        var te = H.viewer,
          Ae = { value: H.offset.value },
          Ge = new Uint16Array(
            H.width * H.scanlineBlockSize * (H.channels * H.type)
          ),
          qe = new Uint8Array(8192),
          Je = 0,
          St = new Array(H.channels),
          yt = 0;
        yt < H.channels;
        yt++
      )
        (St[yt] = {}),
          (St[yt].start = Je),
          (St[yt].end = St[yt].start),
          (St[yt].nx = H.width),
          (St[yt].ny = H.lines),
          (St[yt].size = H.type),
          (Je += St[yt].nx * St[yt].ny * St[yt].size);
      var z = Re(te, Ae),
        re = Re(te, Ae);
      if (re >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      if (z <= re)
        for (var yt = 0; yt < re - z + 1; yt++) qe[yt + z] = le(te, Ae);
      var pe = new Uint16Array(65536),
        ne = U(qe, pe),
        Se = nt(te, Ae);
      $e(H.array, te, Ae, Se, Ge, Je);
      for (var yt = 0; yt < H.channels; ++yt)
        for (var Ne = St[yt], Ye = 0; Ye < St[yt].size; ++Ye)
          it(Ge, Ne.start + Ye, Ne.nx, Ne.size, Ne.ny, Ne.nx * Ne.size, ne);
      Me(pe, Ge, Je);
      for (
        var lt = 0, pt = new Uint8Array(Ge.buffer.byteLength), wt = 0;
        wt < H.lines;
        wt++
      )
        for (var Bt = 0; Bt < H.channels; Bt++) {
          var Ne = St[Bt],
            Rt = Ne.nx * Ne.size,
            jt = new Uint8Array(Ge.buffer, Ne.end * 2, Rt * 2);
          pt.set(jt, lt), (lt += Rt * 2), (Ne.end += Rt);
        }
      return new DataView(pt.buffer);
    }
    function tt(H) {
      var te = H.array.slice(H.offset.value, H.offset.value + H.size),
        Ae = v0(te);
      const Ge = H.lines * H.channels * H.width,
        qe = H.type == 1 ? new Uint16Array(Ge) : new Uint32Array(Ge);
      let Je = 0,
        St = 0;
      const yt = new Array(4);
      for (let z = 0; z < H.lines; z++)
        for (let re = 0; re < H.channels; re++) {
          let pe = 0;
          switch (H.type) {
            case 1:
              (yt[0] = Je), (yt[1] = yt[0] + H.width), (Je = yt[1] + H.width);
              for (let ne = 0; ne < H.width; ++ne) {
                const Se = (Ae[yt[0]++] << 8) | Ae[yt[1]++];
                (pe += Se), (qe[St] = pe), St++;
              }
              break;
            case 2:
              (yt[0] = Je),
                (yt[1] = yt[0] + H.width),
                (yt[2] = yt[1] + H.width),
                (Je = yt[2] + H.width);
              for (let ne = 0; ne < H.width; ++ne) {
                const Se =
                  (Ae[yt[0]++] << 24) |
                  (Ae[yt[1]++] << 16) |
                  (Ae[yt[2]++] << 8);
                (pe += Se), (qe[St] = pe), St++;
              }
              break;
          }
        }
      return new DataView(qe.buffer);
    }
    function Ke(H) {
      var te = H.viewer,
        Ae = { value: H.offset.value },
        Ge = new Uint8Array(H.width * H.lines * (H.channels * H.type * 2)),
        qe = {
          version: Be(te, Ae),
          unknownUncompressedSize: Be(te, Ae),
          unknownCompressedSize: Be(te, Ae),
          acCompressedSize: Be(te, Ae),
          dcCompressedSize: Be(te, Ae),
          rleCompressedSize: Be(te, Ae),
          rleUncompressedSize: Be(te, Ae),
          rleRawSize: Be(te, Ae),
          totalAcUncompressedCount: Be(te, Ae),
          totalDcUncompressedCount: Be(te, Ae),
          acCompression: Be(te, Ae),
        };
      if (qe.version < 2)
        throw (
          "EXRLoader.parse: " +
          pi.compression +
          " version " +
          qe.version +
          " is unsupported"
        );
      for (var Je = new Array(), St = Re(te, Ae) - 2; St > 0; ) {
        var yt = st(te.buffer, Ae),
          z = le(te, Ae),
          re = (z >> 2) & 3,
          pe = (z >> 4) - 1,
          ne = new Int8Array([pe])[0],
          Se = le(te, Ae);
        Je.push({ name: yt, index: ne, type: Se, compression: re }),
          (St -= yt.length + 3);
      }
      for (
        var Ne = pi.channels, Ye = new Array(H.channels), lt = 0;
        lt < H.channels;
        ++lt
      ) {
        var pt = (Ye[lt] = {}),
          wt = Ne[lt];
        (pt.name = wt.name),
          (pt.compression = 0),
          (pt.decoded = !1),
          (pt.type = wt.pixelType),
          (pt.pLinear = wt.pLinear),
          (pt.width = H.width),
          (pt.height = H.lines);
      }
      for (var Bt = { idx: new Array(3) }, Rt = 0; Rt < H.channels; ++Rt)
        for (var pt = Ye[Rt], lt = 0; lt < Je.length; ++lt) {
          var jt = Je[lt];
          pt.name == jt.name &&
            ((pt.compression = jt.compression),
            jt.index >= 0 && (Bt.idx[jt.index] = Rt),
            (pt.offset = Rt));
        }
      if (qe.acCompressedSize > 0)
        switch (qe.acCompression) {
          case 0:
            var Vt = new Uint16Array(qe.totalAcUncompressedCount);
            $e(
              H.array,
              te,
              Ae,
              qe.acCompressedSize,
              Vt,
              qe.totalAcUncompressedCount
            );
            break;
          case 1:
            var Pt = H.array.slice(
                Ae.value,
                Ae.value + qe.totalAcUncompressedCount
              ),
              yn = v0(Pt),
              Vt = new Uint16Array(yn.buffer);
            Ae.value += qe.totalAcUncompressedCount;
            break;
        }
      if (qe.dcCompressedSize > 0) {
        var Gt = { array: H.array, offset: Ae, size: qe.dcCompressedSize },
          It = new Uint16Array(we(Gt).buffer);
        Ae.value += qe.dcCompressedSize;
      }
      if (qe.rleRawSize > 0) {
        var Pt = H.array.slice(Ae.value, Ae.value + qe.rleCompressedSize),
          yn = v0(Pt),
          Jn = ft(yn.buffer);
        Ae.value += qe.rleCompressedSize;
      }
      for (var qt = 0, rn = new Array(Ye.length), lt = 0; lt < rn.length; ++lt)
        rn[lt] = new Array();
      for (var Ln = 0; Ln < H.lines; ++Ln)
        for (var sn = 0; sn < Ye.length; ++sn)
          rn[sn].push(qt), (qt += Ye[sn].width * H.type * 2);
      Pe(Bt, rn, Ye, Vt, It, Ge);
      for (var lt = 0; lt < Ye.length; ++lt) {
        var pt = Ye[lt];
        if (!pt.decoded)
          switch (pt.compression) {
            case 2:
              for (var Xt = 0, on = 0, Ln = 0; Ln < H.lines; ++Ln) {
                for (var Zn = rn[lt][Xt], Tn = 0; Tn < pt.width; ++Tn) {
                  for (var Nn = 0; Nn < 2 * pt.type; ++Nn)
                    Ge[Zn++] = Jn[on + Nn * pt.width * pt.height];
                  on++;
                }
                Xt++;
              }
              break;
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression";
          }
      }
      return new DataView(Ge.buffer);
    }
    function st(H, te) {
      for (var Ae = new Uint8Array(H), Ge = 0; Ae[te.value + Ge] != 0; )
        Ge += 1;
      var qe = new TextDecoder().decode(Ae.slice(te.value, te.value + Ge));
      return (te.value = te.value + Ge + 1), qe;
    }
    function Ut(H, te, Ae) {
      var Ge = new TextDecoder().decode(
        new Uint8Array(H).slice(te.value, te.value + Ae)
      );
      return (te.value = te.value + Ae), Ge;
    }
    function et(H, te) {
      var Ae = mt(H, te),
        Ge = nt(H, te);
      return [Ae, Ge];
    }
    function At(H, te) {
      var Ae = nt(H, te),
        Ge = nt(H, te);
      return [Ae, Ge];
    }
    function mt(H, te) {
      var Ae = H.getInt32(te.value, !0);
      return (te.value = te.value + 4), Ae;
    }
    function nt(H, te) {
      var Ae = H.getUint32(te.value, !0);
      return (te.value = te.value + 4), Ae;
    }
    function Ze(H, te) {
      var Ae = H[te.value];
      return (te.value = te.value + 1), Ae;
    }
    function le(H, te) {
      var Ae = H.getUint8(te.value);
      return (te.value = te.value + 1), Ae;
    }
    const Be = function (H, te) {
      let Ae;
      return (
        "getBigInt64" in DataView.prototype
          ? (Ae = Number(H.getBigInt64(te.value, !0)))
          : (Ae =
              H.getUint32(te.value + 4, !0) +
              Number(H.getUint32(te.value, !0) << 32)),
        (te.value += 8),
        Ae
      );
    };
    function vt(H, te) {
      var Ae = H.getFloat32(te.value, !0);
      return (te.value += 4), Ae;
    }
    function ce(H, te) {
      return Ff.toHalfFloat(vt(H, te));
    }
    function xe(H) {
      var te = (H & 31744) >> 10,
        Ae = H & 1023;
      return (
        (H >> 15 ? -1 : 1) *
        (te
          ? te === 31
            ? Ae
              ? NaN
              : 1 / 0
            : Math.pow(2, te - 15) * (1 + Ae / 1024)
          : 6103515625e-14 * (Ae / 1024))
      );
    }
    function Re(H, te) {
      var Ae = H.getUint16(te.value, !0);
      return (te.value += 2), Ae;
    }
    function Qe(H, te) {
      return xe(Re(H, te));
    }
    function gt(H, te, Ae, Ge) {
      for (var qe = Ae.value, Je = []; Ae.value < qe + Ge - 1; ) {
        var St = st(te, Ae),
          yt = mt(H, Ae),
          z = le(H, Ae);
        Ae.value += 3;
        var re = mt(H, Ae),
          pe = mt(H, Ae);
        Je.push({
          name: St,
          pixelType: yt,
          pLinear: z,
          xSampling: re,
          ySampling: pe,
        });
      }
      return (Ae.value += 1), Je;
    }
    function dt(H, te) {
      var Ae = vt(H, te),
        Ge = vt(H, te),
        qe = vt(H, te),
        Je = vt(H, te),
        St = vt(H, te),
        yt = vt(H, te),
        z = vt(H, te),
        re = vt(H, te);
      return {
        redX: Ae,
        redY: Ge,
        greenX: qe,
        greenY: Je,
        blueX: St,
        blueY: yt,
        whiteX: z,
        whiteY: re,
      };
    }
    function Ct(H, te) {
      var Ae = [
          "NO_COMPRESSION",
          "RLE_COMPRESSION",
          "ZIPS_COMPRESSION",
          "ZIP_COMPRESSION",
          "PIZ_COMPRESSION",
          "PXR24_COMPRESSION",
          "B44_COMPRESSION",
          "B44A_COMPRESSION",
          "DWAA_COMPRESSION",
          "DWAB_COMPRESSION",
        ],
        Ge = le(H, te);
      return Ae[Ge];
    }
    function Ht(H, te) {
      var Ae = nt(H, te),
        Ge = nt(H, te),
        qe = nt(H, te),
        Je = nt(H, te);
      return { xMin: Ae, yMin: Ge, xMax: qe, yMax: Je };
    }
    function Nt(H, te) {
      var Ae = ["INCREASING_Y"],
        Ge = le(H, te);
      return Ae[Ge];
    }
    function Ft(H, te) {
      var Ae = vt(H, te),
        Ge = vt(H, te);
      return [Ae, Ge];
    }
    function gn(H, te) {
      var Ae = vt(H, te),
        Ge = vt(H, te),
        qe = vt(H, te);
      return [Ae, Ge, qe];
    }
    function vn(H, te, Ae, Ge, qe) {
      if (Ge === "string" || Ge === "stringvector" || Ge === "iccProfile")
        return Ut(te, Ae, qe);
      if (Ge === "chlist") return gt(H, te, Ae, qe);
      if (Ge === "chromaticities") return dt(H, Ae);
      if (Ge === "compression") return Ct(H, Ae);
      if (Ge === "box2i") return Ht(H, Ae);
      if (Ge === "lineOrder") return Nt(H, Ae);
      if (Ge === "float") return vt(H, Ae);
      if (Ge === "v2f") return Ft(H, Ae);
      if (Ge === "v3f") return gn(H, Ae);
      if (Ge === "int") return mt(H, Ae);
      if (Ge === "rational") return et(H, Ae);
      if (Ge === "timecode") return At(H, Ae);
      if (Ge === "preview") return (Ae.value += qe), "skipped";
      Ae.value += qe;
    }
    function ai(H, te, Ae) {
      const Ge = {};
      if (H.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      Ge.version = H.getUint8(4);
      const qe = H.getUint8(5);
      (Ge.spec = {
        singleTile: !!(qe & 2),
        longName: !!(qe & 4),
        deepFormat: !!(qe & 8),
        multiPart: !!(qe & 16),
      }),
        (Ae.value = 8);
      for (var Je = !0; Je; ) {
        var St = st(te, Ae);
        if (St == 0) Je = !1;
        else {
          var yt = st(te, Ae),
            z = nt(H, Ae),
            re = vn(H, te, Ae, yt, z);
          re === void 0
            ? console.warn(
                `EXRLoader.parse: skipped unknown header attribute type '${yt}'.`
              )
            : (Ge[St] = re);
        }
      }
      if ((qe & -5) != 0)
        throw (
          (console.error("EXRHeader:", Ge),
          "THREE.EXRLoader: provided file is currently unsupported.")
        );
      return Ge;
    }
    function Bi(H, te, Ae, Ge, qe) {
      const Je = {
        size: 0,
        viewer: te,
        array: Ae,
        offset: Ge,
        width: H.dataWindow.xMax - H.dataWindow.xMin + 1,
        height: H.dataWindow.yMax - H.dataWindow.yMin + 1,
        channels: H.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: H.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [cm ? "colorSpace" : "encoding"]: null,
      };
      switch (H.compression) {
        case "NO_COMPRESSION":
          (Je.lines = 1), (Je.uncompress = de);
          break;
        case "RLE_COMPRESSION":
          (Je.lines = 1), (Je.uncompress = Ee);
          break;
        case "ZIPS_COMPRESSION":
          (Je.lines = 1), (Je.uncompress = we);
          break;
        case "ZIP_COMPRESSION":
          (Je.lines = 16), (Je.uncompress = we);
          break;
        case "PIZ_COMPRESSION":
          (Je.lines = 32), (Je.uncompress = He);
          break;
        case "PXR24_COMPRESSION":
          (Je.lines = 16), (Je.uncompress = tt);
          break;
        case "DWAA_COMPRESSION":
          (Je.lines = 32), (Je.uncompress = Ke);
          break;
        case "DWAB_COMPRESSION":
          (Je.lines = 256), (Je.uncompress = Ke);
          break;
        default:
          throw "EXRLoader.parse: " + H.compression + " is unsupported";
      }
      if (((Je.scanlineBlockSize = Je.lines), Je.type == 1))
        switch (qe) {
          case yi:
            (Je.getter = Qe), (Je.inputSize = 2);
            break;
          case va:
            (Je.getter = Re), (Je.inputSize = 2);
            break;
        }
      else if (Je.type == 2)
        switch (qe) {
          case yi:
            (Je.getter = vt), (Je.inputSize = 4);
            break;
          case va:
            (Je.getter = ce), (Je.inputSize = 4);
        }
      else
        throw (
          "EXRLoader.parse: unsupported pixelType " +
          Je.type +
          " for " +
          H.compression +
          "."
        );
      Je.blockCount = (H.dataWindow.yMax + 1) / Je.scanlineBlockSize;
      for (var St = 0; St < Je.blockCount; St++) Be(te, Ge);
      Je.outputChannels = Je.channels == 3 ? 4 : Je.channels;
      const yt = Je.width * Je.height * Je.outputChannels;
      switch (qe) {
        case yi:
          (Je.byteArray = new Float32Array(yt)),
            Je.channels < Je.outputChannels && Je.byteArray.fill(1, 0, yt);
          break;
        case va:
          (Je.byteArray = new Uint16Array(yt)),
            Je.channels < Je.outputChannels && Je.byteArray.fill(15360, 0, yt);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", qe);
          break;
      }
      return (
        (Je.bytesPerLine = Je.width * Je.inputSize * Je.channels),
        Je.outputChannels == 4 ? (Je.format = oa) : (Je.format = vc),
        cm ? (Je.colorSpace = "srgb-linear") : (Je.encoding = 3e3),
        Je
      );
    }
    const ui = new DataView(e),
      di = new Uint8Array(e),
      Di = { value: 0 },
      pi = ai(ui, e, Di),
      zt = Bi(pi, ui, di, Di, this.type),
      pn = { value: 0 },
      en = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let H = 0; H < zt.height / zt.scanlineBlockSize; H++) {
      const te = nt(ui, Di);
      (zt.size = nt(ui, Di)),
        (zt.lines =
          te + zt.scanlineBlockSize > zt.height
            ? zt.height - te
            : zt.scanlineBlockSize);
      const Ge =
        zt.size < zt.lines * zt.bytesPerLine ? zt.uncompress(zt) : de(zt);
      Di.value += zt.size;
      for (let qe = 0; qe < zt.scanlineBlockSize; qe++) {
        const Je = qe + H * zt.scanlineBlockSize;
        if (Je >= zt.height) break;
        for (let St = 0; St < zt.channels; St++) {
          const yt = en[pi.channels[St].name];
          for (let z = 0; z < zt.width; z++) {
            pn.value =
              (qe * (zt.channels * zt.width) + St * zt.width + z) *
              zt.inputSize;
            const re =
              (zt.height - 1 - Je) * (zt.width * zt.outputChannels) +
              z * zt.outputChannels +
              yt;
            zt.byteArray[re] = zt.getter(Ge, pn);
          }
        }
      }
    }
    return {
      header: pi,
      width: zt.width,
      height: zt.height,
      data: zt.byteArray,
      format: zt.format,
      [cm ? "colorSpace" : "encoding"]: zt[cm ? "colorSpace" : "encoding"],
      type: this.type,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, n, i) {
    function a(l, u) {
      cm ? (l.colorSpace = u.colorSpace) : (l.encoding = u.encoding),
        (l.minFilter = In),
        (l.magFilter = In),
        (l.generateMipmaps = !1),
        (l.flipY = !1),
        t && t(l, u);
    }
    return super.load(e, a, n, i);
  }
}
const aA = new WeakMap();
class hF extends qa {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, n, i) {
    const a = new Ja(this.manager);
    a.setPath(this.path),
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        (l) => {
          const u = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(l, u).then(t).catch(i);
        },
        n,
        i
      );
  }
  decodeDracoFile(e, t, n, i) {
    const a = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
    };
    this.decodeGeometry(e, a).then(t);
  }
  decodeGeometry(e, t) {
    for (const f in t.attributeTypes) {
      const d = t.attributeTypes[f];
      d.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[f] = d.name);
    }
    const n = JSON.stringify(t);
    if (aA.has(e)) {
      const f = aA.get(e);
      if (f.key === n) return f.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let i;
    const a = this.workerNextTaskID++,
      l = e.byteLength,
      u = this._getWorker(a, l)
        .then(
          (f) => (
            (i = f),
            new Promise((d, m) => {
              (i._callbacks[a] = { resolve: d, reject: m }),
                i.postMessage(
                  { type: "decode", id: a, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((f) => this._createGeometry(f.geometry));
    return (
      u
        .catch(() => !0)
        .then(() => {
          i && a && this._releaseTask(i, a);
        }),
      aA.set(e, { key: n, promise: u }),
      u
    );
  }
  _createGeometry(e) {
    const t = new mn();
    e.index && t.setIndex(new Yn(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const i = e.attributes[n],
        a = i.name,
        l = i.array,
        u = i.itemSize;
      t.setAttribute(a, new Yn(l, u));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const n = new Ja(this.manager);
    return (
      n.setPath(this.decoderPath),
      n.setResponseType(t),
      n.setWithCredentials(this.withCredentials),
      new Promise((i, a) => {
        n.load(e, i, void 0, a);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((n) => {
        const i = n[0];
        e || (this.decoderConfig.wasmBinary = n[1]);
        const a = dF.toString(),
          l = [
            "/* draco decoder */",
            i,
            "",
            "/* worker */",
            a.substring(a.indexOf("{") + 1, a.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([l]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        (i._callbacks = {}),
          (i._taskCosts = {}),
          (i._taskLoad = 0),
          i.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (i.onmessage = function (a) {
            const l = a.data;
            switch (l.type) {
              case "decode":
                i._callbacks[l.id].resolve(l);
                break;
              case "error":
                i._callbacks[l.id].reject(l);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + l.type + '"'
                );
            }
          }),
          this.workerPool.push(i);
      } else
        this.workerPool.sort(function (i, a) {
          return i._taskLoad > a._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return (n._taskCosts[e] = t), (n._taskLoad += t), n;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function dF() {
  let s, e;
  onmessage = function (l) {
    const u = l.data;
    switch (u.type) {
      case "init":
        (s = u.decoderConfig),
          (e = new Promise(function (m) {
            (s.onModuleLoaded = function (v) {
              m({ draco: v });
            }),
              DracoDecoderModule(s);
          }));
        break;
      case "decode":
        const f = u.buffer,
          d = u.taskConfig;
        e.then((m) => {
          const v = m.draco,
            _ = new v.Decoder(),
            A = new v.DecoderBuffer();
          A.Init(new Int8Array(f), f.byteLength);
          try {
            const M = t(v, _, A, d),
              T = M.attributes.map((E) => E.array.buffer);
            M.index && T.push(M.index.array.buffer),
              self.postMessage({ type: "decode", id: u.id, geometry: M }, T);
          } catch (M) {
            console.error(M),
              self.postMessage({ type: "error", id: u.id, error: M.message });
          } finally {
            v.destroy(A), v.destroy(_);
          }
        });
        break;
    }
  };
  function t(l, u, f, d) {
    const m = d.attributeIDs,
      v = d.attributeTypes;
    let _, A;
    const M = u.GetEncodedGeometryType(f);
    if (M === l.TRIANGULAR_MESH)
      (_ = new l.Mesh()), (A = u.DecodeBufferToMesh(f, _));
    else if (M === l.POINT_CLOUD)
      (_ = new l.PointCloud()), (A = u.DecodeBufferToPointCloud(f, _));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!A.ok() || _.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + A.error_msg());
    const T = { index: null, attributes: [] };
    for (const E in m) {
      const b = self[v[E]];
      let w, D;
      if (d.useUniqueIDs) (D = m[E]), (w = u.GetAttributeByUniqueId(_, D));
      else {
        if (((D = u.GetAttributeId(_, l[m[E]])), D === -1)) continue;
        w = u.GetAttribute(_, D);
      }
      T.attributes.push(i(l, u, _, E, b, w));
    }
    return M === l.TRIANGULAR_MESH && (T.index = n(l, u, _)), l.destroy(_), T;
  }
  function n(l, u, f) {
    const m = f.num_faces() * 3,
      v = m * 4,
      _ = l._malloc(v);
    u.GetTrianglesUInt32Array(f, v, _);
    const A = new Uint32Array(l.HEAPF32.buffer, _, m).slice();
    return l._free(_), { array: A, itemSize: 1 };
  }
  function i(l, u, f, d, m, v) {
    const _ = v.num_components(),
      M = f.num_points() * _,
      T = M * m.BYTES_PER_ELEMENT,
      E = a(l, m),
      b = l._malloc(T);
    u.GetAttributeDataArrayForAllPoints(f, v, E, T, b);
    const w = new m(l.HEAPF32.buffer, b, M).slice();
    return l._free(b), { name: d, array: w, itemSize: _ };
  }
  function a(l, u) {
    switch (u) {
      case Float32Array:
        return l.DT_FLOAT32;
      case Int8Array:
        return l.DT_INT8;
      case Int16Array:
        return l.DT_INT16;
      case Int32Array:
        return l.DT_INT32;
      case Uint8Array:
        return l.DT_UINT8;
      case Uint16Array:
        return l.DT_UINT16;
      case Uint32Array:
        return l.DT_UINT32;
    }
  }
}
let _0;
const rA = () => {
  if (_0) return _0;
  const s =
      "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
    e =
      "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
    t = new Uint8Array([
      0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0,
      1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7,
      0, 65, 0, 253, 15, 26, 11,
    ]),
    n = new Uint8Array([
      32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
      128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
      107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
      44, 45, 74, 156, 154, 70, 167,
    ]);
  if (typeof WebAssembly != "object") return { supported: !1 };
  let i = s;
  WebAssembly.validate(t) && (i = e);
  let a;
  const l = WebAssembly.instantiate(u(i), {}).then((v) => {
    (a = v.instance), a.exports.__wasm_call_ctors();
  });
  function u(v) {
    const _ = new Uint8Array(v.length);
    for (let M = 0; M < v.length; ++M) {
      const T = v.charCodeAt(M);
      _[M] =
        T > 96 ? T - 71 : T > 64 ? T - 65 : T > 47 ? T + 4 : T > 46 ? 63 : 62;
    }
    let A = 0;
    for (let M = 0; M < v.length; ++M)
      _[A++] = _[M] < 60 ? n[_[M]] : (_[M] - 60) * 64 + _[++M];
    return _.buffer.slice(0, A);
  }
  function f(v, _, A, M, T, E) {
    const b = a.exports.sbrk,
      w = (A + 3) & -4,
      D = b(w * M),
      B = b(T.length),
      I = new Uint8Array(a.exports.memory.buffer);
    I.set(T, B);
    const N = v(D, A, M, B, T.length);
    if (
      (N === 0 && E && E(D, w, M),
      _.set(I.subarray(D, D + A * M)),
      b(D - b(0)),
      N !== 0)
    )
      throw new Error(`Malformed buffer data: ${N}`);
  }
  const d = {
      0: "",
      1: "meshopt_decodeFilterOct",
      2: "meshopt_decodeFilterQuat",
      3: "meshopt_decodeFilterExp",
      NONE: "",
      OCTAHEDRAL: "meshopt_decodeFilterOct",
      QUATERNION: "meshopt_decodeFilterQuat",
      EXPONENTIAL: "meshopt_decodeFilterExp",
    },
    m = {
      0: "meshopt_decodeVertexBuffer",
      1: "meshopt_decodeIndexBuffer",
      2: "meshopt_decodeIndexSequence",
      ATTRIBUTES: "meshopt_decodeVertexBuffer",
      TRIANGLES: "meshopt_decodeIndexBuffer",
      INDICES: "meshopt_decodeIndexSequence",
    };
  return (
    (_0 = {
      ready: l,
      supported: !0,
      decodeVertexBuffer(v, _, A, M, T) {
        f(a.exports.meshopt_decodeVertexBuffer, v, _, A, M, a.exports[d[T]]);
      },
      decodeIndexBuffer(v, _, A, M) {
        f(a.exports.meshopt_decodeIndexBuffer, v, _, A, M);
      },
      decodeIndexSequence(v, _, A, M) {
        f(a.exports.meshopt_decodeIndexSequence, v, _, A, M);
      },
      decodeGltfBuffer(v, _, A, M, T, E) {
        f(a.exports[m[T]], v, _, A, M, a.exports[d[E]]);
      },
    }),
    _0
  );
};
function pF() {
  var s = Object.create(null);
  function e(i, a) {
    var l = i.id,
      u = i.name,
      f = i.dependencies;
    f === void 0 && (f = []);
    var d = i.init;
    d === void 0 && (d = function () {});
    var m = i.getTransferables;
    if ((m === void 0 && (m = null), !s[l]))
      try {
        (f = f.map(function (_) {
          return (
            _ &&
              _.isWorkerModule &&
              (e(_, function (A) {
                if (A instanceof Error) throw A;
              }),
              (_ = s[_.id].value)),
            _
          );
        })),
          (d = n("<" + u + ">.init", d)),
          m && (m = n("<" + u + ">.getTransferables", m));
        var v = null;
        typeof d == "function"
          ? (v = d.apply(void 0, f))
          : console.error("worker module init function failed to rehydrate"),
          (s[l] = { id: l, value: v, getTransferables: m }),
          a(v);
      } catch (_) {
        (_ && _.noLog) || console.error(_), a(_);
      }
  }
  function t(i, a) {
    var l,
      u = i.id,
      f = i.args;
    (!s[u] || typeof s[u].value != "function") &&
      a(
        new Error(
          "Worker module " +
            u +
            ": not found or its 'init' did not return a function"
        )
      );
    try {
      var d = (l = s[u]).value.apply(l, f);
      d && typeof d.then == "function"
        ? d.then(m, function (v) {
            return a(v instanceof Error ? v : new Error("" + v));
          })
        : m(d);
    } catch (v) {
      a(v);
    }
    function m(v) {
      try {
        var _ = s[u].getTransferables && s[u].getTransferables(v);
        (!_ || !Array.isArray(_) || !_.length) && (_ = void 0), a(v, _);
      } catch (A) {
        console.error(A), a(A);
      }
    }
  }
  function n(i, a) {
    var l = void 0;
    self.troikaDefine = function (f) {
      return (l = f);
    };
    var u = URL.createObjectURL(
      new Blob(
        [
          "/** " +
            i.replace(/\*/g, "") +
            ` **/

troikaDefine(
` +
            a +
            `
)`,
        ],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(u);
    } catch (f) {
      console.error(f);
    }
    return URL.revokeObjectURL(u), delete self.troikaDefine, l;
  }
  self.addEventListener("message", function (i) {
    var a = i.data,
      l = a.messageId,
      u = a.action,
      f = a.data;
    try {
      u === "registerModule" &&
        e(f, function (d) {
          d instanceof Error
            ? postMessage({ messageId: l, success: !1, error: d.message })
            : postMessage({
                messageId: l,
                success: !0,
                result: { isCallable: typeof d == "function" },
              });
        }),
        u === "callModule" &&
          t(f, function (d, m) {
            d instanceof Error
              ? postMessage({ messageId: l, success: !1, error: d.message })
              : postMessage(
                  { messageId: l, success: !0, result: d },
                  m || void 0
                );
          });
    } catch (d) {
      postMessage({ messageId: l, success: !1, error: d.stack });
    }
  });
}
function mF(s) {
  var e = function () {
    for (var t = [], n = arguments.length; n--; ) t[n] = arguments[n];
    return e._getInitResult().then(function (i) {
      if (typeof i == "function") return i.apply(void 0, t);
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  };
  return (
    (e._getInitResult = function () {
      var t = s.dependencies,
        n = s.init;
      t = Array.isArray(t)
        ? t.map(function (a) {
            return (
              a &&
                ((a = a.onMainThread || a),
                a._getInitResult && (a = a._getInitResult())),
              a
            );
          })
        : [];
      var i = Promise.all(t).then(function (a) {
        return n.apply(null, a);
      });
      return (
        (e._getInitResult = function () {
          return i;
        }),
        i
      );
    }),
    e
  );
}
var B2 = function () {
    var s = !1;
    if (typeof window < "u" && typeof window.document < "u")
      try {
        var e = new Worker(
          URL.createObjectURL(
            new Blob([""], { type: "application/javascript" })
          )
        );
        e.terminate(), (s = !0);
      } catch (t) {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" +
            t.message +
            "]"
        );
      }
    return (
      (B2 = function () {
        return s;
      }),
      s
    );
  },
  gF = 0,
  vF = 0,
  sA = !1,
  Cm = Object.create(null),
  Rm = Object.create(null),
  FA = Object.create(null);
function Hd(s) {
  if ((!s || typeof s.init != "function") && !sA)
    throw new Error("requires `options.init` function");
  var e = s.dependencies,
    t = s.init,
    n = s.getTransferables,
    i = s.workerId,
    a = mF(s);
  i == null && (i = "#default");
  var l = "workerModule" + ++gF,
    u = s.name || l,
    f = null;
  e =
    e &&
    e.map(function (m) {
      return (
        typeof m == "function" &&
          !m.workerModuleData &&
          ((sA = !0),
          (m = Hd({
            workerId: i,
            name: "<" + u + "> function dependency: " + m.name,
            init:
              `function(){return (
` +
              w0(m) +
              `
)}`,
          })),
          (sA = !1)),
        m && m.workerModuleData && (m = m.workerModuleData),
        m
      );
    });
  function d() {
    for (var m = [], v = arguments.length; v--; ) m[v] = arguments[v];
    if (!B2()) return a.apply(void 0, m);
    if (!f) {
      f = Wb(i, "registerModule", d.workerModuleData);
      var _ = function () {
        (f = null), Rm[i].delete(_);
      };
      (Rm[i] || (Rm[i] = new Set())).add(_);
    }
    return f.then(function (A) {
      var M = A.isCallable;
      if (M) return Wb(i, "callModule", { id: l, args: m });
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  }
  return (
    (d.workerModuleData = {
      isWorkerModule: !0,
      id: l,
      name: u,
      dependencies: e,
      init: w0(t),
      getTransferables: n && w0(n),
    }),
    (d.onMainThread = a),
    d
  );
}
function yF(s) {
  Rm[s] &&
    Rm[s].forEach(function (e) {
      e();
    }),
    Cm[s] && (Cm[s].terminate(), delete Cm[s]);
}
function w0(s) {
  var e = s.toString();
  return (
    !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e
  );
}
function _F(s) {
  var e = Cm[s];
  if (!e) {
    var t = w0(pF);
    (e = Cm[s] =
      new Worker(
        URL.createObjectURL(
          new Blob(
            [
              "/** Worker Module Bootstrap: " +
                s.replace(/\*/g, "") +
                ` **/

;(` +
                t +
                ")()",
            ],
            { type: "application/javascript" }
          )
        )
      )),
      (e.onmessage = function (n) {
        var i = n.data,
          a = i.messageId,
          l = FA[a];
        if (!l)
          throw new Error(
            "WorkerModule response with empty or unknown messageId"
          );
        delete FA[a], l(i);
      });
  }
  return e;
}
function Wb(s, e, t) {
  return new Promise(function (n, i) {
    var a = ++vF;
    (FA[a] = function (l) {
      l.success
        ? n(l.result)
        : i(new Error("Error in worker " + e + " call: " + l.error));
    }),
      _F(s).postMessage({ messageId: a, action: e, data: t });
  });
}
function D2() {
  var s = (function (e) {
    function t(me, V, Y, ae, fe, j, se, ve) {
      var ye = 1 - se;
      (ve.x = ye * ye * me + 2 * ye * se * Y + se * se * fe),
        (ve.y = ye * ye * V + 2 * ye * se * ae + se * se * j);
    }
    function n(me, V, Y, ae, fe, j, se, ve, ye, be) {
      var it = 1 - ye;
      (be.x =
        it * it * it * me +
        3 * it * it * ye * Y +
        3 * it * ye * ye * fe +
        ye * ye * ye * se),
        (be.y =
          it * it * it * V +
          3 * it * it * ye * ae +
          3 * it * ye * ye * j +
          ye * ye * ye * ve);
    }
    function i(me, V) {
      for (
        var Y = /([MLQCZ])([^MLQCZ]*)/g, ae, fe, j, se, ve;
        (ae = Y.exec(me));

      ) {
        var ye = ae[2]
          .replace(/^\s*|\s*$/g, "")
          .split(/[,\s]+/)
          .map(function (be) {
            return parseFloat(be);
          });
        switch (ae[1]) {
          case "M":
            (se = fe = ye[0]), (ve = j = ye[1]);
            break;
          case "L":
            (ye[0] !== se || ye[1] !== ve) &&
              V("L", se, ve, (se = ye[0]), (ve = ye[1]));
            break;
          case "Q": {
            V("Q", se, ve, (se = ye[2]), (ve = ye[3]), ye[0], ye[1]);
            break;
          }
          case "C": {
            V(
              "C",
              se,
              ve,
              (se = ye[4]),
              (ve = ye[5]),
              ye[0],
              ye[1],
              ye[2],
              ye[3]
            );
            break;
          }
          case "Z":
            (se !== fe || ve !== j) && V("L", se, ve, fe, j);
            break;
        }
      }
    }
    function a(me, V, Y) {
      Y === void 0 && (Y = 16);
      var ae = { x: 0, y: 0 };
      i(me, function (fe, j, se, ve, ye, be, it, We, $e) {
        switch (fe) {
          case "L":
            V(j, se, ve, ye);
            break;
          case "Q": {
            for (var Me = j, Ie = se, $ = 1; $ < Y; $++)
              t(j, se, be, it, ve, ye, $ / (Y - 1), ae),
                V(Me, Ie, ae.x, ae.y),
                (Me = ae.x),
                (Ie = ae.y);
            break;
          }
          case "C": {
            for (var ft = j, Pe = se, rt = 1; rt < Y; rt++)
              n(j, se, be, it, We, $e, ve, ye, rt / (Y - 1), ae),
                V(ft, Pe, ae.x, ae.y),
                (ft = ae.x),
                (Pe = ae.y);
            break;
          }
        }
      });
    }
    var l =
        "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      u =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",
      f = new WeakMap(),
      d = {
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0,
        antialias: !1,
        depth: !1,
      };
    function m(me, V) {
      var Y = me.getContext ? me.getContext("webgl", d) : me,
        ae = f.get(Y);
      if (!ae) {
        let ft = function (X) {
            var k = j[X];
            if (!k && ((k = j[X] = Y.getExtension(X)), !k))
              throw new Error(X + " not supported");
            return k;
          },
          Pe = function (X, k) {
            var de = Y.createShader(k);
            return Y.shaderSource(de, X), Y.compileShader(de), de;
          },
          rt = function (X, k, de, Ee) {
            if (!se[X]) {
              var we = {},
                He = {},
                tt = Y.createProgram();
              Y.attachShader(tt, Pe(k, Y.VERTEX_SHADER)),
                Y.attachShader(tt, Pe(de, Y.FRAGMENT_SHADER)),
                Y.linkProgram(tt),
                (se[X] = {
                  program: tt,
                  transaction: function (st) {
                    Y.useProgram(tt),
                      st({
                        setUniform: function (et, At) {
                          for (
                            var mt = [], nt = arguments.length - 2;
                            nt-- > 0;

                          )
                            mt[nt] = arguments[nt + 2];
                          var Ze =
                            He[At] || (He[At] = Y.getUniformLocation(tt, At));
                          Y["uniform" + et].apply(Y, [Ze].concat(mt));
                        },
                        setAttribute: function (et, At, mt, nt, Ze) {
                          var le = we[et];
                          le ||
                            (le = we[et] =
                              {
                                buf: Y.createBuffer(),
                                loc: Y.getAttribLocation(tt, et),
                                data: null,
                              }),
                            Y.bindBuffer(Y.ARRAY_BUFFER, le.buf),
                            Y.vertexAttribPointer(
                              le.loc,
                              At,
                              Y.FLOAT,
                              !1,
                              0,
                              0
                            ),
                            Y.enableVertexAttribArray(le.loc),
                            fe
                              ? Y.vertexAttribDivisor(le.loc, nt)
                              : ft(
                                  "ANGLE_instanced_arrays"
                                ).vertexAttribDivisorANGLE(le.loc, nt),
                            Ze !== le.data &&
                              (Y.bufferData(Y.ARRAY_BUFFER, Ze, mt),
                              (le.data = Ze));
                        },
                      });
                  },
                });
            }
            se[X].transaction(Ee);
          },
          Ue = function (X, k) {
            ye++;
            try {
              Y.activeTexture(Y.TEXTURE0 + ye);
              var de = ve[X];
              de ||
                ((de = ve[X] = Y.createTexture()),
                Y.bindTexture(Y.TEXTURE_2D, de),
                Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MIN_FILTER, Y.NEAREST),
                Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MAG_FILTER, Y.NEAREST)),
                Y.bindTexture(Y.TEXTURE_2D, de),
                k(de, ye);
            } finally {
              ye--;
            }
          },
          ht = function (X, k, de) {
            var Ee = Y.createFramebuffer();
            be.push(Ee),
              Y.bindFramebuffer(Y.FRAMEBUFFER, Ee),
              Y.activeTexture(Y.TEXTURE0 + k),
              Y.bindTexture(Y.TEXTURE_2D, X),
              Y.framebufferTexture2D(
                Y.FRAMEBUFFER,
                Y.COLOR_ATTACHMENT0,
                Y.TEXTURE_2D,
                X,
                0
              );
            try {
              de(Ee);
            } finally {
              Y.deleteFramebuffer(Ee),
                Y.bindFramebuffer(Y.FRAMEBUFFER, be[--be.length - 1] || null);
            }
          },
          Ve = function () {
            (j = {}), (se = {}), (ve = {}), (ye = -1), (be.length = 0);
          };
        var it = ft,
          We = Pe,
          $e = rt,
          Me = Ue,
          Ie = ht,
          $ = Ve,
          fe =
            typeof WebGL2RenderingContext < "u" &&
            Y instanceof WebGL2RenderingContext,
          j = {},
          se = {},
          ve = {},
          ye = -1,
          be = [];
        Y.canvas.addEventListener(
          "webglcontextlost",
          function (X) {
            Ve(), X.preventDefault();
          },
          !1
        ),
          f.set(
            Y,
            (ae = {
              gl: Y,
              isWebGL2: fe,
              getExtension: ft,
              withProgram: rt,
              withTexture: Ue,
              withTextureFramebuffer: ht,
              handleContextLoss: Ve,
            })
          );
      }
      V(ae);
    }
    function v(me, V, Y, ae, fe, j, se, ve) {
      se === void 0 && (se = 15),
        ve === void 0 && (ve = null),
        m(me, function (ye) {
          var be = ye.gl,
            it = ye.withProgram,
            We = ye.withTexture;
          We("copy", function ($e, Me) {
            be.texImage2D(
              be.TEXTURE_2D,
              0,
              be.RGBA,
              fe,
              j,
              0,
              be.RGBA,
              be.UNSIGNED_BYTE,
              V
            ),
              it("copy", l, u, function (Ie) {
                var $ = Ie.setUniform,
                  ft = Ie.setAttribute;
                ft(
                  "aUV",
                  2,
                  be.STATIC_DRAW,
                  0,
                  new Float32Array([0, 0, 2, 0, 0, 2])
                ),
                  $("1i", "image", Me),
                  be.bindFramebuffer(be.FRAMEBUFFER, ve || null),
                  be.disable(be.BLEND),
                  be.colorMask(se & 8, se & 4, se & 2, se & 1),
                  be.viewport(Y, ae, fe, j),
                  be.scissor(Y, ae, fe, j),
                  be.drawArrays(be.TRIANGLES, 0, 3);
              });
          });
        });
    }
    function _(me, V, Y) {
      var ae = me.width,
        fe = me.height;
      m(me, function (j) {
        var se = j.gl,
          ve = new Uint8Array(ae * fe * 4);
        se.readPixels(0, 0, ae, fe, se.RGBA, se.UNSIGNED_BYTE, ve),
          (me.width = V),
          (me.height = Y),
          v(se, ve, 0, 0, ae, fe);
      });
    }
    var A = Object.freeze({
      __proto__: null,
      withWebGLContext: m,
      renderImageData: v,
      resizeWebGLCanvasWithoutClearing: _,
    });
    function M(me, V, Y, ae, fe, j) {
      j === void 0 && (j = 1);
      var se = new Uint8Array(me * V),
        ve = ae[2] - ae[0],
        ye = ae[3] - ae[1],
        be = [];
      a(Y, function (ft, Pe, rt, Ue) {
        be.push({
          x1: ft,
          y1: Pe,
          x2: rt,
          y2: Ue,
          minX: Math.min(ft, rt),
          minY: Math.min(Pe, Ue),
          maxX: Math.max(ft, rt),
          maxY: Math.max(Pe, Ue),
        });
      }),
        be.sort(function (ft, Pe) {
          return ft.maxX - Pe.maxX;
        });
      for (var it = 0; it < me; it++)
        for (var We = 0; We < V; We++) {
          var $e = Ie(
              ae[0] + (ve * (it + 0.5)) / me,
              ae[1] + (ye * (We + 0.5)) / V
            ),
            Me = Math.pow(1 - Math.abs($e) / fe, j) / 2;
          $e < 0 && (Me = 1 - Me),
            (Me = Math.max(0, Math.min(255, Math.round(Me * 255)))),
            (se[We * me + it] = Me);
        }
      return se;
      function Ie(ft, Pe) {
        for (var rt = 1 / 0, Ue = 1 / 0, ht = be.length; ht--; ) {
          var Ve = be[ht];
          if (Ve.maxX + Ue <= ft) break;
          if (ft + Ue > Ve.minX && Pe - Ue < Ve.maxY && Pe + Ue > Ve.minY) {
            var X = b(ft, Pe, Ve.x1, Ve.y1, Ve.x2, Ve.y2);
            X < rt && ((rt = X), (Ue = Math.sqrt(rt)));
          }
        }
        return $(ft, Pe) && (Ue = -Ue), Ue;
      }
      function $(ft, Pe) {
        for (var rt = 0, Ue = be.length; Ue--; ) {
          var ht = be[Ue];
          if (ht.maxX <= ft) break;
          var Ve =
            ht.y1 > Pe != ht.y2 > Pe &&
            ft < ((ht.x2 - ht.x1) * (Pe - ht.y1)) / (ht.y2 - ht.y1) + ht.x1;
          Ve && (rt += ht.y1 < ht.y2 ? 1 : -1);
        }
        return rt !== 0;
      }
    }
    function T(me, V, Y, ae, fe, j, se, ve, ye, be) {
      j === void 0 && (j = 1),
        ve === void 0 && (ve = 0),
        ye === void 0 && (ye = 0),
        be === void 0 && (be = 0),
        E(me, V, Y, ae, fe, j, se, null, ve, ye, be);
    }
    function E(me, V, Y, ae, fe, j, se, ve, ye, be, it) {
      j === void 0 && (j = 1),
        ye === void 0 && (ye = 0),
        be === void 0 && (be = 0),
        it === void 0 && (it = 0);
      for (
        var We = M(me, V, Y, ae, fe, j),
          $e = new Uint8Array(We.length * 4),
          Me = 0;
        Me < We.length;
        Me++
      )
        $e[Me * 4 + it] = We[Me];
      v(se, $e, ye, be, me, V, 1 << (3 - it), ve);
    }
    function b(me, V, Y, ae, fe, j) {
      var se = fe - Y,
        ve = j - ae,
        ye = se * se + ve * ve,
        be = ye
          ? Math.max(0, Math.min(1, ((me - Y) * se + (V - ae) * ve) / ye))
          : 0,
        it = me - (Y + be * se),
        We = V - (ae + be * ve);
      return it * it + We * We;
    }
    var w = Object.freeze({
        __proto__: null,
        generate: M,
        generateIntoCanvas: T,
        generateIntoFramebuffer: E,
      }),
      D =
        "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      B =
        "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",
      I =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",
      N = new Float32Array([0, 0, 2, 0, 0, 2]),
      P = null,
      F = !1,
      O = {},
      U = new WeakMap();
    function W(me) {
      if (!F && !ue(me)) throw new Error("WebGL generation not supported");
    }
    function J(me, V, Y, ae, fe, j, se) {
      if (
        (j === void 0 && (j = 1),
        se === void 0 && (se = null),
        !se && ((se = P), !se))
      ) {
        var ve =
          typeof OffscreenCanvas == "function"
            ? new OffscreenCanvas(1, 1)
            : typeof document < "u"
            ? document.createElement("canvas")
            : null;
        if (!ve) throw new Error("OffscreenCanvas or DOM canvas not supported");
        se = P = ve.getContext("webgl", { depth: !1 });
      }
      W(se);
      var ye = new Uint8Array(me * V * 4);
      m(se, function ($e) {
        var Me = $e.gl,
          Ie = $e.withTexture,
          $ = $e.withTextureFramebuffer;
        Ie("readable", function (ft, Pe) {
          Me.texImage2D(
            Me.TEXTURE_2D,
            0,
            Me.RGBA,
            me,
            V,
            0,
            Me.RGBA,
            Me.UNSIGNED_BYTE,
            null
          ),
            $(ft, Pe, function (rt) {
              Z(me, V, Y, ae, fe, j, Me, rt, 0, 0, 0),
                Me.readPixels(0, 0, me, V, Me.RGBA, Me.UNSIGNED_BYTE, ye);
            });
        });
      });
      for (
        var be = new Uint8Array(me * V), it = 0, We = 0;
        it < ye.length;
        it += 4
      )
        be[We++] = ye[it];
      return be;
    }
    function q(me, V, Y, ae, fe, j, se, ve, ye, be) {
      j === void 0 && (j = 1),
        ve === void 0 && (ve = 0),
        ye === void 0 && (ye = 0),
        be === void 0 && (be = 0),
        Z(me, V, Y, ae, fe, j, se, null, ve, ye, be);
    }
    function Z(me, V, Y, ae, fe, j, se, ve, ye, be, it) {
      j === void 0 && (j = 1),
        ye === void 0 && (ye = 0),
        be === void 0 && (be = 0),
        it === void 0 && (it = 0),
        W(se);
      var We = [];
      a(Y, function ($e, Me, Ie, $) {
        We.push($e, Me, Ie, $);
      }),
        (We = new Float32Array(We)),
        m(se, function ($e) {
          var Me = $e.gl,
            Ie = $e.isWebGL2,
            $ = $e.getExtension,
            ft = $e.withProgram,
            Pe = $e.withTexture,
            rt = $e.withTextureFramebuffer,
            Ue = $e.handleContextLoss;
          if (
            (Pe("rawDistances", function (ht, Ve) {
              (me !== ht._lastWidth || V !== ht._lastHeight) &&
                Me.texImage2D(
                  Me.TEXTURE_2D,
                  0,
                  Me.RGBA,
                  (ht._lastWidth = me),
                  (ht._lastHeight = V),
                  0,
                  Me.RGBA,
                  Me.UNSIGNED_BYTE,
                  null
                ),
                ft("main", D, B, function (X) {
                  var k = X.setAttribute,
                    de = X.setUniform,
                    Ee = !Ie && $("ANGLE_instanced_arrays"),
                    we = !Ie && $("EXT_blend_minmax");
                  k("aUV", 2, Me.STATIC_DRAW, 0, N),
                    k("aLineSegment", 4, Me.DYNAMIC_DRAW, 1, We),
                    de.apply(void 0, ["4f", "uGlyphBounds"].concat(ae)),
                    de("1f", "uMaxDistance", fe),
                    de("1f", "uExponent", j),
                    rt(ht, Ve, function (He) {
                      Me.enable(Me.BLEND),
                        Me.colorMask(!0, !0, !0, !0),
                        Me.viewport(0, 0, me, V),
                        Me.scissor(0, 0, me, V),
                        Me.blendFunc(Me.ONE, Me.ONE),
                        Me.blendEquationSeparate(
                          Me.FUNC_ADD,
                          Ie ? Me.MAX : we.MAX_EXT
                        ),
                        Me.clear(Me.COLOR_BUFFER_BIT),
                        Ie
                          ? Me.drawArraysInstanced(
                              Me.TRIANGLES,
                              0,
                              3,
                              We.length / 4
                            )
                          : Ee.drawArraysInstancedANGLE(
                              Me.TRIANGLES,
                              0,
                              3,
                              We.length / 4
                            );
                    });
                }),
                ft("post", l, I, function (X) {
                  X.setAttribute("aUV", 2, Me.STATIC_DRAW, 0, N),
                    X.setUniform("1i", "tex", Ve),
                    Me.bindFramebuffer(Me.FRAMEBUFFER, ve),
                    Me.disable(Me.BLEND),
                    Me.colorMask(it === 0, it === 1, it === 2, it === 3),
                    Me.viewport(ye, be, me, V),
                    Me.scissor(ye, be, me, V),
                    Me.drawArrays(Me.TRIANGLES, 0, 3);
                });
            }),
            Me.isContextLost())
          )
            throw (Ue(), new Error("webgl context lost"));
        });
    }
    function ue(me) {
      var V = !me || me === P ? O : me.canvas || me,
        Y = U.get(V);
      if (Y === void 0) {
        F = !0;
        var ae = null;
        try {
          var fe = [
              97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106,
              97,
            ],
            j = J(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, me);
          (Y =
            j &&
            fe.length === j.length &&
            j.every(function (se, ve) {
              return se === fe[ve];
            })),
            Y || ((ae = "bad trial run results"), console.info(fe, j));
        } catch (se) {
          (Y = !1), (ae = se.message);
        }
        ae && console.warn("WebGL SDF generation not supported:", ae),
          (F = !1),
          U.set(V, Y);
      }
      return Y;
    }
    var K = Object.freeze({
      __proto__: null,
      generate: J,
      generateIntoCanvas: q,
      generateIntoFramebuffer: Z,
      isSupported: ue,
    });
    function ge(me, V, Y, ae, fe, j) {
      fe === void 0 && (fe = Math.max(ae[2] - ae[0], ae[3] - ae[1]) / 2),
        j === void 0 && (j = 1);
      try {
        return J.apply(K, arguments);
      } catch (se) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", se),
          M.apply(w, arguments)
        );
      }
    }
    function oe(me, V, Y, ae, fe, j, se, ve, ye, be) {
      fe === void 0 && (fe = Math.max(ae[2] - ae[0], ae[3] - ae[1]) / 2),
        j === void 0 && (j = 1),
        ve === void 0 && (ve = 0),
        ye === void 0 && (ye = 0),
        be === void 0 && (be = 0);
      try {
        return q.apply(K, arguments);
      } catch (it) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", it),
          T.apply(w, arguments)
        );
      }
    }
    return (
      (e.forEachPathCommand = i),
      (e.generate = ge),
      (e.generateIntoCanvas = oe),
      (e.javascript = w),
      (e.pathToLineSegments = a),
      (e.webgl = K),
      (e.webglUtils = A),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return s;
}
function AF() {
  var s = (function (e) {
    var t = {
        R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
        EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
        ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
        ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
        AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
        CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
        B: "a,3,f+2,2v,690",
        S: "9,2,k",
        WS: "c,k,4f4,1vk+a,u,1j,335",
        ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
        BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
        NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
        AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
        LRO: "6ct",
        RLO: "6cu",
        LRE: "6cq",
        RLE: "6cr",
        PDF: "6cs",
        LRI: "6ee",
        RLI: "6ef",
        FSI: "6eg",
        PDI: "6eh",
      },
      n = {},
      i = {};
    (n.L = 1),
      (i[1] = "L"),
      Object.keys(t).forEach(function (Ue, ht) {
        (n[Ue] = 1 << (ht + 1)), (i[n[Ue]] = Ue);
      }),
      Object.freeze(n);
    var a = n.LRI | n.RLI | n.FSI,
      l = n.L | n.R | n.AL,
      u = n.B | n.S | n.WS | n.ON | n.FSI | n.LRI | n.RLI | n.PDI,
      f = n.BN | n.RLE | n.LRE | n.RLO | n.LRO | n.PDF,
      d = n.S | n.WS | n.B | a | n.PDI | f,
      m = null;
    function v() {
      if (!m) {
        m = new Map();
        var Ue = function (Ve) {
          if (t.hasOwnProperty(Ve)) {
            var X = 0;
            t[Ve].split(",").forEach(function (k) {
              var de = k.split("+"),
                Ee = de[0],
                we = de[1];
              (Ee = parseInt(Ee, 36)),
                (we = we ? parseInt(we, 36) : 0),
                m.set((X += Ee), n[Ve]);
              for (var He = 0; He < we; He++) m.set(++X, n[Ve]);
            });
          }
        };
        for (var ht in t) Ue(ht);
      }
    }
    function _(Ue) {
      return v(), m.get(Ue.codePointAt(0)) || n.L;
    }
    function A(Ue) {
      return i[_(Ue)];
    }
    var M = {
      pairs:
        "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical:
        "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye",
    };
    function T(Ue, ht) {
      var Ve = 36,
        X = 0,
        k = new Map(),
        de = ht && new Map(),
        Ee;
      return (
        Ue.split(",").forEach(function we(He) {
          if (He.indexOf("+") !== -1) for (var tt = +He; tt--; ) we(Ee);
          else {
            Ee = He;
            var Ke = He.split(">"),
              st = Ke[0],
              Ut = Ke[1];
            (st = String.fromCodePoint((X += parseInt(st, Ve)))),
              (Ut = String.fromCodePoint((X += parseInt(Ut, Ve)))),
              k.set(st, Ut),
              ht && de.set(Ut, st);
          }
        }),
        { map: k, reverseMap: de }
      );
    }
    var E, b, w;
    function D() {
      if (!E) {
        var Ue = T(M.pairs, !0),
          ht = Ue.map,
          Ve = Ue.reverseMap;
        (E = ht), (b = Ve), (w = T(M.canonical, !1).map);
      }
    }
    function B(Ue) {
      return D(), E.get(Ue) || null;
    }
    function I(Ue) {
      return D(), b.get(Ue) || null;
    }
    function N(Ue) {
      return D(), w.get(Ue) || null;
    }
    var P = n.L,
      F = n.R,
      O = n.EN,
      U = n.ES,
      W = n.ET,
      J = n.AN,
      q = n.CS,
      Z = n.B,
      ue = n.S,
      K = n.ON,
      ge = n.BN,
      oe = n.NSM,
      me = n.AL,
      V = n.LRO,
      Y = n.RLO,
      ae = n.LRE,
      fe = n.RLE,
      j = n.PDF,
      se = n.LRI,
      ve = n.RLI,
      ye = n.FSI,
      be = n.PDI;
    function it(Ue, ht) {
      for (
        var Ve = 125, X = new Uint32Array(Ue.length), k = 0;
        k < Ue.length;
        k++
      )
        X[k] = _(Ue[k]);
      var de = new Map();
      function Ee(da, Ka) {
        var ki = X[da];
        (X[da] = Ka),
          de.set(ki, de.get(ki) - 1),
          ki & u && de.set(u, de.get(u) - 1),
          de.set(Ka, (de.get(Ka) || 0) + 1),
          Ka & u && de.set(u, (de.get(u) || 0) + 1);
      }
      for (
        var we = new Uint8Array(Ue.length),
          He = new Map(),
          tt = [],
          Ke = null,
          st = 0;
        st < Ue.length;
        st++
      )
        Ke ||
          tt.push(
            (Ke = {
              start: st,
              end: Ue.length - 1,
              level: ht === "rtl" ? 1 : ht === "ltr" ? 0 : wc(st, !1),
            })
          ),
          X[st] & Z && ((Ke.end = st), (Ke = null));
      for (
        var Ut = fe | ae | Y | V | a | be | j | Z,
          et = function (da) {
            return da + (da & 1 ? 1 : 2);
          },
          At = function (da) {
            return da + (da & 1 ? 2 : 1);
          },
          mt = 0;
        mt < tt.length;
        mt++
      ) {
        Ke = tt[mt];
        var nt = [{ _level: Ke.level, _override: 0, _isolate: 0 }],
          Ze = void 0,
          le = 0,
          Be = 0,
          vt = 0;
        de.clear();
        for (var ce = Ke.start; ce <= Ke.end; ce++) {
          var xe = X[ce];
          if (
            ((Ze = nt[nt.length - 1]),
            de.set(xe, (de.get(xe) || 0) + 1),
            xe & u && de.set(u, (de.get(u) || 0) + 1),
            xe & Ut)
          )
            if (xe & (fe | ae)) {
              we[ce] = Ze._level;
              var Re = (xe === fe ? At : et)(Ze._level);
              Re <= Ve && !le && !Be
                ? nt.push({ _level: Re, _override: 0, _isolate: 0 })
                : le || Be++;
            } else if (xe & (Y | V)) {
              we[ce] = Ze._level;
              var Qe = (xe === Y ? At : et)(Ze._level);
              Qe <= Ve && !le && !Be
                ? nt.push({
                    _level: Qe,
                    _override: xe & Y ? F : P,
                    _isolate: 0,
                  })
                : le || Be++;
            } else if (xe & a) {
              xe & ye && (xe = wc(ce + 1, !0) === 1 ? ve : se),
                (we[ce] = Ze._level),
                Ze._override && Ee(ce, Ze._override);
              var gt = (xe === ve ? At : et)(Ze._level);
              gt <= Ve && le === 0 && Be === 0
                ? (vt++,
                  nt.push({
                    _level: gt,
                    _override: 0,
                    _isolate: 1,
                    _isolInitIndex: ce,
                  }))
                : le++;
            } else if (xe & be) {
              if (le > 0) le--;
              else if (vt > 0) {
                for (Be = 0; !nt[nt.length - 1]._isolate; ) nt.pop();
                var dt = nt[nt.length - 1]._isolInitIndex;
                dt != null && (He.set(dt, ce), He.set(ce, dt)), nt.pop(), vt--;
              }
              (Ze = nt[nt.length - 1]),
                (we[ce] = Ze._level),
                Ze._override && Ee(ce, Ze._override);
            } else
              xe & j
                ? (le === 0 &&
                    (Be > 0
                      ? Be--
                      : !Ze._isolate &&
                        nt.length > 1 &&
                        (nt.pop(), (Ze = nt[nt.length - 1]))),
                  (we[ce] = Ze._level))
                : xe & Z && (we[ce] = Ke.level);
          else
            (we[ce] = Ze._level),
              Ze._override && xe !== ge && Ee(ce, Ze._override);
        }
        for (var Ct = [], Ht = null, Nt = Ke.start; Nt <= Ke.end; Nt++) {
          var Ft = X[Nt];
          if (!(Ft & f)) {
            var gn = we[Nt],
              vn = Ft & a,
              ai = Ft === be;
            Ht && gn === Ht._level
              ? ((Ht._end = Nt), (Ht._endsWithIsolInit = vn))
              : Ct.push(
                  (Ht = {
                    _start: Nt,
                    _end: Nt,
                    _level: gn,
                    _startsWithPDI: ai,
                    _endsWithIsolInit: vn,
                  })
                );
          }
        }
        for (var Bi = [], ui = 0; ui < Ct.length; ui++) {
          var di = Ct[ui];
          if (!di._startsWithPDI || (di._startsWithPDI && !He.has(di._start))) {
            for (
              var Di = [(Ht = di)], pi = void 0;
              Ht && Ht._endsWithIsolInit && (pi = He.get(Ht._end)) != null;

            )
              for (var zt = ui + 1; zt < Ct.length; zt++)
                if (Ct[zt]._start === pi) {
                  Di.push((Ht = Ct[zt]));
                  break;
                }
            for (var pn = [], en = 0; en < Di.length; en++)
              for (var H = Di[en], te = H._start; te <= H._end; te++)
                pn.push(te);
            for (
              var Ae = we[pn[0]], Ge = Ke.level, qe = pn[0] - 1;
              qe >= 0;
              qe--
            )
              if (!(X[qe] & f)) {
                Ge = we[qe];
                break;
              }
            var Je = pn[pn.length - 1],
              St = we[Je],
              yt = Ke.level;
            if (!(X[Je] & a)) {
              for (var z = Je + 1; z <= Ke.end; z++)
                if (!(X[z] & f)) {
                  yt = we[z];
                  break;
                }
            }
            Bi.push({
              _seqIndices: pn,
              _sosType: Math.max(Ge, Ae) % 2 ? F : P,
              _eosType: Math.max(yt, St) % 2 ? F : P,
            });
          }
        }
        for (var re = 0; re < Bi.length; re++) {
          var pe = Bi[re],
            ne = pe._seqIndices,
            Se = pe._sosType,
            Ne = pe._eosType,
            Ye = we[ne[0]] & 1 ? F : P;
          if (de.get(oe))
            for (var lt = 0; lt < ne.length; lt++) {
              var pt = ne[lt];
              if (X[pt] & oe) {
                for (var wt = Se, Bt = lt - 1; Bt >= 0; Bt--)
                  if (!(X[ne[Bt]] & f)) {
                    wt = X[ne[Bt]];
                    break;
                  }
                Ee(pt, wt & (a | be) ? K : wt);
              }
            }
          if (de.get(O))
            for (var Rt = 0; Rt < ne.length; Rt++) {
              var jt = ne[Rt];
              if (X[jt] & O)
                for (var Pt = Rt - 1; Pt >= -1; Pt--) {
                  var yn = Pt === -1 ? Se : X[ne[Pt]];
                  if (yn & l) {
                    yn === me && Ee(jt, J);
                    break;
                  }
                }
            }
          if (de.get(me))
            for (var Vt = 0; Vt < ne.length; Vt++) {
              var Gt = ne[Vt];
              X[Gt] & me && Ee(Gt, F);
            }
          if (de.get(U) || de.get(q))
            for (var It = 1; It < ne.length - 1; It++) {
              var Jn = ne[It];
              if (X[Jn] & (U | q)) {
                for (
                  var qt = 0, rn = 0, Ln = It - 1;
                  Ln >= 0 && ((qt = X[ne[Ln]]), !!(qt & f));
                  Ln--
                );
                for (
                  var sn = It + 1;
                  sn < ne.length && ((rn = X[ne[sn]]), !!(rn & f));
                  sn++
                );
                qt === rn &&
                  (X[Jn] === U ? qt === O : qt & (O | J)) &&
                  Ee(Jn, qt);
              }
            }
          if (de.get(O))
            for (var Xt = 0; Xt < ne.length; Xt++) {
              var on = ne[Xt];
              if (X[on] & O) {
                for (var Zn = Xt - 1; Zn >= 0 && X[ne[Zn]] & (W | f); Zn--)
                  Ee(ne[Zn], O);
                for (Xt++; Xt < ne.length && X[ne[Xt]] & (W | f | O); Xt++)
                  X[ne[Xt]] !== O && Ee(ne[Xt], O);
              }
            }
          if (de.get(W) || de.get(U) || de.get(q))
            for (var Tn = 0; Tn < ne.length; Tn++) {
              var Nn = ne[Tn];
              if (X[Nn] & (W | U | q)) {
                Ee(Nn, K);
                for (var Mi = Tn - 1; Mi >= 0 && X[ne[Mi]] & f; Mi--)
                  Ee(ne[Mi], K);
                for (var Sa = Tn + 1; Sa < ne.length && X[ne[Sa]] & f; Sa++)
                  Ee(ne[Sa], K);
              }
            }
          if (de.get(O))
            for (var ea = 0, Bl = Se; ea < ne.length; ea++) {
              var Fo = ne[ea],
                Dl = X[Fo];
              Dl & O ? Bl === P && Ee(Fo, P) : Dl & l && (Bl = Dl);
            }
          if (de.get(u)) {
            var Qr = F | O | J,
              Rc = Qr | P,
              Ul = [];
            {
              for (var wr = [], $r = 0; $r < ne.length; $r++)
                if (X[ne[$r]] & u) {
                  var es = Ue[ne[$r]],
                    ys = void 0;
                  if (B(es) !== null)
                    if (wr.length < 63) wr.push({ char: es, seqIndex: $r });
                    else break;
                  else if ((ys = I(es)) !== null)
                    for (var pr = wr.length - 1; pr >= 0; pr--) {
                      var Po = wr[pr].char;
                      if (Po === ys || Po === I(N(es)) || B(N(Po)) === es) {
                        Ul.push([wr[pr].seqIndex, $r]), (wr.length = pr);
                        break;
                      }
                    }
                }
              Ul.sort(function (da, Ka) {
                return da[0] - Ka[0];
              });
            }
            for (var Go = 0; Go < Ul.length; Go++) {
              for (
                var Eu = Ul[Go],
                  ts = Eu[0],
                  Vs = Eu[1],
                  ks = !1,
                  Ui = 0,
                  Ol = ts + 1;
                Ol < Vs;
                Ol++
              ) {
                var Ll = ne[Ol];
                if (X[Ll] & Rc) {
                  ks = !0;
                  var Tu = X[Ll] & Qr ? F : P;
                  if (Tu === Ye) {
                    Ui = Tu;
                    break;
                  }
                }
              }
              if (ks && !Ui) {
                Ui = Se;
                for (var Br = ts - 1; Br >= 0; Br--) {
                  var Xs = ne[Br];
                  if (X[Xs] & Rc) {
                    var zo = X[Xs] & Qr ? F : P;
                    zo !== Ye ? (Ui = zo) : (Ui = Ye);
                    break;
                  }
                }
              }
              if (Ui) {
                if (((X[ne[ts]] = X[ne[Vs]] = Ui), Ui !== Ye)) {
                  for (var Oi = ts + 1; Oi < ne.length; Oi++)
                    if (!(X[ne[Oi]] & f)) {
                      _(Ue[ne[Oi]]) & oe && (X[ne[Oi]] = Ui);
                      break;
                    }
                }
                if (Ui !== Ye) {
                  for (var ja = Vs + 1; ja < ne.length; ja++)
                    if (!(X[ne[ja]] & f)) {
                      _(Ue[ne[ja]]) & oe && (X[ne[ja]] = Ui);
                      break;
                    }
                }
              }
            }
            for (var Ia = 0; Ia < ne.length; Ia++)
              if (X[ne[Ia]] & u) {
                for (var Ys = Ia, Cu = Ia, mr = Se, Dr = Ia - 1; Dr >= 0; Dr--)
                  if (X[ne[Dr]] & f) Ys = Dr;
                  else {
                    mr = X[ne[Dr]] & Qr ? F : P;
                    break;
                  }
                for (var Ws = Ne, Ur = Ia + 1; Ur < ne.length; Ur++)
                  if (X[ne[Ur]] & (u | f)) Cu = Ur;
                  else {
                    Ws = X[ne[Ur]] & Qr ? F : P;
                    break;
                  }
                for (var Nl = Ys; Nl <= Cu; Nl++)
                  X[ne[Nl]] = mr === Ws ? mr : Ye;
                Ia = Cu;
              }
          }
        }
        for (var Ma = Ke.start; Ma <= Ke.end; Ma++) {
          var Vd = we[Ma],
            Ti = X[Ma];
          if (
            (Vd & 1
              ? Ti & (P | O | J) && we[Ma]++
              : Ti & F
              ? we[Ma]++
              : Ti & (J | O) && (we[Ma] += 2),
            Ti & f && (we[Ma] = Ma === 0 ? Ke.level : we[Ma - 1]),
            Ma === Ke.end || _(Ue[Ma]) & (ue | Z))
          )
            for (var Js = Ma; Js >= 0 && _(Ue[Js]) & d; Js--) we[Js] = Ke.level;
        }
      }
      return { levels: we, paragraphs: tt };
      function wc(da, Ka) {
        for (var ki = da; ki < Ue.length; ki++) {
          var gr = X[ki];
          if (gr & (F | me)) return 1;
          if (gr & (Z | P) || (Ka && gr === be)) return 0;
          if (gr & a) {
            var Bc = ih(ki);
            ki = Bc === -1 ? Ue.length : Bc;
          }
        }
        return 0;
      }
      function ih(da) {
        for (var Ka = 1, ki = da + 1; ki < Ue.length; ki++) {
          var gr = X[ki];
          if (gr & Z) break;
          if (gr & be) {
            if (--Ka === 0) return ki;
          } else gr & a && Ka++;
        }
        return -1;
      }
    }
    var We =
        "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
      $e;
    function Me() {
      if (!$e) {
        var Ue = T(We, !0),
          ht = Ue.map,
          Ve = Ue.reverseMap;
        Ve.forEach(function (X, k) {
          ht.set(k, X);
        }),
          ($e = ht);
      }
    }
    function Ie(Ue) {
      return Me(), $e.get(Ue) || null;
    }
    function $(Ue, ht, Ve, X) {
      var k = Ue.length;
      (Ve = Math.max(0, Ve == null ? 0 : +Ve)),
        (X = Math.min(k - 1, X == null ? k - 1 : +X));
      for (var de = new Map(), Ee = Ve; Ee <= X; Ee++)
        if (ht[Ee] & 1) {
          var we = Ie(Ue[Ee]);
          we !== null && de.set(Ee, we);
        }
      return de;
    }
    function ft(Ue, ht, Ve, X) {
      var k = Ue.length;
      (Ve = Math.max(0, Ve == null ? 0 : +Ve)),
        (X = Math.min(k - 1, X == null ? k - 1 : +X));
      var de = [];
      return (
        ht.paragraphs.forEach(function (Ee) {
          var we = Math.max(Ve, Ee.start),
            He = Math.min(X, Ee.end);
          if (we < He) {
            for (
              var tt = ht.levels.slice(we, He + 1), Ke = He;
              Ke >= we && _(Ue[Ke]) & d;
              Ke--
            )
              tt[Ke] = Ee.level;
            for (var st = Ee.level, Ut = 1 / 0, et = 0; et < tt.length; et++) {
              var At = tt[et];
              At > st && (st = At), At < Ut && (Ut = At | 1);
            }
            for (var mt = st; mt >= Ut; mt--)
              for (var nt = 0; nt < tt.length; nt++)
                if (tt[nt] >= mt) {
                  for (var Ze = nt; nt + 1 < tt.length && tt[nt + 1] >= mt; )
                    nt++;
                  nt > Ze && de.push([Ze + we, nt + we]);
                }
          }
        }),
        de
      );
    }
    function Pe(Ue, ht, Ve, X) {
      var k = rt(Ue, ht, Ve, X),
        de = [].concat(Ue);
      return (
        k.forEach(function (Ee, we) {
          de[we] = (ht.levels[Ee] & 1 ? Ie(Ue[Ee]) : null) || Ue[Ee];
        }),
        de.join("")
      );
    }
    function rt(Ue, ht, Ve, X) {
      for (var k = ft(Ue, ht, Ve, X), de = [], Ee = 0; Ee < Ue.length; Ee++)
        de[Ee] = Ee;
      return (
        k.forEach(function (we) {
          for (
            var He = we[0],
              tt = we[1],
              Ke = de.slice(He, tt + 1),
              st = Ke.length;
            st--;

          )
            de[tt - st] = Ke[st];
        }),
        de
      );
    }
    return (
      (e.closingToOpeningBracket = I),
      (e.getBidiCharType = _),
      (e.getBidiCharTypeName = A),
      (e.getCanonicalBracket = N),
      (e.getEmbeddingLevels = it),
      (e.getMirroredCharacter = Ie),
      (e.getMirroredCharactersMap = $),
      (e.getReorderSegments = ft),
      (e.getReorderedIndices = rt),
      (e.getReorderedString = Pe),
      (e.openingToClosingBracket = B),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return s;
}
const U2 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function PA(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(n, i) {
    let a = _n[i];
    return a ? PA(a) : n;
  }
  return s.replace(e, t);
}
const Ya = [];
for (let s = 0; s < 256; s++) Ya[s] = (s < 16 ? "0" : "") + s.toString(16);
function xF() {
  const s = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    Ya[s & 255] +
    Ya[(s >> 8) & 255] +
    Ya[(s >> 16) & 255] +
    Ya[(s >> 24) & 255] +
    "-" +
    Ya[e & 255] +
    Ya[(e >> 8) & 255] +
    "-" +
    Ya[((e >> 16) & 15) | 64] +
    Ya[(e >> 24) & 255] +
    "-" +
    Ya[(t & 63) | 128] +
    Ya[(t >> 8) & 255] +
    "-" +
    Ya[(t >> 16) & 255] +
    Ya[(t >> 24) & 255] +
    Ya[n & 255] +
    Ya[(n >> 8) & 255] +
    Ya[(n >> 16) & 255] +
    Ya[(n >> 24) & 255]
  ).toUpperCase();
}
const Cf =
    Object.assign ||
    function () {
      let s = arguments[0];
      for (let e = 1, t = arguments.length; e < t; e++) {
        let n = arguments[e];
        if (n)
          for (let i in n)
            Object.prototype.hasOwnProperty.call(n, i) && (s[i] = n[i]);
      }
      return s;
    },
  SF = Date.now(),
  Jb = new WeakMap(),
  qb = new Map();
let MF = 1e10;
function GA(s, e) {
  const t = CF(e);
  let n = Jb.get(s);
  if ((n || Jb.set(s, (n = Object.create(null))), n[t])) return new n[t]();
  const i = `_onBeforeCompile${t}`,
    a = function (d, m) {
      s.onBeforeCompile.call(this, d, m);
      const v =
        this.customProgramCacheKey() +
        "|" +
        d.vertexShader +
        "|" +
        d.fragmentShader;
      let _ = qb[v];
      if (!_) {
        const A = bF(this, d, e, t);
        _ = qb[v] = A;
      }
      (d.vertexShader = _.vertexShader),
        (d.fragmentShader = _.fragmentShader),
        Cf(d.uniforms, this.uniforms),
        e.timeUniform &&
          (d.uniforms[e.timeUniform] = {
            get value() {
              return Date.now() - SF;
            },
          }),
        this[i] && this[i](d);
    },
    l = function () {
      return u(e.chained ? s : s.clone());
    },
    u = function (d) {
      const m = Object.create(d, f);
      return (
        Object.defineProperty(m, "baseMaterial", { value: s }),
        Object.defineProperty(m, "id", { value: MF++ }),
        (m.uuid = xF()),
        (m.uniforms = Cf({}, d.uniforms, e.uniforms)),
        (m.defines = Cf({}, d.defines, e.defines)),
        (m.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = ""),
        (m.extensions = Cf({}, d.extensions, e.extensions)),
        (m._listeners = void 0),
        m
      );
    },
    f = {
      constructor: { value: l },
      isDerivedMaterial: { value: !0 },
      type: {
        get: () => s.type,
        set: (d) => {
          s.type = d;
        },
      },
      isDerivedFrom: {
        writable: !0,
        configurable: !0,
        value: function (d) {
          const m = this.baseMaterial;
          return d === m || (m.isDerivedMaterial && m.isDerivedFrom(d)) || !1;
        },
      },
      customProgramCacheKey: {
        writable: !0,
        configurable: !0,
        value: function () {
          return s.customProgramCacheKey() + "|" + t;
        },
      },
      onBeforeCompile: {
        get() {
          return a;
        },
        set(d) {
          this[i] = d;
        },
      },
      copy: {
        writable: !0,
        configurable: !0,
        value: function (d) {
          return (
            s.copy.call(this, d),
            !s.isShaderMaterial &&
              !s.isDerivedMaterial &&
              (Cf(this.extensions, d.extensions),
              Cf(this.defines, d.defines),
              Cf(this.uniforms, Ny.clone(d.uniforms))),
            this
          );
        },
      },
      clone: {
        writable: !0,
        configurable: !0,
        value: function () {
          const d = new s.constructor();
          return u(d).copy(this);
        },
      },
      getDepthMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let d = this._depthMaterial;
          return (
            d ||
              ((d = this._depthMaterial =
                GA(
                  s.isDerivedMaterial
                    ? s.getDepthMaterial()
                    : new n_({ depthPacking: QA }),
                  e
                )),
              (d.defines.IS_DEPTH_MATERIAL = ""),
              (d.uniforms = this.uniforms)),
            d
          );
        },
      },
      getDistanceMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let d = this._distanceMaterial;
          return (
            d ||
              ((d = this._distanceMaterial =
                GA(
                  s.isDerivedMaterial ? s.getDistanceMaterial() : new i_(),
                  e
                )),
              (d.defines.IS_DISTANCE_MATERIAL = ""),
              (d.uniforms = this.uniforms)),
            d
          );
        },
      },
      dispose: {
        writable: !0,
        configurable: !0,
        value() {
          const { _depthMaterial: d, _distanceMaterial: m } = this;
          d && d.dispose(), m && m.dispose(), s.dispose.call(this);
        },
      },
    };
  return (n[t] = l), new l();
}
function bF(s, { vertexShader: e, fragmentShader: t }, n, i) {
  let {
    vertexDefs: a,
    vertexMainIntro: l,
    vertexMainOutro: u,
    vertexTransform: f,
    fragmentDefs: d,
    fragmentMainIntro: m,
    fragmentMainOutro: v,
    fragmentColorTransform: _,
    customRewriter: A,
    timeUniform: M,
  } = n;
  if (
    ((a = a || ""),
    (l = l || ""),
    (u = u || ""),
    (d = d || ""),
    (m = m || ""),
    (v = v || ""),
    (f || A) && (e = PA(e)),
    (_ || A) &&
      ((t = t.replace(
        /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
        `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
      )),
      (t = PA(t))),
    A)
  ) {
    let T = A({ vertexShader: e, fragmentShader: t });
    (e = T.vertexShader), (t = T.fragmentShader);
  }
  if (_) {
    let T = [];
    (t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (E) => (T.push(E), "")
    )),
      (v = `${_}
${T.join(`
`)}
${v}`);
  }
  if (M) {
    const T = `
uniform float ${M};
`;
    (a = T + a), (d = T + d);
  }
  return (
    f &&
      ((e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`),
      (a = `${a}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${f}
}
`),
      (l = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${l}
`),
      (e = e.replace(/\b(position|normal|uv)\b/g, (T, E, b, w) =>
        /\battribute\s+vec[23]\s+$/.test(w.substr(0, b))
          ? E
          : `troika_${E}_${i}`
      )),
      (s.map && s.map.channel > 0) ||
        (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))),
    (e = jb(e, i, a, l, u)),
    (t = jb(t, i, d, m, v)),
    { vertexShader: e, fragmentShader: t }
  );
}
function jb(s, e, t, n, i) {
  return (
    (n || i || t) &&
      ((s = s.replace(
        U2,
        `
${t}
void troikaOrigMain${e}() {`
      )),
      (s += `
void main() {
  ${n}
  troikaOrigMain${e}();
  ${i}
}`)),
    s
  );
}
function EF(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let TF = 0;
const Kb = new Map();
function CF(s) {
  const e = JSON.stringify(s, EF);
  let t = Kb.get(e);
  return t == null && Kb.set(e, (t = ++TF)), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/ function RF() {
  return (
    typeof window > "u" && (self.window = self),
    (function (s) {
      var e = {
        parse: function (i) {
          var a = e._bin,
            l = new Uint8Array(i);
          if (a.readASCII(l, 0, 4) == "ttcf") {
            var u = 4;
            a.readUshort(l, u), (u += 2), a.readUshort(l, u), (u += 2);
            var f = a.readUint(l, u);
            u += 4;
            for (var d = [], m = 0; m < f; m++) {
              var v = a.readUint(l, u);
              (u += 4), d.push(e._readFont(l, v));
            }
            return d;
          }
          return [e._readFont(l, 0)];
        },
        _readFont: function (i, a) {
          var l = e._bin,
            u = a;
          l.readFixed(i, a), (a += 4);
          var f = l.readUshort(i, a);
          (a += 2),
            l.readUshort(i, a),
            (a += 2),
            l.readUshort(i, a),
            (a += 2),
            l.readUshort(i, a),
            (a += 2);
          for (
            var d = [
                "cmap",
                "head",
                "hhea",
                "maxp",
                "hmtx",
                "name",
                "OS/2",
                "post",
                "loca",
                "glyf",
                "kern",
                "CFF ",
                "GDEF",
                "GPOS",
                "GSUB",
                "SVG ",
              ],
              m = { _data: i, _offset: u },
              v = {},
              _ = 0;
            _ < f;
            _++
          ) {
            var A = l.readASCII(i, a, 4);
            (a += 4), l.readUint(i, a), (a += 4);
            var M = l.readUint(i, a);
            a += 4;
            var T = l.readUint(i, a);
            (a += 4), (v[A] = { offset: M, length: T });
          }
          for (_ = 0; _ < d.length; _++) {
            var E = d[_];
            v[E] &&
              (m[E.trim()] = e[E.trim()].parse(i, v[E].offset, v[E].length, m));
          }
          return m;
        },
        _tabOffset: function (i, a, l) {
          for (
            var u = e._bin, f = u.readUshort(i, l + 4), d = l + 12, m = 0;
            m < f;
            m++
          ) {
            var v = u.readASCII(i, d, 4);
            (d += 4), u.readUint(i, d), (d += 4);
            var _ = u.readUint(i, d);
            if (((d += 4), u.readUint(i, d), (d += 4), v == a)) return _;
          }
          return 0;
        },
      };
      (e._bin = {
        readFixed: function (i, a) {
          return (
            ((i[a] << 8) | i[a + 1]) + ((i[a + 2] << 8) | i[a + 3]) / 65540
          );
        },
        readF2dot14: function (i, a) {
          return e._bin.readShort(i, a) / 16384;
        },
        readInt: function (i, a) {
          return e._bin._view(i).getInt32(a);
        },
        readInt8: function (i, a) {
          return e._bin._view(i).getInt8(a);
        },
        readShort: function (i, a) {
          return e._bin._view(i).getInt16(a);
        },
        readUshort: function (i, a) {
          return e._bin._view(i).getUint16(a);
        },
        readUshorts: function (i, a, l) {
          for (var u = [], f = 0; f < l; f++)
            u.push(e._bin.readUshort(i, a + 2 * f));
          return u;
        },
        readUint: function (i, a) {
          return e._bin._view(i).getUint32(a);
        },
        readUint64: function (i, a) {
          return 4294967296 * e._bin.readUint(i, a) + e._bin.readUint(i, a + 4);
        },
        readASCII: function (i, a, l) {
          for (var u = "", f = 0; f < l; f++)
            u += String.fromCharCode(i[a + f]);
          return u;
        },
        readUnicode: function (i, a, l) {
          for (var u = "", f = 0; f < l; f++) {
            var d = (i[a++] << 8) | i[a++];
            u += String.fromCharCode(d);
          }
          return u;
        },
        _tdec:
          typeof window < "u" && window.TextDecoder
            ? new window.TextDecoder()
            : null,
        readUTF8: function (i, a, l) {
          var u = e._bin._tdec;
          return u && a == 0 && l == i.length
            ? u.decode(i)
            : e._bin.readASCII(i, a, l);
        },
        readBytes: function (i, a, l) {
          for (var u = [], f = 0; f < l; f++) u.push(i[a + f]);
          return u;
        },
        readASCIIArray: function (i, a, l) {
          for (var u = [], f = 0; f < l; f++)
            u.push(String.fromCharCode(i[a + f]));
          return u;
        },
        _view: function (i) {
          return (
            i._dataView ||
            (i._dataView = i.buffer
              ? new DataView(i.buffer, i.byteOffset, i.byteLength)
              : new DataView(new Uint8Array(i).buffer))
          );
        },
      }),
        (e._lctf = {}),
        (e._lctf.parse = function (i, a, l, u, f) {
          var d = e._bin,
            m = {},
            v = a;
          d.readFixed(i, a), (a += 4);
          var _ = d.readUshort(i, a);
          a += 2;
          var A = d.readUshort(i, a);
          a += 2;
          var M = d.readUshort(i, a);
          return (
            (a += 2),
            (m.scriptList = e._lctf.readScriptList(i, v + _)),
            (m.featureList = e._lctf.readFeatureList(i, v + A)),
            (m.lookupList = e._lctf.readLookupList(i, v + M, f)),
            m
          );
        }),
        (e._lctf.readLookupList = function (i, a, l) {
          var u = e._bin,
            f = a,
            d = [],
            m = u.readUshort(i, a);
          a += 2;
          for (var v = 0; v < m; v++) {
            var _ = u.readUshort(i, a);
            a += 2;
            var A = e._lctf.readLookupTable(i, f + _, l);
            d.push(A);
          }
          return d;
        }),
        (e._lctf.readLookupTable = function (i, a, l) {
          var u = e._bin,
            f = a,
            d = { tabs: [] };
          (d.ltype = u.readUshort(i, a)),
            (a += 2),
            (d.flag = u.readUshort(i, a)),
            (a += 2);
          var m = u.readUshort(i, a);
          a += 2;
          for (var v = d.ltype, _ = 0; _ < m; _++) {
            var A = u.readUshort(i, a);
            a += 2;
            var M = l(i, v, f + A, d);
            d.tabs.push(M);
          }
          return d;
        }),
        (e._lctf.numOfOnes = function (i) {
          for (var a = 0, l = 0; l < 32; l++) ((i >>> l) & 1) != 0 && a++;
          return a;
        }),
        (e._lctf.readClassDef = function (i, a) {
          var l = e._bin,
            u = [],
            f = l.readUshort(i, a);
          if (((a += 2), f == 1)) {
            var d = l.readUshort(i, a);
            a += 2;
            var m = l.readUshort(i, a);
            a += 2;
            for (var v = 0; v < m; v++)
              u.push(d + v),
                u.push(d + v),
                u.push(l.readUshort(i, a)),
                (a += 2);
          }
          if (f == 2) {
            var _ = l.readUshort(i, a);
            for (a += 2, v = 0; v < _; v++)
              u.push(l.readUshort(i, a)),
                (a += 2),
                u.push(l.readUshort(i, a)),
                (a += 2),
                u.push(l.readUshort(i, a)),
                (a += 2);
          }
          return u;
        }),
        (e._lctf.getInterval = function (i, a) {
          for (var l = 0; l < i.length; l += 3) {
            var u = i[l],
              f = i[l + 1];
            if ((i[l + 2], u <= a && a <= f)) return l;
          }
          return -1;
        }),
        (e._lctf.readCoverage = function (i, a) {
          var l = e._bin,
            u = {};
          (u.fmt = l.readUshort(i, a)), (a += 2);
          var f = l.readUshort(i, a);
          return (
            (a += 2),
            u.fmt == 1 && (u.tab = l.readUshorts(i, a, f)),
            u.fmt == 2 && (u.tab = l.readUshorts(i, a, 3 * f)),
            u
          );
        }),
        (e._lctf.coverageIndex = function (i, a) {
          var l = i.tab;
          if (i.fmt == 1) return l.indexOf(a);
          if (i.fmt == 2) {
            var u = e._lctf.getInterval(l, a);
            if (u != -1) return l[u + 2] + (a - l[u]);
          }
          return -1;
        }),
        (e._lctf.readFeatureList = function (i, a) {
          var l = e._bin,
            u = a,
            f = [],
            d = l.readUshort(i, a);
          a += 2;
          for (var m = 0; m < d; m++) {
            var v = l.readASCII(i, a, 4);
            a += 4;
            var _ = l.readUshort(i, a);
            a += 2;
            var A = e._lctf.readFeatureTable(i, u + _);
            (A.tag = v.trim()), f.push(A);
          }
          return f;
        }),
        (e._lctf.readFeatureTable = function (i, a) {
          var l = e._bin,
            u = a,
            f = {},
            d = l.readUshort(i, a);
          (a += 2), d > 0 && (f.featureParams = u + d);
          var m = l.readUshort(i, a);
          (a += 2), (f.tab = []);
          for (var v = 0; v < m; v++) f.tab.push(l.readUshort(i, a + 2 * v));
          return f;
        }),
        (e._lctf.readScriptList = function (i, a) {
          var l = e._bin,
            u = a,
            f = {},
            d = l.readUshort(i, a);
          a += 2;
          for (var m = 0; m < d; m++) {
            var v = l.readASCII(i, a, 4);
            a += 4;
            var _ = l.readUshort(i, a);
            (a += 2), (f[v.trim()] = e._lctf.readScriptTable(i, u + _));
          }
          return f;
        }),
        (e._lctf.readScriptTable = function (i, a) {
          var l = e._bin,
            u = a,
            f = {},
            d = l.readUshort(i, a);
          (a += 2), d > 0 && (f.default = e._lctf.readLangSysTable(i, u + d));
          var m = l.readUshort(i, a);
          a += 2;
          for (var v = 0; v < m; v++) {
            var _ = l.readASCII(i, a, 4);
            a += 4;
            var A = l.readUshort(i, a);
            (a += 2), (f[_.trim()] = e._lctf.readLangSysTable(i, u + A));
          }
          return f;
        }),
        (e._lctf.readLangSysTable = function (i, a) {
          var l = e._bin,
            u = {};
          l.readUshort(i, a),
            (a += 2),
            (u.reqFeature = l.readUshort(i, a)),
            (a += 2);
          var f = l.readUshort(i, a);
          return (a += 2), (u.features = l.readUshorts(i, a, f)), u;
        }),
        (e.CFF = {}),
        (e.CFF.parse = function (i, a, l) {
          var u = e._bin;
          (i = new Uint8Array(i.buffer, a, l))[(a = 0)],
            i[++a],
            i[++a],
            i[++a],
            a++;
          var f = [];
          a = e.CFF.readIndex(i, a, f);
          for (var d = [], m = 0; m < f.length - 1; m++)
            d.push(u.readASCII(i, a + f[m], f[m + 1] - f[m]));
          a += f[f.length - 1];
          var v = [];
          a = e.CFF.readIndex(i, a, v);
          var _ = [];
          for (m = 0; m < v.length - 1; m++)
            _.push(e.CFF.readDict(i, a + v[m], a + v[m + 1]));
          a += v[v.length - 1];
          var A = _[0],
            M = [];
          a = e.CFF.readIndex(i, a, M);
          var T = [];
          for (m = 0; m < M.length - 1; m++)
            T.push(u.readASCII(i, a + M[m], M[m + 1] - M[m]));
          if (
            ((a += M[M.length - 1]), e.CFF.readSubrs(i, a, A), A.CharStrings)
          ) {
            (a = A.CharStrings), (M = []), (a = e.CFF.readIndex(i, a, M));
            var E = [];
            for (m = 0; m < M.length - 1; m++)
              E.push(u.readBytes(i, a + M[m], M[m + 1] - M[m]));
            A.CharStrings = E;
          }
          if (A.ROS) {
            a = A.FDArray;
            var b = [];
            for (
              a = e.CFF.readIndex(i, a, b), A.FDArray = [], m = 0;
              m < b.length - 1;
              m++
            ) {
              var w = e.CFF.readDict(i, a + b[m], a + b[m + 1]);
              e.CFF._readFDict(i, w, T), A.FDArray.push(w);
            }
            (a += b[b.length - 1]), (a = A.FDSelect), (A.FDSelect = []);
            var D = i[a];
            if ((a++, D != 3)) throw D;
            var B = u.readUshort(i, a);
            for (a += 2, m = 0; m < B + 1; m++)
              A.FDSelect.push(u.readUshort(i, a), i[a + 2]), (a += 3);
          }
          return (
            A.Encoding &&
              (A.Encoding = e.CFF.readEncoding(
                i,
                A.Encoding,
                A.CharStrings.length
              )),
            A.charset &&
              (A.charset = e.CFF.readCharset(
                i,
                A.charset,
                A.CharStrings.length
              )),
            e.CFF._readFDict(i, A, T),
            A
          );
        }),
        (e.CFF._readFDict = function (i, a, l) {
          var u;
          for (var f in (a.Private &&
            ((u = a.Private[1]),
            (a.Private = e.CFF.readDict(i, u, u + a.Private[0])),
            a.Private.Subrs &&
              e.CFF.readSubrs(i, u + a.Private.Subrs, a.Private)),
          a))
            [
              "FamilyName",
              "FontName",
              "FullName",
              "Notice",
              "version",
              "Copyright",
            ].indexOf(f) != -1 && (a[f] = l[a[f] - 426 + 35]);
        }),
        (e.CFF.readSubrs = function (i, a, l) {
          var u = e._bin,
            f = [];
          a = e.CFF.readIndex(i, a, f);
          var d,
            m = f.length;
          (d = m < 1240 ? 107 : m < 33900 ? 1131 : 32768),
            (l.Bias = d),
            (l.Subrs = []);
          for (var v = 0; v < f.length - 1; v++)
            l.Subrs.push(u.readBytes(i, a + f[v], f[v + 1] - f[v]));
        }),
        (e.CFF.tableSE = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
          14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
          31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
          65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
          82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,
          107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119,
          120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0,
          132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0,
          0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0,
        ]),
        (e.CFF.glyphByUnicode = function (i, a) {
          for (var l = 0; l < i.charset.length; l++)
            if (i.charset[l] == a) return l;
          return -1;
        }),
        (e.CFF.glyphBySE = function (i, a) {
          return a < 0 || a > 255
            ? -1
            : e.CFF.glyphByUnicode(i, e.CFF.tableSE[a]);
        }),
        (e.CFF.readEncoding = function (i, a, l) {
          e._bin;
          var u = [".notdef"],
            f = i[a];
          if ((a++, f != 0)) throw "error: unknown encoding format: " + f;
          var d = i[a];
          a++;
          for (var m = 0; m < d; m++) u.push(i[a + m]);
          return u;
        }),
        (e.CFF.readCharset = function (i, a, l) {
          var u = e._bin,
            f = [".notdef"],
            d = i[a];
          if ((a++, d == 0))
            for (var m = 0; m < l; m++) {
              var v = u.readUshort(i, a);
              (a += 2), f.push(v);
            }
          else {
            if (d != 1 && d != 2) throw "error: format: " + d;
            for (; f.length < l; ) {
              (v = u.readUshort(i, a)), (a += 2);
              var _ = 0;
              for (
                d == 1
                  ? ((_ = i[a]), a++)
                  : ((_ = u.readUshort(i, a)), (a += 2)),
                  m = 0;
                m <= _;
                m++
              )
                f.push(v), v++;
            }
          }
          return f;
        }),
        (e.CFF.readIndex = function (i, a, l) {
          var u = e._bin,
            f = u.readUshort(i, a) + 1,
            d = i[(a += 2)];
          if ((a++, d == 1)) for (var m = 0; m < f; m++) l.push(i[a + m]);
          else if (d == 2)
            for (m = 0; m < f; m++) l.push(u.readUshort(i, a + 2 * m));
          else if (d == 3)
            for (m = 0; m < f; m++)
              l.push(16777215 & u.readUint(i, a + 3 * m - 1));
          else if (f != 1)
            throw "unsupported offset size: " + d + ", count: " + f;
          return (a += f * d) - 1;
        }),
        (e.CFF.getCharString = function (i, a, l) {
          var u = e._bin,
            f = i[a],
            d = i[a + 1];
          i[a + 2], i[a + 3], i[a + 4];
          var m = 1,
            v = null,
            _ = null;
          f <= 20 && ((v = f), (m = 1)),
            f == 12 && ((v = 100 * f + d), (m = 2)),
            21 <= f && f <= 27 && ((v = f), (m = 1)),
            f == 28 && ((_ = u.readShort(i, a + 1)), (m = 3)),
            29 <= f && f <= 31 && ((v = f), (m = 1)),
            32 <= f && f <= 246 && ((_ = f - 139), (m = 1)),
            247 <= f && f <= 250 && ((_ = 256 * (f - 247) + d + 108), (m = 2)),
            251 <= f && f <= 254 && ((_ = 256 * -(f - 251) - d - 108), (m = 2)),
            f == 255 && ((_ = u.readInt(i, a + 1) / 65535), (m = 5)),
            (l.val = _ ?? "o" + v),
            (l.size = m);
        }),
        (e.CFF.readCharString = function (i, a, l) {
          for (var u = a + l, f = e._bin, d = []; a < u; ) {
            var m = i[a],
              v = i[a + 1];
            i[a + 2], i[a + 3], i[a + 4];
            var _ = 1,
              A = null,
              M = null;
            m <= 20 && ((A = m), (_ = 1)),
              m == 12 && ((A = 100 * m + v), (_ = 2)),
              (m != 19 && m != 20) || ((A = m), (_ = 2)),
              21 <= m && m <= 27 && ((A = m), (_ = 1)),
              m == 28 && ((M = f.readShort(i, a + 1)), (_ = 3)),
              29 <= m && m <= 31 && ((A = m), (_ = 1)),
              32 <= m && m <= 246 && ((M = m - 139), (_ = 1)),
              247 <= m &&
                m <= 250 &&
                ((M = 256 * (m - 247) + v + 108), (_ = 2)),
              251 <= m &&
                m <= 254 &&
                ((M = 256 * -(m - 251) - v - 108), (_ = 2)),
              m == 255 && ((M = f.readInt(i, a + 1) / 65535), (_ = 5)),
              d.push(M ?? "o" + A),
              (a += _);
          }
          return d;
        }),
        (e.CFF.readDict = function (i, a, l) {
          for (var u = e._bin, f = {}, d = []; a < l; ) {
            var m = i[a],
              v = i[a + 1];
            i[a + 2], i[a + 3], i[a + 4];
            var _ = 1,
              A = null,
              M = null;
            if (
              (m == 28 && ((M = u.readShort(i, a + 1)), (_ = 3)),
              m == 29 && ((M = u.readInt(i, a + 1)), (_ = 5)),
              32 <= m && m <= 246 && ((M = m - 139), (_ = 1)),
              247 <= m &&
                m <= 250 &&
                ((M = 256 * (m - 247) + v + 108), (_ = 2)),
              251 <= m &&
                m <= 254 &&
                ((M = 256 * -(m - 251) - v - 108), (_ = 2)),
              m == 255)
            )
              throw (
                ((M = u.readInt(i, a + 1) / 65535), (_ = 5), "unknown number")
              );
            if (m == 30) {
              var T = [];
              for (_ = 1; ; ) {
                var E = i[a + _];
                _++;
                var b = E >> 4,
                  w = 15 & E;
                if ((b != 15 && T.push(b), w != 15 && T.push(w), w == 15))
                  break;
              }
              for (
                var D = "",
                  B = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber",
                  ],
                  I = 0;
                I < T.length;
                I++
              )
                D += B[T[I]];
              M = parseFloat(D);
            }
            m <= 21 &&
              ((A = [
                "version",
                "Notice",
                "FullName",
                "FamilyName",
                "Weight",
                "FontBBox",
                "BlueValues",
                "OtherBlues",
                "FamilyBlues",
                "FamilyOtherBlues",
                "StdHW",
                "StdVW",
                "escape",
                "UniqueID",
                "XUID",
                "charset",
                "Encoding",
                "CharStrings",
                "Private",
                "Subrs",
                "defaultWidthX",
                "nominalWidthX",
              ][m]),
              (_ = 1),
              m == 12 &&
                ((A = [
                  "Copyright",
                  "isFixedPitch",
                  "ItalicAngle",
                  "UnderlinePosition",
                  "UnderlineThickness",
                  "PaintType",
                  "CharstringType",
                  "FontMatrix",
                  "StrokeWidth",
                  "BlueScale",
                  "BlueShift",
                  "BlueFuzz",
                  "StemSnapH",
                  "StemSnapV",
                  "ForceBold",
                  0,
                  0,
                  "LanguageGroup",
                  "ExpansionFactor",
                  "initialRandomSeed",
                  "SyntheticBase",
                  "PostScript",
                  "BaseFontName",
                  "BaseFontBlend",
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  "ROS",
                  "CIDFontVersion",
                  "CIDFontRevision",
                  "CIDFontType",
                  "CIDCount",
                  "UIDBase",
                  "FDArray",
                  "FDSelect",
                  "FontName",
                ][v]),
                (_ = 2))),
              A != null
                ? ((f[A] = d.length == 1 ? d[0] : d), (d = []))
                : d.push(M),
              (a += _);
          }
          return f;
        }),
        (e.cmap = {}),
        (e.cmap.parse = function (i, a, l) {
          (i = new Uint8Array(i.buffer, a, l)), (a = 0);
          var u = e._bin,
            f = {};
          u.readUshort(i, a), (a += 2);
          var d = u.readUshort(i, a);
          a += 2;
          var m = [];
          f.tables = [];
          for (var v = 0; v < d; v++) {
            var _ = u.readUshort(i, a);
            a += 2;
            var A = u.readUshort(i, a);
            a += 2;
            var M = u.readUint(i, a);
            a += 4;
            var T = "p" + _ + "e" + A,
              E = m.indexOf(M);
            if (E == -1) {
              var b;
              (E = f.tables.length), m.push(M);
              var w = u.readUshort(i, M);
              w == 0
                ? (b = e.cmap.parse0(i, M))
                : w == 4
                ? (b = e.cmap.parse4(i, M))
                : w == 6
                ? (b = e.cmap.parse6(i, M))
                : w == 12
                ? (b = e.cmap.parse12(i, M))
                : console.debug("unknown format: " + w, _, A, M),
                f.tables.push(b);
            }
            if (f[T] != null) throw "multiple tables for one platform+encoding";
            f[T] = E;
          }
          return f;
        }),
        (e.cmap.parse0 = function (i, a) {
          var l = e._bin,
            u = {};
          (u.format = l.readUshort(i, a)), (a += 2);
          var f = l.readUshort(i, a);
          (a += 2), l.readUshort(i, a), (a += 2), (u.map = []);
          for (var d = 0; d < f - 6; d++) u.map.push(i[a + d]);
          return u;
        }),
        (e.cmap.parse4 = function (i, a) {
          var l = e._bin,
            u = a,
            f = {};
          (f.format = l.readUshort(i, a)), (a += 2);
          var d = l.readUshort(i, a);
          (a += 2), l.readUshort(i, a), (a += 2);
          var m = l.readUshort(i, a);
          a += 2;
          var v = m / 2;
          (f.searchRange = l.readUshort(i, a)),
            (a += 2),
            (f.entrySelector = l.readUshort(i, a)),
            (a += 2),
            (f.rangeShift = l.readUshort(i, a)),
            (a += 2),
            (f.endCount = l.readUshorts(i, a, v)),
            (a += 2 * v),
            (a += 2),
            (f.startCount = l.readUshorts(i, a, v)),
            (a += 2 * v),
            (f.idDelta = []);
          for (var _ = 0; _ < v; _++)
            f.idDelta.push(l.readShort(i, a)), (a += 2);
          for (
            f.idRangeOffset = l.readUshorts(i, a, v),
              a += 2 * v,
              f.glyphIdArray = [];
            a < u + d;

          )
            f.glyphIdArray.push(l.readUshort(i, a)), (a += 2);
          return f;
        }),
        (e.cmap.parse6 = function (i, a) {
          var l = e._bin,
            u = {};
          (u.format = l.readUshort(i, a)),
            (a += 2),
            l.readUshort(i, a),
            (a += 2),
            l.readUshort(i, a),
            (a += 2),
            (u.firstCode = l.readUshort(i, a)),
            (a += 2);
          var f = l.readUshort(i, a);
          (a += 2), (u.glyphIdArray = []);
          for (var d = 0; d < f; d++)
            u.glyphIdArray.push(l.readUshort(i, a)), (a += 2);
          return u;
        }),
        (e.cmap.parse12 = function (i, a) {
          var l = e._bin,
            u = {};
          (u.format = l.readUshort(i, a)),
            (a += 2),
            (a += 2),
            l.readUint(i, a),
            (a += 4),
            l.readUint(i, a),
            (a += 4);
          var f = l.readUint(i, a);
          (a += 4), (u.groups = []);
          for (var d = 0; d < f; d++) {
            var m = a + 12 * d,
              v = l.readUint(i, m + 0),
              _ = l.readUint(i, m + 4),
              A = l.readUint(i, m + 8);
            u.groups.push([v, _, A]);
          }
          return u;
        }),
        (e.glyf = {}),
        (e.glyf.parse = function (i, a, l, u) {
          for (var f = [], d = 0; d < u.maxp.numGlyphs; d++) f.push(null);
          return f;
        }),
        (e.glyf._parseGlyf = function (i, a) {
          var l = e._bin,
            u = i._data,
            f = e._tabOffset(u, "glyf", i._offset) + i.loca[a];
          if (i.loca[a] == i.loca[a + 1]) return null;
          var d = {};
          if (
            ((d.noc = l.readShort(u, f)),
            (f += 2),
            (d.xMin = l.readShort(u, f)),
            (f += 2),
            (d.yMin = l.readShort(u, f)),
            (f += 2),
            (d.xMax = l.readShort(u, f)),
            (f += 2),
            (d.yMax = l.readShort(u, f)),
            (f += 2),
            d.xMin >= d.xMax || d.yMin >= d.yMax)
          )
            return null;
          if (d.noc > 0) {
            d.endPts = [];
            for (var m = 0; m < d.noc; m++)
              d.endPts.push(l.readUshort(u, f)), (f += 2);
            var v = l.readUshort(u, f);
            if (((f += 2), u.length - f < v)) return null;
            (d.instructions = l.readBytes(u, f, v)), (f += v);
            var _ = d.endPts[d.noc - 1] + 1;
            for (d.flags = [], m = 0; m < _; m++) {
              var A = u[f];
              if ((f++, d.flags.push(A), (8 & A) != 0)) {
                var M = u[f];
                f++;
                for (var T = 0; T < M; T++) d.flags.push(A), m++;
              }
            }
            for (d.xs = [], m = 0; m < _; m++) {
              var E = (2 & d.flags[m]) != 0,
                b = (16 & d.flags[m]) != 0;
              E
                ? (d.xs.push(b ? u[f] : -u[f]), f++)
                : b
                ? d.xs.push(0)
                : (d.xs.push(l.readShort(u, f)), (f += 2));
            }
            for (d.ys = [], m = 0; m < _; m++)
              (E = (4 & d.flags[m]) != 0),
                (b = (32 & d.flags[m]) != 0),
                E
                  ? (d.ys.push(b ? u[f] : -u[f]), f++)
                  : b
                  ? d.ys.push(0)
                  : (d.ys.push(l.readShort(u, f)), (f += 2));
            var w = 0,
              D = 0;
            for (m = 0; m < _; m++)
              (w += d.xs[m]), (D += d.ys[m]), (d.xs[m] = w), (d.ys[m] = D);
          } else {
            var B;
            d.parts = [];
            do {
              (B = l.readUshort(u, f)), (f += 2);
              var I = {
                m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 },
                p1: -1,
                p2: -1,
              };
              if (
                (d.parts.push(I),
                (I.glyphIndex = l.readUshort(u, f)),
                (f += 2),
                1 & B)
              ) {
                var N = l.readShort(u, f);
                f += 2;
                var P = l.readShort(u, f);
                f += 2;
              } else (N = l.readInt8(u, f)), f++, (P = l.readInt8(u, f)), f++;
              2 & B ? ((I.m.tx = N), (I.m.ty = P)) : ((I.p1 = N), (I.p2 = P)),
                8 & B
                  ? ((I.m.a = I.m.d = l.readF2dot14(u, f)), (f += 2))
                  : 64 & B
                  ? ((I.m.a = l.readF2dot14(u, f)),
                    (f += 2),
                    (I.m.d = l.readF2dot14(u, f)),
                    (f += 2))
                  : 128 & B &&
                    ((I.m.a = l.readF2dot14(u, f)),
                    (f += 2),
                    (I.m.b = l.readF2dot14(u, f)),
                    (f += 2),
                    (I.m.c = l.readF2dot14(u, f)),
                    (f += 2),
                    (I.m.d = l.readF2dot14(u, f)),
                    (f += 2));
            } while (32 & B);
            if (256 & B) {
              var F = l.readUshort(u, f);
              for (f += 2, d.instr = [], m = 0; m < F; m++)
                d.instr.push(u[f]), f++;
            }
          }
          return d;
        }),
        (e.GDEF = {}),
        (e.GDEF.parse = function (i, a, l, u) {
          var f = a;
          a += 4;
          var d = e._bin.readUshort(i, a);
          return {
            glyphClassDef: d === 0 ? null : e._lctf.readClassDef(i, f + d),
          };
        }),
        (e.GPOS = {}),
        (e.GPOS.parse = function (i, a, l, u) {
          return e._lctf.parse(i, a, l, u, e.GPOS.subt);
        }),
        (e.GPOS.subt = function (i, a, l, u) {
          var f = e._bin,
            d = l,
            m = {};
          if (
            ((m.fmt = f.readUshort(i, l)),
            (l += 2),
            a == 1 || a == 2 || a == 3 || a == 7 || (a == 8 && m.fmt <= 2))
          ) {
            var v = f.readUshort(i, l);
            (l += 2), (m.coverage = e._lctf.readCoverage(i, v + d));
          }
          if (a == 1 && m.fmt == 1) {
            var _ = f.readUshort(i, l);
            (l += 2), _ != 0 && (m.pos = e.GPOS.readValueRecord(i, l, _));
          } else if (a == 2 && m.fmt >= 1 && m.fmt <= 2) {
            (_ = f.readUshort(i, l)), (l += 2);
            var A = f.readUshort(i, l);
            l += 2;
            var M = e._lctf.numOfOnes(_),
              T = e._lctf.numOfOnes(A);
            if (m.fmt == 1) {
              m.pairsets = [];
              var E = f.readUshort(i, l);
              l += 2;
              for (var b = 0; b < E; b++) {
                var w = d + f.readUshort(i, l);
                l += 2;
                var D = f.readUshort(i, w);
                w += 2;
                for (var B = [], I = 0; I < D; I++) {
                  var N = f.readUshort(i, w);
                  (w += 2),
                    _ != 0 &&
                      ((J = e.GPOS.readValueRecord(i, w, _)), (w += 2 * M)),
                    A != 0 &&
                      ((q = e.GPOS.readValueRecord(i, w, A)), (w += 2 * T)),
                    B.push({ gid2: N, val1: J, val2: q });
                }
                m.pairsets.push(B);
              }
            }
            if (m.fmt == 2) {
              var P = f.readUshort(i, l);
              l += 2;
              var F = f.readUshort(i, l);
              l += 2;
              var O = f.readUshort(i, l);
              l += 2;
              var U = f.readUshort(i, l);
              for (
                l += 2,
                  m.classDef1 = e._lctf.readClassDef(i, d + P),
                  m.classDef2 = e._lctf.readClassDef(i, d + F),
                  m.matrix = [],
                  b = 0;
                b < O;
                b++
              ) {
                var W = [];
                for (I = 0; I < U; I++) {
                  var J = null,
                    q = null;
                  _ != 0 &&
                    ((J = e.GPOS.readValueRecord(i, l, _)), (l += 2 * M)),
                    A != 0 &&
                      ((q = e.GPOS.readValueRecord(i, l, A)), (l += 2 * T)),
                    W.push({ val1: J, val2: q });
                }
                m.matrix.push(W);
              }
            }
          } else if (a == 4 && m.fmt == 1)
            (m.markCoverage = e._lctf.readCoverage(i, f.readUshort(i, l) + d)),
              (m.baseCoverage = e._lctf.readCoverage(
                i,
                f.readUshort(i, l + 2) + d
              )),
              (m.markClassCount = f.readUshort(i, l + 4)),
              (m.markArray = e.GPOS.readMarkArray(
                i,
                f.readUshort(i, l + 6) + d
              )),
              (m.baseArray = e.GPOS.readBaseArray(
                i,
                f.readUshort(i, l + 8) + d,
                m.markClassCount
              ));
          else if (a == 6 && m.fmt == 1)
            (m.mark1Coverage = e._lctf.readCoverage(i, f.readUshort(i, l) + d)),
              (m.mark2Coverage = e._lctf.readCoverage(
                i,
                f.readUshort(i, l + 2) + d
              )),
              (m.markClassCount = f.readUshort(i, l + 4)),
              (m.mark1Array = e.GPOS.readMarkArray(
                i,
                f.readUshort(i, l + 6) + d
              )),
              (m.mark2Array = e.GPOS.readBaseArray(
                i,
                f.readUshort(i, l + 8) + d,
                m.markClassCount
              ));
          else {
            if (a == 9 && m.fmt == 1) {
              var Z = f.readUshort(i, l);
              l += 2;
              var ue = f.readUint(i, l);
              if (((l += 4), u.ltype == 9)) u.ltype = Z;
              else if (u.ltype != Z) throw "invalid extension substitution";
              return e.GPOS.subt(i, u.ltype, d + ue);
            }
            console.debug(
              "unsupported GPOS table LookupType",
              a,
              "format",
              m.fmt
            );
          }
          return m;
        }),
        (e.GPOS.readValueRecord = function (i, a, l) {
          var u = e._bin,
            f = [];
          return (
            f.push(1 & l ? u.readShort(i, a) : 0),
            (a += 1 & l ? 2 : 0),
            f.push(2 & l ? u.readShort(i, a) : 0),
            (a += 2 & l ? 2 : 0),
            f.push(4 & l ? u.readShort(i, a) : 0),
            (a += 4 & l ? 2 : 0),
            f.push(8 & l ? u.readShort(i, a) : 0),
            (a += 8 & l ? 2 : 0),
            f
          );
        }),
        (e.GPOS.readBaseArray = function (i, a, l) {
          var u = e._bin,
            f = [],
            d = a,
            m = u.readUshort(i, a);
          a += 2;
          for (var v = 0; v < m; v++) {
            for (var _ = [], A = 0; A < l; A++)
              _.push(e.GPOS.readAnchorRecord(i, d + u.readUshort(i, a))),
                (a += 2);
            f.push(_);
          }
          return f;
        }),
        (e.GPOS.readMarkArray = function (i, a) {
          var l = e._bin,
            u = [],
            f = a,
            d = l.readUshort(i, a);
          a += 2;
          for (var m = 0; m < d; m++) {
            var v = e.GPOS.readAnchorRecord(i, l.readUshort(i, a + 2) + f);
            (v.markClass = l.readUshort(i, a)), u.push(v), (a += 4);
          }
          return u;
        }),
        (e.GPOS.readAnchorRecord = function (i, a) {
          var l = e._bin,
            u = {};
          return (
            (u.fmt = l.readUshort(i, a)),
            (u.x = l.readShort(i, a + 2)),
            (u.y = l.readShort(i, a + 4)),
            u
          );
        }),
        (e.GSUB = {}),
        (e.GSUB.parse = function (i, a, l, u) {
          return e._lctf.parse(i, a, l, u, e.GSUB.subt);
        }),
        (e.GSUB.subt = function (i, a, l, u) {
          var f = e._bin,
            d = l,
            m = {};
          if (
            ((m.fmt = f.readUshort(i, l)),
            (l += 2),
            a != 1 && a != 2 && a != 4 && a != 5 && a != 6)
          )
            return null;
          if (
            a == 1 ||
            a == 2 ||
            a == 4 ||
            (a == 5 && m.fmt <= 2) ||
            (a == 6 && m.fmt <= 2)
          ) {
            var v = f.readUshort(i, l);
            (l += 2), (m.coverage = e._lctf.readCoverage(i, d + v));
          }
          if (a == 1 && m.fmt >= 1 && m.fmt <= 2) {
            if (m.fmt == 1) (m.delta = f.readShort(i, l)), (l += 2);
            else if (m.fmt == 2) {
              var _ = f.readUshort(i, l);
              (l += 2),
                (m.newg = f.readUshorts(i, l, _)),
                (l += 2 * m.newg.length);
            }
          } else if (a == 2 && m.fmt == 1) {
            (_ = f.readUshort(i, l)), (l += 2), (m.seqs = []);
            for (var A = 0; A < _; A++) {
              var M = f.readUshort(i, l) + d;
              l += 2;
              var T = f.readUshort(i, M);
              m.seqs.push(f.readUshorts(i, M + 2, T));
            }
          } else if (a == 4)
            for (
              m.vals = [], _ = f.readUshort(i, l), l += 2, A = 0;
              A < _;
              A++
            ) {
              var E = f.readUshort(i, l);
              (l += 2), m.vals.push(e.GSUB.readLigatureSet(i, d + E));
            }
          else if (a == 5 && m.fmt == 2) {
            if (m.fmt == 2) {
              var b = f.readUshort(i, l);
              (l += 2),
                (m.cDef = e._lctf.readClassDef(i, d + b)),
                (m.scset = []);
              var w = f.readUshort(i, l);
              for (l += 2, A = 0; A < w; A++) {
                var D = f.readUshort(i, l);
                (l += 2),
                  m.scset.push(
                    D == 0 ? null : e.GSUB.readSubClassSet(i, d + D)
                  );
              }
            }
          } else if (a == 6 && m.fmt == 3) {
            if (m.fmt == 3) {
              for (A = 0; A < 3; A++) {
                (_ = f.readUshort(i, l)), (l += 2);
                for (var B = [], I = 0; I < _; I++)
                  B.push(
                    e._lctf.readCoverage(i, d + f.readUshort(i, l + 2 * I))
                  );
                (l += 2 * _),
                  A == 0 && (m.backCvg = B),
                  A == 1 && (m.inptCvg = B),
                  A == 2 && (m.ahedCvg = B);
              }
              (_ = f.readUshort(i, l)),
                (l += 2),
                (m.lookupRec = e.GSUB.readSubstLookupRecords(i, l, _));
            }
          } else {
            if (a == 7 && m.fmt == 1) {
              var N = f.readUshort(i, l);
              l += 2;
              var P = f.readUint(i, l);
              if (((l += 4), u.ltype == 9)) u.ltype = N;
              else if (u.ltype != N) throw "invalid extension substitution";
              return e.GSUB.subt(i, u.ltype, d + P);
            }
            console.debug(
              "unsupported GSUB table LookupType",
              a,
              "format",
              m.fmt
            );
          }
          return m;
        }),
        (e.GSUB.readSubClassSet = function (i, a) {
          var l = e._bin.readUshort,
            u = a,
            f = [],
            d = l(i, a);
          a += 2;
          for (var m = 0; m < d; m++) {
            var v = l(i, a);
            (a += 2), f.push(e.GSUB.readSubClassRule(i, u + v));
          }
          return f;
        }),
        (e.GSUB.readSubClassRule = function (i, a) {
          var l = e._bin.readUshort,
            u = {},
            f = l(i, a),
            d = l(i, (a += 2));
          (a += 2), (u.input = []);
          for (var m = 0; m < f - 1; m++) u.input.push(l(i, a)), (a += 2);
          return (
            (u.substLookupRecords = e.GSUB.readSubstLookupRecords(i, a, d)), u
          );
        }),
        (e.GSUB.readSubstLookupRecords = function (i, a, l) {
          for (var u = e._bin.readUshort, f = [], d = 0; d < l; d++)
            f.push(u(i, a), u(i, a + 2)), (a += 4);
          return f;
        }),
        (e.GSUB.readChainSubClassSet = function (i, a) {
          var l = e._bin,
            u = a,
            f = [],
            d = l.readUshort(i, a);
          a += 2;
          for (var m = 0; m < d; m++) {
            var v = l.readUshort(i, a);
            (a += 2), f.push(e.GSUB.readChainSubClassRule(i, u + v));
          }
          return f;
        }),
        (e.GSUB.readChainSubClassRule = function (i, a) {
          for (
            var l = e._bin,
              u = {},
              f = ["backtrack", "input", "lookahead"],
              d = 0;
            d < f.length;
            d++
          ) {
            var m = l.readUshort(i, a);
            (a += 2),
              d == 1 && m--,
              (u[f[d]] = l.readUshorts(i, a, m)),
              (a += 2 * u[f[d]].length);
          }
          return (
            (m = l.readUshort(i, a)),
            (a += 2),
            (u.subst = l.readUshorts(i, a, 2 * m)),
            (a += 2 * u.subst.length),
            u
          );
        }),
        (e.GSUB.readLigatureSet = function (i, a) {
          var l = e._bin,
            u = a,
            f = [],
            d = l.readUshort(i, a);
          a += 2;
          for (var m = 0; m < d; m++) {
            var v = l.readUshort(i, a);
            (a += 2), f.push(e.GSUB.readLigature(i, u + v));
          }
          return f;
        }),
        (e.GSUB.readLigature = function (i, a) {
          var l = e._bin,
            u = { chain: [] };
          (u.nglyph = l.readUshort(i, a)), (a += 2);
          var f = l.readUshort(i, a);
          a += 2;
          for (var d = 0; d < f - 1; d++)
            u.chain.push(l.readUshort(i, a)), (a += 2);
          return u;
        }),
        (e.head = {}),
        (e.head.parse = function (i, a, l) {
          var u = e._bin,
            f = {};
          return (
            u.readFixed(i, a),
            (a += 4),
            (f.fontRevision = u.readFixed(i, a)),
            (a += 4),
            u.readUint(i, a),
            (a += 4),
            u.readUint(i, a),
            (a += 4),
            (f.flags = u.readUshort(i, a)),
            (a += 2),
            (f.unitsPerEm = u.readUshort(i, a)),
            (a += 2),
            (f.created = u.readUint64(i, a)),
            (a += 8),
            (f.modified = u.readUint64(i, a)),
            (a += 8),
            (f.xMin = u.readShort(i, a)),
            (a += 2),
            (f.yMin = u.readShort(i, a)),
            (a += 2),
            (f.xMax = u.readShort(i, a)),
            (a += 2),
            (f.yMax = u.readShort(i, a)),
            (a += 2),
            (f.macStyle = u.readUshort(i, a)),
            (a += 2),
            (f.lowestRecPPEM = u.readUshort(i, a)),
            (a += 2),
            (f.fontDirectionHint = u.readShort(i, a)),
            (a += 2),
            (f.indexToLocFormat = u.readShort(i, a)),
            (a += 2),
            (f.glyphDataFormat = u.readShort(i, a)),
            (a += 2),
            f
          );
        }),
        (e.hhea = {}),
        (e.hhea.parse = function (i, a, l) {
          var u = e._bin,
            f = {};
          return (
            u.readFixed(i, a),
            (a += 4),
            (f.ascender = u.readShort(i, a)),
            (a += 2),
            (f.descender = u.readShort(i, a)),
            (a += 2),
            (f.lineGap = u.readShort(i, a)),
            (a += 2),
            (f.advanceWidthMax = u.readUshort(i, a)),
            (a += 2),
            (f.minLeftSideBearing = u.readShort(i, a)),
            (a += 2),
            (f.minRightSideBearing = u.readShort(i, a)),
            (a += 2),
            (f.xMaxExtent = u.readShort(i, a)),
            (a += 2),
            (f.caretSlopeRise = u.readShort(i, a)),
            (a += 2),
            (f.caretSlopeRun = u.readShort(i, a)),
            (a += 2),
            (f.caretOffset = u.readShort(i, a)),
            (a += 2),
            (a += 8),
            (f.metricDataFormat = u.readShort(i, a)),
            (a += 2),
            (f.numberOfHMetrics = u.readUshort(i, a)),
            (a += 2),
            f
          );
        }),
        (e.hmtx = {}),
        (e.hmtx.parse = function (i, a, l, u) {
          for (
            var f = e._bin,
              d = { aWidth: [], lsBearing: [] },
              m = 0,
              v = 0,
              _ = 0;
            _ < u.maxp.numGlyphs;
            _++
          )
            _ < u.hhea.numberOfHMetrics &&
              ((m = f.readUshort(i, a)),
              (a += 2),
              (v = f.readShort(i, a)),
              (a += 2)),
              d.aWidth.push(m),
              d.lsBearing.push(v);
          return d;
        }),
        (e.kern = {}),
        (e.kern.parse = function (i, a, l, u) {
          var f = e._bin,
            d = f.readUshort(i, a);
          if (((a += 2), d == 1)) return e.kern.parseV1(i, a - 2, l, u);
          var m = f.readUshort(i, a);
          a += 2;
          for (var v = { glyph1: [], rval: [] }, _ = 0; _ < m; _++) {
            (a += 2), (l = f.readUshort(i, a)), (a += 2);
            var A = f.readUshort(i, a);
            a += 2;
            var M = A >>> 8;
            if ((M &= 15) != 0) throw "unknown kern table format: " + M;
            a = e.kern.readFormat0(i, a, v);
          }
          return v;
        }),
        (e.kern.parseV1 = function (i, a, l, u) {
          var f = e._bin;
          f.readFixed(i, a), (a += 4);
          var d = f.readUint(i, a);
          a += 4;
          for (var m = { glyph1: [], rval: [] }, v = 0; v < d; v++) {
            f.readUint(i, a), (a += 4);
            var _ = f.readUshort(i, a);
            (a += 2), f.readUshort(i, a), (a += 2);
            var A = _ >>> 8;
            if ((A &= 15) != 0) throw "unknown kern table format: " + A;
            a = e.kern.readFormat0(i, a, m);
          }
          return m;
        }),
        (e.kern.readFormat0 = function (i, a, l) {
          var u = e._bin,
            f = -1,
            d = u.readUshort(i, a);
          (a += 2),
            u.readUshort(i, a),
            (a += 2),
            u.readUshort(i, a),
            (a += 2),
            u.readUshort(i, a),
            (a += 2);
          for (var m = 0; m < d; m++) {
            var v = u.readUshort(i, a);
            a += 2;
            var _ = u.readUshort(i, a);
            a += 2;
            var A = u.readShort(i, a);
            (a += 2),
              v != f &&
                (l.glyph1.push(v), l.rval.push({ glyph2: [], vals: [] }));
            var M = l.rval[l.rval.length - 1];
            M.glyph2.push(_), M.vals.push(A), (f = v);
          }
          return a;
        }),
        (e.loca = {}),
        (e.loca.parse = function (i, a, l, u) {
          var f = e._bin,
            d = [],
            m = u.head.indexToLocFormat,
            v = u.maxp.numGlyphs + 1;
          if (m == 0)
            for (var _ = 0; _ < v; _++)
              d.push(f.readUshort(i, a + (_ << 1)) << 1);
          if (m == 1)
            for (_ = 0; _ < v; _++) d.push(f.readUint(i, a + (_ << 2)));
          return d;
        }),
        (e.maxp = {}),
        (e.maxp.parse = function (i, a, l) {
          var u = e._bin,
            f = {},
            d = u.readUint(i, a);
          return (
            (a += 4),
            (f.numGlyphs = u.readUshort(i, a)),
            (a += 2),
            d == 65536 &&
              ((f.maxPoints = u.readUshort(i, a)),
              (a += 2),
              (f.maxContours = u.readUshort(i, a)),
              (a += 2),
              (f.maxCompositePoints = u.readUshort(i, a)),
              (a += 2),
              (f.maxCompositeContours = u.readUshort(i, a)),
              (a += 2),
              (f.maxZones = u.readUshort(i, a)),
              (a += 2),
              (f.maxTwilightPoints = u.readUshort(i, a)),
              (a += 2),
              (f.maxStorage = u.readUshort(i, a)),
              (a += 2),
              (f.maxFunctionDefs = u.readUshort(i, a)),
              (a += 2),
              (f.maxInstructionDefs = u.readUshort(i, a)),
              (a += 2),
              (f.maxStackElements = u.readUshort(i, a)),
              (a += 2),
              (f.maxSizeOfInstructions = u.readUshort(i, a)),
              (a += 2),
              (f.maxComponentElements = u.readUshort(i, a)),
              (a += 2),
              (f.maxComponentDepth = u.readUshort(i, a)),
              (a += 2)),
            f
          );
        }),
        (e.name = {}),
        (e.name.parse = function (i, a, l) {
          var u = e._bin,
            f = {};
          u.readUshort(i, a), (a += 2);
          var d = u.readUshort(i, a);
          (a += 2), u.readUshort(i, a);
          for (
            var m,
              v = [
                "copyright",
                "fontFamily",
                "fontSubfamily",
                "ID",
                "fullName",
                "version",
                "postScriptName",
                "trademark",
                "manufacturer",
                "designer",
                "description",
                "urlVendor",
                "urlDesigner",
                "licence",
                "licenceURL",
                "---",
                "typoFamilyName",
                "typoSubfamilyName",
                "compatibleFull",
                "sampleText",
                "postScriptCID",
                "wwsFamilyName",
                "wwsSubfamilyName",
                "lightPalette",
                "darkPalette",
              ],
              _ = (a += 2),
              A = 0;
            A < d;
            A++
          ) {
            var M = u.readUshort(i, a);
            a += 2;
            var T = u.readUshort(i, a);
            a += 2;
            var E = u.readUshort(i, a);
            a += 2;
            var b = u.readUshort(i, a);
            a += 2;
            var w = u.readUshort(i, a);
            a += 2;
            var D = u.readUshort(i, a);
            a += 2;
            var B,
              I = v[b],
              N = _ + 12 * d + D;
            if (M == 0) B = u.readUnicode(i, N, w / 2);
            else if (M == 3 && T == 0) B = u.readUnicode(i, N, w / 2);
            else if (T == 0) B = u.readASCII(i, N, w);
            else if (T == 1) B = u.readUnicode(i, N, w / 2);
            else if (T == 3) B = u.readUnicode(i, N, w / 2);
            else {
              if (M != 1) throw "unknown encoding " + T + ", platformID: " + M;
              (B = u.readASCII(i, N, w)),
                console.debug(
                  "reading unknown MAC encoding " + T + " as ASCII"
                );
            }
            var P = "p" + M + "," + E.toString(16);
            f[P] == null && (f[P] = {}),
              (f[P][I !== void 0 ? I : b] = B),
              (f[P]._lang = E);
          }
          for (var F in f)
            if (f[F].postScriptName != null && f[F]._lang == 1033) return f[F];
          for (var F in f)
            if (f[F].postScriptName != null && f[F]._lang == 0) return f[F];
          for (var F in f)
            if (f[F].postScriptName != null && f[F]._lang == 3084) return f[F];
          for (var F in f) if (f[F].postScriptName != null) return f[F];
          for (var F in f) {
            m = F;
            break;
          }
          return (
            console.debug("returning name table with languageID " + f[m]._lang),
            f[m]
          );
        }),
        (e["OS/2"] = {}),
        (e["OS/2"].parse = function (i, a, l) {
          var u = e._bin.readUshort(i, a);
          a += 2;
          var f = {};
          if (u == 0) e["OS/2"].version0(i, a, f);
          else if (u == 1) e["OS/2"].version1(i, a, f);
          else if (u == 2 || u == 3 || u == 4) e["OS/2"].version2(i, a, f);
          else {
            if (u != 5) throw "unknown OS/2 table version: " + u;
            e["OS/2"].version5(i, a, f);
          }
          return f;
        }),
        (e["OS/2"].version0 = function (i, a, l) {
          var u = e._bin;
          return (
            (l.xAvgCharWidth = u.readShort(i, a)),
            (a += 2),
            (l.usWeightClass = u.readUshort(i, a)),
            (a += 2),
            (l.usWidthClass = u.readUshort(i, a)),
            (a += 2),
            (l.fsType = u.readUshort(i, a)),
            (a += 2),
            (l.ySubscriptXSize = u.readShort(i, a)),
            (a += 2),
            (l.ySubscriptYSize = u.readShort(i, a)),
            (a += 2),
            (l.ySubscriptXOffset = u.readShort(i, a)),
            (a += 2),
            (l.ySubscriptYOffset = u.readShort(i, a)),
            (a += 2),
            (l.ySuperscriptXSize = u.readShort(i, a)),
            (a += 2),
            (l.ySuperscriptYSize = u.readShort(i, a)),
            (a += 2),
            (l.ySuperscriptXOffset = u.readShort(i, a)),
            (a += 2),
            (l.ySuperscriptYOffset = u.readShort(i, a)),
            (a += 2),
            (l.yStrikeoutSize = u.readShort(i, a)),
            (a += 2),
            (l.yStrikeoutPosition = u.readShort(i, a)),
            (a += 2),
            (l.sFamilyClass = u.readShort(i, a)),
            (a += 2),
            (l.panose = u.readBytes(i, a, 10)),
            (a += 10),
            (l.ulUnicodeRange1 = u.readUint(i, a)),
            (a += 4),
            (l.ulUnicodeRange2 = u.readUint(i, a)),
            (a += 4),
            (l.ulUnicodeRange3 = u.readUint(i, a)),
            (a += 4),
            (l.ulUnicodeRange4 = u.readUint(i, a)),
            (a += 4),
            (l.achVendID = [
              u.readInt8(i, a),
              u.readInt8(i, a + 1),
              u.readInt8(i, a + 2),
              u.readInt8(i, a + 3),
            ]),
            (a += 4),
            (l.fsSelection = u.readUshort(i, a)),
            (a += 2),
            (l.usFirstCharIndex = u.readUshort(i, a)),
            (a += 2),
            (l.usLastCharIndex = u.readUshort(i, a)),
            (a += 2),
            (l.sTypoAscender = u.readShort(i, a)),
            (a += 2),
            (l.sTypoDescender = u.readShort(i, a)),
            (a += 2),
            (l.sTypoLineGap = u.readShort(i, a)),
            (a += 2),
            (l.usWinAscent = u.readUshort(i, a)),
            (a += 2),
            (l.usWinDescent = u.readUshort(i, a)),
            (a += 2)
          );
        }),
        (e["OS/2"].version1 = function (i, a, l) {
          var u = e._bin;
          return (
            (a = e["OS/2"].version0(i, a, l)),
            (l.ulCodePageRange1 = u.readUint(i, a)),
            (a += 4),
            (l.ulCodePageRange2 = u.readUint(i, a)),
            (a += 4)
          );
        }),
        (e["OS/2"].version2 = function (i, a, l) {
          var u = e._bin;
          return (
            (a = e["OS/2"].version1(i, a, l)),
            (l.sxHeight = u.readShort(i, a)),
            (a += 2),
            (l.sCapHeight = u.readShort(i, a)),
            (a += 2),
            (l.usDefault = u.readUshort(i, a)),
            (a += 2),
            (l.usBreak = u.readUshort(i, a)),
            (a += 2),
            (l.usMaxContext = u.readUshort(i, a)),
            (a += 2)
          );
        }),
        (e["OS/2"].version5 = function (i, a, l) {
          var u = e._bin;
          return (
            (a = e["OS/2"].version2(i, a, l)),
            (l.usLowerOpticalPointSize = u.readUshort(i, a)),
            (a += 2),
            (l.usUpperOpticalPointSize = u.readUshort(i, a)),
            (a += 2)
          );
        }),
        (e.post = {}),
        (e.post.parse = function (i, a, l) {
          var u = e._bin,
            f = {};
          return (
            (f.version = u.readFixed(i, a)),
            (a += 4),
            (f.italicAngle = u.readFixed(i, a)),
            (a += 4),
            (f.underlinePosition = u.readShort(i, a)),
            (a += 2),
            (f.underlineThickness = u.readShort(i, a)),
            (a += 2),
            f
          );
        }),
        e == null && (e = {}),
        e.U == null && (e.U = {}),
        (e.U.codeToGlyph = function (i, a) {
          var l = i.cmap,
            u = -1;
          if (
            (l.p0e4 != null
              ? (u = l.p0e4)
              : l.p3e1 != null
              ? (u = l.p3e1)
              : l.p1e0 != null
              ? (u = l.p1e0)
              : l.p0e3 != null && (u = l.p0e3),
            u == -1)
          )
            throw "no familiar platform and encoding!";
          var f = l.tables[u];
          if (f.format == 0) return a >= f.map.length ? 0 : f.map[a];
          if (f.format == 4) {
            for (var d = -1, m = 0; m < f.endCount.length; m++)
              if (a <= f.endCount[m]) {
                d = m;
                break;
              }
            return d == -1 || f.startCount[d] > a
              ? 0
              : 65535 &
                  (f.idRangeOffset[d] != 0
                    ? f.glyphIdArray[
                        a -
                          f.startCount[d] +
                          (f.idRangeOffset[d] >> 1) -
                          (f.idRangeOffset.length - d)
                      ]
                    : a + f.idDelta[d]);
          }
          if (f.format == 12) {
            if (a > f.groups[f.groups.length - 1][1]) return 0;
            for (m = 0; m < f.groups.length; m++) {
              var v = f.groups[m];
              if (v[0] <= a && a <= v[1]) return v[2] + (a - v[0]);
            }
            return 0;
          }
          throw "unknown cmap table format " + f.format;
        }),
        (e.U.glyphToPath = function (i, a) {
          var l = { cmds: [], crds: [] };
          if (i.SVG && i.SVG.entries[a]) {
            var u = i.SVG.entries[a];
            return u == null
              ? l
              : (typeof u == "string" &&
                  ((u = e.SVG.toPath(u)), (i.SVG.entries[a] = u)),
                u);
          }
          if (i.CFF) {
            var f = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: !1,
                width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0,
                open: !1,
              },
              d = i.CFF,
              m = i.CFF.Private;
            if (d.ROS) {
              for (var v = 0; d.FDSelect[v + 2] <= a; ) v += 2;
              m = d.FDArray[d.FDSelect[v + 1]].Private;
            }
            e.U._drawCFF(i.CFF.CharStrings[a], f, d, m, l);
          } else i.glyf && e.U._drawGlyf(a, i, l);
          return l;
        }),
        (e.U._drawGlyf = function (i, a, l) {
          var u = a.glyf[i];
          u == null && (u = a.glyf[i] = e.glyf._parseGlyf(a, i)),
            u != null &&
              (u.noc > -1 ? e.U._simpleGlyph(u, l) : e.U._compoGlyph(u, a, l));
        }),
        (e.U._simpleGlyph = function (i, a) {
          for (var l = 0; l < i.noc; l++) {
            for (
              var u = l == 0 ? 0 : i.endPts[l - 1] + 1, f = i.endPts[l], d = u;
              d <= f;
              d++
            ) {
              var m = d == u ? f : d - 1,
                v = d == f ? u : d + 1,
                _ = 1 & i.flags[d],
                A = 1 & i.flags[m],
                M = 1 & i.flags[v],
                T = i.xs[d],
                E = i.ys[d];
              if (d == u)
                if (_) {
                  if (!A) {
                    e.U.P.moveTo(a, T, E);
                    continue;
                  }
                  e.U.P.moveTo(a, i.xs[m], i.ys[m]);
                } else
                  A
                    ? e.U.P.moveTo(a, i.xs[m], i.ys[m])
                    : e.U.P.moveTo(a, (i.xs[m] + T) / 2, (i.ys[m] + E) / 2);
              _
                ? A && e.U.P.lineTo(a, T, E)
                : M
                ? e.U.P.qcurveTo(a, T, E, i.xs[v], i.ys[v])
                : e.U.P.qcurveTo(a, T, E, (T + i.xs[v]) / 2, (E + i.ys[v]) / 2);
            }
            e.U.P.closePath(a);
          }
        }),
        (e.U._compoGlyph = function (i, a, l) {
          for (var u = 0; u < i.parts.length; u++) {
            var f = { cmds: [], crds: [] },
              d = i.parts[u];
            e.U._drawGlyf(d.glyphIndex, a, f);
            for (var m = d.m, v = 0; v < f.crds.length; v += 2) {
              var _ = f.crds[v],
                A = f.crds[v + 1];
              l.crds.push(_ * m.a + A * m.b + m.tx),
                l.crds.push(_ * m.c + A * m.d + m.ty);
            }
            for (v = 0; v < f.cmds.length; v++) l.cmds.push(f.cmds[v]);
          }
        }),
        (e.U._getGlyphClass = function (i, a) {
          var l = e._lctf.getInterval(a, i);
          return l == -1 ? 0 : a[l + 2];
        }),
        (e.U._applySubs = function (i, a, l, u) {
          for (var f = i.length - a - 1, d = 0; d < l.tabs.length; d++)
            if (l.tabs[d] != null) {
              var m,
                v = l.tabs[d];
              if (
                !v.coverage ||
                (m = e._lctf.coverageIndex(v.coverage, i[a])) != -1
              ) {
                if (l.ltype == 1)
                  i[a],
                    v.fmt == 1 ? (i[a] = i[a] + v.delta) : (i[a] = v.newg[m]);
                else if (l.ltype == 4)
                  for (var _ = v.vals[m], A = 0; A < _.length; A++) {
                    var M = _[A],
                      T = M.chain.length;
                    if (!(T > f)) {
                      for (var E = !0, b = 0, w = 0; w < T; w++) {
                        for (; i[a + b + (1 + w)] == -1; ) b++;
                        M.chain[w] != i[a + b + (1 + w)] && (E = !1);
                      }
                      if (E) {
                        for (i[a] = M.nglyph, w = 0; w < T + b; w++)
                          i[a + w + 1] = -1;
                        break;
                      }
                    }
                  }
                else if (l.ltype == 5 && v.fmt == 2)
                  for (
                    var D = e._lctf.getInterval(v.cDef, i[a]),
                      B = v.cDef[D + 2],
                      I = v.scset[B],
                      N = 0;
                    N < I.length;
                    N++
                  ) {
                    var P = I[N],
                      F = P.input;
                    if (!(F.length > f)) {
                      for (E = !0, w = 0; w < F.length; w++) {
                        var O = e._lctf.getInterval(v.cDef, i[a + 1 + w]);
                        if (D == -1 && v.cDef[O + 2] != F[w]) {
                          E = !1;
                          break;
                        }
                      }
                      if (E) {
                        var U = P.substLookupRecords;
                        for (A = 0; A < U.length; A += 2) U[A], U[A + 1];
                      }
                    }
                  }
                else if (l.ltype == 6 && v.fmt == 3) {
                  if (
                    !e.U._glsCovered(i, v.backCvg, a - v.backCvg.length) ||
                    !e.U._glsCovered(i, v.inptCvg, a) ||
                    !e.U._glsCovered(i, v.ahedCvg, a + v.inptCvg.length)
                  )
                    continue;
                  var W = v.lookupRec;
                  for (N = 0; N < W.length; N += 2) {
                    D = W[N];
                    var J = u[W[N + 1]];
                    e.U._applySubs(i, a + D, J, u);
                  }
                }
              }
            }
        }),
        (e.U._glsCovered = function (i, a, l) {
          for (var u = 0; u < a.length; u++)
            if (e._lctf.coverageIndex(a[u], i[l + u]) == -1) return !1;
          return !0;
        }),
        (e.U.glyphsToPath = function (i, a, l) {
          for (
            var u = { cmds: [], crds: [] }, f = 0, d = 0;
            d < a.length;
            d++
          ) {
            var m = a[d];
            if (m != -1) {
              for (
                var v = d < a.length - 1 && a[d + 1] != -1 ? a[d + 1] : 0,
                  _ = e.U.glyphToPath(i, m),
                  A = 0;
                A < _.crds.length;
                A += 2
              )
                u.crds.push(_.crds[A] + f), u.crds.push(_.crds[A + 1]);
              for (l && u.cmds.push(l), A = 0; A < _.cmds.length; A++)
                u.cmds.push(_.cmds[A]);
              l && u.cmds.push("X"),
                (f += i.hmtx.aWidth[m]),
                d < a.length - 1 && (f += e.U.getPairAdjustment(i, m, v));
            }
          }
          return u;
        }),
        (e.U.P = {}),
        (e.U.P.moveTo = function (i, a, l) {
          i.cmds.push("M"), i.crds.push(a, l);
        }),
        (e.U.P.lineTo = function (i, a, l) {
          i.cmds.push("L"), i.crds.push(a, l);
        }),
        (e.U.P.curveTo = function (i, a, l, u, f, d, m) {
          i.cmds.push("C"), i.crds.push(a, l, u, f, d, m);
        }),
        (e.U.P.qcurveTo = function (i, a, l, u, f) {
          i.cmds.push("Q"), i.crds.push(a, l, u, f);
        }),
        (e.U.P.closePath = function (i) {
          i.cmds.push("Z");
        }),
        (e.U._drawCFF = function (i, a, l, u, f) {
          for (
            var d = a.stack,
              m = a.nStems,
              v = a.haveWidth,
              _ = a.width,
              A = a.open,
              M = 0,
              T = a.x,
              E = a.y,
              b = 0,
              w = 0,
              D = 0,
              B = 0,
              I = 0,
              N = 0,
              P = 0,
              F = 0,
              O = 0,
              U = 0,
              W = { val: 0, size: 0 };
            M < i.length;

          ) {
            e.CFF.getCharString(i, M, W);
            var J = W.val;
            if (((M += W.size), J == "o1" || J == "o18"))
              d.length % 2 != 0 && !v && (_ = d.shift() + u.nominalWidthX),
                (m += d.length >> 1),
                (d.length = 0),
                (v = !0);
            else if (J == "o3" || J == "o23")
              d.length % 2 != 0 && !v && (_ = d.shift() + u.nominalWidthX),
                (m += d.length >> 1),
                (d.length = 0),
                (v = !0);
            else if (J == "o4")
              d.length > 1 &&
                !v &&
                ((_ = d.shift() + u.nominalWidthX), (v = !0)),
                A && e.U.P.closePath(f),
                (E += d.pop()),
                e.U.P.moveTo(f, T, E),
                (A = !0);
            else if (J == "o5")
              for (; d.length > 0; )
                (T += d.shift()), (E += d.shift()), e.U.P.lineTo(f, T, E);
            else if (J == "o6" || J == "o7")
              for (var q = d.length, Z = J == "o6", ue = 0; ue < q; ue++) {
                var K = d.shift();
                Z ? (T += K) : (E += K), (Z = !Z), e.U.P.lineTo(f, T, E);
              }
            else if (J == "o8" || J == "o24") {
              q = d.length;
              for (var ge = 0; ge + 6 <= q; )
                (b = T + d.shift()),
                  (w = E + d.shift()),
                  (D = b + d.shift()),
                  (B = w + d.shift()),
                  (T = D + d.shift()),
                  (E = B + d.shift()),
                  e.U.P.curveTo(f, b, w, D, B, T, E),
                  (ge += 6);
              J == "o24" &&
                ((T += d.shift()), (E += d.shift()), e.U.P.lineTo(f, T, E));
            } else {
              if (J == "o11") break;
              if (J == "o1234" || J == "o1235" || J == "o1236" || J == "o1237")
                J == "o1234" &&
                  ((w = E),
                  (D = (b = T + d.shift()) + d.shift()),
                  (U = B = w + d.shift()),
                  (N = B),
                  (F = E),
                  (T =
                    (P = (I = (O = D + d.shift()) + d.shift()) + d.shift()) +
                    d.shift()),
                  e.U.P.curveTo(f, b, w, D, B, O, U),
                  e.U.P.curveTo(f, I, N, P, F, T, E)),
                  J == "o1235" &&
                    ((b = T + d.shift()),
                    (w = E + d.shift()),
                    (D = b + d.shift()),
                    (B = w + d.shift()),
                    (O = D + d.shift()),
                    (U = B + d.shift()),
                    (I = O + d.shift()),
                    (N = U + d.shift()),
                    (P = I + d.shift()),
                    (F = N + d.shift()),
                    (T = P + d.shift()),
                    (E = F + d.shift()),
                    d.shift(),
                    e.U.P.curveTo(f, b, w, D, B, O, U),
                    e.U.P.curveTo(f, I, N, P, F, T, E)),
                  J == "o1236" &&
                    ((b = T + d.shift()),
                    (w = E + d.shift()),
                    (D = b + d.shift()),
                    (U = B = w + d.shift()),
                    (N = B),
                    (P = (I = (O = D + d.shift()) + d.shift()) + d.shift()),
                    (F = N + d.shift()),
                    (T = P + d.shift()),
                    e.U.P.curveTo(f, b, w, D, B, O, U),
                    e.U.P.curveTo(f, I, N, P, F, T, E)),
                  J == "o1237" &&
                    ((b = T + d.shift()),
                    (w = E + d.shift()),
                    (D = b + d.shift()),
                    (B = w + d.shift()),
                    (O = D + d.shift()),
                    (U = B + d.shift()),
                    (I = O + d.shift()),
                    (N = U + d.shift()),
                    (P = I + d.shift()),
                    (F = N + d.shift()),
                    Math.abs(P - T) > Math.abs(F - E)
                      ? (T = P + d.shift())
                      : (E = F + d.shift()),
                    e.U.P.curveTo(f, b, w, D, B, O, U),
                    e.U.P.curveTo(f, I, N, P, F, T, E));
              else if (J == "o14") {
                if (
                  (d.length > 0 &&
                    !v &&
                    ((_ = d.shift() + l.nominalWidthX), (v = !0)),
                  d.length == 4)
                ) {
                  var oe = d.shift(),
                    me = d.shift(),
                    V = d.shift(),
                    Y = d.shift(),
                    ae = e.CFF.glyphBySE(l, V),
                    fe = e.CFF.glyphBySE(l, Y);
                  e.U._drawCFF(l.CharStrings[ae], a, l, u, f),
                    (a.x = oe),
                    (a.y = me),
                    e.U._drawCFF(l.CharStrings[fe], a, l, u, f);
                }
                A && (e.U.P.closePath(f), (A = !1));
              } else if (J == "o19" || J == "o20")
                d.length % 2 != 0 && !v && (_ = d.shift() + u.nominalWidthX),
                  (m += d.length >> 1),
                  (d.length = 0),
                  (v = !0),
                  (M += (m + 7) >> 3);
              else if (J == "o21")
                d.length > 2 &&
                  !v &&
                  ((_ = d.shift() + u.nominalWidthX), (v = !0)),
                  (E += d.pop()),
                  (T += d.pop()),
                  A && e.U.P.closePath(f),
                  e.U.P.moveTo(f, T, E),
                  (A = !0);
              else if (J == "o22")
                d.length > 1 &&
                  !v &&
                  ((_ = d.shift() + u.nominalWidthX), (v = !0)),
                  (T += d.pop()),
                  A && e.U.P.closePath(f),
                  e.U.P.moveTo(f, T, E),
                  (A = !0);
              else if (J == "o25") {
                for (; d.length > 6; )
                  (T += d.shift()), (E += d.shift()), e.U.P.lineTo(f, T, E);
                (b = T + d.shift()),
                  (w = E + d.shift()),
                  (D = b + d.shift()),
                  (B = w + d.shift()),
                  (T = D + d.shift()),
                  (E = B + d.shift()),
                  e.U.P.curveTo(f, b, w, D, B, T, E);
              } else if (J == "o26")
                for (d.length % 2 && (T += d.shift()); d.length > 0; )
                  (b = T),
                    (w = E + d.shift()),
                    (T = D = b + d.shift()),
                    (E = (B = w + d.shift()) + d.shift()),
                    e.U.P.curveTo(f, b, w, D, B, T, E);
              else if (J == "o27")
                for (d.length % 2 && (E += d.shift()); d.length > 0; )
                  (w = E),
                    (D = (b = T + d.shift()) + d.shift()),
                    (B = w + d.shift()),
                    (T = D + d.shift()),
                    (E = B),
                    e.U.P.curveTo(f, b, w, D, B, T, E);
              else if (J == "o10" || J == "o29") {
                var j = J == "o10" ? u : l;
                if (d.length == 0) console.debug("error: empty stack");
                else {
                  var se = d.pop(),
                    ve = j.Subrs[se + j.Bias];
                  (a.x = T),
                    (a.y = E),
                    (a.nStems = m),
                    (a.haveWidth = v),
                    (a.width = _),
                    (a.open = A),
                    e.U._drawCFF(ve, a, l, u, f),
                    (T = a.x),
                    (E = a.y),
                    (m = a.nStems),
                    (v = a.haveWidth),
                    (_ = a.width),
                    (A = a.open);
                }
              } else if (J == "o30" || J == "o31") {
                var ye = d.length,
                  be = ((ge = 0), J == "o31");
                for (ge += ye - (q = -3 & ye); ge < q; )
                  be
                    ? ((w = E),
                      (D = (b = T + d.shift()) + d.shift()),
                      (E = (B = w + d.shift()) + d.shift()),
                      q - ge == 5 ? ((T = D + d.shift()), ge++) : (T = D),
                      (be = !1))
                    : ((b = T),
                      (w = E + d.shift()),
                      (D = b + d.shift()),
                      (B = w + d.shift()),
                      (T = D + d.shift()),
                      q - ge == 5 ? ((E = B + d.shift()), ge++) : (E = B),
                      (be = !0)),
                    e.U.P.curveTo(f, b, w, D, B, T, E),
                    (ge += 4);
              } else {
                if ((J + "").charAt(0) == "o")
                  throw (console.debug("Unknown operation: " + J, i), J);
                d.push(J);
              }
            }
          }
          (a.x = T),
            (a.y = E),
            (a.nStems = m),
            (a.haveWidth = v),
            (a.width = _),
            (a.open = A);
        });
      var t = e,
        n = { Typr: t };
      return (
        (s.Typr = t),
        (s.default = n),
        Object.defineProperty(s, "__esModule", { value: !0 }),
        s
      );
    })({}).Typr
  );
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/ function wF() {
  return (function (s) {
    var e = Uint8Array,
      t = Uint16Array,
      n = Uint32Array,
      i = new e([
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
        5, 5, 5, 5, 0, 0, 0, 0,
      ]),
      a = new e([
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
        10, 11, 11, 12, 12, 13, 13, 0, 0,
      ]),
      l = new e([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]),
      u = function (J, q) {
        for (var Z = new t(31), ue = 0; ue < 31; ++ue)
          Z[ue] = q += 1 << J[ue - 1];
        var K = new n(Z[30]);
        for (ue = 1; ue < 30; ++ue)
          for (var ge = Z[ue]; ge < Z[ue + 1]; ++ge)
            K[ge] = ((ge - Z[ue]) << 5) | ue;
        return [Z, K];
      },
      f = u(i, 2),
      d = f[0],
      m = f[1];
    (d[28] = 258), (m[258] = 28);
    for (var v = u(a, 0)[0], _ = new t(32768), A = 0; A < 32768; ++A) {
      var M = ((43690 & A) >>> 1) | ((21845 & A) << 1);
      (M =
        ((61680 & (M = ((52428 & M) >>> 2) | ((13107 & M) << 2))) >>> 4) |
        ((3855 & M) << 4)),
        (_[A] = (((65280 & M) >>> 8) | ((255 & M) << 8)) >>> 1);
    }
    var T = function (J, q, Z) {
        for (var ue = J.length, K = 0, ge = new t(q); K < ue; ++K)
          ++ge[J[K] - 1];
        var oe,
          me = new t(q);
        for (K = 0; K < q; ++K) me[K] = (me[K - 1] + ge[K - 1]) << 1;
        {
          oe = new t(1 << q);
          var V = 15 - q;
          for (K = 0; K < ue; ++K)
            if (J[K])
              for (
                var Y = (K << 4) | J[K],
                  ae = q - J[K],
                  fe = me[J[K] - 1]++ << ae,
                  j = fe | ((1 << ae) - 1);
                fe <= j;
                ++fe
              )
                oe[_[fe] >>> V] = Y;
        }
        return oe;
      },
      E = new e(288);
    for (A = 0; A < 144; ++A) E[A] = 8;
    for (A = 144; A < 256; ++A) E[A] = 9;
    for (A = 256; A < 280; ++A) E[A] = 7;
    for (A = 280; A < 288; ++A) E[A] = 8;
    var b = new e(32);
    for (A = 0; A < 32; ++A) b[A] = 5;
    var w = T(E, 9),
      D = T(b, 5),
      B = function (J) {
        for (var q = J[0], Z = 1; Z < J.length; ++Z) J[Z] > q && (q = J[Z]);
        return q;
      },
      I = function (J, q, Z) {
        var ue = (q / 8) | 0;
        return ((J[ue] | (J[ue + 1] << 8)) >> (7 & q)) & Z;
      },
      N = function (J, q) {
        var Z = (q / 8) | 0;
        return (J[Z] | (J[Z + 1] << 8) | (J[Z + 2] << 16)) >> (7 & q);
      },
      P = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data",
      ],
      F = function (J, q, Z) {
        var ue = new Error(q || P[J]);
        if (
          ((ue.code = J),
          Error.captureStackTrace && Error.captureStackTrace(ue, F),
          !Z)
        )
          throw ue;
        return ue;
      },
      O = function (J, q, Z) {
        var ue = J.length;
        if (!ue || (Z && !Z.l && ue < 5)) return q || new e(0);
        var K = !q || Z,
          ge = !Z || Z.i;
        Z || (Z = {}), q || (q = new e(3 * ue));
        var oe,
          me = function (Ze) {
            var le = q.length;
            if (Ze > le) {
              var Be = new e(Math.max(2 * le, Ze));
              Be.set(q), (q = Be);
            }
          },
          V = Z.f || 0,
          Y = Z.p || 0,
          ae = Z.b || 0,
          fe = Z.l,
          j = Z.d,
          se = Z.m,
          ve = Z.n,
          ye = 8 * ue;
        do {
          if (!fe) {
            Z.f = V = I(J, Y, 1);
            var be = I(J, Y + 1, 3);
            if (((Y += 3), !be)) {
              var it =
                  J[(Ve = (((oe = Y) / 8) | 0) + (7 & oe && 1) + 4) - 4] |
                  (J[Ve - 3] << 8),
                We = Ve + it;
              if (We > ue) {
                ge && F(0);
                break;
              }
              K && me(ae + it),
                q.set(J.subarray(Ve, We), ae),
                (Z.b = ae += it),
                (Z.p = Y = 8 * We);
              continue;
            }
            if (be == 1) (fe = w), (j = D), (se = 9), (ve = 5);
            else if (be == 2) {
              var $e = I(J, Y, 31) + 257,
                Me = I(J, Y + 10, 15) + 4,
                Ie = $e + I(J, Y + 5, 31) + 1;
              Y += 14;
              for (var $ = new e(Ie), ft = new e(19), Pe = 0; Pe < Me; ++Pe)
                ft[l[Pe]] = I(J, Y + 3 * Pe, 7);
              Y += 3 * Me;
              var rt = B(ft),
                Ue = (1 << rt) - 1,
                ht = T(ft, rt);
              for (Pe = 0; Pe < Ie; ) {
                var Ve,
                  X = ht[I(J, Y, Ue)];
                if (((Y += 15 & X), (Ve = X >>> 4) < 16)) $[Pe++] = Ve;
                else {
                  var k = 0,
                    de = 0;
                  for (
                    Ve == 16
                      ? ((de = 3 + I(J, Y, 3)), (Y += 2), (k = $[Pe - 1]))
                      : Ve == 17
                      ? ((de = 3 + I(J, Y, 7)), (Y += 3))
                      : Ve == 18 && ((de = 11 + I(J, Y, 127)), (Y += 7));
                    de--;

                  )
                    $[Pe++] = k;
                }
              }
              var Ee = $.subarray(0, $e),
                we = $.subarray($e);
              (se = B(Ee)), (ve = B(we)), (fe = T(Ee, se)), (j = T(we, ve));
            } else F(1);
            if (Y > ye) {
              ge && F(0);
              break;
            }
          }
          K && me(ae + 131072);
          for (var He = (1 << se) - 1, tt = (1 << ve) - 1, Ke = Y; ; Ke = Y) {
            var st = (k = fe[N(J, Y) & He]) >>> 4;
            if ((Y += 15 & k) > ye) {
              ge && F(0);
              break;
            }
            if ((k || F(2), st < 256)) q[ae++] = st;
            else {
              if (st == 256) {
                (Ke = Y), (fe = null);
                break;
              }
              var Ut = st - 254;
              if (st > 264) {
                var et = i[(Pe = st - 257)];
                (Ut = I(J, Y, (1 << et) - 1) + d[Pe]), (Y += et);
              }
              var At = j[N(J, Y) & tt],
                mt = At >>> 4;
              if (
                (At || F(3),
                (Y += 15 & At),
                (we = v[mt]),
                mt > 3 &&
                  ((et = a[mt]), (we += N(J, Y) & ((1 << et) - 1)), (Y += et)),
                Y > ye)
              ) {
                ge && F(0);
                break;
              }
              K && me(ae + 131072);
              for (var nt = ae + Ut; ae < nt; ae += 4)
                (q[ae] = q[ae - we]),
                  (q[ae + 1] = q[ae + 1 - we]),
                  (q[ae + 2] = q[ae + 2 - we]),
                  (q[ae + 3] = q[ae + 3 - we]);
              ae = nt;
            }
          }
          (Z.l = fe),
            (Z.p = Ke),
            (Z.b = ae),
            fe && ((V = 1), (Z.m = se), (Z.d = j), (Z.n = ve));
        } while (!V);
        return ae == q.length
          ? q
          : (function (Ze, le, Be) {
              (Be == null || Be > Ze.length) && (Be = Ze.length);
              var vt = new (Ze instanceof t ? t : Ze instanceof n ? n : e)(
                Be - le
              );
              return vt.set(Ze.subarray(le, Be)), vt;
            })(q, 0, ae);
      },
      U = new e(0),
      W = typeof TextDecoder < "u" && new TextDecoder();
    try {
      W.decode(U, { stream: !0 });
    } catch {}
    return (
      (s.convert_streams = function (J) {
        var q = new DataView(J),
          Z = 0;
        function ue() {
          var $e = q.getUint16(Z);
          return (Z += 2), $e;
        }
        function K() {
          var $e = q.getUint32(Z);
          return (Z += 4), $e;
        }
        function ge($e) {
          it.setUint16(We, $e), (We += 2);
        }
        function oe($e) {
          it.setUint32(We, $e), (We += 4);
        }
        for (
          var me = {
              signature: K(),
              flavor: K(),
              length: K(),
              numTables: ue(),
              reserved: ue(),
              totalSfntSize: K(),
              majorVersion: ue(),
              minorVersion: ue(),
              metaOffset: K(),
              metaLength: K(),
              metaOrigLength: K(),
              privOffset: K(),
              privLength: K(),
            },
            V = 0;
          Math.pow(2, V) <= me.numTables;

        )
          V++;
        V--;
        for (
          var Y = 16 * Math.pow(2, V),
            ae = 16 * me.numTables - Y,
            fe = 12,
            j = [],
            se = 0;
          se < me.numTables;
          se++
        )
          j.push({
            tag: K(),
            offset: K(),
            compLength: K(),
            origLength: K(),
            origChecksum: K(),
          }),
            (fe += 16);
        var ve,
          ye = new Uint8Array(
            12 +
              16 * j.length +
              j.reduce(function ($e, Me) {
                return $e + Me.origLength + 4;
              }, 0)
          ),
          be = ye.buffer,
          it = new DataView(be),
          We = 0;
        return (
          oe(me.flavor),
          ge(me.numTables),
          ge(Y),
          ge(V),
          ge(ae),
          j.forEach(function ($e) {
            oe($e.tag),
              oe($e.origChecksum),
              oe(fe),
              oe($e.origLength),
              ($e.outOffset = fe),
              (fe += $e.origLength) % 4 != 0 && (fe += 4 - (fe % 4));
          }),
          j.forEach(function ($e) {
            var Me,
              Ie = J.slice($e.offset, $e.offset + $e.compLength);
            if ($e.compLength != $e.origLength) {
              var $ = new Uint8Array($e.origLength);
              (Me = new Uint8Array(Ie, 2)), O(Me, $);
            } else $ = new Uint8Array(Ie);
            ye.set($, $e.outOffset);
            var ft = 0;
            (fe = $e.outOffset + $e.origLength) % 4 != 0 && (ft = 4 - (fe % 4)),
              ye.set(new Uint8Array(ft).buffer, $e.outOffset + $e.origLength),
              (ve = fe + ft);
          }),
          be.slice(0, ve)
        );
      }),
      Object.defineProperty(s, "__esModule", { value: !0 }),
      s
    );
  })({}).convert_streams;
}
function BF(s, e) {
  const t = { M: 2, L: 2, Q: 4, C: 6, Z: 0 },
    n = {
      C: "18g,ca,368,1kz",
      D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
      R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
      L: "x9u,jff,a,fd,jv",
      T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n",
    },
    i = 1,
    a = 2,
    l = 4,
    u = 8,
    f = 16,
    d = 32;
  let m;
  function v(P) {
    if (!m) {
      const F = { R: a, L: i, D: l, C: f, U: d, T: u };
      m = new Map();
      for (let O in n) {
        let U = 0;
        n[O].split(",").forEach((W) => {
          let [J, q] = W.split("+");
          (J = parseInt(J, 36)),
            (q = q ? parseInt(q, 36) : 0),
            m.set((U += J), F[O]);
          for (let Z = q; Z--; ) m.set(++U, F[O]);
        });
      }
    }
    return m.get(P) || d;
  }
  const _ = 1,
    A = 2,
    M = 3,
    T = 4,
    E = [null, "isol", "init", "fina", "medi"];
  function b(P) {
    const F = new Uint8Array(P.length);
    let O = d,
      U = _,
      W = -1;
    for (let J = 0; J < P.length; J++) {
      const q = P.codePointAt(J);
      let Z = v(q) | 0,
        ue = _;
      Z & u ||
        (O & (i | l | f)
          ? Z & (a | l | f)
            ? ((ue = M), (U === _ || U === M) && F[W]++)
            : Z & (i | d) && (U === A || U === T) && F[W]--
          : O & (a | d) && (U === A || U === T) && F[W]--,
        (U = F[J] = ue),
        (O = Z),
        (W = J),
        q > 65535 && J++);
    }
    return F;
  }
  function w(P, F) {
    const O = [];
    for (let W = 0; W < F.length; W++) {
      const J = F.codePointAt(W);
      J > 65535 && W++, O.push(s.U.codeToGlyph(P, J));
    }
    const U = P.GSUB;
    if (U) {
      const { lookupList: W, featureList: J } = U;
      let q;
      const Z = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/,
        ue = [];
      J.forEach((K) => {
        if (Z.test(K.tag))
          for (let ge = 0; ge < K.tab.length; ge++) {
            if (ue[K.tab[ge]]) continue;
            ue[K.tab[ge]] = !0;
            const oe = W[K.tab[ge]],
              me = /^(isol|init|fina|medi)$/.test(K.tag);
            me && !q && (q = b(F));
            for (let V = 0; V < O.length; V++)
              (!q || !me || E[q[V]] === K.tag) && s.U._applySubs(O, V, oe, W);
          }
      });
    }
    return O;
  }
  function D(P, F) {
    const O = new Int16Array(F.length * 3);
    let U = 0;
    for (; U < F.length; U++) {
      const Z = F[U];
      if (Z === -1) continue;
      O[U * 3 + 2] = P.hmtx.aWidth[Z];
      const ue = P.GPOS;
      if (ue) {
        const K = ue.lookupList;
        for (let ge = 0; ge < K.length; ge++) {
          const oe = K[ge];
          for (let me = 0; me < oe.tabs.length; me++) {
            const V = oe.tabs[me];
            if (oe.ltype === 1) {
              if (s._lctf.coverageIndex(V.coverage, Z) !== -1 && V.pos) {
                q(V.pos, U);
                break;
              }
            } else if (oe.ltype === 2) {
              let Y = null,
                ae = W();
              if (ae !== -1) {
                const fe = s._lctf.coverageIndex(V.coverage, F[ae]);
                if (fe !== -1) {
                  if (V.fmt === 1) {
                    const j = V.pairsets[fe];
                    for (let se = 0; se < j.length; se++)
                      j[se].gid2 === Z && (Y = j[se]);
                  } else if (V.fmt === 2) {
                    const j = s.U._getGlyphClass(F[ae], V.classDef1),
                      se = s.U._getGlyphClass(Z, V.classDef2);
                    Y = V.matrix[j][se];
                  }
                  if (Y) {
                    Y.val1 && q(Y.val1, ae), Y.val2 && q(Y.val2, U);
                    break;
                  }
                }
              }
            } else if (oe.ltype === 4) {
              const Y = s._lctf.coverageIndex(V.markCoverage, Z);
              if (Y !== -1) {
                const ae = W(J),
                  fe =
                    ae === -1
                      ? -1
                      : s._lctf.coverageIndex(V.baseCoverage, F[ae]);
                if (fe !== -1) {
                  const j = V.markArray[Y],
                    se = V.baseArray[fe][j.markClass];
                  (O[U * 3] = se.x - j.x + O[ae * 3] - O[ae * 3 + 2]),
                    (O[U * 3 + 1] = se.y - j.y + O[ae * 3 + 1]);
                  break;
                }
              }
            } else if (oe.ltype === 6) {
              const Y = s._lctf.coverageIndex(V.mark1Coverage, Z);
              if (Y !== -1) {
                const ae = W();
                if (ae !== -1) {
                  const fe = F[ae];
                  if (B(P, fe) === 3) {
                    const j = s._lctf.coverageIndex(V.mark2Coverage, fe);
                    if (j !== -1) {
                      const se = V.mark1Array[Y],
                        ve = V.mark2Array[j][se.markClass];
                      (O[U * 3] = ve.x - se.x + O[ae * 3] - O[ae * 3 + 2]),
                        (O[U * 3 + 1] = ve.y - se.y + O[ae * 3 + 1]);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (P.kern && !P.cff) {
        const K = W();
        if (K !== -1) {
          const ge = P.kern.glyph1.indexOf(F[K]);
          if (ge !== -1) {
            const oe = P.kern.rval[ge].glyph2.indexOf(Z);
            oe !== -1 && (O[K * 3 + 2] += P.kern.rval[ge].vals[oe]);
          }
        }
      }
    }
    return O;
    function W(Z) {
      for (let ue = U - 1; ue >= 0; ue--)
        if (F[ue] !== -1 && (!Z || Z(F[ue]))) return ue;
      return -1;
    }
    function J(Z) {
      return B(P, Z) === 1;
    }
    function q(Z, ue) {
      for (let K = 0; K < 3; K++) O[ue * 3 + K] += Z[K] || 0;
    }
  }
  function B(P, F) {
    const O = P.GDEF && P.GDEF.glyphClassDef;
    return O ? s.U._getGlyphClass(F, O) : 0;
  }
  function I(...P) {
    for (let F = 0; F < P.length; F++) if (typeof P[F] == "number") return P[F];
  }
  function N(P) {
    const F = Object.create(null),
      O = P["OS/2"],
      U = P.hhea,
      W = P.head.unitsPerEm,
      J = I(O && O.sTypoAscender, U && U.ascender, W),
      q = {
        unitsPerEm: W,
        ascender: J,
        descender: I(O && O.sTypoDescender, U && U.descender, 0),
        capHeight: I(O && O.sCapHeight, J),
        xHeight: I(O && O.sxHeight, J),
        lineGap: I(O && O.sTypoLineGap, U && U.lineGap),
        supportsCodePoint(Z) {
          return s.U.codeToGlyph(P, Z) > 0;
        },
        forEachGlyph(Z, ue, K, ge) {
          let oe = 0;
          const me = (1 / q.unitsPerEm) * ue,
            V = w(P, Z);
          let Y = 0;
          const ae = D(P, V);
          return (
            V.forEach((fe, j) => {
              if (fe !== -1) {
                let se = F[fe];
                if (!se) {
                  const { cmds: ve, crds: ye } = s.U.glyphToPath(P, fe);
                  let be = "",
                    it = 0;
                  for (let $ = 0, ft = ve.length; $ < ft; $++) {
                    const Pe = t[ve[$]];
                    be += ve[$];
                    for (let rt = 1; rt <= Pe; rt++)
                      be += (rt > 1 ? "," : "") + ye[it++];
                  }
                  let We, $e, Me, Ie;
                  if (ye.length) {
                    (We = $e = 1 / 0), (Me = Ie = -1 / 0);
                    for (let $ = 0, ft = ye.length; $ < ft; $ += 2) {
                      let Pe = ye[$],
                        rt = ye[$ + 1];
                      Pe < We && (We = Pe),
                        rt < $e && ($e = rt),
                        Pe > Me && (Me = Pe),
                        rt > Ie && (Ie = rt);
                    }
                  } else We = Me = $e = Ie = 0;
                  se = F[fe] = {
                    index: fe,
                    advanceWidth: P.hmtx.aWidth[fe],
                    xMin: We,
                    yMin: $e,
                    xMax: Me,
                    yMax: Ie,
                    path: be,
                  };
                }
                ge.call(null, se, oe + ae[j * 3] * me, ae[j * 3 + 1] * me, Y),
                  (oe += ae[j * 3 + 2] * me),
                  K && (oe += K * ue);
              }
              Y += Z.codePointAt(Y) > 65535 ? 2 : 1;
            }),
            oe
          );
        },
      };
    return q;
  }
  return function (F) {
    const O = new Uint8Array(F, 0, 4),
      U = s._bin.readASCII(O, 0, 4);
    if (U === "wOFF") F = e(F);
    else if (U === "wOF2") throw new Error("woff2 fonts not supported");
    return N(s.parse(F)[0]);
  };
}
const DF = Hd({
  name: "Typr Font Parser",
  dependencies: [RF, wF, BF],
  init(s, e, t) {
    const n = s(),
      i = e();
    return t(n, i);
  },
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/ function UF() {
  return (function (s) {
    var e = function () {
      this.buckets = new Map();
    };
    (e.prototype.add = function (D) {
      var B = D >> 5;
      this.buckets.set(B, (this.buckets.get(B) || 0) | (1 << (31 & D)));
    }),
      (e.prototype.has = function (D) {
        var B = this.buckets.get(D >> 5);
        return B !== void 0 && (B & (1 << (31 & D))) != 0;
      }),
      (e.prototype.serialize = function () {
        var D = [];
        return (
          this.buckets.forEach(function (B, I) {
            D.push((+I).toString(36) + ":" + B.toString(36));
          }),
          D.join(",")
        );
      }),
      (e.prototype.deserialize = function (D) {
        var B = this;
        this.buckets.clear(),
          D.split(",").forEach(function (I) {
            var N = I.split(":");
            B.buckets.set(parseInt(N[0], 36), parseInt(N[1], 36));
          });
      });
    var t = Math.pow(2, 8),
      n = t - 1,
      i = ~n;
    function a(D) {
      var B = (function (N) {
          return N & i;
        })(D).toString(16),
        I = (function (N) {
          return (N & i) + t - 1;
        })(D).toString(16);
      return "codepoint-index/plane" + (D >> 16) + "/" + B + "-" + I + ".json";
    }
    function l(D, B) {
      var I = D & n,
        N = B.codePointAt((I / 6) | 0);
      return ((N = (N || 48) - 48) & (1 << I % 6)) != 0;
    }
    function u(D, B) {
      var I;
      ((I = D),
      I.replace(/U\+/gi, "")
        .replace(/^,+|,+$/g, "")
        .split(/,+/)
        .map(function (N) {
          return N.split("-").map(function (P) {
            return parseInt(P.trim(), 16);
          });
        })).forEach(function (N) {
        var P = N[0],
          F = N[1];
        F === void 0 && (F = P), B(P, F);
      });
    }
    function f(D, B) {
      u(D, function (I, N) {
        for (var P = I; P <= N; P++) B(P);
      });
    }
    var d = {},
      m = {},
      v = new WeakMap(),
      _ =
        "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function A(D) {
      var B = v.get(D);
      return (
        B ||
          ((B = new e()),
          f(D.ranges, function (I) {
            return B.add(I);
          }),
          v.set(D, B)),
        B
      );
    }
    var M,
      T = new Map();
    function E(D, B, I) {
      return D[B]
        ? B
        : D[I]
        ? I
        : (function (N) {
            for (var P in N) return P;
          })(D);
    }
    function b(D, B) {
      var I = B;
      if (!D.includes(I)) {
        I = 1 / 0;
        for (var N = 0; N < D.length; N++)
          Math.abs(D[N] - B) < Math.abs(I - B) && (I = D[N]);
      }
      return I;
    }
    function w(D) {
      return (
        M ||
          ((M = new Set()),
          f("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function (B) {
            M.add(B);
          })),
        M.has(D)
      );
    }
    return (
      (s.CodePointSet = e),
      (s.clearCache = function () {
        (d = {}), (m = {});
      }),
      (s.getFontsForString = function (D, B) {
        B === void 0 && (B = {});
        var I,
          N = B.lang;
        N === void 0 &&
          (N = new RegExp("\\p{Script=Hangul}", "u").test((I = D))
            ? "ko"
            : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(
                I
              )
            ? "ja"
            : "en");
        var P = B.category;
        P === void 0 && (P = "sans-serif");
        var F = B.style;
        F === void 0 && (F = "normal");
        var O = B.weight;
        O === void 0 && (O = 400);
        var U = (B.dataUrl || _).replace(/\/$/g, ""),
          W = new Map(),
          J = new Uint8Array(D.length),
          q = {},
          Z = {},
          ue = new Array(D.length),
          K = new Map(),
          ge = !1;
        function oe(Y) {
          var ae = T.get(Y);
          return (
            ae ||
              ((ae = fetch(U + "/" + Y)
                .then(function (fe) {
                  if (!fe.ok) throw new Error(fe.statusText);
                  return fe.json().then(function (j) {
                    if (!Array.isArray(j) || j[0] !== 1)
                      throw new Error(
                        "Incorrect schema version; need 1, got " + j[0]
                      );
                    return j[1];
                  });
                })
                .catch(function (fe) {
                  if (U !== _)
                    return (
                      ge ||
                        (console.error(
                          'unicode-font-resolver: Failed loading from dataUrl "' +
                            U +
                            '", trying default CDN. ' +
                            fe.message
                        ),
                        (ge = !0)),
                      (U = _),
                      T.delete(Y),
                      oe(Y)
                    );
                  throw fe;
                })),
              T.set(Y, ae)),
            ae
          );
        }
        for (
          var me = function (Y) {
              var ae = D.codePointAt(Y),
                fe = a(ae);
              (ue[Y] = fe),
                d[fe] ||
                  K.has(fe) ||
                  K.set(
                    fe,
                    oe(fe).then(function (j) {
                      d[fe] = j;
                    })
                  ),
                ae > 65535 && (Y++, (V = Y));
            },
            V = 0;
          V < D.length;
          V++
        )
          me(V);
        return Promise.all(K.values())
          .then(function () {
            K.clear();
            for (
              var Y = function (fe) {
                  var j = D.codePointAt(fe),
                    se = null,
                    ve = d[ue[fe]],
                    ye = void 0;
                  for (var be in ve) {
                    var it = Z[be];
                    if (
                      (it === void 0 &&
                        (it = Z[be] = new RegExp(be).test(N || "en")),
                      it)
                    ) {
                      for (var We in ((ye = be), ve[be]))
                        if (l(j, ve[be][We])) {
                          se = We;
                          break;
                        }
                      break;
                    }
                  }
                  if (!se) {
                    e: for (var $e in ve)
                      if ($e !== ye) {
                        for (var Me in ve[$e])
                          if (l(j, ve[$e][Me])) {
                            se = Me;
                            break e;
                          }
                      }
                  }
                  se ||
                    (console.debug("No font coverage for U+" + j.toString(16)),
                    (se = "latin")),
                    (ue[fe] = se),
                    m[se] ||
                      K.has(se) ||
                      K.set(
                        se,
                        oe("font-meta/" + se + ".json").then(function (Ie) {
                          m[se] = Ie;
                        })
                      ),
                    j > 65535 && (fe++, (ae = fe));
                },
                ae = 0;
              ae < D.length;
              ae++
            )
              Y(ae);
            return Promise.all(K.values());
          })
          .then(function () {
            for (var Y, ae = null, fe = 0; fe < D.length; fe++) {
              var j = D.codePointAt(fe);
              if (ae && (w(j) || A(ae).has(j))) J[fe] = J[fe - 1];
              else {
                ae = m[ue[fe]];
                var se = q[ae.id];
                if (!se) {
                  var ve = ae.typeforms,
                    ye = E(ve, P, "sans-serif"),
                    be = E(ve[ye], F, "normal"),
                    it = b(
                      (Y = ve[ye]) === null || Y === void 0 ? void 0 : Y[be],
                      O
                    );
                  se = q[ae.id] =
                    U +
                    "/font-files/" +
                    ae.id +
                    "/" +
                    ye +
                    "." +
                    be +
                    "." +
                    it +
                    ".woff";
                }
                var We = W.get(se);
                We == null && ((We = W.size), W.set(se, We)), (J[fe] = We);
              }
              j > 65535 && (fe++, (J[fe] = J[fe - 1]));
            }
            return { fontUrls: Array.from(W.keys()), chars: J };
          });
      }),
      Object.defineProperty(s, "__esModule", { value: !0 }),
      s
    );
  })({});
}
function OF(s, e) {
  const t = Object.create(null),
    n = Object.create(null);
  function i(l, u) {
    const f = (d) => {
      console.error(`Failure loading font ${l}`, d);
    };
    try {
      const d = new XMLHttpRequest();
      d.open("get", l, !0),
        (d.responseType = "arraybuffer"),
        (d.onload = function () {
          if (d.status >= 400) f(new Error(d.statusText));
          else if (d.status > 0)
            try {
              const m = s(d.response);
              (m.src = l), u(m);
            } catch (m) {
              f(m);
            }
        }),
        (d.onerror = f),
        d.send();
    } catch (d) {
      f(d);
    }
  }
  function a(l, u) {
    let f = t[l];
    f
      ? u(f)
      : n[l]
      ? n[l].push(u)
      : ((n[l] = [u]),
        i(l, (d) => {
          (d.src = l), (t[l] = d), n[l].forEach((m) => m(d)), delete n[l];
        }));
  }
  return function (
    l,
    u,
    {
      lang: f,
      fonts: d = [],
      style: m = "normal",
      weight: v = "normal",
      unicodeFontsURL: _,
    } = {}
  ) {
    const A = new Uint8Array(l.length),
      M = [];
    l.length || w();
    const T = new Map(),
      E = [];
    if (
      (m !== "italic" && (m = "normal"),
      typeof v != "number" && (v = v === "bold" ? 700 : 400),
      d && !Array.isArray(d) && (d = [d]),
      (d = d
        .slice()
        .filter((B) => !B.lang || B.lang.test(f))
        .reverse()),
      d.length)
    ) {
      let P = 0;
      (function F(O = 0) {
        for (let U = O, W = l.length; U < W; U++) {
          const J = l.codePointAt(U);
          if (
            (P === 1 && M[A[U - 1]].supportsCodePoint(J)) ||
            (U > 0 && /\s/.test(l[U]))
          )
            (A[U] = A[U - 1]), P === 2 && (E[E.length - 1][1] = U);
          else
            for (let q = A[U], Z = d.length; q <= Z; q++)
              if (q === Z) {
                const ue = P === 2 ? E[E.length - 1] : (E[E.length] = [U, U]);
                (ue[1] = U), (P = 2);
              } else {
                A[U] = q;
                const { src: ue, unicodeRange: K } = d[q];
                if (!K || D(J, K)) {
                  const ge = t[ue];
                  if (!ge) {
                    a(ue, () => {
                      F(U);
                    });
                    return;
                  }
                  if (ge.supportsCodePoint(J)) {
                    let oe = T.get(ge);
                    typeof oe != "number" &&
                      ((oe = M.length), M.push(ge), T.set(ge, oe)),
                      (A[U] = oe),
                      (P = 1);
                    break;
                  }
                }
              }
          J > 65535 &&
            U + 1 < W &&
            ((A[U + 1] = A[U]), U++, P === 2 && (E[E.length - 1][1] = U));
        }
        b();
      })();
    } else E.push([0, l.length - 1]), b();
    function b() {
      if (E.length) {
        const B = E.map((I) => l.substring(I[0], I[1] + 1)).join(`
`);
        e.getFontsForString(B, {
          lang: f || void 0,
          style: m,
          weight: v,
          dataUrl: _,
        }).then(({ fontUrls: I, chars: N }) => {
          const P = M.length;
          let F = 0;
          E.forEach((U) => {
            for (let W = 0, J = U[1] - U[0]; W <= J; W++)
              A[U[0] + W] = N[F++] + P;
            F++;
          });
          let O = 0;
          I.forEach((U, W) => {
            a(U, (J) => {
              (M[W + P] = J), ++O === I.length && w();
            });
          });
        });
      } else w();
    }
    function w() {
      u({ chars: A, fonts: M });
    }
    function D(B, I) {
      for (let N = 0; N < I.length; N++) {
        const [P, F = P] = I[N];
        if (P <= B && B <= F) return !0;
      }
      return !1;
    }
  };
}
const LF = Hd({
  name: "FontResolver",
  dependencies: [OF, DF, UF],
  init(s, e, t) {
    return s(e, t());
  },
});
function NF(s, e) {
  const n =
      /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
    i = "[^\\S\\u00A0]",
    a = new RegExp(
      `${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`
    );
  function l(
    {
      text: M,
      lang: T,
      fonts: E,
      style: b,
      weight: w,
      preResolvedFonts: D,
      unicodeFontsURL: B,
    },
    I
  ) {
    const N = ({ chars: P, fonts: F }) => {
      let O, U;
      const W = [];
      for (let J = 0; J < P.length; J++)
        P[J] !== U
          ? ((U = P[J]), W.push((O = { start: J, end: J, fontObj: F[P[J]] })))
          : (O.end = J);
      I(W);
    };
    D
      ? N(D)
      : s(M, N, { lang: T, fonts: E, style: b, weight: w, unicodeFontsURL: B });
  }
  function u(
    {
      text: M = "",
      font: T,
      lang: E,
      sdfGlyphSize: b = 64,
      fontSize: w = 400,
      fontWeight: D = 1,
      fontStyle: B = "normal",
      letterSpacing: I = 0,
      lineHeight: N = "normal",
      maxWidth: P = 1 / 0,
      direction: F,
      textAlign: O = "left",
      textIndent: U = 0,
      whiteSpace: W = "normal",
      overflowWrap: J = "normal",
      anchorX: q = 0,
      anchorY: Z = 0,
      metricsOnly: ue = !1,
      unicodeFontsURL: K,
      preResolvedFonts: ge = null,
      includeCaretPositions: oe = !1,
      chunkedBoundsSize: me = 8192,
      colorRanges: V = null,
    },
    Y
  ) {
    const ae = v(),
      fe = { fontLoad: 0, typesetting: 0 };
    M.indexOf("\r") > -1 &&
      (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
      (M = M.replace(
        /\r\n/g,
        `
`
      ).replace(
        /\r/g,
        `
`
      ))),
      (w = +w),
      (I = +I),
      (P = +P),
      (N = N || "normal"),
      (U = +U),
      l(
        {
          text: M,
          lang: E,
          style: B,
          weight: D,
          fonts: typeof T == "string" ? [{ src: T }] : T,
          unicodeFontsURL: K,
          preResolvedFonts: ge,
        },
        (j) => {
          fe.fontLoad = v() - ae;
          const se = isFinite(P);
          let ve = null,
            ye = null,
            be = null,
            it = null,
            We = null,
            $e = null,
            Me = null,
            Ie = null,
            $ = 0,
            ft = 0,
            Pe = W !== "nowrap";
          const rt = new Map(),
            Ue = v();
          let ht = U,
            Ve = 0,
            X = new _();
          const k = [X];
          j.forEach((tt) => {
            const { fontObj: Ke } = tt,
              {
                ascender: st,
                descender: Ut,
                unitsPerEm: et,
                lineGap: At,
                capHeight: mt,
                xHeight: nt,
              } = Ke;
            let Ze = rt.get(Ke);
            if (!Ze) {
              const xe = w / et,
                Re = N === "normal" ? (st - Ut + At) * xe : N * w,
                Qe = (Re - (st - Ut) * xe) / 2,
                gt = Math.min(Re, (st - Ut) * xe),
                dt = ((st + Ut) / 2) * xe + gt / 2;
              (Ze = {
                index: rt.size,
                src: Ke.src,
                fontObj: Ke,
                fontSizeMult: xe,
                unitsPerEm: et,
                ascender: st * xe,
                descender: Ut * xe,
                capHeight: mt * xe,
                xHeight: nt * xe,
                lineHeight: Re,
                baseline: -Qe - st * xe,
                caretTop: dt,
                caretBottom: dt - gt,
              }),
                rt.set(Ke, Ze);
            }
            const { fontSizeMult: le } = Ze,
              Be = M.slice(tt.start, tt.end + 1);
            let vt, ce;
            Ke.forEachGlyph(Be, w, I, (xe, Re, Qe, gt) => {
              (Re += Ve), (gt += tt.start), (vt = Re), (ce = xe);
              const dt = M.charAt(gt),
                Ct = xe.advanceWidth * le,
                Ht = X.count;
              let Nt;
              if (
                ("isEmpty" in xe ||
                  ((xe.isWhitespace = !!dt && new RegExp(i).test(dt)),
                  (xe.canBreakAfter = !!dt && a.test(dt)),
                  (xe.isEmpty =
                    xe.xMin === xe.xMax || xe.yMin === xe.yMax || n.test(dt))),
                !xe.isWhitespace && !xe.isEmpty && ft++,
                Pe && se && !xe.isWhitespace && Re + Ct + ht > P && Ht)
              ) {
                if (X.glyphAt(Ht - 1).glyphObj.canBreakAfter)
                  (Nt = new _()), (ht = -Re);
                else
                  for (let gn = Ht; gn--; )
                    if (gn === 0 && J === "break-word") {
                      (Nt = new _()), (ht = -Re);
                      break;
                    } else if (X.glyphAt(gn).glyphObj.canBreakAfter) {
                      Nt = X.splitAt(gn + 1);
                      const vn = Nt.glyphAt(0).x;
                      ht -= vn;
                      for (let ai = Nt.count; ai--; ) Nt.glyphAt(ai).x -= vn;
                      break;
                    }
                Nt && ((X.isSoftWrapped = !0), (X = Nt), k.push(X), ($ = P));
              }
              let Ft = X.glyphAt(X.count);
              (Ft.glyphObj = xe),
                (Ft.x = Re + ht),
                (Ft.y = Qe),
                (Ft.width = Ct),
                (Ft.charIndex = gt),
                (Ft.fontData = Ze),
                dt ===
                  `
` && ((X = new _()), k.push(X), (ht = -(Re + Ct + I * w) + U));
            }),
              (Ve = vt + ce.advanceWidth * le + I * w);
          });
          let de = 0;
          k.forEach((tt) => {
            let Ke = !0;
            for (let st = tt.count; st--; ) {
              const Ut = tt.glyphAt(st);
              Ke &&
                !Ut.glyphObj.isWhitespace &&
                ((tt.width = Ut.x + Ut.width),
                tt.width > $ && ($ = tt.width),
                (Ke = !1));
              let {
                lineHeight: et,
                capHeight: At,
                xHeight: mt,
                baseline: nt,
              } = Ut.fontData;
              et > tt.lineHeight && (tt.lineHeight = et);
              const Ze = nt - tt.baseline;
              Ze < 0 && ((tt.baseline += Ze), (tt.cap += Ze), (tt.ex += Ze)),
                (tt.cap = Math.max(tt.cap, tt.baseline + At)),
                (tt.ex = Math.max(tt.ex, tt.baseline + mt));
            }
            (tt.baseline -= de),
              (tt.cap -= de),
              (tt.ex -= de),
              (de += tt.lineHeight);
          });
          let Ee = 0,
            we = 0;
          if (
            (q &&
              (typeof q == "number"
                ? (Ee = -q)
                : typeof q == "string" &&
                  (Ee =
                    -$ *
                    (q === "left"
                      ? 0
                      : q === "center"
                      ? 0.5
                      : q === "right"
                      ? 1
                      : d(q)))),
            Z &&
              (typeof Z == "number"
                ? (we = -Z)
                : typeof Z == "string" &&
                  (we =
                    Z === "top"
                      ? 0
                      : Z === "top-baseline"
                      ? -k[0].baseline
                      : Z === "top-cap"
                      ? -k[0].cap
                      : Z === "top-ex"
                      ? -k[0].ex
                      : Z === "middle"
                      ? de / 2
                      : Z === "bottom"
                      ? de
                      : Z === "bottom-baseline"
                      ? -k[k.length - 1].baseline
                      : d(Z) * de)),
            !ue)
          ) {
            const tt = e.getEmbeddingLevels(M, F);
            (ve = new Uint16Array(ft)),
              (ye = new Uint8Array(ft)),
              (be = new Float32Array(ft * 2)),
              (it = {}),
              (Me = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
              (Ie = []),
              oe && ($e = new Float32Array(M.length * 4)),
              V && (We = new Uint8Array(ft * 3));
            let Ke = 0,
              st = -1,
              Ut = -1,
              et,
              At;
            if (
              (k.forEach((mt, nt) => {
                let { count: Ze, width: le } = mt;
                if (Ze > 0) {
                  let Be = 0;
                  for (
                    let gt = Ze;
                    gt-- && mt.glyphAt(gt).glyphObj.isWhitespace;

                  )
                    Be++;
                  let vt = 0,
                    ce = 0;
                  if (O === "center") vt = ($ - le) / 2;
                  else if (O === "right") vt = $ - le;
                  else if (O === "justify" && mt.isSoftWrapped) {
                    let gt = 0;
                    for (let dt = Ze - Be; dt--; )
                      mt.glyphAt(dt).glyphObj.isWhitespace && gt++;
                    ce = ($ - le) / gt;
                  }
                  if (ce || vt) {
                    let gt = 0;
                    for (let dt = 0; dt < Ze; dt++) {
                      let Ct = mt.glyphAt(dt);
                      const Ht = Ct.glyphObj;
                      (Ct.x += vt + gt),
                        ce !== 0 &&
                          Ht.isWhitespace &&
                          dt < Ze - Be &&
                          ((gt += ce), (Ct.width += ce));
                    }
                  }
                  const xe = e.getReorderSegments(
                    M,
                    tt,
                    mt.glyphAt(0).charIndex,
                    mt.glyphAt(mt.count - 1).charIndex
                  );
                  for (let gt = 0; gt < xe.length; gt++) {
                    const [dt, Ct] = xe[gt];
                    let Ht = 1 / 0,
                      Nt = -1 / 0;
                    for (let Ft = 0; Ft < Ze; Ft++)
                      if (mt.glyphAt(Ft).charIndex >= dt) {
                        let gn = Ft,
                          vn = Ft;
                        for (; vn < Ze; vn++) {
                          let ai = mt.glyphAt(vn);
                          if (ai.charIndex > Ct) break;
                          vn < Ze - Be &&
                            ((Ht = Math.min(Ht, ai.x)),
                            (Nt = Math.max(Nt, ai.x + ai.width)));
                        }
                        for (let ai = gn; ai < vn; ai++) {
                          const Bi = mt.glyphAt(ai);
                          Bi.x = Nt - (Bi.x + Bi.width - Ht);
                        }
                        break;
                      }
                  }
                  let Re;
                  const Qe = (gt) => (Re = gt);
                  for (let gt = 0; gt < Ze; gt++) {
                    const dt = mt.glyphAt(gt);
                    Re = dt.glyphObj;
                    const Ct = Re.index,
                      Ht = tt.levels[dt.charIndex] & 1;
                    if (Ht) {
                      const Nt = e.getMirroredCharacter(M[dt.charIndex]);
                      Nt && dt.fontData.fontObj.forEachGlyph(Nt, 0, 0, Qe);
                    }
                    if (oe) {
                      const { charIndex: Nt, fontData: Ft } = dt,
                        gn = dt.x + Ee,
                        vn = dt.x + dt.width + Ee;
                      ($e[Nt * 4] = Ht ? vn : gn),
                        ($e[Nt * 4 + 1] = Ht ? gn : vn),
                        ($e[Nt * 4 + 2] = mt.baseline + Ft.caretBottom + we),
                        ($e[Nt * 4 + 3] = mt.baseline + Ft.caretTop + we);
                      const ai = Nt - st;
                      ai > 1 && m($e, st, ai), (st = Nt);
                    }
                    if (V) {
                      const { charIndex: Nt } = dt;
                      for (; Nt > Ut; )
                        Ut++, V.hasOwnProperty(Ut) && (At = V[Ut]);
                    }
                    if (!Re.isWhitespace && !Re.isEmpty) {
                      const Nt = Ke++,
                        { fontSizeMult: Ft, src: gn, index: vn } = dt.fontData,
                        ai = it[gn] || (it[gn] = {});
                      ai[Ct] ||
                        (ai[Ct] = {
                          path: Re.path,
                          pathBounds: [Re.xMin, Re.yMin, Re.xMax, Re.yMax],
                        });
                      const Bi = dt.x + Ee,
                        ui = dt.y + mt.baseline + we;
                      (be[Nt * 2] = Bi), (be[Nt * 2 + 1] = ui);
                      const di = Bi + Re.xMin * Ft,
                        Di = ui + Re.yMin * Ft,
                        pi = Bi + Re.xMax * Ft,
                        zt = ui + Re.yMax * Ft;
                      di < Me[0] && (Me[0] = di),
                        Di < Me[1] && (Me[1] = Di),
                        pi > Me[2] && (Me[2] = pi),
                        zt > Me[3] && (Me[3] = zt),
                        Nt % me === 0 &&
                          ((et = {
                            start: Nt,
                            end: Nt,
                            rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                          }),
                          Ie.push(et)),
                        et.end++;
                      const pn = et.rect;
                      if (
                        (di < pn[0] && (pn[0] = di),
                        Di < pn[1] && (pn[1] = Di),
                        pi > pn[2] && (pn[2] = pi),
                        zt > pn[3] && (pn[3] = zt),
                        (ve[Nt] = Ct),
                        (ye[Nt] = vn),
                        V)
                      ) {
                        const en = Nt * 3;
                        (We[en] = (At >> 16) & 255),
                          (We[en + 1] = (At >> 8) & 255),
                          (We[en + 2] = At & 255);
                      }
                    }
                  }
                }
              }),
              $e)
            ) {
              const mt = M.length - st;
              mt > 1 && m($e, st, mt);
            }
          }
          const He = [];
          rt.forEach(
            ({
              index: tt,
              src: Ke,
              unitsPerEm: st,
              ascender: Ut,
              descender: et,
              lineHeight: At,
              capHeight: mt,
              xHeight: nt,
            }) => {
              He[tt] = {
                src: Ke,
                unitsPerEm: st,
                ascender: Ut,
                descender: et,
                lineHeight: At,
                capHeight: mt,
                xHeight: nt,
              };
            }
          ),
            (fe.typesetting = v() - Ue),
            Y({
              glyphIds: ve,
              glyphFontIndices: ye,
              glyphPositions: be,
              glyphData: it,
              fontData: He,
              caretPositions: $e,
              glyphColors: We,
              chunkedBounds: Ie,
              fontSize: w,
              topBaseline: we + k[0].baseline,
              blockBounds: [Ee, we - de, Ee + $, we],
              visibleBounds: Me,
              timings: fe,
            });
        }
      );
  }
  function f(M, T) {
    u({ ...M, metricsOnly: !0 }, (E) => {
      const [b, w, D, B] = E.blockBounds;
      T({ width: D - b, height: B - w });
    });
  }
  function d(M) {
    let T = M.match(/^([\d.]+)%$/),
      E = T ? parseFloat(T[1]) : NaN;
    return isNaN(E) ? 0 : E / 100;
  }
  function m(M, T, E) {
    const b = M[T * 4],
      w = M[T * 4 + 1],
      D = M[T * 4 + 2],
      B = M[T * 4 + 3],
      I = (w - b) / E;
    for (let N = 0; N < E; N++) {
      const P = (T + N) * 4;
      (M[P] = b + I * N),
        (M[P + 1] = b + I * (N + 1)),
        (M[P + 2] = D),
        (M[P + 3] = B);
    }
  }
  function v() {
    return (self.performance || Date).now();
  }
  function _() {
    this.data = [];
  }
  const A = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return (
    (_.prototype = {
      width: 0,
      lineHeight: 0,
      baseline: 0,
      cap: 0,
      ex: 0,
      isSoftWrapped: !1,
      get count() {
        return Math.ceil(this.data.length / A.length);
      },
      glyphAt(M) {
        let T = _.flyweight;
        return (T.data = this.data), (T.index = M), T;
      },
      splitAt(M) {
        let T = new _();
        return (T.data = this.data.splice(M * A.length)), T;
      },
    }),
    (_.flyweight = A.reduce(
      (M, T, E, b) => (
        Object.defineProperty(M, T, {
          get() {
            return this.data[this.index * A.length + E];
          },
          set(w) {
            this.data[this.index * A.length + E] = w;
          },
        }),
        M
      ),
      { data: null, index: 0 }
    )),
    { typeset: u, measure: f }
  );
}
const Xf = () => (self.performance || Date).now(),
  u_ = D2();
let Zb;
function IF(s, e, t, n, i, a, l, u, f, d, m = !0) {
  return m
    ? PF(s, e, t, n, i, a, l, u, f, d).then(
        null,
        (v) => (
          Zb ||
            (console.warn("WebGL SDF generation failed, falling back to JS", v),
            (Zb = !0)),
          $b(s, e, t, n, i, a, l, u, f, d)
        )
      )
    : $b(s, e, t, n, i, a, l, u, f, d);
}
const B0 = [],
  FF = 5;
let zA = 0;
function O2() {
  const s = Xf();
  for (; B0.length && Xf() - s < FF; ) B0.shift()();
  zA = B0.length ? setTimeout(O2, 0) : 0;
}
const PF = (...s) =>
    new Promise((e, t) => {
      B0.push(() => {
        const n = Xf();
        try {
          u_.webgl.generateIntoCanvas(...s), e({ timing: Xf() - n });
        } catch (i) {
          t(i);
        }
      }),
        zA || (zA = setTimeout(O2, 0));
    }),
  GF = 4,
  zF = 2e3,
  Qb = {};
let HF = 0;
function $b(s, e, t, n, i, a, l, u, f, d) {
  const m = "TroikaTextSDFGenerator_JS_" + (HF++ % GF);
  let v = Qb[m];
  return (
    v ||
      (v = Qb[m] =
        {
          workerModule: Hd({
            name: m,
            workerId: m,
            dependencies: [D2, Xf],
            init(_, A) {
              const M = _().javascript.generate;
              return function (...T) {
                const E = A();
                return { textureData: M(...T), timing: A() - E };
              };
            },
            getTransferables(_) {
              return [_.textureData.buffer];
            },
          }),
          requests: 0,
          idleTimer: null,
        }),
    v.requests++,
    clearTimeout(v.idleTimer),
    v.workerModule(s, e, t, n, i, a).then(({ textureData: _, timing: A }) => {
      const M = Xf(),
        T = new Uint8Array(_.length * 4);
      for (let E = 0; E < _.length; E++) T[E * 4 + d] = _[E];
      return (
        u_.webglUtils.renderImageData(l, T, u, f, s, e, 1 << (3 - d)),
        (A += Xf() - M),
        --v.requests === 0 &&
          (v.idleTimer = setTimeout(() => {
            yF(m);
          }, zF)),
        { timing: A }
      );
    })
  );
}
function VF(s) {
  s._warm || (u_.webgl.isSupported(s), (s._warm = !0));
}
const kF = u_.webglUtils.resizeWebGLCanvasWithoutClearing,
  mm = {
    unicodeFontsURL: null,
    sdfGlyphSize: 64,
    sdfMargin: 1 / 16,
    sdfExponent: 9,
    textureWidth: 2048,
  },
  XF = new Dt();
function hd() {
  return (self.performance || Date).now();
}
const eE = Object.create(null);
function L2(s, e) {
  s = JF({}, s);
  const t = hd(),
    n = [];
  if (
    (s.font && n.push({ label: "user", src: qF(s.font) }),
    (s.font = n),
    (s.text = "" + s.text),
    (s.sdfGlyphSize = s.sdfGlyphSize || mm.sdfGlyphSize),
    (s.unicodeFontsURL = s.unicodeFontsURL || mm.unicodeFontsURL),
    s.colorRanges != null)
  ) {
    let _ = {};
    for (let A in s.colorRanges)
      if (s.colorRanges.hasOwnProperty(A)) {
        let M = s.colorRanges[A];
        typeof M != "number" && (M = XF.set(M).getHex()), (_[A] = M);
      }
    s.colorRanges = _;
  }
  Object.freeze(s);
  const { textureWidth: i, sdfExponent: a } = mm,
    { sdfGlyphSize: l } = s,
    u = (i / l) * 4;
  let f = eE[l];
  if (!f) {
    const _ = document.createElement("canvas");
    (_.width = i),
      (_.height = (l * 256) / u),
      (f = eE[l] =
        {
          glyphCount: 0,
          sdfGlyphSize: l,
          sdfCanvas: _,
          sdfTexture: new Wn(_, void 0, void 0, void 0, In, In),
          contextLost: !1,
          glyphsByFont: new Map(),
        }),
      (f.sdfTexture.generateMipmaps = !1),
      YF(f);
  }
  const { sdfTexture: d, sdfCanvas: m } = f;
  F2(s).then((_) => {
    const {
        glyphIds: A,
        glyphFontIndices: M,
        fontData: T,
        glyphPositions: E,
        fontSize: b,
        timings: w,
      } = _,
      D = [],
      B = new Float32Array(A.length * 4);
    let I = 0,
      N = 0;
    const P = hd(),
      F = T.map((q) => {
        let Z = f.glyphsByFont.get(q.src);
        return Z || f.glyphsByFont.set(q.src, (Z = new Map())), Z;
      });
    A.forEach((q, Z) => {
      const ue = M[Z],
        { src: K, unitsPerEm: ge } = T[ue];
      let oe = F[ue].get(q);
      if (!oe) {
        const { path: fe, pathBounds: j } = _.glyphData[K][q],
          se =
            (Math.max(j[2] - j[0], j[3] - j[1]) / l) * (mm.sdfMargin * l + 0.5),
          ve = f.glyphCount++,
          ye = [j[0] - se, j[1] - se, j[2] + se, j[3] + se];
        F[ue].set(q, (oe = { path: fe, atlasIndex: ve, sdfViewBox: ye })),
          D.push(oe);
      }
      const { sdfViewBox: me } = oe,
        V = E[N++],
        Y = E[N++],
        ae = b / ge;
      (B[I++] = V + me[0] * ae),
        (B[I++] = Y + me[1] * ae),
        (B[I++] = V + me[2] * ae),
        (B[I++] = Y + me[3] * ae),
        (A[Z] = oe.atlasIndex);
    }),
      (w.quads = (w.quads || 0) + (hd() - P));
    const O = hd();
    w.sdf = {};
    const U = m.height,
      W = Math.ceil(f.glyphCount / u),
      J = Math.pow(2, Math.ceil(Math.log2(W * l)));
    J > U &&
      (console.info(`Increasing SDF texture size ${U}->${J}`),
      kF(m, i, J),
      d.dispose()),
      Promise.all(
        D.map((q) =>
          N2(q, f, s.gpuAccelerateSDF).then(({ timing: Z }) => {
            w.sdf[q.atlasIndex] = Z;
          })
        )
      ).then(() => {
        D.length && !f.contextLost && (I2(f), (d.needsUpdate = !0)),
          (w.sdfTotal = hd() - O),
          (w.total = hd() - t),
          e(
            Object.freeze({
              parameters: s,
              sdfTexture: d,
              sdfGlyphSize: l,
              sdfExponent: a,
              glyphBounds: B,
              glyphAtlasIndices: A,
              glyphColors: _.glyphColors,
              caretPositions: _.caretPositions,
              chunkedBounds: _.chunkedBounds,
              ascender: _.ascender,
              descender: _.descender,
              lineHeight: _.lineHeight,
              capHeight: _.capHeight,
              xHeight: _.xHeight,
              topBaseline: _.topBaseline,
              blockBounds: _.blockBounds,
              visibleBounds: _.visibleBounds,
              timings: _.timings,
            })
          );
      });
  }),
    Promise.resolve().then(() => {
      f.contextLost || VF(m);
    });
}
function N2(
  { path: s, atlasIndex: e, sdfViewBox: t },
  { sdfGlyphSize: n, sdfCanvas: i, contextLost: a },
  l
) {
  if (a) return Promise.resolve({ timing: -1 });
  const { textureWidth: u, sdfExponent: f } = mm,
    d = Math.max(t[2] - t[0], t[3] - t[1]),
    m = Math.floor(e / 4),
    v = (m % (u / n)) * n,
    _ = Math.floor(m / (u / n)) * n,
    A = e % 4;
  return IF(n, n, s, t, d, f, i, v, _, A, l);
}
function YF(s) {
  const e = s.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), (s.contextLost = !0);
  }),
    e.addEventListener("webglcontextrestored", (t) => {
      console.log("Context Restored", t), (s.contextLost = !1);
      const n = [];
      s.glyphsByFont.forEach((i) => {
        i.forEach((a) => {
          n.push(N2(a, s, !0));
        });
      }),
        Promise.all(n).then(() => {
          I2(s), (s.sdfTexture.needsUpdate = !0);
        });
    });
}
function WF({ font: s, characters: e, sdfGlyphSize: t }, n) {
  let i = Array.isArray(e)
    ? e.join(`
`)
    : "" + e;
  L2({ font: s, sdfGlyphSize: t, text: i }, n);
}
function JF(s, e) {
  for (let t in e) e.hasOwnProperty(t) && (s[t] = e[t]);
  return s;
}
let A0;
function qF(s) {
  return (
    A0 || (A0 = typeof document > "u" ? {} : document.createElement("a")),
    (A0.href = s),
    A0.href
  );
}
function I2(s) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = s,
      { width: n, height: i } = e,
      a = s.sdfCanvas.getContext("webgl");
    let l = t.image.data;
    (!l || l.length !== n * i * 4) &&
      ((l = new Uint8Array(n * i * 4)),
      (t.image = { width: n, height: i, data: l }),
      (t.flipY = !1),
      (t.isDataTexture = !0)),
      a.readPixels(0, 0, n, i, a.RGBA, a.UNSIGNED_BYTE, l);
  }
}
const jF = Hd({
    name: "Typesetter",
    dependencies: [NF, LF, AF],
    init(s, e, t) {
      return s(e, t());
    },
  }),
  F2 = Hd({
    name: "Typesetter",
    dependencies: [jF],
    init(s) {
      return function (e) {
        return new Promise((t) => {
          s.typeset(e, t);
        });
      };
    },
    getTransferables(s) {
      const e = [];
      for (let t in s) s[t] && s[t].buffer && e.push(s[t].buffer);
      return e;
    },
  });
F2.onMainThread;
const tE = {};
function KF(s) {
  let e = tE[s];
  return e || (e = tE[s] = new zs(1, 1, s, s).translate(0.5, 0.5, 0)), e;
}
const ZF = "aTroikaGlyphBounds",
  nE = "aTroikaGlyphIndex",
  QF = "aTroikaGlyphColor";
class $F extends bx {
  constructor() {
    super(),
      (this.detail = 1),
      (this.curveRadius = 0),
      (this.groups = [
        { start: 0, count: 1 / 0, materialIndex: 0 },
        { start: 0, count: 1 / 0, materialIndex: 1 },
      ]),
      (this.boundingSphere = new Na()),
      (this.boundingBox = new ya());
  }
  computeBoundingSphere() {}
  computeBoundingBox() {}
  set detail(e) {
    if (e !== this._detail) {
      (this._detail = e), (typeof e != "number" || e < 1) && (e = 1);
      let t = KF(e);
      ["position", "normal", "uv"].forEach((n) => {
        this.attributes[n] = t.attributes[n].clone();
      }),
        this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && ((this._curveRadius = e), this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(e, t, n, i, a) {
    this.updateAttributeData(ZF, e, 4),
      this.updateAttributeData(nE, t, 1),
      this.updateAttributeData(QF, a, 3),
      (this._blockBounds = n),
      (this._chunkedBounds = i),
      (this.instanceCount = t.length),
      this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: n } = this;
      if (t) {
        const { PI: i, floor: a, min: l, max: u, sin: f, cos: d } = Math,
          m = i / 2,
          v = i * 2,
          _ = Math.abs(t),
          A = e[0] / _,
          M = e[2] / _,
          T = a((A + m) / v) !== a((M + m) / v) ? -_ : l(f(A) * _, f(M) * _),
          E = a((A - m) / v) !== a((M - m) / v) ? _ : u(f(A) * _, f(M) * _),
          b =
            a((A + i) / v) !== a((M + i) / v)
              ? _ * 2
              : u(_ - d(A) * _, _ - d(M) * _);
        n.min.set(T, e[1], t < 0 ? -b : 0), n.max.set(E, e[3], t < 0 ? 0 : b);
      } else n.min.set(e[0], e[1], 0), n.max.set(e[2], e[3], 0);
      n.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(e) {
    let t = this.getAttribute(nE).count,
      n = this._chunkedBounds;
    if (n)
      for (let i = n.length; i--; ) {
        t = n[i].end;
        let a = n[i].rect;
        if (a[1] < e.w && a[3] > e.y && a[0] < e.z && a[2] > e.x) break;
      }
    this.instanceCount = t;
  }
  updateAttributeData(e, t, n) {
    const i = this.getAttribute(e);
    t
      ? i && i.array.length === t.length
        ? (i.array.set(t), (i.needsUpdate = !0))
        : (this.setAttribute(e, new bc(t, n)),
          delete this._maxInstanceCount,
          this.dispose())
      : i && this.deleteAttribute(e);
  }
}
const e4 = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
  t4 = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
  n4 = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
  i4 = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function a4(s) {
  const e = GA(s, {
    chained: !0,
    extensions: { derivatives: !0 },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new at() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Hn(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Hn(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new at() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Dt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new hn() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 },
    },
    vertexDefs: e4,
    vertexTransform: t4,
    fragmentDefs: n4,
    fragmentColorTransform: i4,
    customRewriter({ vertexShader: t, fragmentShader: n }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return (
        i.test(n) &&
          ((n = n
            .replace(i, "varying vec3 vTroikaGlyphColor")
            .replace(/\bdiffuse\b/g, "vTroikaGlyphColor")),
          i.test(t) ||
            (t = t.replace(
              U2,
              `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
            ))),
        { vertexShader: t, fragmentShader: n }
      );
    },
  });
  return (
    (e.transparent = !0),
    (e.forceSinglePass = !0),
    Object.defineProperties(e, {
      isTroikaTextMaterial: { value: !0 },
      shadowSide: {
        get() {
          return this.side;
        },
        set() {},
      },
    }),
    e
  );
}
const Vx = new fr({ color: 16777215, side: jr, transparent: !0 }),
  iE = 8421504,
  aE = new Qt(),
  x0 = new ie(),
  oA = new ie(),
  fm = [],
  r4 = new ie(),
  lA = "+x+y";
function rE(s) {
  return Array.isArray(s) ? s[0] : s;
}
let P2 = () => {
    const s = new li(new zs(1, 1), Vx);
    return (P2 = () => s), s;
  },
  G2 = () => {
    const s = new li(new zs(1, 1, 32, 1), Vx);
    return (G2 = () => s), s;
  };
const s4 = { type: "syncstart" },
  o4 = { type: "synccomplete" },
  z2 = [
    "font",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lang",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize",
  ],
  l4 = z2.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
let H2 = class extends li {
  constructor() {
    const e = new $F();
    super(e, null),
      (this.text = ""),
      (this.anchorX = 0),
      (this.anchorY = 0),
      (this.curveRadius = 0),
      (this.direction = "auto"),
      (this.font = null),
      (this.unicodeFontsURL = null),
      (this.fontSize = 0.1),
      (this.fontWeight = "normal"),
      (this.fontStyle = "normal"),
      (this.lang = null),
      (this.letterSpacing = 0),
      (this.lineHeight = "normal"),
      (this.maxWidth = 1 / 0),
      (this.overflowWrap = "normal"),
      (this.textAlign = "left"),
      (this.textIndent = 0),
      (this.whiteSpace = "normal"),
      (this.material = null),
      (this.color = null),
      (this.colorRanges = null),
      (this.outlineWidth = 0),
      (this.outlineColor = 0),
      (this.outlineOpacity = 1),
      (this.outlineBlur = 0),
      (this.outlineOffsetX = 0),
      (this.outlineOffsetY = 0),
      (this.strokeWidth = 0),
      (this.strokeColor = iE),
      (this.strokeOpacity = 1),
      (this.fillOpacity = 1),
      (this.depthOffset = 0),
      (this.clipRect = null),
      (this.orientation = lA),
      (this.glyphGeometryDetail = 1),
      (this.sdfGlyphSize = null),
      (this.gpuAccelerateSDF = !0),
      (this.debugSDF = !1);
  }
  sync(e) {
    this._needsSync &&
      ((this._needsSync = !1),
      this._isSyncing
        ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e)
        : ((this._isSyncing = !0),
          this.dispatchEvent(s4),
          L2(
            {
              text: this.text,
              font: this.font,
              lang: this.lang,
              fontSize: this.fontSize || 0.1,
              fontWeight: this.fontWeight || "normal",
              fontStyle: this.fontStyle || "normal",
              letterSpacing: this.letterSpacing || 0,
              lineHeight: this.lineHeight || "normal",
              maxWidth: this.maxWidth,
              direction: this.direction || "auto",
              textAlign: this.textAlign,
              textIndent: this.textIndent,
              whiteSpace: this.whiteSpace,
              overflowWrap: this.overflowWrap,
              anchorX: this.anchorX,
              anchorY: this.anchorY,
              colorRanges: this.colorRanges,
              includeCaretPositions: !0,
              sdfGlyphSize: this.sdfGlyphSize,
              gpuAccelerateSDF: this.gpuAccelerateSDF,
              unicodeFontsURL: this.unicodeFontsURL,
            },
            (t) => {
              (this._isSyncing = !1),
                (this._textRenderInfo = t),
                this.geometry.updateGlyphs(
                  t.glyphBounds,
                  t.glyphAtlasIndices,
                  t.blockBounds,
                  t.chunkedBounds,
                  t.glyphColors
                );
              const n = this._queuedSyncs;
              n &&
                ((this._queuedSyncs = null),
                (this._needsSync = !0),
                this.sync(() => {
                  n.forEach((i) => i && i());
                })),
                this.dispatchEvent(o4),
                e && e();
            }
          )));
  }
  onBeforeRender(e, t, n, i, a, l) {
    this.sync(), a.isTroikaTextMaterial && this._prepareForRender(a);
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  createDerivedMaterial(e) {
    return a4(e);
  }
  get material() {
    let e = this._derivedMaterial;
    const t =
      this._baseMaterial ||
      this._defaultMaterial ||
      (this._defaultMaterial = Vx.clone());
    if (
      ((!e || !e.isDerivedFrom(t)) &&
        ((e = this._derivedMaterial = this.createDerivedMaterial(t)),
        t.addEventListener("dispose", function n() {
          t.removeEventListener("dispose", n), e.dispose();
        })),
      this.hasOutline())
    ) {
      let n = e._outlineMtl;
      return (
        n ||
          ((n = e._outlineMtl =
            Object.create(e, { id: { value: e.id + 0.1 } })),
          (n.isTextOutlineMaterial = !0),
          (n.depthWrite = !1),
          (n.map = null),
          e.addEventListener("dispose", function i() {
            e.removeEventListener("dispose", i), n.dispose();
          })),
        [n, e]
      );
    } else return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial
      ? ((this._derivedMaterial = e), (this._baseMaterial = e.baseMaterial))
      : (this._baseMaterial = e);
  }
  hasOutline() {
    return !!(
      this.outlineWidth ||
      this.outlineBlur ||
      this.outlineOffsetX ||
      this.outlineOffsetY
    );
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  get customDepthMaterial() {
    return rE(this.material).getDepthMaterial();
  }
  set customDepthMaterial(e) {}
  get customDistanceMaterial() {
    return rE(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(e) {}
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial,
      n = e.uniforms,
      i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: u, blockBounds: f } = i;
      (n.uTroikaSDFTexture.value = u),
        n.uTroikaSDFTextureSize.value.set(u.image.width, u.image.height),
        (n.uTroikaSDFGlyphSize.value = i.sdfGlyphSize),
        (n.uTroikaSDFExponent.value = i.sdfExponent),
        n.uTroikaTotalBounds.value.fromArray(f),
        (n.uTroikaUseGlyphColors.value = !t && !!i.glyphColors);
      let d = 0,
        m = 0,
        v = 0,
        _,
        A,
        M,
        T = 0,
        E = 0;
      if (t) {
        let {
          outlineWidth: w,
          outlineOffsetX: D,
          outlineOffsetY: B,
          outlineBlur: I,
          outlineOpacity: N,
        } = this;
        (d = this._parsePercent(w) || 0),
          (m = Math.max(0, this._parsePercent(I) || 0)),
          (_ = N),
          (T = this._parsePercent(D) || 0),
          (E = this._parsePercent(B) || 0);
      } else
        (v = Math.max(0, this._parsePercent(this.strokeWidth) || 0)),
          v &&
            ((M = this.strokeColor),
            n.uTroikaStrokeColor.value.set(M ?? iE),
            (A = this.strokeOpacity),
            A == null && (A = 1)),
          (_ = this.fillOpacity);
      (n.uTroikaEdgeOffset.value = d),
        n.uTroikaPositionOffset.value.set(T, E),
        (n.uTroikaBlurRadius.value = m),
        (n.uTroikaStrokeWidth.value = v),
        (n.uTroikaStrokeOpacity.value = A),
        (n.uTroikaFillOpacity.value = _ ?? 1),
        (n.uTroikaCurveRadius.value = this.curveRadius || 0);
      let b = this.clipRect;
      if (b && Array.isArray(b) && b.length === 4)
        n.uTroikaClipRect.value.fromArray(b);
      else {
        const w = (this.fontSize || 0.1) * 100;
        n.uTroikaClipRect.value.set(f[0] - w, f[1] - w, f[2] + w, f[3] + w);
      }
      this.geometry.applyClipRect(n.uTroikaClipRect.value);
    }
    (n.uTroikaSDFDebug.value = !!this.debugSDF),
      (e.polygonOffset = !!this.depthOffset),
      (e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0);
    const a = t ? this.outlineColor || 0 : this.color;
    if (a == null) delete e.color;
    else {
      const u = e.hasOwnProperty("color") ? e.color : (e.color = new Dt());
      (a !== u._input || typeof a == "object") && u.set((u._input = a));
    }
    let l = this.orientation || lA;
    if (l !== e._orientation) {
      let u = n.uTroikaOrient.value;
      l = l.replace(/[^-+xyz]/g, "");
      let f = l !== lA && l.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (f) {
        let [, d, m, v, _] = f;
        (x0.set(0, 0, 0)[m] = d === "-" ? 1 : -1),
          (oA.set(0, 0, 0)[_] = v === "-" ? -1 : 1),
          aE.lookAt(r4, x0.cross(oA), oA),
          u.setFromMatrix4(aE);
      } else u.identity();
      e._orientation = l;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/),
        n = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(n) ? 0 : n / 100) * this.fontSize;
    }
    return e;
  }
  localPositionToTextCoords(e, t = new at()) {
    t.copy(e);
    const n = this.curveRadius;
    return (
      n && (t.x = Math.atan2(e.x, Math.abs(n) - Math.abs(e.z)) * Math.abs(n)), t
    );
  }
  worldPositionToTextCoords(e, t = new at()) {
    return x0.copy(e), this.localPositionToTextCoords(this.worldToLocal(x0), t);
  }
  raycast(e, t) {
    const { textRenderInfo: n, curveRadius: i } = this;
    if (n) {
      const a = n.blockBounds,
        l = i ? G2() : P2(),
        u = l.geometry,
        { position: f, uv: d } = u.attributes;
      for (let m = 0; m < d.count; m++) {
        let v = a[0] + d.getX(m) * (a[2] - a[0]);
        const _ = a[1] + d.getY(m) * (a[3] - a[1]);
        let A = 0;
        i && ((A = i - Math.cos(v / i) * i), (v = Math.sin(v / i) * i)),
          f.setXYZ(m, v, _, A);
      }
      (u.boundingSphere = this.geometry.boundingSphere),
        (u.boundingBox = this.geometry.boundingBox),
        (l.matrixWorld = this.matrixWorld),
        (l.material.side = this.material.side),
        (fm.length = 0),
        l.raycast(e, fm);
      for (let m = 0; m < fm.length; m++) (fm[m].object = this), t.push(fm[m]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return (
      super.copy(e),
      (this.geometry = t),
      l4.forEach((n) => {
        this[n] = e[n];
      }),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
z2.forEach((s) => {
  const e = "_private_" + s;
  Object.defineProperty(H2.prototype, s, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && ((this[e] = t), (this._needsSync = !0));
    },
  });
});
new ya();
new Dt();
const V2 = je.forwardRef(
  (
    {
      sdfGlyphSize: s = 64,
      anchorX: e = "center",
      anchorY: t = "middle",
      font: n,
      fontSize: i = 1,
      children: a,
      characters: l,
      onSync: u,
      ...f
    },
    d
  ) => {
    const m = aa(({ invalidate: M }) => M),
      [v] = je.useState(() => new H2()),
      [_, A] = je.useMemo(() => {
        const M = [];
        let T = "";
        return (
          je.Children.forEach(a, (E) => {
            typeof E == "string" || typeof E == "number" ? (T += E) : M.push(E);
          }),
          [M, T]
        );
      }, [a]);
    return (
      e2(
        () => new Promise((M) => WF({ font: n, characters: l }, M)),
        ["troika-text", n, l]
      ),
      je.useLayoutEffect(
        () =>
          void v.sync(() => {
            m(), u && u(v);
          })
      ),
      je.useEffect(() => () => v.dispose(), [v]),
      je.createElement(
        "primitive",
        Mu(
          {
            object: v,
            ref: d,
            font: n,
            text: A,
            anchorX: e,
            anchorY: t,
            fontSize: i,
            sdfGlyphSize: s,
          },
          f
        ),
        _
      )
    );
  }
);
function u4(s, e, t, n) {
  var i;
  return (
    (i = class extends ra {
      constructor(a) {
        super({ vertexShader: e, fragmentShader: t, ...a });
        for (const l in s)
          (this.uniforms[l] = new s_(s[l])),
            Object.defineProperty(this, l, {
              get() {
                return this.uniforms[l].value;
              },
              set(u) {
                this.uniforms[l].value = u;
              },
            });
        this.uniforms = Ny.clone(this.uniforms);
      }
    }),
    (i.key = tx.generateUUID()),
    i
  );
}
const uA = (s) =>
  s === Object(s) && !Array.isArray(s) && typeof s != "function";
function kx(s, e) {
  const t = aa((a) => a.gl),
    n = Gs(tg, uA(s) ? Object.values(s) : s);
  return (
    je.useLayoutEffect(() => {
      e == null || e(n);
    }, [e]),
    je.useEffect(() => {
      if ("initTexture" in t) {
        let a = [];
        Array.isArray(n)
          ? (a = n)
          : n instanceof Wn
          ? (a = [n])
          : uA(n) && (a = Object.values(n)),
          a.forEach((l) => {
            l instanceof Wn && t.initTexture(l);
          });
      }
    }, [t, n]),
    je.useMemo(() => {
      if (uA(s)) {
        const a = {};
        let l = 0;
        for (const u in s) a[u] = n[l++];
        return a;
      } else return n;
    }, [s, n])
  );
}
kx.preload = (s) => Gs.preload(tg, s);
kx.clear = (s) => Gs.clear(tg, s);
const c4 = () => parseInt(Od.replace(/\D+/g, "")),
  k2 = c4();
let S0 = null,
  X2 = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";
function Y2(s = !0, e = !0, t) {
  return (n) => {
    t && t(n),
      s &&
        (S0 || (S0 = new hF()),
        S0.setDecoderPath(typeof s == "string" ? s : X2),
        n.setDRACOLoader(S0)),
      e && n.setMeshoptDecoder(typeof rA == "function" ? rA() : rA);
  };
}
const bu = (s, e, t, n) => Gs(Hx, s, Y2(e, t, n));
bu.preload = (s, e, t, n) => Gs.preload(Hx, s, Y2(e, t, n));
bu.clear = (s) => Gs.clear(Hx, s);
bu.setDecoderPath = (s) => {
  X2 = s;
};
function Sy(s, e, t) {
  const n = aa((A) => A.size),
    i = aa((A) => A.viewport),
    a = typeof s == "number" ? s : n.width * i.dpr,
    l = typeof e == "number" ? e : n.height * i.dpr,
    u = (typeof s == "number" ? t : s) || {},
    { samples: f = 0, depth: d, ...m } = u,
    v = d ?? u.depthBuffer,
    _ = je.useMemo(() => {
      const A = new ha(a, l, { minFilter: In, magFilter: In, type: va, ...m });
      return v && (A.depthTexture = new Vy(a, l, yi)), (A.samples = f), A;
    }, []);
  return (
    je.useLayoutEffect(() => {
      _.setSize(a, l), f && (_.samples = f);
    }, [f, _, a, l]),
    je.useEffect(() => () => _.dispose(), []),
    _
  );
}
const f4 = je.forwardRef(
  (
    {
      makeDefault: s,
      camera: e,
      regress: t,
      domElement: n,
      enableDamping: i = !0,
      keyEvents: a = !1,
      onChange: l,
      onStart: u,
      onEnd: f,
      ...d
    },
    m
  ) => {
    const v = aa((N) => N.invalidate),
      _ = aa((N) => N.camera),
      A = aa((N) => N.gl),
      M = aa((N) => N.events),
      T = aa((N) => N.setEvents),
      E = aa((N) => N.set),
      b = aa((N) => N.get),
      w = aa((N) => N.performance),
      D = e || _,
      B = n || M.connected || A.domElement,
      I = je.useMemo(() => new TI(D), [D]);
    return (
      zd(() => {
        I.enabled && I.update();
      }, -1),
      je.useEffect(
        () => (
          a && I.connect(a === !0 ? B : a), I.connect(B), () => void I.dispose()
        ),
        [a, B, t, I, v]
      ),
      je.useEffect(() => {
        const N = (O) => {
            v(), t && w.regress(), l && l(O);
          },
          P = (O) => {
            u && u(O);
          },
          F = (O) => {
            f && f(O);
          };
        return (
          I.addEventListener("change", N),
          I.addEventListener("start", P),
          I.addEventListener("end", F),
          () => {
            I.removeEventListener("start", P),
              I.removeEventListener("end", F),
              I.removeEventListener("change", N);
          }
        );
      }, [l, u, f, I, v, T]),
      je.useEffect(() => {
        if (s) {
          const N = b().controls;
          return E({ controls: I }), () => E({ controls: N });
        }
      }, [s, I]),
      je.createElement(
        "primitive",
        Mu({ ref: m, object: I, enableDamping: i }, d)
      )
    );
  }
);
function h4(s) {
  const e = je.useRef(null),
    t = je.useRef(!1),
    n = je.useRef(!1),
    i = je.useRef(s);
  return (
    je.useLayoutEffect(() => void (i.current = s), [s]),
    je.useEffect(() => {
      const a = e.current;
      if (a) {
        const l = JN(() => ((t.current = !1), !0)),
          u = a.onBeforeRender;
        a.onBeforeRender = () => (t.current = !0);
        const f = qN(
          () => (
            t.current !== n.current &&
              (i.current == null || i.current((n.current = t.current))),
            !0
          )
        );
        return () => {
          (a.onBeforeRender = u), l(), f();
        };
      }
    }, []),
    e
  );
}
const xl = 1e-5;
function d4(s, e, t) {
  const n = new yc(),
    i = t - xl;
  return (
    n.absarc(xl, xl, xl, -Math.PI / 2, -Math.PI, !0),
    n.absarc(xl, e - i * 2, xl, Math.PI, Math.PI / 2, !0),
    n.absarc(s - i * 2, e - i * 2, xl, Math.PI / 2, 0, !0),
    n.absarc(s - i * 2, xl, xl, 0, -Math.PI / 2, !0),
    n
  );
}
const p4 = je.forwardRef(function (
    {
      args: [e = 1, t = 1, n = 1] = [],
      radius: i = 0.05,
      steps: a = 1,
      smoothness: l = 4,
      bevelSegments: u = 4,
      creaseAngle: f = 0.4,
      children: d,
      ...m
    },
    v
  ) {
    return je.createElement(
      "mesh",
      Mu({ ref: v }, m),
      je.createElement(m4, {
        args: [e, t, n],
        radius: i,
        steps: a,
        smoothness: l,
        bevelSegments: u,
        creaseAngle: f,
      }),
      d
    );
  }),
  m4 = je.forwardRef(function (
    {
      args: [e = 1, t = 1, n = 1] = [],
      radius: i = 0.05,
      steps: a = 1,
      smoothness: l = 4,
      bevelSegments: u = 4,
      creaseAngle: f = 0.4,
      ...d
    },
    m
  ) {
    const v = je.useMemo(() => d4(e, t, i), [e, t, i]),
      _ = je.useMemo(
        () => ({
          depth: n - i * 2,
          bevelEnabled: !0,
          bevelSegments: u * 2,
          steps: a,
          bevelSize: i - xl,
          bevelThickness: i,
          curveSegments: l,
        }),
        [n, i, l, u, a]
      ),
      A = je.useRef(null);
    return (
      je.useLayoutEffect(() => {
        A.current && (A.current.center(), iI(A.current, f));
      }, [v, _, f]),
      je.useImperativeHandle(m, () => A.current),
      je.createElement("extrudeGeometry", Mu({ ref: A, args: [v, _] }, d))
    );
  }),
  W2 = (s, e, t) => {
    let n;
    switch (s) {
      case Zr:
        n = new Uint8ClampedArray(e * t * 4);
        break;
      case va:
        n = new Uint16Array(e * t * 4);
        break;
      case Rl:
        n = new Uint32Array(e * t * 4);
        break;
      case Ty:
        n = new Int8Array(e * t * 4);
        break;
      case Cy:
        n = new Int16Array(e * t * 4);
        break;
      case km:
        n = new Int32Array(e * t * 4);
        break;
      case yi:
        n = new Float32Array(e * t * 4);
        break;
      default:
        throw new Error("Unsupported data type");
    }
    return n;
  };
let M0;
const g4 = (s, e, t, n) => {
  if (M0 !== void 0) return M0;
  const i = new ha(1, 1, n);
  e.setRenderTarget(i);
  const a = new li(new zs(), new fr({ color: 16777215 }));
  e.render(a, t), e.setRenderTarget(null);
  const l = W2(s, i.width, i.height);
  return (
    e.readRenderTargetPixels(i, 0, 0, i.width, i.height, l),
    i.dispose(),
    a.geometry.dispose(),
    a.material.dispose(),
    (M0 = l[0] !== 0),
    M0
  );
};
class Xx {
  constructor(e) {
    var t, n, i, a, l, u, f, d, m, v, _, A, M, T, E, b;
    (this._rendererIsDisposable = !1),
      (this._supportsReadPixels = !0),
      (this.render = () => {
        this._renderer.setRenderTarget(this._renderTarget);
        try {
          this._renderer.render(this._scene, this._camera);
        } catch (D) {
          throw (this._renderer.setRenderTarget(null), D);
        }
        this._renderer.setRenderTarget(null);
      }),
      (this._width = e.width),
      (this._height = e.height),
      (this._type = e.type),
      (this._colorSpace = e.colorSpace);
    const w = {
      format: oa,
      depthBuffer: !1,
      stencilBuffer: !1,
      type: this._type,
      colorSpace: this._colorSpace,
      anisotropy:
        ((t = e.renderTargetOptions) === null || t === void 0
          ? void 0
          : t.anisotropy) !== void 0
          ? (n = e.renderTargetOptions) === null || n === void 0
            ? void 0
            : n.anisotropy
          : 1,
      generateMipmaps:
        ((i = e.renderTargetOptions) === null || i === void 0
          ? void 0
          : i.generateMipmaps) !== void 0
          ? (a = e.renderTargetOptions) === null || a === void 0
            ? void 0
            : a.generateMipmaps
          : !1,
      magFilter:
        ((l = e.renderTargetOptions) === null || l === void 0
          ? void 0
          : l.magFilter) !== void 0
          ? (u = e.renderTargetOptions) === null || u === void 0
            ? void 0
            : u.magFilter
          : In,
      minFilter:
        ((f = e.renderTargetOptions) === null || f === void 0
          ? void 0
          : f.minFilter) !== void 0
          ? (d = e.renderTargetOptions) === null || d === void 0
            ? void 0
            : d.minFilter
          : In,
      samples:
        ((m = e.renderTargetOptions) === null || m === void 0
          ? void 0
          : m.samples) !== void 0
          ? (v = e.renderTargetOptions) === null || v === void 0
            ? void 0
            : v.samples
          : void 0,
      wrapS:
        ((_ = e.renderTargetOptions) === null || _ === void 0
          ? void 0
          : _.wrapS) !== void 0
          ? (A = e.renderTargetOptions) === null || A === void 0
            ? void 0
            : A.wrapS
          : sa,
      wrapT:
        ((M = e.renderTargetOptions) === null || M === void 0
          ? void 0
          : M.wrapT) !== void 0
          ? (T = e.renderTargetOptions) === null || T === void 0
            ? void 0
            : T.wrapT
          : sa,
    };
    if (
      ((this._material = e.material),
      e.renderer
        ? (this._renderer = e.renderer)
        : ((this._renderer = Xx.instantiateRenderer()),
          (this._rendererIsDisposable = !0)),
      (this._scene = new Nd()),
      (this._camera = new Ps()),
      this._camera.position.set(0, 0, 10),
      (this._camera.left = -0.5),
      (this._camera.right = 0.5),
      (this._camera.top = 0.5),
      (this._camera.bottom = -0.5),
      this._camera.updateProjectionMatrix(),
      !g4(this._type, this._renderer, this._camera, w))
    ) {
      let D;
      switch (this._type) {
        case va:
          D = this._renderer.extensions.has("EXT_color_buffer_float")
            ? yi
            : void 0;
          break;
      }
      D !== void 0
        ? (console.warn(
            `This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${yi}`
          ),
          (this._type = D))
        : ((this._supportsReadPixels = !1),
          console.warn(
            "This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"
          ));
    }
    (this._quad = new li(new zs(), this._material)),
      this._quad.geometry.computeBoundingBox(),
      this._scene.add(this._quad),
      (this._renderTarget = new ha(this.width, this.height, w)),
      (this._renderTarget.texture.mapping =
        ((E = e.renderTargetOptions) === null || E === void 0
          ? void 0
          : E.mapping) !== void 0
          ? (b = e.renderTargetOptions) === null || b === void 0
            ? void 0
            : b.mapping
          : Ac);
  }
  static instantiateRenderer() {
    const e = new Ux();
    return e.setSize(128, 128), e;
  }
  toArray() {
    if (!this._supportsReadPixels)
      throw new Error("Can't read pixels in this browser");
    const e = W2(this._type, this._width, this._height);
    return (
      this._renderer.readRenderTargetPixels(
        this._renderTarget,
        0,
        0,
        this._width,
        this._height,
        e
      ),
      e
    );
  }
  toDataTexture(e) {
    const t = new Uo(
      this.toArray(),
      this.width,
      this.height,
      oa,
      this._type,
      (e == null ? void 0 : e.mapping) || Ac,
      (e == null ? void 0 : e.wrapS) || sa,
      (e == null ? void 0 : e.wrapT) || sa,
      (e == null ? void 0 : e.magFilter) || In,
      (e == null ? void 0 : e.minFilter) || In,
      (e == null ? void 0 : e.anisotropy) || 1,
      Oo
    );
    return (
      (t.generateMipmaps =
        (e == null ? void 0 : e.generateMipmaps) !== void 0
          ? e == null
            ? void 0
            : e.generateMipmaps
          : !1),
      t
    );
  }
  disposeOnDemandRenderer() {
    this._renderer.setRenderTarget(null),
      this._rendererIsDisposable &&
        (this._renderer.dispose(), this._renderer.forceContextLoss());
  }
  dispose(e) {
    this.disposeOnDemandRenderer(),
      e && this.renderTarget.dispose(),
      this.material instanceof ra &&
        Object.values(this.material.uniforms).forEach((t) => {
          t.value instanceof Wn && t.value.dispose();
        }),
      Object.values(this.material).forEach((t) => {
        t instanceof Wn && t.dispose();
      }),
      this.material.dispose(),
      this._quad.geometry.dispose();
  }
  get width() {
    return this._width;
  }
  set width(e) {
    (this._width = e), this._renderTarget.setSize(this._width, this._height);
  }
  get height() {
    return this._height;
  }
  set height(e) {
    (this._height = e), this._renderTarget.setSize(this._width, this._height);
  }
  get renderer() {
    return this._renderer;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  set renderTarget(e) {
    (this._renderTarget = e),
      (this._width = e.width),
      (this._height = e.height);
  }
  get material() {
    return this._material;
  }
  get type() {
    return this._type;
  }
  get colorSpace() {
    return this._colorSpace;
  }
}
const v4 = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
  y4 = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;
class _4 extends ra {
  constructor({
    gamma: e,
    offsetHdr: t,
    offsetSdr: n,
    gainMapMin: i,
    gainMapMax: a,
    maxDisplayBoost: l,
    hdrCapacityMin: u,
    hdrCapacityMax: f,
    sdr: d,
    gainMap: m,
  }) {
    super({
      name: "GainMapDecoderMaterial",
      vertexShader: v4,
      fragmentShader: y4,
      uniforms: {
        sdr: { value: d },
        gainMap: { value: m },
        gamma: { value: new ie(1 / e[0], 1 / e[1], 1 / e[2]) },
        offsetHdr: { value: new ie().fromArray(t) },
        offsetSdr: { value: new ie().fromArray(n) },
        gainMapMin: { value: new ie().fromArray(i) },
        gainMapMax: { value: new ie().fromArray(a) },
        weightFactor: { value: (Math.log2(l) - u) / (f - u) },
      },
      blending: Ml,
      depthTest: !1,
      depthWrite: !1,
    }),
      (this._maxDisplayBoost = l),
      (this._hdrCapacityMin = u),
      (this._hdrCapacityMax = f),
      (this.needsUpdate = !0),
      (this.uniformsNeedUpdate = !0);
  }
  get sdr() {
    return this.uniforms.sdr.value;
  }
  set sdr(e) {
    this.uniforms.sdr.value = e;
  }
  get gainMap() {
    return this.uniforms.gainMap.value;
  }
  set gainMap(e) {
    this.uniforms.gainMap.value = e;
  }
  get offsetHdr() {
    return this.uniforms.offsetHdr.value.toArray();
  }
  set offsetHdr(e) {
    this.uniforms.offsetHdr.value.fromArray(e);
  }
  get offsetSdr() {
    return this.uniforms.offsetSdr.value.toArray();
  }
  set offsetSdr(e) {
    this.uniforms.offsetSdr.value.fromArray(e);
  }
  get gainMapMin() {
    return this.uniforms.gainMapMin.value.toArray();
  }
  set gainMapMin(e) {
    this.uniforms.gainMapMin.value.fromArray(e);
  }
  get gainMapMax() {
    return this.uniforms.gainMapMax.value.toArray();
  }
  set gainMapMax(e) {
    this.uniforms.gainMapMax.value.fromArray(e);
  }
  get gamma() {
    const e = this.uniforms.gamma.value;
    return [1 / e.x, 1 / e.y, 1 / e.z];
  }
  set gamma(e) {
    const t = this.uniforms.gamma.value;
    (t.x = 1 / e[0]), (t.y = 1 / e[1]), (t.z = 1 / e[2]);
  }
  get hdrCapacityMin() {
    return this._hdrCapacityMin;
  }
  set hdrCapacityMin(e) {
    (this._hdrCapacityMin = e), this.calculateWeight();
  }
  get hdrCapacityMax() {
    return this._hdrCapacityMax;
  }
  set hdrCapacityMax(e) {
    (this._hdrCapacityMax = e), this.calculateWeight();
  }
  get maxDisplayBoost() {
    return this._maxDisplayBoost;
  }
  set maxDisplayBoost(e) {
    (this._maxDisplayBoost = Math.max(1, Math.min(65504, e))),
      this.calculateWeight();
  }
  calculateWeight() {
    const e =
      (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) /
      (this._hdrCapacityMax - this._hdrCapacityMin);
    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, e));
  }
}
class J2 extends Error {}
class q2 extends Error {}
const hm = (s, e, t) => {
    const n = new RegExp(`${e}="([^"]*)"`, "i").exec(s);
    if (n) return n[1];
    const i = new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`, "i").exec(s);
    if (i) {
      const a = i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
      return a && a.length === 3
        ? a.map((l) => l.replace(/<\/?rdf:li>/g, ""))
        : i[1].trim();
    }
    if (t !== void 0) return t;
    throw new Error(`Can't find ${e} in gainmap metadata`);
  },
  A4 = (s) => {
    let e;
    typeof TextDecoder < "u"
      ? (e = new TextDecoder().decode(s))
      : (e = s.toString());
    let t = e.indexOf("<x:xmpmeta");
    for (; t !== -1; ) {
      const n = e.indexOf("x:xmpmeta>", t),
        i = e.slice(t, n + 10);
      try {
        const a = hm(i, "hdrgm:GainMapMin", "0"),
          l = hm(i, "hdrgm:GainMapMax"),
          u = hm(i, "hdrgm:Gamma", "1"),
          f = hm(i, "hdrgm:OffsetSDR", "0.015625"),
          d = hm(i, "hdrgm:OffsetHDR", "0.015625"),
          m = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(i),
          v = m ? m[1] : "0",
          _ = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(i);
        if (!_) throw new Error("Incomplete gainmap metadata");
        const A = _[1];
        return {
          gainMapMin: Array.isArray(a)
            ? a.map((M) => parseFloat(M))
            : [parseFloat(a), parseFloat(a), parseFloat(a)],
          gainMapMax: Array.isArray(l)
            ? l.map((M) => parseFloat(M))
            : [parseFloat(l), parseFloat(l), parseFloat(l)],
          gamma: Array.isArray(u)
            ? u.map((M) => parseFloat(M))
            : [parseFloat(u), parseFloat(u), parseFloat(u)],
          offsetSdr: Array.isArray(f)
            ? f.map((M) => parseFloat(M))
            : [parseFloat(f), parseFloat(f), parseFloat(f)],
          offsetHdr: Array.isArray(d)
            ? d.map((M) => parseFloat(M))
            : [parseFloat(d), parseFloat(d), parseFloat(d)],
          hdrCapacityMin: parseFloat(v),
          hdrCapacityMax: parseFloat(A),
        };
      } catch {}
      t = e.indexOf("<x:xmpmeta", n);
    }
  };
class x4 {
  constructor(e) {
    this.options = {
      debug: e && e.debug !== void 0 ? e.debug : !1,
      extractFII: e && e.extractFII !== void 0 ? e.extractFII : !0,
      extractNonFII: e && e.extractNonFII !== void 0 ? e.extractNonFII : !0,
    };
  }
  extract(e) {
    return new Promise((t, n) => {
      const i = this.options.debug,
        a = new DataView(e.buffer);
      if (a.getUint16(0) !== 65496) {
        n(new Error("Not a valid jpeg"));
        return;
      }
      const l = a.byteLength;
      let u = 2,
        f = 0,
        d;
      for (; u < l; ) {
        if (++f > 250) {
          n(new Error(`Found no marker after ${f} loops `));
          return;
        }
        if (a.getUint8(u) !== 255) {
          n(
            new Error(
              `Not a valid marker at offset 0x${u.toString(16)}, found: 0x${a
                .getUint8(u)
                .toString(16)}`
            )
          );
          return;
        }
        if (
          ((d = a.getUint8(u + 1)),
          i && console.log(`Marker: ${d.toString(16)}`),
          d === 226)
        ) {
          i && console.log("Found APP2 marker (0xffe2)");
          const m = u + 4;
          if (a.getUint32(m) === 1297106432) {
            const v = m + 4;
            let _;
            if (a.getUint16(v) === 18761) _ = !1;
            else if (a.getUint16(v) === 19789) _ = !0;
            else {
              n(new Error("No valid endianness marker found in TIFF header"));
              return;
            }
            if (a.getUint16(v + 2, !_) !== 42) {
              n(new Error("Not valid TIFF data! (no 0x002A marker)"));
              return;
            }
            const A = a.getUint32(v + 4, !_);
            if (A < 8) {
              n(new Error("Not valid TIFF data! (First offset less than 8)"));
              return;
            }
            const M = v + A,
              T = a.getUint16(M, !_),
              E = M + 2;
            let b = 0;
            for (let I = E; I < E + 12 * T; I += 12)
              a.getUint16(I, !_) === 45057 && (b = a.getUint32(I + 8, !_));
            const D = M + 2 + T * 12 + 4,
              B = [];
            for (let I = D; I < D + b * 16; I += 16) {
              const N = {
                MPType: a.getUint32(I, !_),
                size: a.getUint32(I + 4, !_),
                dataOffset: a.getUint32(I + 8, !_),
                dependantImages: a.getUint32(I + 12, !_),
                start: -1,
                end: -1,
                isFII: !1,
              };
              N.dataOffset
                ? ((N.start = v + N.dataOffset), (N.isFII = !1))
                : ((N.start = 0), (N.isFII = !0)),
                (N.end = N.start + N.size),
                B.push(N);
            }
            if (this.options.extractNonFII && B.length) {
              const I = new Blob([a]),
                N = [];
              for (const P of B) {
                if (P.isFII && !this.options.extractFII) continue;
                const F = I.slice(P.start, P.end + 1, "image/jpeg");
                N.push(F);
              }
              t(N);
            }
          }
        }
        u += 2 + a.getUint16(u + 2);
      }
    });
  }
}
const S4 = async (s) => {
    const e = A4(s);
    if (!e) throw new q2("Gain map XMP metadata not found");
    const n = await new x4({ extractFII: !0, extractNonFII: !0 }).extract(s);
    if (n.length !== 2) throw new J2("Gain map recovery image not found");
    return {
      sdr: new Uint8Array(await n[0].arrayBuffer()),
      gainMap: new Uint8Array(await n[1].arrayBuffer()),
      metadata: e,
    };
  },
  sE = (s) =>
    new Promise((e, t) => {
      const n = document.createElement("img");
      (n.onload = () => {
        e(n);
      }),
        (n.onerror = (i) => {
          t(i);
        }),
        (n.src = URL.createObjectURL(s));
    });
class j2 extends qa {
  constructor(e, t) {
    super(t),
      e && (this._renderer = e),
      (this._internalLoadingManager = new a_());
  }
  setRenderer(e) {
    return (this._renderer = e), this;
  }
  setRenderTargetOptions(e) {
    return (this._renderTargetOptions = e), this;
  }
  prepareQuadRenderer() {
    this._renderer ||
      console.warn(
        "WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer."
      );
    const e = new _4({
      gainMapMax: [1, 1, 1],
      gainMapMin: [0, 0, 0],
      gamma: [1, 1, 1],
      offsetHdr: [1, 1, 1],
      offsetSdr: [1, 1, 1],
      hdrCapacityMax: 1,
      hdrCapacityMin: 0,
      maxDisplayBoost: 1,
      gainMap: new Wn(),
      sdr: new Wn(),
    });
    return new Xx({
      width: 16,
      height: 16,
      type: va,
      colorSpace: Oo,
      material: e,
      renderer: this._renderer,
      renderTargetOptions: this._renderTargetOptions,
    });
  }
  async render(e, t, n, i) {
    const a = i ? new Blob([i], { type: "image/jpeg" }) : void 0,
      l = new Blob([n], { type: "image/jpeg" });
    let u,
      f,
      d = !1;
    if (typeof createImageBitmap > "u") {
      const _ = await Promise.all([a ? sE(a) : Promise.resolve(void 0), sE(l)]);
      (f = _[0]), (u = _[1]), (d = !0);
    } else {
      const _ = await Promise.all([
        a
          ? createImageBitmap(a, { imageOrientation: "flipY" })
          : Promise.resolve(void 0),
        createImageBitmap(l, { imageOrientation: "flipY" }),
      ]);
      (f = _[0]), (u = _[1]);
    }
    const m = new Wn(
      f || new ImageData(2, 2),
      Ac,
      sa,
      sa,
      In,
      gA,
      oa,
      Zr,
      1,
      Oo
    );
    (m.flipY = d), (m.needsUpdate = !0);
    const v = new Wn(u, Ac, sa, sa, In, gA, oa, Zr, 1, Wa);
    (v.flipY = d),
      (v.needsUpdate = !0),
      (e.width = u.width),
      (e.height = u.height),
      (e.material.gainMap = m),
      (e.material.sdr = v),
      (e.material.gainMapMin = t.gainMapMin),
      (e.material.gainMapMax = t.gainMapMax),
      (e.material.offsetHdr = t.offsetHdr),
      (e.material.offsetSdr = t.offsetSdr),
      (e.material.gamma = t.gamma),
      (e.material.hdrCapacityMin = t.hdrCapacityMin),
      (e.material.hdrCapacityMax = t.hdrCapacityMax),
      (e.material.maxDisplayBoost = Math.pow(2, t.hdrCapacityMax)),
      (e.material.needsUpdate = !0),
      e.render();
  }
}
class M4 extends j2 {
  load([e, t, n], i, a, l) {
    const u = this.prepareQuadRenderer();
    let f, d, m;
    const v = async () => {
      if (f && d && m) {
        try {
          await this.render(u, m, f, d);
        } catch (O) {
          this.manager.itemError(e),
            this.manager.itemError(t),
            this.manager.itemError(n),
            typeof l == "function" && l(O),
            u.disposeOnDemandRenderer();
          return;
        }
        typeof i == "function" && i(u),
          this.manager.itemEnd(e),
          this.manager.itemEnd(t),
          this.manager.itemEnd(n),
          u.disposeOnDemandRenderer();
      }
    };
    let _ = !0,
      A = 0,
      M = 0,
      T = !0,
      E = 0,
      b = 0,
      w = !0,
      D = 0,
      B = 0;
    const I = () => {
      if (typeof a == "function") {
        const O = A + E + D,
          U = M + b + B,
          W = _ && T && w;
        a(
          new ProgressEvent("progress", {
            lengthComputable: W,
            loaded: U,
            total: O,
          })
        );
      }
    };
    this.manager.itemStart(e),
      this.manager.itemStart(t),
      this.manager.itemStart(n);
    const N = new Ja(this._internalLoadingManager);
    N.setResponseType("arraybuffer"),
      N.setRequestHeader(this.requestHeader),
      N.setPath(this.path),
      N.setWithCredentials(this.withCredentials),
      N.load(
        e,
        async (O) => {
          if (typeof O == "string") throw new Error("Invalid sdr buffer");
          (f = O), await v();
        },
        (O) => {
          (_ = O.lengthComputable), (M = O.loaded), (A = O.total), I();
        },
        (O) => {
          this.manager.itemError(e), typeof l == "function" && l(O);
        }
      );
    const P = new Ja(this._internalLoadingManager);
    P.setResponseType("arraybuffer"),
      P.setRequestHeader(this.requestHeader),
      P.setPath(this.path),
      P.setWithCredentials(this.withCredentials),
      P.load(
        t,
        async (O) => {
          if (typeof O == "string") throw new Error("Invalid gainmap buffer");
          (d = O), await v();
        },
        (O) => {
          (T = O.lengthComputable), (b = O.loaded), (E = O.total), I();
        },
        (O) => {
          this.manager.itemError(t), typeof l == "function" && l(O);
        }
      );
    const F = new Ja(this._internalLoadingManager);
    return (
      F.setRequestHeader(this.requestHeader),
      F.setPath(this.path),
      F.setWithCredentials(this.withCredentials),
      F.load(
        n,
        async (O) => {
          if (typeof O != "string") throw new Error("Invalid metadata string");
          (m = JSON.parse(O)), await v();
        },
        (O) => {
          (w = O.lengthComputable), (B = O.loaded), (D = O.total), I();
        },
        (O) => {
          this.manager.itemError(n), typeof l == "function" && l(O);
        }
      ),
      u
    );
  }
}
class b4 extends j2 {
  load(e, t, n, i) {
    const a = this.prepareQuadRenderer(),
      l = new Ja(this._internalLoadingManager);
    return (
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setPath(this.path),
      l.setWithCredentials(this.withCredentials),
      this.manager.itemStart(e),
      l.load(
        e,
        async (u) => {
          if (typeof u == "string")
            throw new Error(
              "Invalid buffer, received [string], was expecting [ArrayBuffer]"
            );
          const f = new Uint8Array(u);
          let d, m, v;
          try {
            const _ = await S4(f);
            (d = _.sdr), (m = _.gainMap), (v = _.metadata);
          } catch (_) {
            if (_ instanceof q2 || _ instanceof J2)
              console.warn(
                `Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`
              ),
                (v = {
                  gainMapMin: [0, 0, 0],
                  gainMapMax: [1, 1, 1],
                  gamma: [1, 1, 1],
                  hdrCapacityMin: 0,
                  hdrCapacityMax: 1,
                  offsetHdr: [0, 0, 0],
                  offsetSdr: [0, 0, 0],
                }),
                (d = f);
            else throw _;
          }
          try {
            await this.render(a, v, d, m);
          } catch (_) {
            this.manager.itemError(e),
              typeof i == "function" && i(_),
              a.disposeOnDemandRenderer();
            return;
          }
          typeof t == "function" && t(a),
            this.manager.itemEnd(e),
            a.disposeOnDemandRenderer();
        },
        n,
        (u) => {
          this.manager.itemError(e), typeof i == "function" && i(u);
        }
      ),
      a
    );
  }
}
const Hm = {
    apartment: "lebombo_1k.hdr",
    city: "potsdamer_platz_1k.hdr",
    dawn: "kiara_1_dawn_1k.hdr",
    forest: "forest_slope_1k.hdr",
    lobby: "st_fagans_interior_1k.hdr",
    night: "dikhololo_night_1k.hdr",
    park: "rooitou_park_1k.hdr",
    studio: "studio_small_03_1k.hdr",
    sunset: "venice_sunset_1k.hdr",
    warehouse: "empty_warehouse_01_1k.hdr",
  },
  K2 =
    "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",
  xd = (s) => Array.isArray(s),
  Yx = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"];
function c_({
  files: s = Yx,
  path: e = "",
  preset: t = void 0,
  colorSpace: n = void 0,
  extensions: i,
} = {}) {
  t && (Wx(t), (s = Hm[t]), (e = K2));
  const a = xd(s),
    { extension: l, isCubemap: u } = Jx(s),
    f = qx(l);
  if (!f) throw new Error("useEnvironment: Unrecognized file extension: " + s);
  const d = aa((A) => A.gl);
  je.useLayoutEffect(() => {
    if (l !== "webp" && l !== "jpg" && l !== "jpeg") return;
    function A() {
      Gs.clear(f, a ? [s] : s);
    }
    d.domElement.addEventListener("webglcontextlost", A, { once: !0 });
  }, [s, d.domElement]);
  const m = Gs(f, a ? [s] : s, (A) => {
    (l === "webp" || l === "jpg" || l === "jpeg") && A.setRenderer(d),
      A.setPath == null || A.setPath(e),
      i && i(A);
  });
  let v = a ? m[0] : m;
  if (l === "jpg" || l === "jpeg" || l === "webp") {
    var _;
    v = (_ = v.renderTarget) == null ? void 0 : _.texture;
  }
  return (
    (v.mapping = u ? Cl : Sd),
    (v.colorSpace = n ?? (u ? "srgb" : "srgb-linear")),
    v
  );
}
const E4 = { files: Yx, path: "", preset: void 0, extensions: void 0 };
c_.preload = (s) => {
  const e = { ...E4, ...s };
  let { files: t, path: n = "" } = e;
  const { preset: i, extensions: a } = e;
  i && (Wx(i), (t = Hm[i]), (n = K2));
  const { extension: l } = Jx(t);
  if (l === "webp" || l === "jpg" || l === "jpeg")
    throw new Error("useEnvironment: Preloading gainmaps is not supported");
  const u = qx(l);
  if (!u) throw new Error("useEnvironment: Unrecognized file extension: " + t);
  Gs.preload(u, xd(t) ? [t] : t, (f) => {
    f.setPath == null || f.setPath(n), a && a(f);
  });
};
const T4 = { files: Yx, preset: void 0 };
c_.clear = (s) => {
  const e = { ...T4, ...s };
  let { files: t } = e;
  const { preset: n } = e;
  n && (Wx(n), (t = Hm[n]));
  const { extension: i } = Jx(t),
    a = qx(i);
  if (!a) throw new Error("useEnvironment: Unrecognized file extension: " + t);
  Gs.clear(a, xd(t) ? [t] : t);
};
function Wx(s) {
  if (!(s in Hm))
    throw new Error("Preset must be one of: " + Object.keys(Hm).join(", "));
}
function Jx(s) {
  var e;
  const t = xd(s) && s.length === 6,
    n = xd(s) && s.length === 3 && s.some((l) => l.endsWith("json")),
    i = xd(s) ? s[0] : s;
  return {
    extension: t
      ? "cube"
      : n
      ? "webp"
      : i.startsWith("data:application/exr")
      ? "exr"
      : i.startsWith("data:application/hdr")
      ? "hdr"
      : i.startsWith("data:image/jpeg")
      ? "jpg"
      : (e = i.split(".").pop()) == null ||
        (e = e.split("?")) == null ||
        (e = e.shift()) == null
      ? void 0
      : e.toLowerCase(),
    isCubemap: t,
    isGainmap: n,
  };
}
function qx(s) {
  return s === "cube"
    ? UT
    : s === "hdr"
    ? cF
    : s === "exr"
    ? fF
    : s === "jpg" || s === "jpeg"
    ? b4
    : s === "webp"
    ? M4
    : null;
}
const C4 = (s) => s.current && s.current.isScene,
  R4 = (s) => (C4(s) ? s.current : s);
function jx(s, e, t, n, i = {}) {
  var a, l, u, f;
  i = {
    backgroundBlurriness: 0,
    backgroundIntensity: 1,
    backgroundRotation: [0, 0, 0],
    environmentIntensity: 1,
    environmentRotation: [0, 0, 0],
    ...i,
  };
  const d = R4(e || t),
    m = d.background,
    v = d.environment,
    _ = {
      backgroundBlurriness: d.backgroundBlurriness,
      backgroundIntensity: d.backgroundIntensity,
      backgroundRotation:
        (a =
          (l = d.backgroundRotation) == null || l.clone == null
            ? void 0
            : l.clone()) !== null && a !== void 0
          ? a
          : [0, 0, 0],
      environmentIntensity: d.environmentIntensity,
      environmentRotation:
        (u =
          (f = d.environmentRotation) == null || f.clone == null
            ? void 0
            : f.clone()) !== null && u !== void 0
          ? u
          : [0, 0, 0],
    };
  return (
    s !== "only" && (d.environment = n),
    s && (d.background = n),
    Sl(d, i),
    () => {
      s !== "only" && (d.environment = v), s && (d.background = m), Sl(d, _);
    }
  );
}
function Kx({ scene: s, background: e = !1, map: t, ...n }) {
  const i = aa((a) => a.scene);
  return (
    je.useLayoutEffect(() => {
      if (t) return jx(e, s, i, t, n);
    }),
    null
  );
}
function Z2({
  background: s = !1,
  scene: e,
  blur: t,
  backgroundBlurriness: n,
  backgroundIntensity: i,
  backgroundRotation: a,
  environmentIntensity: l,
  environmentRotation: u,
  ...f
}) {
  const d = c_(f),
    m = aa((v) => v.scene);
  return (
    je.useLayoutEffect(() =>
      jx(s, e, m, d, {
        backgroundBlurriness: t ?? n,
        backgroundIntensity: i,
        backgroundRotation: a,
        environmentIntensity: l,
        environmentRotation: u,
      })
    ),
    je.useEffect(
      () => () => {
        d.dispose();
      },
      [d]
    ),
    null
  );
}
function w4({
  children: s,
  near: e = 0.1,
  far: t = 1e3,
  resolution: n = 256,
  frames: i = 1,
  map: a,
  background: l = !1,
  blur: u,
  backgroundBlurriness: f,
  backgroundIntensity: d,
  backgroundRotation: m,
  environmentIntensity: v,
  environmentRotation: _,
  scene: A,
  files: M,
  path: T,
  preset: E = void 0,
  extensions: b,
}) {
  const w = aa((F) => F.gl),
    D = aa((F) => F.scene),
    B = je.useRef(null),
    [I] = je.useState(() => new Nd()),
    N = je.useMemo(() => {
      const F = new ax(n);
      return (F.texture.type = va), F;
    }, [n]);
  je.useEffect(
    () => () => {
      N.dispose();
    },
    [N]
  ),
    je.useLayoutEffect(() => {
      if (i === 1) {
        const F = w.autoClear;
        (w.autoClear = !0), B.current.update(w, I), (w.autoClear = F);
      }
      return jx(l, A, D, N.texture, {
        backgroundBlurriness: u ?? f,
        backgroundIntensity: d,
        backgroundRotation: m,
        environmentIntensity: v,
        environmentRotation: _,
      });
    }, [s, I, N.texture, A, D, l, i, w]);
  let P = 1;
  return (
    zd(() => {
      if (i === 1 / 0 || P < i) {
        const F = w.autoClear;
        (w.autoClear = !0), B.current.update(w, I), (w.autoClear = F), P++;
      }
    }),
    je.createElement(
      je.Fragment,
      null,
      g2(
        je.createElement(
          je.Fragment,
          null,
          s,
          je.createElement("cubeCamera", { ref: B, args: [e, t, N] }),
          M || E
            ? je.createElement(Z2, {
                background: !0,
                files: M,
                preset: E,
                path: T,
                extensions: b,
              })
            : a
            ? je.createElement(Kx, { background: !0, map: a, extensions: b })
            : null
        ),
        I
      )
    )
  );
}
function B4(s) {
  var e, t, n, i;
  const a = c_(s),
    l = s.map || a;
  je.useMemo(() => Px({ GroundProjectedEnvImpl: yI }), []),
    je.useEffect(
      () => () => {
        a.dispose();
      },
      [a]
    );
  const u = je.useMemo(() => [l], [l]),
    f = (e = s.ground) == null ? void 0 : e.height,
    d = (t = s.ground) == null ? void 0 : t.radius,
    m =
      (n = (i = s.ground) == null ? void 0 : i.scale) !== null && n !== void 0
        ? n
        : 1e3;
  return je.createElement(
    je.Fragment,
    null,
    je.createElement(Kx, Mu({}, s, { map: l })),
    je.createElement("groundProjectedEnvImpl", {
      args: u,
      scale: m,
      height: f,
      radius: d,
    })
  );
}
function Q2(s) {
  return s.ground
    ? je.createElement(B4, s)
    : s.map
    ? je.createElement(Kx, s)
    : s.children
    ? je.createElement(w4, s)
    : je.createElement(Z2, s);
}
const D4 = je.forwardRef(
  (
    {
      children: s,
      compute: e,
      width: t,
      height: n,
      samples: i = 8,
      renderPriority: a = 0,
      eventPriority: l = 0,
      frames: u = 1 / 0,
      stencilBuffer: f = !1,
      depthBuffer: d = !0,
      generateMipmaps: m = !1,
      ...v
    },
    _
  ) => {
    const { size: A, viewport: M } = aa(),
      T = Sy((t || A.width) * M.dpr, (n || A.height) * M.dpr, {
        samples: i,
        stencilBuffer: f,
        depthBuffer: d,
        generateMipmaps: m,
      }),
      [E] = je.useState(() => new Nd()),
      b = je.useCallback((w, D, B) => {
        var I, N;
        let P =
          (I = T.texture) == null || (I = I.__r3f.parent) == null
            ? void 0
            : I.object;
        for (; P && !(P instanceof On); ) {
          var F;
          P = (F = P.__r3f.parent) == null ? void 0 : F.object;
        }
        if (!P) return !1;
        B.raycaster.camera ||
          B.events.compute(
            w,
            B,
            (N = B.previousRoot) == null ? void 0 : N.getState()
          );
        const [O] = B.raycaster.intersectObject(P);
        if (!O) return !1;
        const U = O.uv;
        if (!U) return !1;
        D.raycaster.setFromCamera(
          D.pointer.set(U.x * 2 - 1, U.y * 2 - 1),
          D.camera
        );
      }, []);
    return (
      je.useImperativeHandle(_, () => T.texture, [T]),
      je.createElement(
        je.Fragment,
        null,
        g2(
          je.createElement(
            U4,
            { renderPriority: a, frames: u, fbo: T },
            s,
            je.createElement("group", { onPointerOver: () => null })
          ),
          E,
          { events: { compute: e || b, priority: l } }
        ),
        je.createElement("primitive", Mu({ object: T.texture }, v))
      )
    );
  }
);
function U4({ frames: s, renderPriority: e, children: t, fbo: n }) {
  let i = 0,
    a,
    l,
    u,
    f;
  return (
    zd((d) => {
      (s === 1 / 0 || i < s) &&
        ((a = d.gl.autoClear),
        (l = d.gl.xr.enabled),
        (u = d.gl.getRenderTarget()),
        (f = d.gl.xr.isPresenting),
        (d.gl.autoClear = !0),
        (d.gl.xr.enabled = !1),
        (d.gl.xr.isPresenting = !1),
        d.gl.setRenderTarget(n),
        d.gl.render(d.scene, d.camera),
        d.gl.setRenderTarget(u),
        (d.gl.autoClear = a),
        (d.gl.xr.enabled = l),
        (d.gl.xr.isPresenting = f),
        i++);
    }, e),
    je.createElement(je.Fragment, null, t)
  );
}
const O4 = u4(
    { blur: 0, map: null, sdf: null, blend: 0, size: 0, resolution: new at() },
    `varying vec2 vUv;
   void main() {
     gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
     vUv = uv;
   }`,
    `uniform sampler2D sdf;
   uniform sampler2D map;
   uniform float blur;
   uniform float size;
   uniform float time;
   uniform vec2 resolution;
   varying vec2 vUv;
   #include <packing>
   void main() {
     vec2 uv = gl_FragCoord.xy / resolution.xy;
     vec4 t = texture2D(map, uv);
     float k = blur;
     float d = texture2D(sdf, vUv).r/size;
     float alpha = 1.0 - smoothstep(0.0, 1.0, clamp(d/k + 1.0, 0.0, 1.0));
     gl_FragColor = vec4(t.rgb, blur == 0.0 ? t.a : t.a * alpha);
     #include <tonemapping_fragment>
     #include <${k2 >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
   }`
  ),
  L4 = je.forwardRef(
    (
      {
        children: s,
        events: e = void 0,
        blur: t = 0,
        eventPriority: n = 0,
        renderPriority: i = 0,
        worldUnits: a = !1,
        resolution: l = 512,
        ...u
      },
      f
    ) => {
      Px({ PortalMaterialImpl: O4 });
      const d = je.useRef(null),
        { scene: m, gl: v, size: _, viewport: A, setEvents: M } = aa(),
        T = Sy(l, l),
        [E, b] = je.useState(0);
      zd(() => {
        const N = d.current.blend > 0 ? Math.max(1, i) : 0;
        E !== N && b(N);
      }),
        je.useEffect(() => {
          e !== void 0 && M({ enabled: !e });
        }, [e]);
      const [w, D] = je.useState(!0),
        B = h4(D);
      je.useLayoutEffect(() => {
        var N;
        B.current =
          (N = d.current) == null || (N = N.__r3f.parent) == null
            ? void 0
            : N.object;
      }, []),
        je.useLayoutEffect(() => {
          if (B.current && t && d.current.sdf === null) {
            const N = new li(B.current.geometry, new fr()),
              P = new ya().setFromBufferAttribute(
                N.geometry.attributes.position
              ),
              F = new Ps(
                P.min.x * (1 + 2 / l),
                P.max.x * (1 + 2 / l),
                P.max.y * (1 + 2 / l),
                P.min.y * (1 + 2 / l),
                0.1,
                1e3
              );
            F.position.set(0, 0, 1),
              F.lookAt(0, 0, 0),
              v.setRenderTarget(T),
              v.render(N, F);
            const U = I4(l, l, v)(T.texture),
              W = new Float32Array(l * l);
            v.readRenderTargetPixels(U, 0, 0, l, l, W);
            let J = 1 / 0;
            for (let q = 0; q < W.length; q++) W[q] < J && (J = W[q]);
            (J = -J),
              (d.current.size = J),
              (d.current.sdf = U.texture),
              v.setRenderTarget(null);
          }
        }, [l, t]),
        je.useImperativeHandle(f, () => d.current);
      const I = je.useCallback((N, P, F) => {
        var O;
        if (!B.current) return !1;
        if (
          (P.pointer.set(
            (N.offsetX / P.size.width) * 2 - 1,
            -(N.offsetY / P.size.height) * 2 + 1
          ),
          P.raycaster.setFromCamera(P.pointer, P.camera),
          ((O = d.current) == null ? void 0 : O.blend) === 0)
        ) {
          const [U] = P.raycaster.intersectObject(B.current);
          if (!U) return (P.raycaster.camera = void 0), !1;
        }
      }, []);
      return je.createElement(
        "portalMaterialImpl",
        Mu(
          {
            ref: d,
            blur: t,
            blend: 0,
            resolution: [_.width * A.dpr, _.height * A.dpr],
            attach: "material",
          },
          u
        ),
        je.createElement(
          D4,
          {
            attach: "map",
            frames: w ? 1 / 0 : 0,
            eventPriority: n,
            renderPriority: i,
            compute: I,
          },
          s,
          je.createElement(N4, {
            events: e,
            rootScene: m,
            priority: E,
            material: d,
            worldUnits: a,
          })
        )
      );
    }
  );
function N4({
  events: s = void 0,
  rootScene: e,
  material: t,
  priority: n,
  worldUnits: i,
}) {
  const a = aa((v) => v.scene),
    l = aa((v) => v.setEvents),
    u = Sy(),
    f = Sy();
  je.useLayoutEffect(() => {
    a.matrixAutoUpdate = !1;
  }, []),
    je.useEffect(() => {
      s !== void 0 && l({ enabled: s });
    }, [s]);
  const [d, m] = je.useMemo(() => {
    const v = { value: 0 };
    return [
      new pd(
        new ra({
          uniforms: {
            a: { value: u.texture },
            b: { value: f.texture },
            blend: v,
          },
          vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
          }`,
          fragmentShader: `
          uniform sampler2D a;
          uniform sampler2D b;
          uniform float blend;
          varying vec2 vUv;
          #include <packing>
          void main() {
            vec4 ta = texture2D(a, vUv);
            vec4 tb = texture2D(b, vUv);
            gl_FragColor = mix(tb, ta, blend);
            #include <tonemapping_fragment>
            #include <${
              k2 >= 154 ? "colorspace_fragment" : "encodings_fragment"
            }>
          }`,
        })
      ),
      v,
    ];
  }, []);
  return (
    zd((v) => {
      var _;
      let A =
        t == null || (_ = t.current) == null || (_ = _.__r3f.parent) == null
          ? void 0
          : _.object;
      if (A) {
        if (i) a.matrixWorld.identity();
        else {
          var M;
          n &&
            ((M = t.current) == null ? void 0 : M.blend) === 1 &&
            A.updateWorldMatrix(!0, !1),
            a.matrixWorld.copy(A.matrixWorld);
        }
        if (n) {
          var T, E, b;
          ((T = t.current) == null ? void 0 : T.blend) > 0 &&
          ((E = t.current) == null ? void 0 : E.blend) < 1
            ? ((m.value = t.current.blend),
              v.gl.setRenderTarget(u),
              v.gl.render(a, v.camera),
              v.gl.setRenderTarget(f),
              v.gl.render(e, v.camera),
              v.gl.setRenderTarget(null),
              d.render(v.gl))
            : ((b = t.current) == null ? void 0 : b.blend) === 1 &&
              v.gl.render(a, v.camera);
        }
      }
    }, n),
    je.createElement(je.Fragment, null)
  );
}
const I4 = (s, e, t) => {
    let n = new ha(s, e, {
        minFilter: ms,
        magFilter: In,
        type: yi,
        format: vc,
        generateMipmaps: !0,
      }),
      i = new ha(s, e, { minFilter: Kn, magFilter: Kn }),
      a = new ha(s, e, { minFilter: Kn, magFilter: Kn }),
      l = new ha(s, e, { minFilter: Kn, magFilter: Kn }),
      u = new ha(s, e, { minFilter: Kn, magFilter: Kn }),
      f = new ha(s, e, { minFilter: Kn, magFilter: Kn, type: yi, format: vc }),
      d = new ha(s, e, { minFilter: Kn, magFilter: Kn, type: yi, format: vc });
    const m = new pd(
        new ra({
          uniforms: { tex: { value: null } },
          vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`,
          fragmentShader: `
        uniform sampler2D tex;
        varying vec2 vUv;
        #include <packing>
        void main() {
          gl_FragColor = pack2HalfToRGBA(vUv * (round(texture2D(tex, vUv).x)));
        }`,
        })
      ),
      v = new pd(
        new ra({
          uniforms: { tex: { value: null } },
          vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`,
          fragmentShader: `
        uniform sampler2D tex;
        varying vec2 vUv;
        #include <packing>
        void main() {
          gl_FragColor = pack2HalfToRGBA(vUv * (1.0 - round(texture2D(tex, vUv).x)));
        }`,
        })
      ),
      _ = new pd(
        new ra({
          uniforms: {
            tex: { value: null },
            offset: { value: 0 },
            level: { value: 0 },
            maxSteps: { value: 0 },
          },
          vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`,
          fragmentShader: `
        varying vec2 vUv;
        uniform sampler2D tex;
        uniform float offset;
        uniform float level;
        uniform float maxSteps;
        #include <packing>
        void main() {
          float closestDist = 9999999.9;
          vec2 closestPos = vec2(0.0);
          for (float x = -1.0; x <= 1.0; x += 1.0) {
            for (float y = -1.0; y <= 1.0; y += 1.0) {
              vec2 voffset = vUv;
              voffset += vec2(x, y) * vec2(${1 / s}, ${1 / e}) * offset;
              vec2 pos = unpackRGBATo2Half(texture2D(tex, voffset));
              float dist = distance(pos.xy, vUv);
              if(pos.x != 0.0 && pos.y != 0.0 && dist < closestDist) {
                closestDist = dist;
                closestPos = pos;
              }
            }
          }
          gl_FragColor = pack2HalfToRGBA(closestPos);
        }`,
        })
      ),
      A = new pd(
        new ra({
          uniforms: { tex: { value: null }, size: { value: new at(s, e) } },
          vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`,
          fragmentShader: `
        varying vec2 vUv;
        uniform sampler2D tex;
        uniform vec2 size;
        #include <packing>
        void main() {
          gl_FragColor = vec4(distance(size * unpackRGBATo2Half(texture2D(tex, vUv)), size * vUv), 0.0, 0.0, 0.0);
        }`,
        })
      ),
      M = new pd(
        new ra({
          uniforms: {
            inside: { value: d.texture },
            outside: { value: f.texture },
            tex: { value: null },
          },
          vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`,
          fragmentShader: `
        varying vec2 vUv;
        uniform sampler2D inside;
        uniform sampler2D outside;
        uniform sampler2D tex;
        #include <packing>
        void main() {
          float i = texture2D(inside, vUv).x;
          float o =texture2D(outside, vUv).x;
          if (texture2D(tex, vUv).x == 0.0) {
            gl_FragColor = vec4(o, 0.0, 0.0, 0.0);
          } else {
            gl_FragColor = vec4(-i, 0.0, 0.0, 0.0);
          }
        }`,
        })
      );
    return (T) => {
      let E = n;
      (T.minFilter = Kn),
        (T.magFilter = Kn),
        (m.material.uniforms.tex.value = T),
        t.setRenderTarget(i),
        m.render(t);
      const b = Math.ceil(Math.log(Math.max(s, e)) / Math.log(2));
      let w = i,
        D = null;
      for (let B = 0; B < b; B++) {
        const I = Math.pow(2, b - B - 1);
        (D = w === i ? l : i),
          (_.material.uniforms.level.value = B),
          (_.material.uniforms.maxSteps.value = b),
          (_.material.uniforms.offset.value = I),
          (_.material.uniforms.tex.value = w.texture),
          t.setRenderTarget(D),
          _.render(t),
          (w = D);
      }
      t.setRenderTarget(f),
        (A.material.uniforms.tex.value = D.texture),
        A.render(t),
        (v.material.uniforms.tex.value = T),
        t.setRenderTarget(a),
        v.render(t),
        (w = a);
      for (let B = 0; B < b; B++) {
        const I = Math.pow(2, b - B - 1);
        (D = w === a ? u : a),
          (_.material.uniforms.level.value = B),
          (_.material.uniforms.maxSteps.value = b),
          (_.material.uniforms.offset.value = I),
          (_.material.uniforms.tex.value = w.texture),
          t.setRenderTarget(D),
          _.render(t),
          (w = D);
      }
      return (
        t.setRenderTarget(d),
        (A.material.uniforms.tex.value = D.texture),
        A.render(t),
        t.setRenderTarget(E),
        (M.material.uniforms.tex.value = T),
        M.render(t),
        t.setRenderTarget(null),
        E
      );
    };
  },
  F4 = ({ count: s = 500 }) => {
    const e = je.useRef(),
      t = je.useMemo(() => new On(), []),
      n = je.useMemo(() => {
        const i = [];
        for (let a = 0; a < s; a++)
          i.push({
            x: (Math.random() - 0.5) * 20,
            y: Math.random() * 20 + 10,
            z: (Math.random() - 0.5) * 20,
            speed: Math.random() * 0.02 + 0.01,
            drift: Math.random() * 0.02 - 0.01,
          });
        return i;
      }, [s]);
    return (
      zd((i) => {
        n.forEach((a, l) => {
          (a.y -= a.speed),
            (a.x += Math.sin(i.clock.elapsedTime + l) * a.drift),
            a.y < -7 && ((a.y = 20), (a.x = (Math.random() - 0.5) * 20)),
            t.position.set(a.x, a.y, a.z),
            (t.rotation.x = i.clock.elapsedTime * 2),
            (t.rotation.y = i.clock.elapsedTime * 3),
            t.updateMatrix(),
            e.current.setMatrixAt(l, t.matrix);
        }),
          (e.current.instanceMatrix.needsUpdate = !0);
      }),
      Tt.jsxs("instancedMesh", {
        ref: e,
        args: [null, null, s],
        children: [
          Tt.jsx("octahedronGeometry", { args: [0.05, 0] }),
          Tt.jsx("meshBasicMaterial", { color: "#FFFFFF" }),
        ],
      })
    );
  };
function P4(s) {
  const { nodes: e, materials: t } = bu("./models/snowman2.glb");
  return Tt.jsxs("group", {
    ...s,
    dispose: null,
    children: [
      Tt.jsx(F4, { count: 500 }),
      Tt.jsx("mesh", {
        geometry: e.Sphere001.geometry,
        material: e.Sphere001.material,
        position: [-0.111, -1.078, -0.29],
        rotation: [0.256, -0.046, -0.117],
      }),
      Tt.jsx("mesh", {
        geometry: e.Sphere002.geometry,
        material: e.Sphere002.material,
        position: [-0.146, 1.099, -0.251],
        rotation: [0.256, -0.046, -0.117],
        scale: 0.65,
      }),
      Tt.jsx("mesh", {
        geometry: e.Sphere003.geometry,
        material: e.Sphere003.material,
        position: [-0.131, 1.949, -0.25],
        rotation: [0.256, -0.046, -0.117],
        scale: 0.435,
      }),
      Tt.jsx("mesh", {
        geometry: e.Plane.geometry,
        material: e.Plane.material,
        position: [0, -0.841, 0],
        scale: 29.029,
      }),
      Tt.jsx("mesh", {
        geometry: e.hat.geometry,
        material: t.baked,
        position: [-0.139, 2.585, -0.251],
        scale: 0.335,
      }),
      Tt.jsx("mesh", {
        geometry: e.tie.geometry,
        material: t.baked,
        position: [-0.146, 1.624, -0.251],
        scale: 0.324,
      }),
      Tt.jsx("mesh", {
        geometry: e.rim_on_hat.geometry,
        material: t.baked,
        position: [-0.142, 2.617, -0.27],
        scale: 0.349,
      }),
      Tt.jsx("mesh", { geometry: e.arms.geometry, material: t.baked }),
      Tt.jsx("mesh", {
        geometry: e.Icosphere.geometry,
        material: t.baked,
        position: [0.183, 2.756, -0.128],
        scale: -0.035,
      }),
      Tt.jsx("mesh", {
        geometry: e.Pencilmesh_data001.geometry,
        material: t["Material.005"],
      }),
      Tt.jsx("mesh", {
        geometry: e.Pencilmesh_data001_1.geometry,
        material: t["Material.008"],
      }),
    ],
  });
}
bu.preload("./models/snowman2.glb");
function G4(s) {
  const { nodes: e, materials: t } = bu("./models/ballen.glb");
  return Tt.jsxs("group", {
    ...s,
    dispose: null,
    children: [
      Tt.jsx("mesh", {
        geometry: e.bal.geometry,
        material: t["3ballen"],
        position: [0.154, -0.534, 0.222],
        rotation: [0, 0.316, 0],
      }),
      Tt.jsx("mesh", {
        geometry: e.haakje.geometry,
        material: t["3ballen"],
        position: [0.174, 0.65, 0.246],
        rotation: [-0.248, 0.185, 0.152],
      }),
      Tt.jsx("mesh", {
        geometry: e.kraagje.geometry,
        material: t["3ballen"],
        position: [0.154, -0.534, 0.222],
        rotation: [0, 0.316, 0],
      }),
      Tt.jsx("mesh", {
        geometry: e.bal001.geometry,
        material: t["3ballen"],
        position: [1.322, 0.707, -2.199],
        rotation: [-Math.PI, 1.407, -Math.PI],
      }),
      Tt.jsx("mesh", {
        geometry: e.haakje001.geometry,
        material: t["3ballen"],
        position: [1.348, 1.89, -2.215],
        rotation: [-1.722, 1.324, 1.833],
      }),
      Tt.jsx("mesh", {
        geometry: e.kraagje001.geometry,
        material: t["3ballen"],
        position: [1.322, 0.707, -2.199],
        rotation: [-Math.PI, 1.407, -Math.PI],
      }),
      Tt.jsx("mesh", {
        geometry: e.bal002.geometry,
        material: t["3ballen"],
        position: [-1.356, 0.757, 1.697],
        rotation: [Math.PI, -1.28, Math.PI],
      }),
      Tt.jsx("mesh", {
        geometry: e.haakje002.geometry,
        material: t["3ballen"],
        position: [-1.344, 1.941, 1.726],
        rotation: [-0.246, -0.122, 0.075],
      }),
      Tt.jsx("mesh", {
        geometry: e.kraagje002.geometry,
        material: t["3ballen"],
        position: [-1.356, 0.757, 1.697],
      }),
    ],
  });
}
bu.preload("./models/ballen.glb");
function z4(s) {
  const { nodes: e, materials: t } = bu("./models/scene3.glb");
  return Tt.jsxs("group", {
    ...s,
    dispose: null,
    children: [
      Tt.jsx("mesh", {
        geometry: e.table.geometry,
        material: t.houtenblad,
        position: [-1.752, 0, -3.411],
      }),
      Tt.jsx("mesh", {
        geometry: e.Cup.geometry,
        material: t.redcup,
        position: [-1.061, -0.003, -1.976],
      }),
      Tt.jsx("mesh", {
        geometry: e.gingerbreadman.geometry,
        material: t.gingerbreadman,
        position: [-0.416, 0.264, -1.185],
        rotation: [1.612, -0.036, -0.548],
      }),
      Tt.jsxs("group", {
        position: [-0.421, 0.248, -1.187],
        rotation: [0.02, -0.002, 0.022],
        children: [
          Tt.jsx("mesh", {
            geometry: e.PencilGPMcurve_meshcurve_mesh_data.geometry,
            material: t.glazuur,
          }),
          Tt.jsx("mesh", {
            geometry: e.PencilGPMcurve_meshcurve_mesh_data_1.geometry,
            material: t["Material.001"],
          }),
        ],
      }),
      Tt.jsx("mesh", {
        geometry: e.bowtie.geometry,
        material: t.bowtie,
        position: [-0.418, 0.248, -1.185],
        rotation: [-0.003, -0.012, 0.002],
      }),
      Tt.jsx("mesh", {
        geometry: e.drink.geometry,
        material: t.drankje,
        position: [-1.061, -0.003, -1.976],
      }),
      Tt.jsx("mesh", {
        geometry: e.leaf.geometry,
        material: t.hulst,
        position: [-3.364, 0.01, -3.912],
        rotation: [0.083, 0.006, -0.14],
      }),
      Tt.jsx("mesh", {
        geometry: e.leaf001.geometry,
        material: t.hulst,
        position: [-3.364, 0.01, -3.903],
        rotation: [3.128, -1.243, 3.079],
      }),
      Tt.jsx("mesh", {
        geometry: e.leaf002.geometry,
        material: t.hulst,
        position: [-3.364, 0.007, -3.903],
        rotation: [-3.125, 1.099, -3.104],
      }),
      Tt.jsx("mesh", {
        geometry: e.berry.geometry,
        material: t.besje,
        position: [-3.426, 0.217, -3.917],
        rotation: [-0.109, 0.056, 0.535],
      }),
      Tt.jsx("mesh", {
        geometry: e.Sphberryere001.geometry,
        material: t.besje,
        position: [-3.258, 0.232, -3.683],
        rotation: [2.163, -1.127, 0.097],
      }),
      Tt.jsx("mesh", {
        geometry: e.berry001.geometry,
        material: t.besje,
        position: [-3.226, 0.239, -3.891],
        rotation: [-0.144, -0.434, -0.53],
      }),
      Tt.jsx("mesh", {
        geometry: e.gingerbreadman001.geometry,
        material: t.gingerbreadman,
        position: [-0.381, 0.084, -3.139],
        rotation: [0.458, -1.192, 0.426],
      }),
      Tt.jsx("mesh", {
        geometry: e.bowtie001.geometry,
        material: t.bowtie,
        position: [-0.378, 0.062, -3.131],
        rotation: [-2.083, -0.314, -1.299],
      }),
      Tt.jsxs("group", {
        position: [-0.381, 0.084, -3.139],
        rotation: [-2.104, -0.311, -1.299],
        children: [
          Tt.jsx("mesh", {
            geometry: e.PencilGPMcurve_meshcurve_mesh_data002.geometry,
            material: t.glazuur,
          }),
          Tt.jsx("mesh", {
            geometry: e.PencilGPMcurve_meshcurve_mesh_data002_1.geometry,
            material: t["Material.001"],
          }),
        ],
      }),
      Tt.jsxs("group", {
        position: [-1.062, 0.1, -2.75],
        rotation: [-2.622, 0.701, -1.239],
        children: [
          Tt.jsx("mesh", {
            geometry: e.Circle007.geometry,
            material: t.Material,
          }),
          Tt.jsx("mesh", {
            geometry: e.Circle007_1.geometry,
            material: t["Material.003"],
          }),
        ],
      }),
    ],
  });
}
bu.preload("./models/scene3.glb");
const H4 = () => {
    const [s, e] = je.useState(null);
    return Tt.jsxs(Tt.Fragment, {
      children: [
        Tt.jsx(V2, {
          font: "fonts/FleurDeLeah-Regular.ttf",
          position: [0, 4, 0],
          color: "Maroon",
          anchorY: "top",
          children: "Merry Christmas",
        }),
        Tt.jsx("ambientLight", { intensity: 0.5 }),
        Tt.jsx(Q2, { preset: "sunset" }),
        Tt.jsx(f4, {}),
        Tt.jsx(cA, {
          texture: "textures/skybox_texture.png",
          name: "White Christmas",
          color: "#610009",
          active: s,
          setActive: e,
          children: Tt.jsx(P4, {
            scale: 1.2,
            "position-y": -1,
            "position-z": -3,
          }),
        }),
        Tt.jsx(cA, {
          texture: "textures/pyramid.jpg",
          "position-x": -4.5,
          "rotation-y": Math.PI / 8,
          name: "Christmas Ornaments",
          color: "#b69bb0",
          active: s,
          setActive: e,
          children: Tt.jsx(G4, { "position-z": -3 }),
        }),
        Tt.jsx(cA, {
          texture: "textures/sphere_landscape.jpg",
          "position-x": 4.5,
          "rotation-y": -Math.PI / 8,
          name: "Food and Company",
          color: "#e0bfce",
          active: s,
          setActive: e,
          children: Tt.jsx(z4, {
            position: [1, -2, -1],
            "rotation-x": Math.PI / 12,
          }),
        }),
      ],
    });
  },
  cA = ({
    children: s,
    texture: e,
    name: t,
    color: n,
    active: i,
    setActive: a,
    ...l
  }) => {
    const u = kx(e);
    return Tt.jsxs("group", {
      ...l,
      children: [
        Tt.jsxs(V2, {
          font: "fonts/Delius-Regular.ttf",
          fontSize: "0.2",
          position: [0, -2.3, 0.051],
          anchorY: "bottom-baseline",
          children: [
            t,
            Tt.jsx("meshBasicMaterial", { color: n, toneMapped: !1 }),
          ],
        }),
        Tt.jsx(p4, {
          args: [3, 5, 0.1],
          onDoubleClick: () => a(i === t ? null : t),
          children: Tt.jsxs(L4, {
            side: jr,
            blend: i === t ? 1 : 0,
            children: [
              Tt.jsx("ambientLight", { intensity: 1.5 }),
              s,
              Tt.jsx(Q2, { preset: "sunset" }),
              Tt.jsxs("mesh", {
                children: [
                  Tt.jsx("sphereGeometry", { args: [25, 64, 64] }),
                  Tt.jsx("meshStandardMaterial", { map: u, side: hr }),
                ],
              }),
            ],
          }),
        }),
      ],
    });
  };
function V4() {
  return Tt.jsxs(nI, {
    shadows: !0,
    camera: { position: [0, 0, 18], fov: 30 },
    children: [
      Tt.jsx("color", { attach: "background", args: ["#e0bfce"] }),
      Tt.jsx(H4, {}),
    ],
  });
}
YC.createRoot(document.getElementById("root")).render(
  Tt.jsx(oE.StrictMode, { children: Tt.jsx(V4, {}) })
);
